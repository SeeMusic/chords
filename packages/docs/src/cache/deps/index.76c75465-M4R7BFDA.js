import {
  f,
  l
} from "./chunk-CA6C2YBR.js";
import "./chunk-HM4MQYWN.js";

// ../../node_modules/.pnpm/vitepress-demo-editor@3.2.1_@vue+babel-plugin-jsx@1.1.4_@vue+runtime-core@3.3.4_@vue+runtime-_nzfxcsweaf2rfajbop72etg6f4/node_modules/vitepress-demo-editor/dist/index.76c75465.js
function mb(s, n) {
  for (var h = 0; h < n.length; h++) {
    const f2 = n[h];
    if (typeof f2 != "string" && !Array.isArray(f2)) {
      for (const p in f2)
        if (p !== "default" && !(p in s)) {
          const g = Object.getOwnPropertyDescriptor(f2, p);
          g && Object.defineProperty(s, p, g.get ? g : {
            enumerable: true,
            get: () => f2[p]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }));
}
var Dl = {};
var Vn = {};
Object.defineProperty(Vn, "__esModule", {
  value: true
});
Vn.declare = Ey;
Vn.declarePreset = void 0;
function Ey(s) {
  return (n, h, f2) => {
    var p;
    let g;
    for (const x of Object.keys(Mp)) {
      var P;
      n[x] || (g = (P = g) != null ? P : bb(n), g[x] = Mp[x](g));
    }
    return s((p = g) != null ? p : n, h || {}, f2);
  };
}
var yb = Ey;
Vn.declarePreset = yb;
var Mp = {
  assertVersion: (s) => (n) => {
    gb(n, s.version);
  },
  targets: () => () => ({}),
  assumption: () => () => {
  }
};
function bb(s) {
  let n = null;
  return typeof s.version == "string" && /^7\./.test(s.version) && (n = Object.getPrototypeOf(s), n && (!qa(n, "version") || !qa(n, "transform") || !qa(n, "template") || !qa(n, "types")) && (n = null)), Object.assign({}, n, s);
}
function qa(s, n) {
  return Object.prototype.hasOwnProperty.call(s, n);
}
function gb(s, n) {
  if (typeof s == "number") {
    if (!Number.isInteger(s))
      throw new Error("Expected string or integer value.");
    s = `^${s}.0.0-0`;
  }
  if (typeof s != "string")
    throw new Error("Expected string or integer value.");
  const h = Error.stackTraceLimit;
  typeof h == "number" && h < 25 && (Error.stackTraceLimit = 25);
  let f2;
  throw n.slice(0, 2) === "7." ? f2 = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${n}". You'll need to update your @babel/core version.`) : f2 = new Error(`Requires Babel "${s}", but was loaded with "${n}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof h == "number" && (Error.stackTraceLimit = h), Object.assign(f2, {
    code: "BABEL_VERSION_UNSUPPORTED",
    version: n,
    range: s
  });
}
var Ll = {};
Object.defineProperty(Ll, "__esModule", {
  value: true
});
Ll.default = void 0;
var Tb = Vn;
function Bp(s, n) {
  const h = [];
  s.forEach((f2, p) => {
    (Array.isArray(f2) ? f2[0] : f2) === n && h.unshift(p);
  });
  for (const f2 of h)
    s.splice(f2, 1);
}
var xb = (0, Tb.declare)((s, {
  isTSX: n,
  disallowAmbiguousJSXLike: h
}) => (s.assertVersion(7), {
  name: "syntax-typescript",
  manipulateOptions(f2, p) {
    const {
      plugins: g
    } = p;
    Bp(g, "flow"), Bp(g, "jsx"), g.push(["typescript", {
      disallowAmbiguousJSXLike: h
    }], "classProperties"), g.push("objectRestSpread"), n && g.push("jsx");
  }
}));
Ll.default = xb;
var Lu = {};
var Kn = {};
var ji = {};
var Mu = {};
var vn = {};
var tt = {};
var Bu = {};
var ea = {};
var Va = {};
var Ka = {};
var se = {};
var Wa = {};
var _p;
function zc() {
  if (_p)
    return Wa;
  _p = 1, Object.defineProperty(Wa, "__esModule", {
    value: true
  }), Wa.default = s;
  function s(n, h) {
    const f2 = Object.keys(h);
    for (const p of f2)
      if (n[p] !== h[p])
        return false;
    return true;
  }
  return Wa;
}
var Fp;
function rr() {
  if (Fp)
    return se;
  Fp = 1, Object.defineProperty(se, "__esModule", {
    value: true
  }), se.isAccessor = du, se.isAnyTypeAnnotation = Ye, se.isArgumentPlaceholder = Yt, se.isArrayExpression = n, se.isArrayPattern = Le, se.isArrayTypeAnnotation = bt, se.isArrowFunctionExpression = Ee, se.isAssignmentExpression = h, se.isAssignmentPattern = Se, se.isAwaitExpression = rt, se.isBigIntLiteral = gt, se.isBinary = o, se.isBinaryExpression = f2, se.isBindExpression = Xr, se.isBlock = E, se.isBlockParent = u, se.isBlockStatement = x, se.isBooleanLiteral = Q, se.isBooleanLiteralTypeAnnotation = $t, se.isBooleanTypeAnnotation = ct, se.isBreakStatement = y, se.isCallExpression = A, se.isCatchClause = S, se.isClass = cu, se.isClassAccessorProperty = sr, se.isClassBody = J, se.isClassDeclaration = ke, se.isClassExpression = me, se.isClassImplements = xt, se.isClassMethod = be, se.isClassPrivateMethod = Nr, se.isClassPrivateProperty = ar, se.isClassProperty = Tt, se.isCompletionStatement = ge, se.isConditional = ye, se.isConditionalExpression = v, se.isContinueStatement = T, se.isDebuggerStatement = C, se.isDecimalLiteral = Sr, se.isDeclaration = Ql, se.isDeclareClass = or, se.isDeclareExportAllDeclaration = Wt, se.isDeclareExportDeclaration = _r, se.isDeclareFunction = qt, se.isDeclareInterface = Vt, se.isDeclareModule = it, se.isDeclareModuleExports = wt, se.isDeclareOpaqueType = pt, se.isDeclareTypeAlias = Br, se.isDeclareVariable = Kt, se.isDeclaredPredicate = lr, se.isDecorator = Qs, se.isDirective = g, se.isDirectiveLiteral = P, se.isDoExpression = Qt, se.isDoWhileStatement = I, se.isEmptyStatement = N, se.isEmptyTypeAnnotation = Ur, se.isEnumBody = Pu, se.isEnumBooleanBody = gr, se.isEnumBooleanMember = $s, se.isEnumDeclaration = Fs, se.isEnumDefaultedMember = ft, se.isEnumMember = Su, se.isEnumNumberBody = js, se.isEnumNumberMember = Vr, se.isEnumStringBody = Rs, se.isEnumStringMember = Xt, se.isEnumSymbolBody = Us, se.isExistsTypeAnnotation = ur, se.isExportAllDeclaration = _e, se.isExportDeclaration = fu, se.isExportDefaultDeclaration = Re, se.isExportDefaultSpecifier = Zs, se.isExportNamedDeclaration = $e, se.isExportNamespaceSpecifier = ut, se.isExportSpecifier = Ge, se.isExpression = i, se.isExpressionStatement = D, se.isExpressionWrapper = Ve, se.isFile = _, se.isFlow = yu, se.isFlowBaseAnnotation = gu, se.isFlowDeclaration = Tu, se.isFlowPredicate = xu, se.isFlowType = bu, se.isFor = Ke, se.isForInStatement = m, se.isForOfStatement = lt, se.isForStatement = L, se.isForXStatement = He, se.isFunction = bs, se.isFunctionDeclaration = R, se.isFunctionExpression = O, se.isFunctionParent = zi, se.isFunctionTypeAnnotation = cr, se.isFunctionTypeParam = pr, se.isGenericTypeAnnotation = Fr, se.isIdentifier = B, se.isIfStatement = M, se.isImmutable = su, se.isImport = vt, se.isImportAttribute = Nt, se.isImportDeclaration = Ze, se.isImportDefaultSpecifier = Xe, se.isImportNamespaceSpecifier = et, se.isImportSpecifier = st, se.isIndexedAccessType = qs, se.isInferredPredicate = nt, se.isInterfaceDeclaration = jr, se.isInterfaceExtends = Ht, se.isInterfaceTypeAnnotation = Es, se.isInterpreterDirective = p, se.isIntersectionTypeAnnotation = vs, se.isJSX = Eu, se.isJSXAttribute = xr, se.isJSXClosingElement = Vs, se.isJSXClosingFragment = Ys, se.isJSXElement = Ks, se.isJSXEmptyExpression = Ws, se.isJSXExpressionContainer = Hs, se.isJSXFragment = Xs, se.isJSXIdentifier = Kr, se.isJSXMemberExpression = Pr, se.isJSXNamespacedName = Wr, se.isJSXOpeningElement = Jt, se.isJSXOpeningFragment = Js, se.isJSXSpreadAttribute = Hr, se.isJSXSpreadChild = zs, se.isJSXText = Gs, se.isLVal = eu, se.isLabeledStatement = j, se.isLiteral = ru, se.isLogicalExpression = ee, se.isLoop = Ae, se.isMemberExpression = K, se.isMetaProperty = re, se.isMethod = nu, se.isMiscellaneous = vu, se.isMixedTypeAnnotation = Rr, se.isModuleDeclaration = pu, se.isModuleExpression = ei, se.isModuleSpecifier = hu, se.isNewExpression = G, se.isNoop = zr, se.isNullLiteral = ne, se.isNullLiteralTypeAnnotation = Mr, se.isNullableTypeAnnotation = Pt, se.isNumberLiteral = Nu, se.isNumberLiteralTypeAnnotation = As, se.isNumberTypeAnnotation = Cs, se.isNumericLiteral = k, se.isObjectExpression = F, se.isObjectMember = au, se.isObjectMethod = le, se.isObjectPattern = ue, se.isObjectProperty = oe, se.isObjectTypeAnnotation = ws, se.isObjectTypeCallProperty = zt, se.isObjectTypeIndexer = fr, se.isObjectTypeInternalSlot = Is, se.isObjectTypeProperty = hr, se.isObjectTypeSpreadProperty = dr, se.isOpaqueType = Ns, se.isOptionalCallExpression = De, se.isOptionalIndexedAccessType = Tr, se.isOptionalMemberExpression = qe, se.isParenthesizedExpression = Pe, se.isPattern = uu, se.isPatternLike = Zl, se.isPipelineBareFunction = ri, se.isPipelinePrimaryTopicReference = si, se.isPipelineTopicExpression = ti, se.isPlaceholder = It, se.isPrivate = mu, se.isPrivateName = At, se.isProgram = V, se.isProperty = ou, se.isPureish = Yl, se.isQualifiedTypeIdentifier = ks, se.isRecordExpression = Zt, se.isRegExpLiteral = q, se.isRegexLiteral = ku, se.isRestElement = fe, se.isRestProperty = Ou, se.isReturnStatement = he, se.isScopable = d, se.isSequenceExpression = de, se.isSpreadElement = Me, se.isSpreadProperty = Du, se.isStandardized = r, se.isStatement = w, se.isStaticBlock = Dt, se.isStringLiteral = $, se.isStringLiteralTypeAnnotation = Os, se.isStringTypeAnnotation = Ds, se.isSuper = Y, se.isSwitchCase = we, se.isSwitchStatement = H, se.isSymbolTypeAnnotation = mr, se.isTSAnyKeyword = Et, se.isTSArrayType = Ft, se.isTSAsExpression = Ni, se.isTSBaseType = Iu, se.isTSBigIntKeyword = kt, se.isTSBooleanKeyword = ht, se.isTSCallSignatureDeclaration = ni, se.isTSConditionalType = ns, se.isTSConstructSignatureDeclaration = ai, se.isTSConstructorType = Zr, se.isTSDeclareFunction = ii, se.isTSDeclareMethod = Er, se.isTSEntityName = tu, se.isTSEnumDeclaration = ki, se.isTSEnumMember = Oi, se.isTSExportAssignment = jt, se.isTSExpressionWithTypeArguments = wi, se.isTSExternalModuleReference = Bi, se.isTSFunctionType = gi, se.isTSImportEqualsDeclaration = Mi, se.isTSImportType = Li, se.isTSIndexSignature = ui, se.isTSIndexedAccessType = Ai, se.isTSInferType = Ei, se.isTSInstantiationExpression = ls, se.isTSInterfaceBody = Ar, se.isTSInterfaceDeclaration = Ii, se.isTSIntersectionType = Si, se.isTSIntrinsicKeyword = ci, se.isTSLiteralType = vr, se.isTSMappedType = Ci, se.isTSMethodSignature = li, se.isTSModuleBlock = Di, se.isTSModuleDeclaration = us, se.isTSNamedTupleMember = Pi, se.isTSNamespaceExportDeclaration = cs, se.isTSNeverKeyword = pi, se.isTSNonNullExpression = _i, se.isTSNullKeyword = fi, se.isTSNumberKeyword = hi, se.isTSObjectKeyword = di, se.isTSOptionalType = rs, se.isTSParameterProperty = Ce, se.isTSParenthesizedType = vi, se.isTSPropertySignature = oi, se.isTSQualifiedName = Jr, se.isTSRestType = ss, se.isTSStringKeyword = Yr, se.isTSSymbolKeyword = ve, se.isTSThisType = bi, se.isTSTupleType = ts, se.isTSType = wu, se.isTSTypeAliasDeclaration = os, se.isTSTypeAnnotation = Fi, se.isTSTypeAssertion = Cr, se.isTSTypeElement = Cu, se.isTSTypeLiteral = ze, se.isTSTypeOperator = as, se.isTSTypeParameter = t, se.isTSTypeParameterDeclaration = e, se.isTSTypeParameterInstantiation = a, se.isTSTypePredicate = Ti, se.isTSTypeQuery = xi, se.isTSTypeReference = es, se.isTSUndefinedKeyword = mi, se.isTSUnionType = is, se.isTSUnknownKeyword = Qr, se.isTSVoidKeyword = yi, se.isTaggedTemplateExpression = Ne, se.isTemplateElement = Be, se.isTemplateLiteral = X, se.isTerminatorless = U, se.isThisExpression = te, se.isThisTypeAnnotation = Ls, se.isThrowStatement = Ie, se.isTopicReference = at, se.isTryStatement = Te, se.isTupleExpression = er, se.isTupleTypeAnnotation = $r, se.isTypeAlias = Bt, se.isTypeAnnotation = _t, se.isTypeCastExpression = Bs, se.isTypeParameter = yr, se.isTypeParameterDeclaration = Gt, se.isTypeParameterInstantiation = St, se.isTypeScript = Au, se.isTypeofTypeAnnotation = Ms, se.isUnaryExpression = pe, se.isUnaryLike = lu, se.isUnionTypeAnnotation = br, se.isUpdateExpression = z, se.isUserWhitespacable = iu, se.isV8IntrinsicIdentifier = Gr, se.isVariableDeclaration = W, se.isVariableDeclarator = ae, se.isVariance = _s, se.isVoidTypeAnnotation = qr, se.isWhile = Oe, se.isWhileStatement = ce, se.isWithStatement = xe, se.isYieldExpression = je;
  var s = zc();
  function n(b, c) {
    return b && b.type === "ArrayExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function h(b, c) {
    return b && b.type === "AssignmentExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function f2(b, c) {
    return b && b.type === "BinaryExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function p(b, c) {
    return b && b.type === "InterpreterDirective" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function g(b, c) {
    return b && b.type === "Directive" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function P(b, c) {
    return b && b.type === "DirectiveLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function x(b, c) {
    return b && b.type === "BlockStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function y(b, c) {
    return b && b.type === "BreakStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function A(b, c) {
    return b && b.type === "CallExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function S(b, c) {
    return b && b.type === "CatchClause" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function v(b, c) {
    return b && b.type === "ConditionalExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function T(b, c) {
    return b && b.type === "ContinueStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function C(b, c) {
    return b && b.type === "DebuggerStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function I(b, c) {
    return b && b.type === "DoWhileStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function N(b, c) {
    return b && b.type === "EmptyStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function D(b, c) {
    return b && b.type === "ExpressionStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function _(b, c) {
    return b && b.type === "File" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function m(b, c) {
    return b && b.type === "ForInStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function L(b, c) {
    return b && b.type === "ForStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function R(b, c) {
    return b && b.type === "FunctionDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function O(b, c) {
    return b && b.type === "FunctionExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function B(b, c) {
    return b && b.type === "Identifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function M(b, c) {
    return b && b.type === "IfStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function j(b, c) {
    return b && b.type === "LabeledStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function $(b, c) {
    return b && b.type === "StringLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function k(b, c) {
    return b && b.type === "NumericLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ne(b, c) {
    return b && b.type === "NullLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Q(b, c) {
    return b && b.type === "BooleanLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function q(b, c) {
    return b && b.type === "RegExpLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ee(b, c) {
    return b && b.type === "LogicalExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function K(b, c) {
    return b && b.type === "MemberExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function G(b, c) {
    return b && b.type === "NewExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function V(b, c) {
    return b && b.type === "Program" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function F(b, c) {
    return b && b.type === "ObjectExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function le(b, c) {
    return b && b.type === "ObjectMethod" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function oe(b, c) {
    return b && b.type === "ObjectProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function fe(b, c) {
    return b && b.type === "RestElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function he(b, c) {
    return b && b.type === "ReturnStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function de(b, c) {
    return b && b.type === "SequenceExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Pe(b, c) {
    return b && b.type === "ParenthesizedExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function we(b, c) {
    return b && b.type === "SwitchCase" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function H(b, c) {
    return b && b.type === "SwitchStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function te(b, c) {
    return b && b.type === "ThisExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ie(b, c) {
    return b && b.type === "ThrowStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Te(b, c) {
    return b && b.type === "TryStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function pe(b, c) {
    return b && b.type === "UnaryExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function z(b, c) {
    return b && b.type === "UpdateExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function W(b, c) {
    return b && b.type === "VariableDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ae(b, c) {
    return b && b.type === "VariableDeclarator" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ce(b, c) {
    return b && b.type === "WhileStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function xe(b, c) {
    return b && b.type === "WithStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Se(b, c) {
    return b && b.type === "AssignmentPattern" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Le(b, c) {
    return b && b.type === "ArrayPattern" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ee(b, c) {
    return b && b.type === "ArrowFunctionExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function J(b, c) {
    return b && b.type === "ClassBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function me(b, c) {
    return b && b.type === "ClassExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ke(b, c) {
    return b && b.type === "ClassDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function _e(b, c) {
    return b && b.type === "ExportAllDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Re(b, c) {
    return b && b.type === "ExportDefaultDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function $e(b, c) {
    return b && b.type === "ExportNamedDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ge(b, c) {
    return b && b.type === "ExportSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function lt(b, c) {
    return b && b.type === "ForOfStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ze(b, c) {
    return b && b.type === "ImportDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Xe(b, c) {
    return b && b.type === "ImportDefaultSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function et(b, c) {
    return b && b.type === "ImportNamespaceSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function st(b, c) {
    return b && b.type === "ImportSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function re(b, c) {
    return b && b.type === "MetaProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function be(b, c) {
    return b && b.type === "ClassMethod" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ue(b, c) {
    return b && b.type === "ObjectPattern" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Me(b, c) {
    return b && b.type === "SpreadElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Y(b, c) {
    return b && b.type === "Super" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ne(b, c) {
    return b && b.type === "TaggedTemplateExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Be(b, c) {
    return b && b.type === "TemplateElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function X(b, c) {
    return b && b.type === "TemplateLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function je(b, c) {
    return b && b.type === "YieldExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function rt(b, c) {
    return b && b.type === "AwaitExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function vt(b, c) {
    return b && b.type === "Import" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function gt(b, c) {
    return b && b.type === "BigIntLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ut(b, c) {
    return b && b.type === "ExportNamespaceSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function qe(b, c) {
    return b && b.type === "OptionalMemberExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function De(b, c) {
    return b && b.type === "OptionalCallExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Tt(b, c) {
    return b && b.type === "ClassProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function sr(b, c) {
    return b && b.type === "ClassAccessorProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ar(b, c) {
    return b && b.type === "ClassPrivateProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Nr(b, c) {
    return b && b.type === "ClassPrivateMethod" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function At(b, c) {
    return b && b.type === "PrivateName" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Dt(b, c) {
    return b && b.type === "StaticBlock" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ye(b, c) {
    return b && b.type === "AnyTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function bt(b, c) {
    return b && b.type === "ArrayTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ct(b, c) {
    return b && b.type === "BooleanTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function $t(b, c) {
    return b && b.type === "BooleanLiteralTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Mr(b, c) {
    return b && b.type === "NullLiteralTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function xt(b, c) {
    return b && b.type === "ClassImplements" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function or(b, c) {
    return b && b.type === "DeclareClass" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function qt(b, c) {
    return b && b.type === "DeclareFunction" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Vt(b, c) {
    return b && b.type === "DeclareInterface" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function it(b, c) {
    return b && b.type === "DeclareModule" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function wt(b, c) {
    return b && b.type === "DeclareModuleExports" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Br(b, c) {
    return b && b.type === "DeclareTypeAlias" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function pt(b, c) {
    return b && b.type === "DeclareOpaqueType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Kt(b, c) {
    return b && b.type === "DeclareVariable" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function _r(b, c) {
    return b && b.type === "DeclareExportDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Wt(b, c) {
    return b && b.type === "DeclareExportAllDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function lr(b, c) {
    return b && b.type === "DeclaredPredicate" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ur(b, c) {
    return b && b.type === "ExistsTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function cr(b, c) {
    return b && b.type === "FunctionTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function pr(b, c) {
    return b && b.type === "FunctionTypeParam" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Fr(b, c) {
    return b && b.type === "GenericTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function nt(b, c) {
    return b && b.type === "InferredPredicate" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ht(b, c) {
    return b && b.type === "InterfaceExtends" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function jr(b, c) {
    return b && b.type === "InterfaceDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Es(b, c) {
    return b && b.type === "InterfaceTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function vs(b, c) {
    return b && b.type === "IntersectionTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Rr(b, c) {
    return b && b.type === "MixedTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ur(b, c) {
    return b && b.type === "EmptyTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Pt(b, c) {
    return b && b.type === "NullableTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function As(b, c) {
    return b && b.type === "NumberLiteralTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Cs(b, c) {
    return b && b.type === "NumberTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ws(b, c) {
    return b && b.type === "ObjectTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Is(b, c) {
    return b && b.type === "ObjectTypeInternalSlot" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function zt(b, c) {
    return b && b.type === "ObjectTypeCallProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function fr(b, c) {
    return b && b.type === "ObjectTypeIndexer" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function hr(b, c) {
    return b && b.type === "ObjectTypeProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function dr(b, c) {
    return b && b.type === "ObjectTypeSpreadProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ns(b, c) {
    return b && b.type === "OpaqueType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ks(b, c) {
    return b && b.type === "QualifiedTypeIdentifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Os(b, c) {
    return b && b.type === "StringLiteralTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ds(b, c) {
    return b && b.type === "StringTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function mr(b, c) {
    return b && b.type === "SymbolTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ls(b, c) {
    return b && b.type === "ThisTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function $r(b, c) {
    return b && b.type === "TupleTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ms(b, c) {
    return b && b.type === "TypeofTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Bt(b, c) {
    return b && b.type === "TypeAlias" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function _t(b, c) {
    return b && b.type === "TypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Bs(b, c) {
    return b && b.type === "TypeCastExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function yr(b, c) {
    return b && b.type === "TypeParameter" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Gt(b, c) {
    return b && b.type === "TypeParameterDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function St(b, c) {
    return b && b.type === "TypeParameterInstantiation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function br(b, c) {
    return b && b.type === "UnionTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function _s(b, c) {
    return b && b.type === "Variance" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function qr(b, c) {
    return b && b.type === "VoidTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Fs(b, c) {
    return b && b.type === "EnumDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function gr(b, c) {
    return b && b.type === "EnumBooleanBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function js(b, c) {
    return b && b.type === "EnumNumberBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Rs(b, c) {
    return b && b.type === "EnumStringBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Us(b, c) {
    return b && b.type === "EnumSymbolBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function $s(b, c) {
    return b && b.type === "EnumBooleanMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Vr(b, c) {
    return b && b.type === "EnumNumberMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Xt(b, c) {
    return b && b.type === "EnumStringMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ft(b, c) {
    return b && b.type === "EnumDefaultedMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function qs(b, c) {
    return b && b.type === "IndexedAccessType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Tr(b, c) {
    return b && b.type === "OptionalIndexedAccessType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function xr(b, c) {
    return b && b.type === "JSXAttribute" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Vs(b, c) {
    return b && b.type === "JSXClosingElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ks(b, c) {
    return b && b.type === "JSXElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ws(b, c) {
    return b && b.type === "JSXEmptyExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Hs(b, c) {
    return b && b.type === "JSXExpressionContainer" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function zs(b, c) {
    return b && b.type === "JSXSpreadChild" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Kr(b, c) {
    return b && b.type === "JSXIdentifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Pr(b, c) {
    return b && b.type === "JSXMemberExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Wr(b, c) {
    return b && b.type === "JSXNamespacedName" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Jt(b, c) {
    return b && b.type === "JSXOpeningElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Hr(b, c) {
    return b && b.type === "JSXSpreadAttribute" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Gs(b, c) {
    return b && b.type === "JSXText" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Xs(b, c) {
    return b && b.type === "JSXFragment" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Js(b, c) {
    return b && b.type === "JSXOpeningFragment" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ys(b, c) {
    return b && b.type === "JSXClosingFragment" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function zr(b, c) {
    return b && b.type === "Noop" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function It(b, c) {
    return b && b.type === "Placeholder" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Gr(b, c) {
    return b && b.type === "V8IntrinsicIdentifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Yt(b, c) {
    return b && b.type === "ArgumentPlaceholder" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Xr(b, c) {
    return b && b.type === "BindExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Nt(b, c) {
    return b && b.type === "ImportAttribute" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Qs(b, c) {
    return b && b.type === "Decorator" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Qt(b, c) {
    return b && b.type === "DoExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Zs(b, c) {
    return b && b.type === "ExportDefaultSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Zt(b, c) {
    return b && b.type === "RecordExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function er(b, c) {
    return b && b.type === "TupleExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Sr(b, c) {
    return b && b.type === "DecimalLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ei(b, c) {
    return b && b.type === "ModuleExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function at(b, c) {
    return b && b.type === "TopicReference" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ti(b, c) {
    return b && b.type === "PipelineTopicExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ri(b, c) {
    return b && b.type === "PipelineBareFunction" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function si(b, c) {
    return b && b.type === "PipelinePrimaryTopicReference" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ce(b, c) {
    return b && b.type === "TSParameterProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ii(b, c) {
    return b && b.type === "TSDeclareFunction" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Er(b, c) {
    return b && b.type === "TSDeclareMethod" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Jr(b, c) {
    return b && b.type === "TSQualifiedName" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ni(b, c) {
    return b && b.type === "TSCallSignatureDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ai(b, c) {
    return b && b.type === "TSConstructSignatureDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function oi(b, c) {
    return b && b.type === "TSPropertySignature" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function li(b, c) {
    return b && b.type === "TSMethodSignature" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ui(b, c) {
    return b && b.type === "TSIndexSignature" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Et(b, c) {
    return b && b.type === "TSAnyKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ht(b, c) {
    return b && b.type === "TSBooleanKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function kt(b, c) {
    return b && b.type === "TSBigIntKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ci(b, c) {
    return b && b.type === "TSIntrinsicKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function pi(b, c) {
    return b && b.type === "TSNeverKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function fi(b, c) {
    return b && b.type === "TSNullKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function hi(b, c) {
    return b && b.type === "TSNumberKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function di(b, c) {
    return b && b.type === "TSObjectKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Yr(b, c) {
    return b && b.type === "TSStringKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ve(b, c) {
    return b && b.type === "TSSymbolKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function mi(b, c) {
    return b && b.type === "TSUndefinedKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Qr(b, c) {
    return b && b.type === "TSUnknownKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function yi(b, c) {
    return b && b.type === "TSVoidKeyword" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function bi(b, c) {
    return b && b.type === "TSThisType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function gi(b, c) {
    return b && b.type === "TSFunctionType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Zr(b, c) {
    return b && b.type === "TSConstructorType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function es(b, c) {
    return b && b.type === "TSTypeReference" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ti(b, c) {
    return b && b.type === "TSTypePredicate" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function xi(b, c) {
    return b && b.type === "TSTypeQuery" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ze(b, c) {
    return b && b.type === "TSTypeLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ft(b, c) {
    return b && b.type === "TSArrayType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ts(b, c) {
    return b && b.type === "TSTupleType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function rs(b, c) {
    return b && b.type === "TSOptionalType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ss(b, c) {
    return b && b.type === "TSRestType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Pi(b, c) {
    return b && b.type === "TSNamedTupleMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function is(b, c) {
    return b && b.type === "TSUnionType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Si(b, c) {
    return b && b.type === "TSIntersectionType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ns(b, c) {
    return b && b.type === "TSConditionalType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ei(b, c) {
    return b && b.type === "TSInferType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function vi(b, c) {
    return b && b.type === "TSParenthesizedType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function as(b, c) {
    return b && b.type === "TSTypeOperator" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ai(b, c) {
    return b && b.type === "TSIndexedAccessType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ci(b, c) {
    return b && b.type === "TSMappedType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function vr(b, c) {
    return b && b.type === "TSLiteralType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function wi(b, c) {
    return b && b.type === "TSExpressionWithTypeArguments" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ii(b, c) {
    return b && b.type === "TSInterfaceDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ar(b, c) {
    return b && b.type === "TSInterfaceBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function os(b, c) {
    return b && b.type === "TSTypeAliasDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ls(b, c) {
    return b && b.type === "TSInstantiationExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ni(b, c) {
    return b && b.type === "TSAsExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Cr(b, c) {
    return b && b.type === "TSTypeAssertion" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ki(b, c) {
    return b && b.type === "TSEnumDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Oi(b, c) {
    return b && b.type === "TSEnumMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function us(b, c) {
    return b && b.type === "TSModuleDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Di(b, c) {
    return b && b.type === "TSModuleBlock" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Li(b, c) {
    return b && b.type === "TSImportType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Mi(b, c) {
    return b && b.type === "TSImportEqualsDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Bi(b, c) {
    return b && b.type === "TSExternalModuleReference" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function _i(b, c) {
    return b && b.type === "TSNonNullExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function jt(b, c) {
    return b && b.type === "TSExportAssignment" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function cs(b, c) {
    return b && b.type === "TSNamespaceExportDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Fi(b, c) {
    return b && b.type === "TSTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function a(b, c) {
    return b && b.type === "TSTypeParameterInstantiation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function e(b, c) {
    return b && b.type === "TSTypeParameterDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function t(b, c) {
    return b && b.type === "TSTypeParameter" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function r(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ArrayExpression" || l2 === "AssignmentExpression" || l2 === "BinaryExpression" || l2 === "InterpreterDirective" || l2 === "Directive" || l2 === "DirectiveLiteral" || l2 === "BlockStatement" || l2 === "BreakStatement" || l2 === "CallExpression" || l2 === "CatchClause" || l2 === "ConditionalExpression" || l2 === "ContinueStatement" || l2 === "DebuggerStatement" || l2 === "DoWhileStatement" || l2 === "EmptyStatement" || l2 === "ExpressionStatement" || l2 === "File" || l2 === "ForInStatement" || l2 === "ForStatement" || l2 === "FunctionDeclaration" || l2 === "FunctionExpression" || l2 === "Identifier" || l2 === "IfStatement" || l2 === "LabeledStatement" || l2 === "StringLiteral" || l2 === "NumericLiteral" || l2 === "NullLiteral" || l2 === "BooleanLiteral" || l2 === "RegExpLiteral" || l2 === "LogicalExpression" || l2 === "MemberExpression" || l2 === "NewExpression" || l2 === "Program" || l2 === "ObjectExpression" || l2 === "ObjectMethod" || l2 === "ObjectProperty" || l2 === "RestElement" || l2 === "ReturnStatement" || l2 === "SequenceExpression" || l2 === "ParenthesizedExpression" || l2 === "SwitchCase" || l2 === "SwitchStatement" || l2 === "ThisExpression" || l2 === "ThrowStatement" || l2 === "TryStatement" || l2 === "UnaryExpression" || l2 === "UpdateExpression" || l2 === "VariableDeclaration" || l2 === "VariableDeclarator" || l2 === "WhileStatement" || l2 === "WithStatement" || l2 === "AssignmentPattern" || l2 === "ArrayPattern" || l2 === "ArrowFunctionExpression" || l2 === "ClassBody" || l2 === "ClassExpression" || l2 === "ClassDeclaration" || l2 === "ExportAllDeclaration" || l2 === "ExportDefaultDeclaration" || l2 === "ExportNamedDeclaration" || l2 === "ExportSpecifier" || l2 === "ForOfStatement" || l2 === "ImportDeclaration" || l2 === "ImportDefaultSpecifier" || l2 === "ImportNamespaceSpecifier" || l2 === "ImportSpecifier" || l2 === "MetaProperty" || l2 === "ClassMethod" || l2 === "ObjectPattern" || l2 === "SpreadElement" || l2 === "Super" || l2 === "TaggedTemplateExpression" || l2 === "TemplateElement" || l2 === "TemplateLiteral" || l2 === "YieldExpression" || l2 === "AwaitExpression" || l2 === "Import" || l2 === "BigIntLiteral" || l2 === "ExportNamespaceSpecifier" || l2 === "OptionalMemberExpression" || l2 === "OptionalCallExpression" || l2 === "ClassProperty" || l2 === "ClassAccessorProperty" || l2 === "ClassPrivateProperty" || l2 === "ClassPrivateMethod" || l2 === "PrivateName" || l2 === "StaticBlock" || l2 === "Placeholder" && (b.expectedNode === "Identifier" || b.expectedNode === "StringLiteral" || b.expectedNode === "BlockStatement" || b.expectedNode === "ClassBody") ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function i(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ArrayExpression" || l2 === "AssignmentExpression" || l2 === "BinaryExpression" || l2 === "CallExpression" || l2 === "ConditionalExpression" || l2 === "FunctionExpression" || l2 === "Identifier" || l2 === "StringLiteral" || l2 === "NumericLiteral" || l2 === "NullLiteral" || l2 === "BooleanLiteral" || l2 === "RegExpLiteral" || l2 === "LogicalExpression" || l2 === "MemberExpression" || l2 === "NewExpression" || l2 === "ObjectExpression" || l2 === "SequenceExpression" || l2 === "ParenthesizedExpression" || l2 === "ThisExpression" || l2 === "UnaryExpression" || l2 === "UpdateExpression" || l2 === "ArrowFunctionExpression" || l2 === "ClassExpression" || l2 === "MetaProperty" || l2 === "Super" || l2 === "TaggedTemplateExpression" || l2 === "TemplateLiteral" || l2 === "YieldExpression" || l2 === "AwaitExpression" || l2 === "Import" || l2 === "BigIntLiteral" || l2 === "OptionalMemberExpression" || l2 === "OptionalCallExpression" || l2 === "TypeCastExpression" || l2 === "JSXElement" || l2 === "JSXFragment" || l2 === "BindExpression" || l2 === "DoExpression" || l2 === "RecordExpression" || l2 === "TupleExpression" || l2 === "DecimalLiteral" || l2 === "ModuleExpression" || l2 === "TopicReference" || l2 === "PipelineTopicExpression" || l2 === "PipelineBareFunction" || l2 === "PipelinePrimaryTopicReference" || l2 === "TSInstantiationExpression" || l2 === "TSAsExpression" || l2 === "TSTypeAssertion" || l2 === "TSNonNullExpression" || l2 === "Placeholder" && (b.expectedNode === "Expression" || b.expectedNode === "Identifier" || b.expectedNode === "StringLiteral") ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function o(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BinaryExpression" || l2 === "LogicalExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function d(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BlockStatement" || l2 === "CatchClause" || l2 === "DoWhileStatement" || l2 === "ForInStatement" || l2 === "ForStatement" || l2 === "FunctionDeclaration" || l2 === "FunctionExpression" || l2 === "Program" || l2 === "ObjectMethod" || l2 === "SwitchStatement" || l2 === "WhileStatement" || l2 === "ArrowFunctionExpression" || l2 === "ClassExpression" || l2 === "ClassDeclaration" || l2 === "ForOfStatement" || l2 === "ClassMethod" || l2 === "ClassPrivateMethod" || l2 === "StaticBlock" || l2 === "TSModuleBlock" || l2 === "Placeholder" && b.expectedNode === "BlockStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function u(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BlockStatement" || l2 === "CatchClause" || l2 === "DoWhileStatement" || l2 === "ForInStatement" || l2 === "ForStatement" || l2 === "FunctionDeclaration" || l2 === "FunctionExpression" || l2 === "Program" || l2 === "ObjectMethod" || l2 === "SwitchStatement" || l2 === "WhileStatement" || l2 === "ArrowFunctionExpression" || l2 === "ForOfStatement" || l2 === "ClassMethod" || l2 === "ClassPrivateMethod" || l2 === "StaticBlock" || l2 === "TSModuleBlock" || l2 === "Placeholder" && b.expectedNode === "BlockStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function E(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BlockStatement" || l2 === "Program" || l2 === "TSModuleBlock" || l2 === "Placeholder" && b.expectedNode === "BlockStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function w(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BlockStatement" || l2 === "BreakStatement" || l2 === "ContinueStatement" || l2 === "DebuggerStatement" || l2 === "DoWhileStatement" || l2 === "EmptyStatement" || l2 === "ExpressionStatement" || l2 === "ForInStatement" || l2 === "ForStatement" || l2 === "FunctionDeclaration" || l2 === "IfStatement" || l2 === "LabeledStatement" || l2 === "ReturnStatement" || l2 === "SwitchStatement" || l2 === "ThrowStatement" || l2 === "TryStatement" || l2 === "VariableDeclaration" || l2 === "WhileStatement" || l2 === "WithStatement" || l2 === "ClassDeclaration" || l2 === "ExportAllDeclaration" || l2 === "ExportDefaultDeclaration" || l2 === "ExportNamedDeclaration" || l2 === "ForOfStatement" || l2 === "ImportDeclaration" || l2 === "DeclareClass" || l2 === "DeclareFunction" || l2 === "DeclareInterface" || l2 === "DeclareModule" || l2 === "DeclareModuleExports" || l2 === "DeclareTypeAlias" || l2 === "DeclareOpaqueType" || l2 === "DeclareVariable" || l2 === "DeclareExportDeclaration" || l2 === "DeclareExportAllDeclaration" || l2 === "InterfaceDeclaration" || l2 === "OpaqueType" || l2 === "TypeAlias" || l2 === "EnumDeclaration" || l2 === "TSDeclareFunction" || l2 === "TSInterfaceDeclaration" || l2 === "TSTypeAliasDeclaration" || l2 === "TSEnumDeclaration" || l2 === "TSModuleDeclaration" || l2 === "TSImportEqualsDeclaration" || l2 === "TSExportAssignment" || l2 === "TSNamespaceExportDeclaration" || l2 === "Placeholder" && (b.expectedNode === "Statement" || b.expectedNode === "Declaration" || b.expectedNode === "BlockStatement") ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function U(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BreakStatement" || l2 === "ContinueStatement" || l2 === "ReturnStatement" || l2 === "ThrowStatement" || l2 === "YieldExpression" || l2 === "AwaitExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ge(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "BreakStatement" || l2 === "ContinueStatement" || l2 === "ReturnStatement" || l2 === "ThrowStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ye(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ConditionalExpression" || l2 === "IfStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ae(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "DoWhileStatement" || l2 === "ForInStatement" || l2 === "ForStatement" || l2 === "WhileStatement" || l2 === "ForOfStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Oe(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "DoWhileStatement" || l2 === "WhileStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ve(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ExpressionStatement" || l2 === "ParenthesizedExpression" || l2 === "TypeCastExpression" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ke(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ForInStatement" || l2 === "ForStatement" || l2 === "ForOfStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function He(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ForInStatement" || l2 === "ForOfStatement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function bs(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "FunctionDeclaration" || l2 === "FunctionExpression" || l2 === "ObjectMethod" || l2 === "ArrowFunctionExpression" || l2 === "ClassMethod" || l2 === "ClassPrivateMethod" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function zi(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "FunctionDeclaration" || l2 === "FunctionExpression" || l2 === "ObjectMethod" || l2 === "ArrowFunctionExpression" || l2 === "ClassMethod" || l2 === "ClassPrivateMethod" || l2 === "StaticBlock" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Yl(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "FunctionDeclaration" || l2 === "FunctionExpression" || l2 === "StringLiteral" || l2 === "NumericLiteral" || l2 === "NullLiteral" || l2 === "BooleanLiteral" || l2 === "RegExpLiteral" || l2 === "ArrowFunctionExpression" || l2 === "BigIntLiteral" || l2 === "DecimalLiteral" || l2 === "Placeholder" && b.expectedNode === "StringLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ql(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "FunctionDeclaration" || l2 === "VariableDeclaration" || l2 === "ClassDeclaration" || l2 === "ExportAllDeclaration" || l2 === "ExportDefaultDeclaration" || l2 === "ExportNamedDeclaration" || l2 === "ImportDeclaration" || l2 === "DeclareClass" || l2 === "DeclareFunction" || l2 === "DeclareInterface" || l2 === "DeclareModule" || l2 === "DeclareModuleExports" || l2 === "DeclareTypeAlias" || l2 === "DeclareOpaqueType" || l2 === "DeclareVariable" || l2 === "DeclareExportDeclaration" || l2 === "DeclareExportAllDeclaration" || l2 === "InterfaceDeclaration" || l2 === "OpaqueType" || l2 === "TypeAlias" || l2 === "EnumDeclaration" || l2 === "TSDeclareFunction" || l2 === "TSInterfaceDeclaration" || l2 === "TSTypeAliasDeclaration" || l2 === "TSEnumDeclaration" || l2 === "TSModuleDeclaration" || l2 === "Placeholder" && b.expectedNode === "Declaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Zl(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "Identifier" || l2 === "RestElement" || l2 === "AssignmentPattern" || l2 === "ArrayPattern" || l2 === "ObjectPattern" || l2 === "TSAsExpression" || l2 === "TSTypeAssertion" || l2 === "TSNonNullExpression" || l2 === "Placeholder" && (b.expectedNode === "Pattern" || b.expectedNode === "Identifier") ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function eu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "Identifier" || l2 === "MemberExpression" || l2 === "RestElement" || l2 === "AssignmentPattern" || l2 === "ArrayPattern" || l2 === "ObjectPattern" || l2 === "TSParameterProperty" || l2 === "TSAsExpression" || l2 === "TSTypeAssertion" || l2 === "TSNonNullExpression" || l2 === "Placeholder" && (b.expectedNode === "Pattern" || b.expectedNode === "Identifier") ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function tu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "Identifier" || l2 === "TSQualifiedName" || l2 === "Placeholder" && b.expectedNode === "Identifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ru(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "StringLiteral" || l2 === "NumericLiteral" || l2 === "NullLiteral" || l2 === "BooleanLiteral" || l2 === "RegExpLiteral" || l2 === "TemplateLiteral" || l2 === "BigIntLiteral" || l2 === "DecimalLiteral" || l2 === "Placeholder" && b.expectedNode === "StringLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function su(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "StringLiteral" || l2 === "NumericLiteral" || l2 === "NullLiteral" || l2 === "BooleanLiteral" || l2 === "BigIntLiteral" || l2 === "JSXAttribute" || l2 === "JSXClosingElement" || l2 === "JSXElement" || l2 === "JSXExpressionContainer" || l2 === "JSXSpreadChild" || l2 === "JSXOpeningElement" || l2 === "JSXText" || l2 === "JSXFragment" || l2 === "JSXOpeningFragment" || l2 === "JSXClosingFragment" || l2 === "DecimalLiteral" || l2 === "Placeholder" && b.expectedNode === "StringLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function iu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ObjectMethod" || l2 === "ObjectProperty" || l2 === "ObjectTypeInternalSlot" || l2 === "ObjectTypeCallProperty" || l2 === "ObjectTypeIndexer" || l2 === "ObjectTypeProperty" || l2 === "ObjectTypeSpreadProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function nu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ObjectMethod" || l2 === "ClassMethod" || l2 === "ClassPrivateMethod" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function au(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ObjectMethod" || l2 === "ObjectProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ou(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ObjectProperty" || l2 === "ClassProperty" || l2 === "ClassAccessorProperty" || l2 === "ClassPrivateProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function lu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "UnaryExpression" || l2 === "SpreadElement" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function uu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "AssignmentPattern" || l2 === "ArrayPattern" || l2 === "ObjectPattern" || l2 === "Placeholder" && b.expectedNode === "Pattern" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function cu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ClassExpression" || l2 === "ClassDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function pu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ExportAllDeclaration" || l2 === "ExportDefaultDeclaration" || l2 === "ExportNamedDeclaration" || l2 === "ImportDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function fu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ExportAllDeclaration" || l2 === "ExportDefaultDeclaration" || l2 === "ExportNamedDeclaration" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function hu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ExportSpecifier" || l2 === "ImportDefaultSpecifier" || l2 === "ImportNamespaceSpecifier" || l2 === "ImportSpecifier" || l2 === "ExportNamespaceSpecifier" || l2 === "ExportDefaultSpecifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function du(b, c) {
    return b && b.type === "ClassAccessorProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function mu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "ClassPrivateProperty" || l2 === "ClassPrivateMethod" || l2 === "PrivateName" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function yu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "AnyTypeAnnotation" || l2 === "ArrayTypeAnnotation" || l2 === "BooleanTypeAnnotation" || l2 === "BooleanLiteralTypeAnnotation" || l2 === "NullLiteralTypeAnnotation" || l2 === "ClassImplements" || l2 === "DeclareClass" || l2 === "DeclareFunction" || l2 === "DeclareInterface" || l2 === "DeclareModule" || l2 === "DeclareModuleExports" || l2 === "DeclareTypeAlias" || l2 === "DeclareOpaqueType" || l2 === "DeclareVariable" || l2 === "DeclareExportDeclaration" || l2 === "DeclareExportAllDeclaration" || l2 === "DeclaredPredicate" || l2 === "ExistsTypeAnnotation" || l2 === "FunctionTypeAnnotation" || l2 === "FunctionTypeParam" || l2 === "GenericTypeAnnotation" || l2 === "InferredPredicate" || l2 === "InterfaceExtends" || l2 === "InterfaceDeclaration" || l2 === "InterfaceTypeAnnotation" || l2 === "IntersectionTypeAnnotation" || l2 === "MixedTypeAnnotation" || l2 === "EmptyTypeAnnotation" || l2 === "NullableTypeAnnotation" || l2 === "NumberLiteralTypeAnnotation" || l2 === "NumberTypeAnnotation" || l2 === "ObjectTypeAnnotation" || l2 === "ObjectTypeInternalSlot" || l2 === "ObjectTypeCallProperty" || l2 === "ObjectTypeIndexer" || l2 === "ObjectTypeProperty" || l2 === "ObjectTypeSpreadProperty" || l2 === "OpaqueType" || l2 === "QualifiedTypeIdentifier" || l2 === "StringLiteralTypeAnnotation" || l2 === "StringTypeAnnotation" || l2 === "SymbolTypeAnnotation" || l2 === "ThisTypeAnnotation" || l2 === "TupleTypeAnnotation" || l2 === "TypeofTypeAnnotation" || l2 === "TypeAlias" || l2 === "TypeAnnotation" || l2 === "TypeCastExpression" || l2 === "TypeParameter" || l2 === "TypeParameterDeclaration" || l2 === "TypeParameterInstantiation" || l2 === "UnionTypeAnnotation" || l2 === "Variance" || l2 === "VoidTypeAnnotation" || l2 === "EnumDeclaration" || l2 === "EnumBooleanBody" || l2 === "EnumNumberBody" || l2 === "EnumStringBody" || l2 === "EnumSymbolBody" || l2 === "EnumBooleanMember" || l2 === "EnumNumberMember" || l2 === "EnumStringMember" || l2 === "EnumDefaultedMember" || l2 === "IndexedAccessType" || l2 === "OptionalIndexedAccessType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function bu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "AnyTypeAnnotation" || l2 === "ArrayTypeAnnotation" || l2 === "BooleanTypeAnnotation" || l2 === "BooleanLiteralTypeAnnotation" || l2 === "NullLiteralTypeAnnotation" || l2 === "ExistsTypeAnnotation" || l2 === "FunctionTypeAnnotation" || l2 === "GenericTypeAnnotation" || l2 === "InterfaceTypeAnnotation" || l2 === "IntersectionTypeAnnotation" || l2 === "MixedTypeAnnotation" || l2 === "EmptyTypeAnnotation" || l2 === "NullableTypeAnnotation" || l2 === "NumberLiteralTypeAnnotation" || l2 === "NumberTypeAnnotation" || l2 === "ObjectTypeAnnotation" || l2 === "StringLiteralTypeAnnotation" || l2 === "StringTypeAnnotation" || l2 === "SymbolTypeAnnotation" || l2 === "ThisTypeAnnotation" || l2 === "TupleTypeAnnotation" || l2 === "TypeofTypeAnnotation" || l2 === "UnionTypeAnnotation" || l2 === "VoidTypeAnnotation" || l2 === "IndexedAccessType" || l2 === "OptionalIndexedAccessType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function gu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "AnyTypeAnnotation" || l2 === "BooleanTypeAnnotation" || l2 === "NullLiteralTypeAnnotation" || l2 === "MixedTypeAnnotation" || l2 === "EmptyTypeAnnotation" || l2 === "NumberTypeAnnotation" || l2 === "StringTypeAnnotation" || l2 === "SymbolTypeAnnotation" || l2 === "ThisTypeAnnotation" || l2 === "VoidTypeAnnotation" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Tu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "DeclareClass" || l2 === "DeclareFunction" || l2 === "DeclareInterface" || l2 === "DeclareModule" || l2 === "DeclareModuleExports" || l2 === "DeclareTypeAlias" || l2 === "DeclareOpaqueType" || l2 === "DeclareVariable" || l2 === "DeclareExportDeclaration" || l2 === "DeclareExportAllDeclaration" || l2 === "InterfaceDeclaration" || l2 === "OpaqueType" || l2 === "TypeAlias" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function xu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "DeclaredPredicate" || l2 === "InferredPredicate" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Pu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "EnumBooleanBody" || l2 === "EnumNumberBody" || l2 === "EnumStringBody" || l2 === "EnumSymbolBody" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Su(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "EnumBooleanMember" || l2 === "EnumNumberMember" || l2 === "EnumStringMember" || l2 === "EnumDefaultedMember" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Eu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "JSXAttribute" || l2 === "JSXClosingElement" || l2 === "JSXElement" || l2 === "JSXEmptyExpression" || l2 === "JSXExpressionContainer" || l2 === "JSXSpreadChild" || l2 === "JSXIdentifier" || l2 === "JSXMemberExpression" || l2 === "JSXNamespacedName" || l2 === "JSXOpeningElement" || l2 === "JSXSpreadAttribute" || l2 === "JSXText" || l2 === "JSXFragment" || l2 === "JSXOpeningFragment" || l2 === "JSXClosingFragment" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function vu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "Noop" || l2 === "Placeholder" || l2 === "V8IntrinsicIdentifier" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Au(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "TSParameterProperty" || l2 === "TSDeclareFunction" || l2 === "TSDeclareMethod" || l2 === "TSQualifiedName" || l2 === "TSCallSignatureDeclaration" || l2 === "TSConstructSignatureDeclaration" || l2 === "TSPropertySignature" || l2 === "TSMethodSignature" || l2 === "TSIndexSignature" || l2 === "TSAnyKeyword" || l2 === "TSBooleanKeyword" || l2 === "TSBigIntKeyword" || l2 === "TSIntrinsicKeyword" || l2 === "TSNeverKeyword" || l2 === "TSNullKeyword" || l2 === "TSNumberKeyword" || l2 === "TSObjectKeyword" || l2 === "TSStringKeyword" || l2 === "TSSymbolKeyword" || l2 === "TSUndefinedKeyword" || l2 === "TSUnknownKeyword" || l2 === "TSVoidKeyword" || l2 === "TSThisType" || l2 === "TSFunctionType" || l2 === "TSConstructorType" || l2 === "TSTypeReference" || l2 === "TSTypePredicate" || l2 === "TSTypeQuery" || l2 === "TSTypeLiteral" || l2 === "TSArrayType" || l2 === "TSTupleType" || l2 === "TSOptionalType" || l2 === "TSRestType" || l2 === "TSNamedTupleMember" || l2 === "TSUnionType" || l2 === "TSIntersectionType" || l2 === "TSConditionalType" || l2 === "TSInferType" || l2 === "TSParenthesizedType" || l2 === "TSTypeOperator" || l2 === "TSIndexedAccessType" || l2 === "TSMappedType" || l2 === "TSLiteralType" || l2 === "TSExpressionWithTypeArguments" || l2 === "TSInterfaceDeclaration" || l2 === "TSInterfaceBody" || l2 === "TSTypeAliasDeclaration" || l2 === "TSInstantiationExpression" || l2 === "TSAsExpression" || l2 === "TSTypeAssertion" || l2 === "TSEnumDeclaration" || l2 === "TSEnumMember" || l2 === "TSModuleDeclaration" || l2 === "TSModuleBlock" || l2 === "TSImportType" || l2 === "TSImportEqualsDeclaration" || l2 === "TSExternalModuleReference" || l2 === "TSNonNullExpression" || l2 === "TSExportAssignment" || l2 === "TSNamespaceExportDeclaration" || l2 === "TSTypeAnnotation" || l2 === "TSTypeParameterInstantiation" || l2 === "TSTypeParameterDeclaration" || l2 === "TSTypeParameter" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Cu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "TSCallSignatureDeclaration" || l2 === "TSConstructSignatureDeclaration" || l2 === "TSPropertySignature" || l2 === "TSMethodSignature" || l2 === "TSIndexSignature" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function wu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "TSAnyKeyword" || l2 === "TSBooleanKeyword" || l2 === "TSBigIntKeyword" || l2 === "TSIntrinsicKeyword" || l2 === "TSNeverKeyword" || l2 === "TSNullKeyword" || l2 === "TSNumberKeyword" || l2 === "TSObjectKeyword" || l2 === "TSStringKeyword" || l2 === "TSSymbolKeyword" || l2 === "TSUndefinedKeyword" || l2 === "TSUnknownKeyword" || l2 === "TSVoidKeyword" || l2 === "TSThisType" || l2 === "TSFunctionType" || l2 === "TSConstructorType" || l2 === "TSTypeReference" || l2 === "TSTypePredicate" || l2 === "TSTypeQuery" || l2 === "TSTypeLiteral" || l2 === "TSArrayType" || l2 === "TSTupleType" || l2 === "TSOptionalType" || l2 === "TSRestType" || l2 === "TSUnionType" || l2 === "TSIntersectionType" || l2 === "TSConditionalType" || l2 === "TSInferType" || l2 === "TSParenthesizedType" || l2 === "TSTypeOperator" || l2 === "TSIndexedAccessType" || l2 === "TSMappedType" || l2 === "TSLiteralType" || l2 === "TSExpressionWithTypeArguments" || l2 === "TSImportType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Iu(b, c) {
    if (!b)
      return false;
    const l2 = b.type;
    return l2 === "TSAnyKeyword" || l2 === "TSBooleanKeyword" || l2 === "TSBigIntKeyword" || l2 === "TSIntrinsicKeyword" || l2 === "TSNeverKeyword" || l2 === "TSNullKeyword" || l2 === "TSNumberKeyword" || l2 === "TSObjectKeyword" || l2 === "TSStringKeyword" || l2 === "TSSymbolKeyword" || l2 === "TSUndefinedKeyword" || l2 === "TSUnknownKeyword" || l2 === "TSVoidKeyword" || l2 === "TSThisType" || l2 === "TSLiteralType" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Nu(b, c) {
    return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), b && b.type === "NumberLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function ku(b, c) {
    return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), b && b.type === "RegexLiteral" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Ou(b, c) {
    return console.trace("The node type RestProperty has been renamed to RestElement"), b && b.type === "RestProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  function Du(b, c) {
    return console.trace("The node type SpreadProperty has been renamed to SpreadElement"), b && b.type === "SpreadProperty" ? typeof c > "u" ? true : (0, s.default)(b, c) : false;
  }
  return se;
}
var jp;
function vy() {
  if (jp)
    return Ka;
  jp = 1, Object.defineProperty(Ka, "__esModule", {
    value: true
  }), Ka.default = n;
  var s = rr();
  function n(h, f2, p) {
    if (!(0, s.isMemberExpression)(h))
      return false;
    const g = Array.isArray(f2) ? f2 : f2.split("."), P = [];
    let x;
    for (x = h; (0, s.isMemberExpression)(x); x = x.object)
      P.push(x.property);
    if (P.push(x), P.length < g.length || !p && P.length > g.length)
      return false;
    for (let y = 0, A = P.length - 1; y < g.length; y++, A--) {
      const S = P[A];
      let v;
      if ((0, s.isIdentifier)(S))
        v = S.name;
      else if ((0, s.isStringLiteral)(S))
        v = S.value;
      else if ((0, s.isThisExpression)(S))
        v = "this";
      else
        return false;
      if (g[y] !== v)
        return false;
    }
    return true;
  }
  return Ka;
}
var Rp;
function Ay() {
  if (Rp)
    return Va;
  Rp = 1, Object.defineProperty(Va, "__esModule", {
    value: true
  }), Va.default = n;
  var s = vy();
  function n(h, f2) {
    const p = h.split(".");
    return (g) => (0, s.default)(g, p, f2);
  }
  return Va;
}
var Up;
function Pb() {
  if (Up)
    return ea;
  Up = 1, Object.defineProperty(ea, "__esModule", {
    value: true
  }), ea.default = void 0;
  var s = Ay(), h = (0, s.default)("React.Component");
  return ea.default = h, ea;
}
var Ha = {};
var $p;
function Sb() {
  if ($p)
    return Ha;
  $p = 1, Object.defineProperty(Ha, "__esModule", {
    value: true
  }), Ha.default = s;
  function s(n) {
    return !!n && /^[a-z]/.test(n);
  }
  return Ha;
}
var za = {};
var Ga = {};
var Z = {};
var Xa = {};
var An = {};
var _u = {};
var Fu;
var qp;
function Eb() {
  if (qp)
    return Fu;
  qp = 1;
  let s = null;
  function n(h) {
    if (s !== null && typeof s.property) {
      const f2 = s;
      return s = n.prototype = null, f2;
    }
    return s = n.prototype = h == null ? /* @__PURE__ */ Object.create(null) : h, new n();
  }
  return n(), Fu = function(f2) {
    return n(f2);
  }, Fu;
}
var Or = {};
var Ja = {};
var Ya = {};
var Vp;
function Gc() {
  if (Vp)
    return Ya;
  Vp = 1, Object.defineProperty(Ya, "__esModule", {
    value: true
  }), Ya.default = n;
  var s = Ui();
  function n(h, f2) {
    if (h === f2)
      return true;
    if (s.ALIAS_KEYS[f2])
      return false;
    const p = s.FLIPPED_ALIAS_KEYS[f2];
    if (p) {
      if (p[0] === h)
        return true;
      for (const g of p)
        if (h === g)
          return true;
    }
    return false;
  }
  return Ya;
}
var Qa = {};
var Kp;
function Cy() {
  if (Kp)
    return Qa;
  Kp = 1, Object.defineProperty(Qa, "__esModule", {
    value: true
  }), Qa.default = n;
  var s = Ui();
  function n(h, f2) {
    if (h === f2)
      return true;
    const p = s.PLACEHOLDERS_ALIAS[h];
    if (p) {
      for (const g of p)
        if (f2 === g)
          return true;
    }
    return false;
  }
  return Qa;
}
var Wp;
function Ma() {
  if (Wp)
    return Ja;
  Wp = 1, Object.defineProperty(Ja, "__esModule", {
    value: true
  }), Ja.default = p;
  var s = zc(), n = Gc(), h = Cy(), f2 = Ui();
  function p(g, P, x) {
    return P ? (0, n.default)(P.type, g) ? typeof x > "u" ? true : (0, s.default)(P, x) : !x && P.type === "Placeholder" && g in f2.FLIPPED_ALIAS_KEYS ? (0, h.default)(P.expectedNode, g) : false : false;
  }
  return Ja;
}
var Za = {};
var ju = {};
var Cn = {};
var Hp;
function vb() {
  if (Hp)
    return Cn;
  Hp = 1, Object.defineProperty(Cn, "__esModule", {
    value: true
  }), Cn.isIdentifierChar = y, Cn.isIdentifierName = A, Cn.isIdentifierStart = x;
  let s = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", n = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const h = new RegExp("[" + s + "]"), f2 = new RegExp("[" + s + n + "]");
  s = n = null;
  const p = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], g = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function P(S, v) {
    let T = 65536;
    for (let C = 0, I = v.length; C < I; C += 2) {
      if (T += v[C], T > S)
        return false;
      if (T += v[C + 1], T >= S)
        return true;
    }
    return false;
  }
  function x(S) {
    return S < 65 ? S === 36 : S <= 90 ? true : S < 97 ? S === 95 : S <= 122 ? true : S <= 65535 ? S >= 170 && h.test(String.fromCharCode(S)) : P(S, p);
  }
  function y(S) {
    return S < 48 ? S === 36 : S < 58 ? true : S < 65 ? false : S <= 90 ? true : S < 97 ? S === 95 : S <= 122 ? true : S <= 65535 ? S >= 170 && f2.test(String.fromCharCode(S)) : P(S, p) || P(S, g);
  }
  function A(S) {
    let v = true;
    for (let T = 0; T < S.length; T++) {
      let C = S.charCodeAt(T);
      if ((C & 64512) === 55296 && T + 1 < S.length) {
        const I = S.charCodeAt(++T);
        (I & 64512) === 56320 && (C = 65536 + ((C & 1023) << 10) + (I & 1023));
      }
      if (v) {
        if (v = false, !x(C))
          return false;
      } else if (!y(C))
        return false;
    }
    return !v;
  }
  return Cn;
}
var ln = {};
var zp;
function Ab() {
  if (zp)
    return ln;
  zp = 1, Object.defineProperty(ln, "__esModule", {
    value: true
  }), ln.isKeyword = y, ln.isReservedWord = p, ln.isStrictBindOnlyReservedWord = P, ln.isStrictBindReservedWord = x, ln.isStrictReservedWord = g;
  const s = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, n = new Set(s.keyword), h = new Set(s.strict), f2 = new Set(s.strictBind);
  function p(A, S) {
    return S && A === "await" || A === "enum";
  }
  function g(A, S) {
    return p(A, S) || h.has(A);
  }
  function P(A) {
    return f2.has(A);
  }
  function x(A, S) {
    return g(A, S) || P(A);
  }
  function y(A) {
    return n.has(A);
  }
  return ln;
}
var Gp;
function Ba() {
  return Gp || (Gp = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return n.isIdentifierChar;
      }
    }), Object.defineProperty(s, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return n.isIdentifierName;
      }
    }), Object.defineProperty(s, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return n.isIdentifierStart;
      }
    }), Object.defineProperty(s, "isKeyword", {
      enumerable: true,
      get: function() {
        return h.isKeyword;
      }
    }), Object.defineProperty(s, "isReservedWord", {
      enumerable: true,
      get: function() {
        return h.isReservedWord;
      }
    }), Object.defineProperty(s, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return h.isStrictBindOnlyReservedWord;
      }
    }), Object.defineProperty(s, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return h.isStrictBindReservedWord;
      }
    }), Object.defineProperty(s, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return h.isStrictReservedWord;
      }
    });
    var n = vb(), h = Ab();
  }(ju)), ju;
}
var Xp;
function _a() {
  if (Xp)
    return Za;
  Xp = 1, Object.defineProperty(Za, "__esModule", {
    value: true
  }), Za.default = n;
  var s = Ba();
  function n(h, f2 = true) {
    return typeof h != "string" || f2 && ((0, s.isKeyword)(h) || (0, s.isStrictReservedWord)(h, true)) ? false : (0, s.isIdentifierName)(h);
  }
  return Za;
}
var Qe = {};
var Jp;
function Tn() {
  if (Jp)
    return Qe;
  Jp = 1, Object.defineProperty(Qe, "__esModule", {
    value: true
  }), Qe.UPDATE_OPERATORS = Qe.UNARY_OPERATORS = Qe.STRING_UNARY_OPERATORS = Qe.STATEMENT_OR_BLOCK_KEYS = Qe.NUMBER_UNARY_OPERATORS = Qe.NUMBER_BINARY_OPERATORS = Qe.NOT_LOCAL_BINDING = Qe.LOGICAL_OPERATORS = Qe.INHERIT_KEYS = Qe.FOR_INIT_KEYS = Qe.FLATTENABLE_KEYS = Qe.EQUALITY_BINARY_OPERATORS = Qe.COMPARISON_BINARY_OPERATORS = Qe.COMMENT_KEYS = Qe.BOOLEAN_UNARY_OPERATORS = Qe.BOOLEAN_NUMBER_BINARY_OPERATORS = Qe.BOOLEAN_BINARY_OPERATORS = Qe.BLOCK_SCOPED_SYMBOL = Qe.BINARY_OPERATORS = Qe.ASSIGNMENT_OPERATORS = void 0;
  const s = ["consequent", "body", "alternate"];
  Qe.STATEMENT_OR_BLOCK_KEYS = s;
  const n = ["body", "expressions"];
  Qe.FLATTENABLE_KEYS = n;
  const h = ["left", "init"];
  Qe.FOR_INIT_KEYS = h;
  const f2 = ["leadingComments", "trailingComments", "innerComments"];
  Qe.COMMENT_KEYS = f2;
  const p = ["||", "&&", "??"];
  Qe.LOGICAL_OPERATORS = p;
  const g = ["++", "--"];
  Qe.UPDATE_OPERATORS = g;
  const P = [">", "<", ">=", "<="];
  Qe.BOOLEAN_NUMBER_BINARY_OPERATORS = P;
  const x = ["==", "===", "!=", "!=="];
  Qe.EQUALITY_BINARY_OPERATORS = x;
  const y = [...x, "in", "instanceof"];
  Qe.COMPARISON_BINARY_OPERATORS = y;
  const A = [...y, ...P];
  Qe.BOOLEAN_BINARY_OPERATORS = A;
  const S = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  Qe.NUMBER_BINARY_OPERATORS = S;
  const v = ["+", ...S, ...A, "|>"];
  Qe.BINARY_OPERATORS = v;
  const T = ["=", "+=", ...S.map((R) => R + "="), ...p.map((R) => R + "=")];
  Qe.ASSIGNMENT_OPERATORS = T;
  const C = ["delete", "!"];
  Qe.BOOLEAN_UNARY_OPERATORS = C;
  const I = ["+", "-", "~"];
  Qe.NUMBER_UNARY_OPERATORS = I;
  const N = ["typeof"];
  Qe.STRING_UNARY_OPERATORS = N;
  const D = ["void", "throw", ...C, ...I, ...N];
  Qe.UNARY_OPERATORS = D;
  const _ = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  Qe.INHERIT_KEYS = _;
  const m = Symbol.for("var used to be block scoped");
  Qe.BLOCK_SCOPED_SYMBOL = m;
  const L = Symbol.for("should not be considered a local binding");
  return Qe.NOT_LOCAL_BINDING = L, Qe;
}
var ot = {};
var Yp;
function pn() {
  if (Yp)
    return ot;
  Yp = 1, Object.defineProperty(ot, "__esModule", {
    value: true
  }), ot.VISITOR_KEYS = ot.NODE_PARENT_VALIDATIONS = ot.NODE_FIELDS = ot.FLIPPED_ALIAS_KEYS = ot.DEPRECATED_KEYS = ot.BUILDER_KEYS = ot.ALIAS_KEYS = void 0, ot.arrayOf = N, ot.arrayOfType = D, ot.assertEach = m, ot.assertNodeOrValueType = O, ot.assertNodeType = R, ot.assertOneOf = L, ot.assertOptionalChainStart = j, ot.assertShape = M, ot.assertValueType = B, ot.chain = $, ot.default = q, ot.defineAliasedType = Q, ot.typeIs = v, ot.validate = S, ot.validateArrayOfType = _, ot.validateOptional = C, ot.validateOptionalType = I, ot.validateType = T;
  var s = Ma(), n = Xc();
  const h = {};
  ot.VISITOR_KEYS = h;
  const f2 = {};
  ot.ALIAS_KEYS = f2;
  const p = {};
  ot.FLIPPED_ALIAS_KEYS = p;
  const g = {};
  ot.NODE_FIELDS = g;
  const P = {};
  ot.BUILDER_KEYS = P;
  const x = {};
  ot.DEPRECATED_KEYS = x;
  const y = {};
  ot.NODE_PARENT_VALIDATIONS = y;
  function A(K) {
    return Array.isArray(K) ? "array" : K === null ? "null" : typeof K;
  }
  function S(K) {
    return {
      validate: K
    };
  }
  function v(K) {
    return typeof K == "string" ? R(K) : R(...K);
  }
  function T(K) {
    return S(v(K));
  }
  function C(K) {
    return {
      validate: K,
      optional: true
    };
  }
  function I(K) {
    return {
      validate: v(K),
      optional: true
    };
  }
  function N(K) {
    return $(B("array"), m(K));
  }
  function D(K) {
    return N(v(K));
  }
  function _(K) {
    return S(D(K));
  }
  function m(K) {
    function G(V, F, le) {
      if (!!Array.isArray(le))
        for (let oe = 0; oe < le.length; oe++) {
          const fe = `${F}[${oe}]`, he = le[oe];
          K(V, fe, he), process.env.BABEL_TYPES_8_BREAKING && (0, n.validateChild)(V, fe, he);
        }
    }
    return G.each = K, G;
  }
  function L(...K) {
    function G(V, F, le) {
      if (K.indexOf(le) < 0)
        throw new TypeError(`Property ${F} expected value to be one of ${JSON.stringify(K)} but got ${JSON.stringify(le)}`);
    }
    return G.oneOf = K, G;
  }
  function R(...K) {
    function G(V, F, le) {
      for (const oe of K)
        if ((0, s.default)(oe, le)) {
          (0, n.validateChild)(V, F, le);
          return;
        }
      throw new TypeError(`Property ${F} of ${V.type} expected node to be of a type ${JSON.stringify(K)} but instead got ${JSON.stringify(le == null ? void 0 : le.type)}`);
    }
    return G.oneOfNodeTypes = K, G;
  }
  function O(...K) {
    function G(V, F, le) {
      for (const oe of K)
        if (A(le) === oe || (0, s.default)(oe, le)) {
          (0, n.validateChild)(V, F, le);
          return;
        }
      throw new TypeError(`Property ${F} of ${V.type} expected node to be of a type ${JSON.stringify(K)} but instead got ${JSON.stringify(le == null ? void 0 : le.type)}`);
    }
    return G.oneOfNodeOrValueTypes = K, G;
  }
  function B(K) {
    function G(V, F, le) {
      if (!(A(le) === K))
        throw new TypeError(`Property ${F} expected type of ${K} but got ${A(le)}`);
    }
    return G.type = K, G;
  }
  function M(K) {
    function G(V, F, le) {
      const oe = [];
      for (const fe of Object.keys(K))
        try {
          (0, n.validateField)(V, fe, le[fe], K[fe]);
        } catch (he) {
          if (he instanceof TypeError) {
            oe.push(he.message);
            continue;
          }
          throw he;
        }
      if (oe.length)
        throw new TypeError(`Property ${F} of ${V.type} expected to have the following:
${oe.join(`
`)}`);
    }
    return G.shapeOf = K, G;
  }
  function j() {
    function K(G) {
      var V;
      let F = G;
      for (; G; ) {
        const {
          type: le
        } = F;
        if (le === "OptionalCallExpression") {
          if (F.optional)
            return;
          F = F.callee;
          continue;
        }
        if (le === "OptionalMemberExpression") {
          if (F.optional)
            return;
          F = F.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${G.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(V = F) == null ? void 0 : V.type}`);
    }
    return K;
  }
  function $(...K) {
    function G(...V) {
      for (const F of K)
        F(...V);
    }
    if (G.chainOf = K, K.length >= 2 && "type" in K[0] && K[0].type === "array" && !("each" in K[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return G;
  }
  const k = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], ne = ["default", "optional", "validate"];
  function Q(...K) {
    return (G, V = {}) => {
      let F = V.aliases;
      if (!F) {
        var le, oe;
        V.inherits && (F = (le = ee[V.inherits].aliases) == null ? void 0 : le.slice()), (oe = F) != null || (F = []), V.aliases = F;
      }
      const fe = K.filter((he) => !F.includes(he));
      return F.unshift(...fe), q(G, V);
    };
  }
  function q(K, G = {}) {
    const V = G.inherits && ee[G.inherits] || {};
    let F = G.fields;
    if (!F && (F = {}, V.fields)) {
      const he = Object.getOwnPropertyNames(V.fields);
      for (const de of he) {
        const Pe = V.fields[de], we = Pe.default;
        if (Array.isArray(we) ? we.length > 0 : we && typeof we == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        F[de] = {
          default: Array.isArray(we) ? [] : we,
          optional: Pe.optional,
          validate: Pe.validate
        };
      }
    }
    const le = G.visitor || V.visitor || [], oe = G.aliases || V.aliases || [], fe = G.builder || V.builder || G.visitor || [];
    for (const he of Object.keys(G))
      if (k.indexOf(he) === -1)
        throw new Error(`Unknown type option "${he}" on ${K}`);
    G.deprecatedAlias && (x[G.deprecatedAlias] = K);
    for (const he of le.concat(fe))
      F[he] = F[he] || {};
    for (const he of Object.keys(F)) {
      const de = F[he];
      de.default !== void 0 && fe.indexOf(he) === -1 && (de.optional = true), de.default === void 0 ? de.default = null : !de.validate && de.default != null && (de.validate = B(A(de.default)));
      for (const Pe of Object.keys(de))
        if (ne.indexOf(Pe) === -1)
          throw new Error(`Unknown field key "${Pe}" on ${K}.${he}`);
    }
    h[K] = G.visitor = le, P[K] = G.builder = fe, g[K] = G.fields = F, f2[K] = G.aliases = oe, oe.forEach((he) => {
      p[he] = p[he] || [], p[he].push(K);
    }), G.validate && (y[K] = G.validate), ee[K] = G;
  }
  const ee = {};
  return ot;
}
var Qp;
function wy() {
  if (Qp)
    return Or;
  Qp = 1, Object.defineProperty(Or, "__esModule", {
    value: true
  }), Or.patternLikeCommon = Or.functionTypeAnnotationCommon = Or.functionDeclarationCommon = Or.functionCommon = Or.classMethodOrPropertyCommon = Or.classMethodOrDeclareMethodCommon = void 0;
  var s = Ma(), n = _a(), h = Ba(), f2 = Tn(), p = pn();
  const g = (0, p.defineAliasedType)("Standardized");
  g("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), g("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, p.assertValueType)("string");
          const T = (0, p.assertOneOf)(...f2.ASSIGNMENT_OPERATORS), C = (0, p.assertOneOf)("=");
          return function(I, N, D) {
            ((0, s.default)("Pattern", I.left) ? C : T)(I, N, D);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, p.assertNodeType)("LVal")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  }), g("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, p.assertOneOf)(...f2.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const T = (0, p.assertNodeType)("Expression"), C = (0, p.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(N, D, _) {
            (N.operator === "in" ? C : T)(N, D, _);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  }), g("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    }
  }), g("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, p.assertNodeType)("DirectiveLiteral")
      }
    }
  }), g("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    }
  }), g("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  }), g("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), g("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, p.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, p.assertOneOf)(true, false),
        optional: true
      }
    }, {
      typeArguments: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  }), g("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  }), g("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, p.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  }), g("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), g("DebuggerStatement", {
    aliases: ["Statement"]
  }), g("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  }), g("EmptyStatement", {
    aliases: ["Statement"]
  }), g("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, p.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  }), g("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, p.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertEach)((0, p.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: true
      },
      tokens: {
        validate: (0, p.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: true
      }
    }
  }), g("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, p.assertNodeType)("VariableDeclaration", "LVal")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), g("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, p.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  });
  const P = () => ({
    params: {
      validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: false
    },
    async: {
      default: false
    }
  });
  Or.functionCommon = P;
  const x = () => ({
    returnType: {
      validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  Or.functionTypeAnnotationCommon = x;
  const y = () => Object.assign({}, P(), {
    declare: {
      validate: (0, p.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, p.assertNodeType)("Identifier"),
      optional: true
    }
  });
  Or.functionDeclarationCommon = y, g("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, y(), x(), {
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, p.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return () => {
        };
      const T = (0, p.assertNodeType)("Identifier");
      return function(C, I, N) {
        (0, s.default)("ExportDefaultDeclaration", C) || T(N, "id", N.id);
      };
    }()
  }), g("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, P(), x(), {
      id: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, p.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  const A = () => ({
    typeAnnotation: {
      validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  Or.patternLikeCommon = A, g("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, A(), {
      name: {
        validate: (0, p.chain)((0, p.assertValueType)("string"), Object.assign(function(T, C, I) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && !(0, n.default)(I, false))
            throw new TypeError(`"${I}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      },
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      }
    }),
    validate(T, C, I) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const N = /\.(\w+)$/.exec(C);
      if (!N)
        return;
      const [, D] = N, _ = {
        computed: false
      };
      if (D === "property") {
        if ((0, s.default)("MemberExpression", T, _) || (0, s.default)("OptionalMemberExpression", T, _))
          return;
      } else if (D === "key") {
        if ((0, s.default)("Property", T, _) || (0, s.default)("Method", T, _))
          return;
      } else if (D === "exported") {
        if ((0, s.default)("ExportSpecifier", T))
          return;
      } else if (D === "imported") {
        if ((0, s.default)("ImportSpecifier", T, {
          imported: I
        }))
          return;
      } else if (D === "meta" && (0, s.default)("MetaProperty", T, {
        meta: I
      }))
        return;
      if (((0, h.isKeyword)(I.name) || (0, h.isReservedWord)(I.name, false)) && I.name !== "this")
        throw new TypeError(`"${I.name}" is not a valid identifier`);
    }
  }), g("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, p.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), g("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), g("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), g("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, p.assertValueType)("number")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), g("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), g("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), g("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, p.assertValueType)("string")
      },
      flags: {
        validate: (0, p.chain)((0, p.assertValueType)("string"), Object.assign(function(T, C, I) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const N = /[^gimsuy]/.exec(I);
          if (N)
            throw new TypeError(`"${N[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  }), g("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, p.assertOneOf)(...f2.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, p.assertNodeType)("Expression")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, p.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const T = (0, p.assertNodeType)("Identifier", "PrivateName"), C = (0, p.assertNodeType)("Expression"), I = function(N, D, _) {
            (N.computed ? C : T)(N, D, _);
          };
          return I.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], I;
        }()
      },
      computed: {
        default: false
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, p.assertOneOf)(true, false),
        optional: true
      }
    })
  }), g("NewExpression", {
    inherits: "CallExpression"
  }), g("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: (0, p.assertValueType)("string")
      },
      sourceType: {
        validate: (0, p.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, p.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  }), g("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  }), g("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, P(), x(), {
      kind: Object.assign({
        validate: (0, p.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const T = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), C = (0, p.assertNodeType)("Expression"), I = function(N, D, _) {
            (N.computed ? C : T)(N, D, _);
          };
          return I.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], I;
        }()
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }), g("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const T = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), C = (0, p.assertNodeType)("Expression");
          return Object.assign(function(N, D, _) {
            (N.computed ? C : T)(N, D, _);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, p.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, p.chain)((0, p.assertValueType)("boolean"), Object.assign(function(T, C, I) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && I && T.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(T, C, I) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && I && !(0, s.default)("Identifier", T.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: false
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      const T = (0, p.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSNonNullExpression", "TSTypeAssertion"), C = (0, p.assertNodeType)("Expression");
      return function(I, N, D) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        ((0, s.default)("ObjectPattern", I) ? T : C)(D, "value", D.value);
      };
    }()
  }), g("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, A(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, p.assertNodeType)("LVal")
      },
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      }
    }),
    validate(T, C) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const I = /(\w+)\[(\d+)\]/.exec(C);
      if (!I)
        throw new Error("Internal Babel error: malformed key.");
      const [, N, D] = I;
      if (T[N].length > +D + 1)
        throw new TypeError(`RestElement must be last element of ${N}`);
    }
  }), g("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      }
    }
  }), g("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  }), g("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      },
      consequent: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Statement")))
      }
    }
  }), g("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, p.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("SwitchCase")))
      }
    }
  }), g("ThisExpression", {
    aliases: ["Expression"]
  }), g("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, p.chain)((0, p.assertNodeType)("BlockStatement"), Object.assign(function(T) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && !T.handler && !T.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: true,
        validate: (0, p.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    }
  }), g("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, p.assertOneOf)(...f2.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  }), g("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.assertNodeType)("Identifier", "MemberExpression") : (0, p.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, p.assertOneOf)(...f2.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  }), g("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, p.assertOneOf)("var", "let", "const")
      },
      declarations: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(T, C, I) {
      if (!!process.env.BABEL_TYPES_8_BREAKING && !!(0, s.default)("ForXStatement", T, {
        left: I
      }) && I.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${T.type}`);
    }
  }), g("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, p.assertNodeType)("LVal");
          const T = (0, p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), C = (0, p.assertNodeType)("Identifier");
          return function(I, N, D) {
            (I.init ? T : C)(I, N, D);
          };
        }()
      },
      definite: {
        optional: true,
        validate: (0, p.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), g("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      }
    }
  }), g("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, A(), {
      left: {
        validate: (0, p.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      }
    })
  }), g("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, A(), {
      elements: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      optional: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      }
    })
  }), g("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, P(), x(), {
      expression: {
        validate: (0, p.assertValueType)("boolean")
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, p.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  }), g("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  }), g("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, p.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, p.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, p.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, p.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  }), g("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, p.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, p.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, p.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: function() {
      const T = (0, p.assertNodeType)("Identifier");
      return function(C, I, N) {
        !process.env.BABEL_TYPES_8_BREAKING || (0, s.default)("ExportDefaultDeclaration", C) || T(N, "id", N.id);
      };
    }()
  }), g("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, p.assertNodeType)("StringLiteral")
      },
      exportKind: (0, p.validateOptional)((0, p.assertOneOf)("type", "value")),
      assertions: {
        optional: true,
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("ImportAttribute")))
      }
    }
  }), g("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, p.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, p.validateOptional)((0, p.assertOneOf)("value"))
    }
  }), g("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: (0, p.chain)((0, p.assertNodeType)("Declaration"), Object.assign(function(T, C, I) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && I && T.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(T, C, I) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && I && T.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      assertions: {
        optional: true,
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)(function() {
          const T = (0, p.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), C = (0, p.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(I, N, D) {
            (I.source ? T : C)(I, N, D);
          } : T;
        }()))
      },
      source: {
        validate: (0, p.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, p.validateOptional)((0, p.assertOneOf)("type", "value"))
    }
  }), g("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, p.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, p.assertOneOf)("type", "value"),
        optional: true
      }
    }
  }), g("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, p.assertNodeType)("VariableDeclaration", "LVal");
          const T = (0, p.assertNodeType)("VariableDeclaration"), C = (0, p.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(I, N, D) {
            (0, s.default)("VariableDeclaration", D) ? T(I, N, D) : C(I, N, D);
          };
        }()
      },
      right: {
        validate: (0, p.assertNodeType)("Expression")
      },
      body: {
        validate: (0, p.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  }), g("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      assertions: {
        optional: true,
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, p.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, p.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  }), g("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), g("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), g("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, p.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, p.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, p.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  }), g("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, p.chain)((0, p.assertNodeType)("Identifier"), Object.assign(function(T, C, I) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let N;
          switch (I.name) {
            case "function":
              N = "sent";
              break;
            case "new":
              N = "target";
              break;
            case "import":
              N = "meta";
              break;
          }
          if (!(0, s.default)("Identifier", T.property, {
            name: N
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  });
  const S = () => ({
    abstract: {
      validate: (0, p.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, p.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, p.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, p.chain)(function() {
        const T = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), C = (0, p.assertNodeType)("Expression");
        return function(I, N, D) {
          (I.computed ? C : T)(I, N, D);
        };
      }(), (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  Or.classMethodOrPropertyCommon = S;
  const v = () => Object.assign({}, P(), S(), {
    params: {
      validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, p.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, p.chain)((0, p.assertValueType)("string"), (0, p.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  return Or.classMethodOrDeclareMethodCommon = v, g("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, v(), x(), {
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    })
  }), g("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, A(), {
      properties: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  }), g("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("Super", {
    aliases: ["Expression"]
  }), g("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, p.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, p.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  }), g("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, p.assertShape)({
          raw: {
            validate: (0, p.assertValueType)("string")
          },
          cooked: {
            validate: (0, p.assertValueType)("string"),
            optional: true
          }
        })
      },
      tail: {
        default: false
      }
    }
  }), g("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Expression", "TSType")), function(T, C, I) {
          if (T.quasis.length !== I.length + 1)
            throw new TypeError(`Number of ${T.type} quasis should be exactly one more than the number of expressions.
Expected ${I.length + 1} quasis but got ${T.quasis.length}`);
        })
      }
    }
  }), g("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, p.chain)((0, p.assertValueType)("boolean"), Object.assign(function(T, C, I) {
          if (!!process.env.BABEL_TYPES_8_BREAKING && I && !T.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, p.assertNodeType)("Expression")
      }
    }
  }), g("Import", {
    aliases: ["Expression"]
  }), g("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, p.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), g("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), g("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, p.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const T = (0, p.assertNodeType)("Identifier"), C = (0, p.assertNodeType)("Expression");
          return Object.assign(function(N, D, _) {
            (N.computed ? C : T)(N, D, _);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: false
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("boolean"), (0, p.assertOptionalChainStart)()) : (0, p.assertValueType)("boolean")
      }
    }
  }), g("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, p.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, p.chain)((0, p.assertValueType)("boolean"), (0, p.assertOptionalChainStart)()) : (0, p.assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, p.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, p.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  }), g("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, S(), {
      value: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, p.assertNodeType)("Variance"),
        optional: true
      }
    })
  }), g("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, S(), {
      key: {
        validate: (0, p.chain)(function() {
          const T = (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), C = (0, p.assertNodeType)("Expression");
          return function(I, N, D) {
            (I.computed ? C : T)(I, N, D);
          };
        }(), (0, p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, p.assertNodeType)("Variance"),
        optional: true
      }
    })
  }), g("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, p.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, p.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Decorator"))),
        optional: true
      },
      static: {
        validate: (0, p.assertValueType)("boolean"),
        default: false
      },
      readonly: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, p.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, p.assertNodeType)("Variance"),
        optional: true
      }
    }
  }), g("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, v(), x(), {
      kind: {
        validate: (0, p.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, p.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, p.assertNodeType)("BlockStatement")
      }
    })
  }), g("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, p.assertNodeType)("Identifier")
      }
    }
  }), g("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, p.chain)((0, p.assertValueType)("array"), (0, p.assertEach)((0, p.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  }), Or;
}
var Zp = {};
var ef;
function Cb() {
  if (ef)
    return Zp;
  ef = 1;
  var s = pn();
  const n = (0, s.defineAliasedType)("Flow"), h = (f2) => {
    n(f2, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, s.validateType)("Identifier"),
        typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")),
        mixins: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")),
        implements: (0, s.validateOptional)((0, s.arrayOfType)("ClassImplements")),
        body: (0, s.validateType)("ObjectTypeAnnotation")
      }
    });
  };
  return n("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, s.validateType)("FlowType")
    }
  }), n("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation")
    }
  }), h("DeclareClass"), n("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      predicate: (0, s.validateOptionalType)("DeclaredPredicate")
    }
  }), h("DeclareInterface"), n("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)(["Identifier", "StringLiteral"]),
      body: (0, s.validateType)("BlockStatement"),
      kind: (0, s.validateOptional)((0, s.assertOneOf)("CommonJS", "ES"))
    }
  }), n("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, s.validateType)("TypeAnnotation")
    }
  }), n("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, s.validateType)("FlowType")
    }
  }), n("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, s.validateOptionalType)("FlowType"),
      impltype: (0, s.validateOptionalType)("FlowType")
    }
  }), n("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)("Identifier")
    }
  }), n("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, s.validateOptionalType)("Flow"),
      specifiers: (0, s.validateOptional)((0, s.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, s.validateOptionalType)("StringLiteral"),
      default: (0, s.validateOptional)((0, s.assertValueType)("boolean"))
    }
  }), n("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, s.validateType)("StringLiteral"),
      exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value"))
    }
  }), n("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, s.validateType)("Flow")
    }
  }), n("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  }), n("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, s.validate)((0, s.arrayOfType)("FunctionTypeParam")),
      rest: (0, s.validateOptionalType)("FunctionTypeParam"),
      this: (0, s.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, s.validateType)("FlowType")
    }
  }), n("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, s.validateOptionalType)("Identifier"),
      typeAnnotation: (0, s.validateType)("FlowType"),
      optional: (0, s.validateOptional)((0, s.assertValueType)("boolean"))
    }
  }), n("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, s.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation")
    }
  }), n("InferredPredicate", {
    aliases: ["FlowPredicate"]
  }), n("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, s.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation")
    }
  }), h("InterfaceDeclaration"), n("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")),
      body: (0, s.validateType)("ObjectTypeAnnotation")
    }
  }), n("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, s.validate)((0, s.arrayOfType)("FlowType"))
    }
  }), n("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, s.validateType)("FlowType")
    }
  }), n("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, s.validate)((0, s.assertValueType)("number"))
    }
  }), n("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, s.validate)((0, s.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, s.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: []
      },
      callProperties: {
        validate: (0, s.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: []
      },
      internalSlots: {
        validate: (0, s.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: []
      },
      exact: {
        validate: (0, s.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, s.validateOptional)((0, s.assertValueType)("boolean"))
    }
  }), n("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      value: (0, s.validateType)("FlowType"),
      optional: (0, s.validate)((0, s.assertValueType)("boolean")),
      static: (0, s.validate)((0, s.assertValueType)("boolean")),
      method: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, s.validateType)("FlowType"),
      static: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, s.validateOptionalType)("Identifier"),
      key: (0, s.validateType)("FlowType"),
      value: (0, s.validateType)("FlowType"),
      static: (0, s.validate)((0, s.assertValueType)("boolean")),
      variance: (0, s.validateOptionalType)("Variance")
    }
  }), n("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, s.validateType)(["Identifier", "StringLiteral"]),
      value: (0, s.validateType)("FlowType"),
      kind: (0, s.validate)((0, s.assertOneOf)("init", "get", "set")),
      static: (0, s.validate)((0, s.assertValueType)("boolean")),
      proto: (0, s.validate)((0, s.assertValueType)("boolean")),
      optional: (0, s.validate)((0, s.assertValueType)("boolean")),
      variance: (0, s.validateOptionalType)("Variance"),
      method: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, s.validateType)("FlowType")
    }
  }), n("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, s.validateOptionalType)("FlowType"),
      impltype: (0, s.validateType)("FlowType")
    }
  }), n("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      qualification: (0, s.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  }), n("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, s.validate)((0, s.assertValueType)("string"))
    }
  }), n("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, s.validate)((0, s.arrayOfType)("FlowType"))
    }
  }), n("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, s.validateType)("FlowType")
    }
  }), n("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, s.validateType)("FlowType")
    }
  }), n("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, s.validateType)("FlowType")
    }
  }), n("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, s.validateType)("Expression"),
      typeAnnotation: (0, s.validateType)("TypeAnnotation")
    }
  }), n("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, s.validate)((0, s.assertValueType)("string")),
      bound: (0, s.validateOptionalType)("TypeAnnotation"),
      default: (0, s.validateOptionalType)("FlowType"),
      variance: (0, s.validateOptionalType)("Variance")
    }
  }), n("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, s.validate)((0, s.arrayOfType)("TypeParameter"))
    }
  }), n("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, s.validate)((0, s.arrayOfType)("FlowType"))
    }
  }), n("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, s.validate)((0, s.arrayOfType)("FlowType"))
    }
  }), n("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, s.validate)((0, s.assertOneOf)("minus", "plus"))
    }
  }), n("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), n("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      body: (0, s.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  }), n("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, s.validate)((0, s.assertValueType)("boolean")),
      members: (0, s.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, s.validate)((0, s.assertValueType)("boolean")),
      members: (0, s.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, s.validate)((0, s.assertValueType)("boolean")),
      members: (0, s.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, s.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), n("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      init: (0, s.validateType)("BooleanLiteral")
    }
  }), n("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      init: (0, s.validateType)("NumericLiteral")
    }
  }), n("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, s.validateType)("Identifier"),
      init: (0, s.validateType)("StringLiteral")
    }
  }), n("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, s.validateType)("Identifier")
    }
  }), n("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, s.validateType)("FlowType"),
      indexType: (0, s.validateType)("FlowType")
    }
  }), n("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, s.validateType)("FlowType"),
      indexType: (0, s.validateType)("FlowType"),
      optional: (0, s.validate)((0, s.assertValueType)("boolean"))
    }
  }), Zp;
}
var tf = {};
var rf;
function wb() {
  if (rf)
    return tf;
  rf = 1;
  var s = pn();
  const n = (0, s.defineAliasedType)("JSX");
  return n("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, s.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, s.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  }), n("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, s.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  }), n("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, s.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, s.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, s.assertValueType)("boolean"),
        optional: true
      }
    })
  }), n("JSXEmptyExpression", {}), n("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, s.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  }), n("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), n("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, s.assertValueType)("string")
      }
    }
  }), n("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, s.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, s.assertNodeType)("JSXIdentifier")
      }
    }
  }), n("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, s.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, s.assertNodeType)("JSXIdentifier")
      }
    }
  }), n("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, s.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  }), n("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), n("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("string")
      }
    }
  }), n("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, s.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, s.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  }), n("JSXOpeningFragment", {
    aliases: ["Immutable"]
  }), n("JSXClosingFragment", {
    aliases: ["Immutable"]
  }), tf;
}
var sf = {};
var Gi = {};
var nf;
function Iy() {
  if (nf)
    return Gi;
  nf = 1, Object.defineProperty(Gi, "__esModule", {
    value: true
  }), Gi.PLACEHOLDERS_FLIPPED_ALIAS = Gi.PLACEHOLDERS_ALIAS = Gi.PLACEHOLDERS = void 0;
  var s = pn();
  const n = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  Gi.PLACEHOLDERS = n;
  const h = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  Gi.PLACEHOLDERS_ALIAS = h;
  for (const p of n) {
    const g = s.ALIAS_KEYS[p];
    g != null && g.length && (h[p] = g);
  }
  const f2 = {};
  return Gi.PLACEHOLDERS_FLIPPED_ALIAS = f2, Object.keys(h).forEach((p) => {
    h[p].forEach((g) => {
      Object.hasOwnProperty.call(f2, g) || (f2[g] = []), f2[g].push(p);
    });
  }), Gi;
}
var af;
function Ib() {
  if (af)
    return sf;
  af = 1;
  var s = pn(), n = Iy();
  const h = (0, s.defineAliasedType)("Miscellaneous");
  return h("Noop", {
    visitor: []
  }), h("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, s.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, s.assertOneOf)(...n.PLACEHOLDERS)
      }
    }
  }), h("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, s.assertValueType)("string")
      }
    }
  }), sf;
}
var of = {};
var lf;
function Nb() {
  if (lf)
    return of;
  lf = 1;
  var s = pn();
  return (0, s.default)("ArgumentPlaceholder", {}), (0, s.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, s.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, s.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  }), (0, s.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, s.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, s.assertNodeType)("StringLiteral")
      }
    }
  }), (0, s.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), (0, s.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, s.assertValueType)("boolean"),
        default: false
      }
    }
  }), (0, s.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, s.assertNodeType)("Identifier")
      }
    }
  }), (0, s.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  }), (0, s.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), (0, s.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), (0, s.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, s.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  }), (0, s.default)("TopicReference", {
    aliases: ["Expression"]
  }), (0, s.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, s.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, s.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, s.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, s.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  }), of;
}
var uf = {};
var cf;
function kb() {
  if (cf)
    return uf;
  cf = 1;
  var s = pn(), n = wy(), h = Ma();
  const f2 = (0, s.defineAliasedType)("TypeScript"), p = (0, s.assertValueType)("boolean"), g = () => ({
    returnType: {
      validate: (0, s.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, s.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  f2("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, s.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, s.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, s.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, s.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: true
      }
    }
  }), f2("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, n.functionDeclarationCommon)(), g())
  }), f2("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, n.classMethodOrDeclareMethodCommon)(), g())
  }), f2("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, s.validateType)("TSEntityName"),
      right: (0, s.validateType)("Identifier")
    }
  });
  const P = () => ({
    typeParameters: (0, s.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, s.validateArrayOfType)(["Identifier", "RestElement"]),
    typeAnnotation: (0, s.validateOptionalType)("TSTypeAnnotation")
  }), x = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: P()
  };
  f2("TSCallSignatureDeclaration", x), f2("TSConstructSignatureDeclaration", x);
  const y = () => ({
    key: (0, s.validateType)("Expression"),
    computed: {
      default: false
    },
    optional: (0, s.validateOptional)(p)
  });
  f2("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, y(), {
      readonly: (0, s.validateOptional)(p),
      typeAnnotation: (0, s.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, s.validateOptionalType)("Expression"),
      kind: {
        validate: (0, s.assertOneOf)("get", "set")
      }
    })
  }), f2("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, P(), y(), {
      kind: {
        validate: (0, s.assertOneOf)("method", "get", "set")
      }
    })
  }), f2("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, s.validateOptional)(p),
      static: (0, s.validateOptional)(p),
      parameters: (0, s.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, s.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const A = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const T of A)
    f2(T, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  f2("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const S = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  f2("TSFunctionType", Object.assign({}, S, {
    fields: P()
  })), f2("TSConstructorType", Object.assign({}, S, {
    fields: Object.assign({}, P(), {
      abstract: (0, s.validateOptional)(p)
    })
  })), f2("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, s.validateType)("TSEntityName"),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), f2("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, s.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, s.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, s.validateOptional)(p)
    }
  }), f2("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, s.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), f2("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, s.validateArrayOfType)("TSTypeElement")
    }
  }), f2("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, s.validateType)("TSType")
    }
  }), f2("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, s.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  }), f2("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, s.validateType)("TSType")
    }
  }), f2("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, s.validateType)("TSType")
    }
  }), f2("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, s.validateType)("Identifier"),
      optional: {
        validate: p,
        default: false
      },
      elementType: (0, s.validateType)("TSType")
    }
  });
  const v = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, s.validateArrayOfType)("TSType")
    }
  };
  return f2("TSUnionType", v), f2("TSIntersectionType", v), f2("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, s.validateType)("TSType"),
      extendsType: (0, s.validateType)("TSType"),
      trueType: (0, s.validateType)("TSType"),
      falseType: (0, s.validateType)("TSType")
    }
  }), f2("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, s.validateType)("TSTypeParameter")
    }
  }), f2("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, s.validateType)("TSType")
    }
  }), f2("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, s.validate)((0, s.assertValueType)("string")),
      typeAnnotation: (0, s.validateType)("TSType")
    }
  }), f2("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, s.validateType)("TSType"),
      indexType: (0, s.validateType)("TSType")
    }
  }), f2("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, s.validateOptional)((0, s.assertOneOf)(true, false, "+", "-")),
      typeParameter: (0, s.validateType)("TSTypeParameter"),
      optional: (0, s.validateOptional)((0, s.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, s.validateOptionalType)("TSType"),
      nameType: (0, s.validateOptionalType)("TSType")
    }
  }), f2("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const T = (0, s.assertNodeType)("NumericLiteral", "BigIntLiteral"), C = (0, s.assertOneOf)("-"), I = (0, s.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function N(D, _, m) {
            (0, h.default)("UnaryExpression", m) ? (C(m, "operator", m.operator), T(m, "argument", m.argument)) : I(D, _, m);
          }
          return N.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], N;
        }()
      }
    }
  }), f2("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, s.validateType)("TSEntityName"),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), f2("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, s.validateOptional)(p),
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, s.validateOptional)((0, s.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, s.validateType)("TSInterfaceBody")
    }
  }), f2("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, s.validateArrayOfType)("TSTypeElement")
    }
  }), f2("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, s.validateOptional)(p),
      id: (0, s.validateType)("Identifier"),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, s.validateType)("TSType")
    }
  }), f2("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, s.validateType)("Expression"),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), f2("TSAsExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, s.validateType)("Expression"),
      typeAnnotation: (0, s.validateType)("TSType")
    }
  }), f2("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, s.validateType)("TSType"),
      expression: (0, s.validateType)("Expression")
    }
  }), f2("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, s.validateOptional)(p),
      const: (0, s.validateOptional)(p),
      id: (0, s.validateType)("Identifier"),
      members: (0, s.validateArrayOfType)("TSEnumMember"),
      initializer: (0, s.validateOptionalType)("Expression")
    }
  }), f2("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, s.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, s.validateOptionalType)("Expression")
    }
  }), f2("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, s.validateOptional)(p),
      global: (0, s.validateOptional)(p),
      id: (0, s.validateType)(["Identifier", "StringLiteral"]),
      body: (0, s.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  }), f2("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: {
      body: (0, s.validateArrayOfType)("Statement")
    }
  }), f2("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, s.validateType)("StringLiteral"),
      qualifier: (0, s.validateOptionalType)("TSEntityName"),
      typeParameters: (0, s.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), f2("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, s.validate)(p),
      id: (0, s.validateType)("Identifier"),
      moduleReference: (0, s.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, s.assertOneOf)("type", "value"),
        optional: true
      }
    }
  }), f2("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, s.validateType)("StringLiteral")
    }
  }), f2("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, s.validateType)("Expression")
    }
  }), f2("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, s.validateType)("Expression")
    }
  }), f2("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, s.validateType)("Identifier")
    }
  }), f2("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, s.assertNodeType)("TSType")
      }
    }
  }), f2("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TSType")))
      }
    }
  }), f2("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TSTypeParameter")))
      }
    }
  }), f2("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, s.assertValueType)("string")
      },
      in: {
        validate: (0, s.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, s.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, s.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, s.assertNodeType)("TSType"),
        optional: true
      }
    }
  }), uf;
}
var pf;
function Ui() {
  return pf || (pf = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return h.ALIAS_KEYS;
      }
    }), Object.defineProperty(s, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return h.BUILDER_KEYS;
      }
    }), Object.defineProperty(s, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return h.DEPRECATED_KEYS;
      }
    }), Object.defineProperty(s, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return h.FLIPPED_ALIAS_KEYS;
      }
    }), Object.defineProperty(s, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return h.NODE_FIELDS;
      }
    }), Object.defineProperty(s, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return h.NODE_PARENT_VALIDATIONS;
      }
    }), Object.defineProperty(s, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return f2.PLACEHOLDERS;
      }
    }), Object.defineProperty(s, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return f2.PLACEHOLDERS_ALIAS;
      }
    }), Object.defineProperty(s, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return f2.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    }), s.TYPES = void 0, Object.defineProperty(s, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return h.VISITOR_KEYS;
      }
    });
    var n = Eb();
    wy(), Cb(), wb(), Ib(), Nb(), kb();
    var h = pn(), f2 = Iy();
    n(h.VISITOR_KEYS), n(h.ALIAS_KEYS), n(h.FLIPPED_ALIAS_KEYS), n(h.NODE_FIELDS), n(h.BUILDER_KEYS), n(h.DEPRECATED_KEYS), n(f2.PLACEHOLDERS_ALIAS), n(f2.PLACEHOLDERS_FLIPPED_ALIAS);
    const p = [].concat(Object.keys(h.VISITOR_KEYS), Object.keys(h.FLIPPED_ALIAS_KEYS), Object.keys(h.DEPRECATED_KEYS));
    s.TYPES = p;
  }(_u)), _u;
}
var ff;
function Xc() {
  if (ff)
    return An;
  ff = 1, Object.defineProperty(An, "__esModule", {
    value: true
  }), An.default = n, An.validateChild = f2, An.validateField = h;
  var s = Ui();
  function n(p, g, P) {
    if (!p)
      return;
    const x = s.NODE_FIELDS[p.type];
    if (!x)
      return;
    const y = x[g];
    h(p, g, P, y), f2(p, g, P);
  }
  function h(p, g, P, x) {
    !(x != null && x.validate) || x.optional && P == null || x.validate(p, g, P);
  }
  function f2(p, g, P) {
    if (P == null)
      return;
    const x = s.NODE_PARENT_VALIDATIONS[P.type];
    !x || x(p, g, P);
  }
  return An;
}
var hf;
function Ob() {
  if (hf)
    return Xa;
  hf = 1, Object.defineProperty(Xa, "__esModule", {
    value: true
  }), Xa.default = h;
  var s = Xc(), n = Je();
  function h(f2) {
    const p = n.BUILDER_KEYS[f2.type];
    for (const g of p)
      (0, s.default)(f2, g, f2[g]);
    return f2;
  }
  return Xa;
}
var df;
function ys() {
  if (df)
    return Z;
  df = 1, Object.defineProperty(Z, "__esModule", {
    value: true
  }), Z.anyTypeAnnotation = Ye, Z.argumentPlaceholder = Yt, Z.arrayExpression = n, Z.arrayPattern = Le, Z.arrayTypeAnnotation = bt, Z.arrowFunctionExpression = Ee, Z.assignmentExpression = h, Z.assignmentPattern = Se, Z.awaitExpression = rt, Z.bigIntLiteral = gt, Z.binaryExpression = f2, Z.bindExpression = Xr, Z.blockStatement = x, Z.booleanLiteral = Q, Z.booleanLiteralTypeAnnotation = $t, Z.booleanTypeAnnotation = ct, Z.breakStatement = y, Z.callExpression = A, Z.catchClause = S, Z.classAccessorProperty = sr, Z.classBody = J, Z.classDeclaration = ke, Z.classExpression = me, Z.classImplements = xt, Z.classMethod = be, Z.classPrivateMethod = Nr, Z.classPrivateProperty = ar, Z.classProperty = Tt, Z.conditionalExpression = v, Z.continueStatement = T, Z.debuggerStatement = C, Z.decimalLiteral = Sr, Z.declareClass = or, Z.declareExportAllDeclaration = Wt, Z.declareExportDeclaration = _r, Z.declareFunction = qt, Z.declareInterface = Vt, Z.declareModule = it, Z.declareModuleExports = wt, Z.declareOpaqueType = pt, Z.declareTypeAlias = Br, Z.declareVariable = Kt, Z.declaredPredicate = lr, Z.decorator = Qs, Z.directive = g, Z.directiveLiteral = P, Z.doExpression = Qt, Z.doWhileStatement = I, Z.emptyStatement = N, Z.emptyTypeAnnotation = Ur, Z.enumBooleanBody = gr, Z.enumBooleanMember = $s, Z.enumDeclaration = Fs, Z.enumDefaultedMember = ft, Z.enumNumberBody = js, Z.enumNumberMember = Vr, Z.enumStringBody = Rs, Z.enumStringMember = Xt, Z.enumSymbolBody = Us, Z.existsTypeAnnotation = ur, Z.exportAllDeclaration = _e, Z.exportDefaultDeclaration = Re, Z.exportDefaultSpecifier = Zs, Z.exportNamedDeclaration = $e, Z.exportNamespaceSpecifier = ut, Z.exportSpecifier = Ge, Z.expressionStatement = D, Z.file = _, Z.forInStatement = m, Z.forOfStatement = lt, Z.forStatement = L, Z.functionDeclaration = R, Z.functionExpression = O, Z.functionTypeAnnotation = cr, Z.functionTypeParam = pr, Z.genericTypeAnnotation = Fr, Z.identifier = B, Z.ifStatement = M, Z.import = vt, Z.importAttribute = Nt, Z.importDeclaration = Ze, Z.importDefaultSpecifier = Xe, Z.importNamespaceSpecifier = et, Z.importSpecifier = st, Z.indexedAccessType = qs, Z.inferredPredicate = nt, Z.interfaceDeclaration = jr, Z.interfaceExtends = Ht, Z.interfaceTypeAnnotation = Es, Z.interpreterDirective = p, Z.intersectionTypeAnnotation = vs, Z.jSXAttribute = Z.jsxAttribute = xr, Z.jSXClosingElement = Z.jsxClosingElement = Vs, Z.jSXClosingFragment = Z.jsxClosingFragment = Ys, Z.jSXElement = Z.jsxElement = Ks, Z.jSXEmptyExpression = Z.jsxEmptyExpression = Ws, Z.jSXExpressionContainer = Z.jsxExpressionContainer = Hs, Z.jSXFragment = Z.jsxFragment = Xs, Z.jSXIdentifier = Z.jsxIdentifier = Kr, Z.jSXMemberExpression = Z.jsxMemberExpression = Pr, Z.jSXNamespacedName = Z.jsxNamespacedName = Wr, Z.jSXOpeningElement = Z.jsxOpeningElement = Jt, Z.jSXOpeningFragment = Z.jsxOpeningFragment = Js, Z.jSXSpreadAttribute = Z.jsxSpreadAttribute = Hr, Z.jSXSpreadChild = Z.jsxSpreadChild = zs, Z.jSXText = Z.jsxText = Gs, Z.labeledStatement = j, Z.logicalExpression = ee, Z.memberExpression = K, Z.metaProperty = re, Z.mixedTypeAnnotation = Rr, Z.moduleExpression = ei, Z.newExpression = G, Z.noop = zr, Z.nullLiteral = ne, Z.nullLiteralTypeAnnotation = Mr, Z.nullableTypeAnnotation = Pt, Z.numberLiteral = r, Z.numberLiteralTypeAnnotation = As, Z.numberTypeAnnotation = Cs, Z.numericLiteral = k, Z.objectExpression = F, Z.objectMethod = le, Z.objectPattern = ue, Z.objectProperty = oe, Z.objectTypeAnnotation = ws, Z.objectTypeCallProperty = zt, Z.objectTypeIndexer = fr, Z.objectTypeInternalSlot = Is, Z.objectTypeProperty = hr, Z.objectTypeSpreadProperty = dr, Z.opaqueType = Ns, Z.optionalCallExpression = De, Z.optionalIndexedAccessType = Tr, Z.optionalMemberExpression = qe, Z.parenthesizedExpression = Pe, Z.pipelineBareFunction = ri, Z.pipelinePrimaryTopicReference = si, Z.pipelineTopicExpression = ti, Z.placeholder = It, Z.privateName = At, Z.program = V, Z.qualifiedTypeIdentifier = ks, Z.recordExpression = Zt, Z.regExpLiteral = q, Z.regexLiteral = i, Z.restElement = fe, Z.restProperty = o, Z.returnStatement = he, Z.sequenceExpression = de, Z.spreadElement = Me, Z.spreadProperty = d, Z.staticBlock = Dt, Z.stringLiteral = $, Z.stringLiteralTypeAnnotation = Os, Z.stringTypeAnnotation = Ds, Z.super = Y, Z.switchCase = we, Z.switchStatement = H, Z.symbolTypeAnnotation = mr, Z.taggedTemplateExpression = Ne, Z.templateElement = Be, Z.templateLiteral = X, Z.thisExpression = te, Z.thisTypeAnnotation = Ls, Z.throwStatement = Ie, Z.topicReference = at, Z.tryStatement = Te, Z.tSAnyKeyword = Z.tsAnyKeyword = Et, Z.tSArrayType = Z.tsArrayType = Ft, Z.tSAsExpression = Z.tsAsExpression = Ni, Z.tSBigIntKeyword = Z.tsBigIntKeyword = kt, Z.tSBooleanKeyword = Z.tsBooleanKeyword = ht, Z.tSCallSignatureDeclaration = Z.tsCallSignatureDeclaration = ni, Z.tSConditionalType = Z.tsConditionalType = ns, Z.tSConstructSignatureDeclaration = Z.tsConstructSignatureDeclaration = ai, Z.tSConstructorType = Z.tsConstructorType = Zr, Z.tSDeclareFunction = Z.tsDeclareFunction = ii, Z.tSDeclareMethod = Z.tsDeclareMethod = Er, Z.tSEnumDeclaration = Z.tsEnumDeclaration = ki, Z.tSEnumMember = Z.tsEnumMember = Oi, Z.tSExportAssignment = Z.tsExportAssignment = jt, Z.tSExpressionWithTypeArguments = Z.tsExpressionWithTypeArguments = wi, Z.tSExternalModuleReference = Z.tsExternalModuleReference = Bi, Z.tSFunctionType = Z.tsFunctionType = gi, Z.tSImportEqualsDeclaration = Z.tsImportEqualsDeclaration = Mi, Z.tSImportType = Z.tsImportType = Li, Z.tSIndexSignature = Z.tsIndexSignature = ui, Z.tSIndexedAccessType = Z.tsIndexedAccessType = Ai, Z.tSInferType = Z.tsInferType = Ei, Z.tSInstantiationExpression = Z.tsInstantiationExpression = ls, Z.tSInterfaceBody = Z.tsInterfaceBody = Ar, Z.tSInterfaceDeclaration = Z.tsInterfaceDeclaration = Ii, Z.tSIntersectionType = Z.tsIntersectionType = Si, Z.tSIntrinsicKeyword = Z.tsIntrinsicKeyword = ci, Z.tSLiteralType = Z.tsLiteralType = vr, Z.tSMappedType = Z.tsMappedType = Ci, Z.tSMethodSignature = Z.tsMethodSignature = li, Z.tSModuleBlock = Z.tsModuleBlock = Di, Z.tSModuleDeclaration = Z.tsModuleDeclaration = us, Z.tSNamedTupleMember = Z.tsNamedTupleMember = Pi, Z.tSNamespaceExportDeclaration = Z.tsNamespaceExportDeclaration = cs, Z.tSNeverKeyword = Z.tsNeverKeyword = pi, Z.tSNonNullExpression = Z.tsNonNullExpression = _i, Z.tSNullKeyword = Z.tsNullKeyword = fi, Z.tSNumberKeyword = Z.tsNumberKeyword = hi, Z.tSObjectKeyword = Z.tsObjectKeyword = di, Z.tSOptionalType = Z.tsOptionalType = rs, Z.tSParameterProperty = Z.tsParameterProperty = Ce, Z.tSParenthesizedType = Z.tsParenthesizedType = vi, Z.tSPropertySignature = Z.tsPropertySignature = oi, Z.tSQualifiedName = Z.tsQualifiedName = Jr, Z.tSRestType = Z.tsRestType = ss, Z.tSStringKeyword = Z.tsStringKeyword = Yr, Z.tSSymbolKeyword = Z.tsSymbolKeyword = ve, Z.tSThisType = Z.tsThisType = bi, Z.tSTupleType = Z.tsTupleType = ts, Z.tSTypeAliasDeclaration = Z.tsTypeAliasDeclaration = os, Z.tSTypeAnnotation = Z.tsTypeAnnotation = Fi, Z.tSTypeAssertion = Z.tsTypeAssertion = Cr, Z.tSTypeLiteral = Z.tsTypeLiteral = ze, Z.tSTypeOperator = Z.tsTypeOperator = as, Z.tSTypeParameter = Z.tsTypeParameter = t, Z.tSTypeParameterDeclaration = Z.tsTypeParameterDeclaration = e, Z.tSTypeParameterInstantiation = Z.tsTypeParameterInstantiation = a, Z.tSTypePredicate = Z.tsTypePredicate = Ti, Z.tSTypeQuery = Z.tsTypeQuery = xi, Z.tSTypeReference = Z.tsTypeReference = es, Z.tSUndefinedKeyword = Z.tsUndefinedKeyword = mi, Z.tSUnionType = Z.tsUnionType = is, Z.tSUnknownKeyword = Z.tsUnknownKeyword = Qr, Z.tSVoidKeyword = Z.tsVoidKeyword = yi, Z.tupleExpression = er, Z.tupleTypeAnnotation = $r, Z.typeAlias = Bt, Z.typeAnnotation = _t, Z.typeCastExpression = Bs, Z.typeParameter = yr, Z.typeParameterDeclaration = Gt, Z.typeParameterInstantiation = St, Z.typeofTypeAnnotation = Ms, Z.unaryExpression = pe, Z.unionTypeAnnotation = br, Z.updateExpression = z, Z.v8IntrinsicIdentifier = Gr, Z.variableDeclaration = W, Z.variableDeclarator = ae, Z.variance = _s, Z.voidTypeAnnotation = qr, Z.whileStatement = ce, Z.withStatement = xe, Z.yieldExpression = je;
  var s = Ob();
  function n(u = []) {
    return (0, s.default)({
      type: "ArrayExpression",
      elements: u
    });
  }
  function h(u, E, w) {
    return (0, s.default)({
      type: "AssignmentExpression",
      operator: u,
      left: E,
      right: w
    });
  }
  function f2(u, E, w) {
    return (0, s.default)({
      type: "BinaryExpression",
      operator: u,
      left: E,
      right: w
    });
  }
  function p(u) {
    return (0, s.default)({
      type: "InterpreterDirective",
      value: u
    });
  }
  function g(u) {
    return (0, s.default)({
      type: "Directive",
      value: u
    });
  }
  function P(u) {
    return (0, s.default)({
      type: "DirectiveLiteral",
      value: u
    });
  }
  function x(u, E = []) {
    return (0, s.default)({
      type: "BlockStatement",
      body: u,
      directives: E
    });
  }
  function y(u = null) {
    return (0, s.default)({
      type: "BreakStatement",
      label: u
    });
  }
  function A(u, E) {
    return (0, s.default)({
      type: "CallExpression",
      callee: u,
      arguments: E
    });
  }
  function S(u = null, E) {
    return (0, s.default)({
      type: "CatchClause",
      param: u,
      body: E
    });
  }
  function v(u, E, w) {
    return (0, s.default)({
      type: "ConditionalExpression",
      test: u,
      consequent: E,
      alternate: w
    });
  }
  function T(u = null) {
    return (0, s.default)({
      type: "ContinueStatement",
      label: u
    });
  }
  function C() {
    return {
      type: "DebuggerStatement"
    };
  }
  function I(u, E) {
    return (0, s.default)({
      type: "DoWhileStatement",
      test: u,
      body: E
    });
  }
  function N() {
    return {
      type: "EmptyStatement"
    };
  }
  function D(u) {
    return (0, s.default)({
      type: "ExpressionStatement",
      expression: u
    });
  }
  function _(u, E = null, w = null) {
    return (0, s.default)({
      type: "File",
      program: u,
      comments: E,
      tokens: w
    });
  }
  function m(u, E, w) {
    return (0, s.default)({
      type: "ForInStatement",
      left: u,
      right: E,
      body: w
    });
  }
  function L(u = null, E = null, w = null, U) {
    return (0, s.default)({
      type: "ForStatement",
      init: u,
      test: E,
      update: w,
      body: U
    });
  }
  function R(u = null, E, w, U = false, ge = false) {
    return (0, s.default)({
      type: "FunctionDeclaration",
      id: u,
      params: E,
      body: w,
      generator: U,
      async: ge
    });
  }
  function O(u = null, E, w, U = false, ge = false) {
    return (0, s.default)({
      type: "FunctionExpression",
      id: u,
      params: E,
      body: w,
      generator: U,
      async: ge
    });
  }
  function B(u) {
    return (0, s.default)({
      type: "Identifier",
      name: u
    });
  }
  function M(u, E, w = null) {
    return (0, s.default)({
      type: "IfStatement",
      test: u,
      consequent: E,
      alternate: w
    });
  }
  function j(u, E) {
    return (0, s.default)({
      type: "LabeledStatement",
      label: u,
      body: E
    });
  }
  function $(u) {
    return (0, s.default)({
      type: "StringLiteral",
      value: u
    });
  }
  function k(u) {
    return (0, s.default)({
      type: "NumericLiteral",
      value: u
    });
  }
  function ne() {
    return {
      type: "NullLiteral"
    };
  }
  function Q(u) {
    return (0, s.default)({
      type: "BooleanLiteral",
      value: u
    });
  }
  function q(u, E = "") {
    return (0, s.default)({
      type: "RegExpLiteral",
      pattern: u,
      flags: E
    });
  }
  function ee(u, E, w) {
    return (0, s.default)({
      type: "LogicalExpression",
      operator: u,
      left: E,
      right: w
    });
  }
  function K(u, E, w = false, U = null) {
    return (0, s.default)({
      type: "MemberExpression",
      object: u,
      property: E,
      computed: w,
      optional: U
    });
  }
  function G(u, E) {
    return (0, s.default)({
      type: "NewExpression",
      callee: u,
      arguments: E
    });
  }
  function V(u, E = [], w = "script", U = null) {
    return (0, s.default)({
      type: "Program",
      body: u,
      directives: E,
      sourceType: w,
      interpreter: U,
      sourceFile: null
    });
  }
  function F(u) {
    return (0, s.default)({
      type: "ObjectExpression",
      properties: u
    });
  }
  function le(u = "method", E, w, U, ge = false, ye = false, Ae = false) {
    return (0, s.default)({
      type: "ObjectMethod",
      kind: u,
      key: E,
      params: w,
      body: U,
      computed: ge,
      generator: ye,
      async: Ae
    });
  }
  function oe(u, E, w = false, U = false, ge = null) {
    return (0, s.default)({
      type: "ObjectProperty",
      key: u,
      value: E,
      computed: w,
      shorthand: U,
      decorators: ge
    });
  }
  function fe(u) {
    return (0, s.default)({
      type: "RestElement",
      argument: u
    });
  }
  function he(u = null) {
    return (0, s.default)({
      type: "ReturnStatement",
      argument: u
    });
  }
  function de(u) {
    return (0, s.default)({
      type: "SequenceExpression",
      expressions: u
    });
  }
  function Pe(u) {
    return (0, s.default)({
      type: "ParenthesizedExpression",
      expression: u
    });
  }
  function we(u = null, E) {
    return (0, s.default)({
      type: "SwitchCase",
      test: u,
      consequent: E
    });
  }
  function H(u, E) {
    return (0, s.default)({
      type: "SwitchStatement",
      discriminant: u,
      cases: E
    });
  }
  function te() {
    return {
      type: "ThisExpression"
    };
  }
  function Ie(u) {
    return (0, s.default)({
      type: "ThrowStatement",
      argument: u
    });
  }
  function Te(u, E = null, w = null) {
    return (0, s.default)({
      type: "TryStatement",
      block: u,
      handler: E,
      finalizer: w
    });
  }
  function pe(u, E, w = true) {
    return (0, s.default)({
      type: "UnaryExpression",
      operator: u,
      argument: E,
      prefix: w
    });
  }
  function z(u, E, w = false) {
    return (0, s.default)({
      type: "UpdateExpression",
      operator: u,
      argument: E,
      prefix: w
    });
  }
  function W(u, E) {
    return (0, s.default)({
      type: "VariableDeclaration",
      kind: u,
      declarations: E
    });
  }
  function ae(u, E = null) {
    return (0, s.default)({
      type: "VariableDeclarator",
      id: u,
      init: E
    });
  }
  function ce(u, E) {
    return (0, s.default)({
      type: "WhileStatement",
      test: u,
      body: E
    });
  }
  function xe(u, E) {
    return (0, s.default)({
      type: "WithStatement",
      object: u,
      body: E
    });
  }
  function Se(u, E) {
    return (0, s.default)({
      type: "AssignmentPattern",
      left: u,
      right: E
    });
  }
  function Le(u) {
    return (0, s.default)({
      type: "ArrayPattern",
      elements: u
    });
  }
  function Ee(u, E, w = false) {
    return (0, s.default)({
      type: "ArrowFunctionExpression",
      params: u,
      body: E,
      async: w,
      expression: null
    });
  }
  function J(u) {
    return (0, s.default)({
      type: "ClassBody",
      body: u
    });
  }
  function me(u = null, E = null, w, U = null) {
    return (0, s.default)({
      type: "ClassExpression",
      id: u,
      superClass: E,
      body: w,
      decorators: U
    });
  }
  function ke(u, E = null, w, U = null) {
    return (0, s.default)({
      type: "ClassDeclaration",
      id: u,
      superClass: E,
      body: w,
      decorators: U
    });
  }
  function _e(u) {
    return (0, s.default)({
      type: "ExportAllDeclaration",
      source: u
    });
  }
  function Re(u) {
    return (0, s.default)({
      type: "ExportDefaultDeclaration",
      declaration: u
    });
  }
  function $e(u = null, E = [], w = null) {
    return (0, s.default)({
      type: "ExportNamedDeclaration",
      declaration: u,
      specifiers: E,
      source: w
    });
  }
  function Ge(u, E) {
    return (0, s.default)({
      type: "ExportSpecifier",
      local: u,
      exported: E
    });
  }
  function lt(u, E, w, U = false) {
    return (0, s.default)({
      type: "ForOfStatement",
      left: u,
      right: E,
      body: w,
      await: U
    });
  }
  function Ze(u, E) {
    return (0, s.default)({
      type: "ImportDeclaration",
      specifiers: u,
      source: E
    });
  }
  function Xe(u) {
    return (0, s.default)({
      type: "ImportDefaultSpecifier",
      local: u
    });
  }
  function et(u) {
    return (0, s.default)({
      type: "ImportNamespaceSpecifier",
      local: u
    });
  }
  function st(u, E) {
    return (0, s.default)({
      type: "ImportSpecifier",
      local: u,
      imported: E
    });
  }
  function re(u, E) {
    return (0, s.default)({
      type: "MetaProperty",
      meta: u,
      property: E
    });
  }
  function be(u = "method", E, w, U, ge = false, ye = false, Ae = false, Oe = false) {
    return (0, s.default)({
      type: "ClassMethod",
      kind: u,
      key: E,
      params: w,
      body: U,
      computed: ge,
      static: ye,
      generator: Ae,
      async: Oe
    });
  }
  function ue(u) {
    return (0, s.default)({
      type: "ObjectPattern",
      properties: u
    });
  }
  function Me(u) {
    return (0, s.default)({
      type: "SpreadElement",
      argument: u
    });
  }
  function Y() {
    return {
      type: "Super"
    };
  }
  function Ne(u, E) {
    return (0, s.default)({
      type: "TaggedTemplateExpression",
      tag: u,
      quasi: E
    });
  }
  function Be(u, E = false) {
    return (0, s.default)({
      type: "TemplateElement",
      value: u,
      tail: E
    });
  }
  function X(u, E) {
    return (0, s.default)({
      type: "TemplateLiteral",
      quasis: u,
      expressions: E
    });
  }
  function je(u = null, E = false) {
    return (0, s.default)({
      type: "YieldExpression",
      argument: u,
      delegate: E
    });
  }
  function rt(u) {
    return (0, s.default)({
      type: "AwaitExpression",
      argument: u
    });
  }
  function vt() {
    return {
      type: "Import"
    };
  }
  function gt(u) {
    return (0, s.default)({
      type: "BigIntLiteral",
      value: u
    });
  }
  function ut(u) {
    return (0, s.default)({
      type: "ExportNamespaceSpecifier",
      exported: u
    });
  }
  function qe(u, E, w = false, U) {
    return (0, s.default)({
      type: "OptionalMemberExpression",
      object: u,
      property: E,
      computed: w,
      optional: U
    });
  }
  function De(u, E, w) {
    return (0, s.default)({
      type: "OptionalCallExpression",
      callee: u,
      arguments: E,
      optional: w
    });
  }
  function Tt(u, E = null, w = null, U = null, ge = false, ye = false) {
    return (0, s.default)({
      type: "ClassProperty",
      key: u,
      value: E,
      typeAnnotation: w,
      decorators: U,
      computed: ge,
      static: ye
    });
  }
  function sr(u, E = null, w = null, U = null, ge = false, ye = false) {
    return (0, s.default)({
      type: "ClassAccessorProperty",
      key: u,
      value: E,
      typeAnnotation: w,
      decorators: U,
      computed: ge,
      static: ye
    });
  }
  function ar(u, E = null, w = null, U = false) {
    return (0, s.default)({
      type: "ClassPrivateProperty",
      key: u,
      value: E,
      decorators: w,
      static: U
    });
  }
  function Nr(u = "method", E, w, U, ge = false) {
    return (0, s.default)({
      type: "ClassPrivateMethod",
      kind: u,
      key: E,
      params: w,
      body: U,
      static: ge
    });
  }
  function At(u) {
    return (0, s.default)({
      type: "PrivateName",
      id: u
    });
  }
  function Dt(u) {
    return (0, s.default)({
      type: "StaticBlock",
      body: u
    });
  }
  function Ye() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function bt(u) {
    return (0, s.default)({
      type: "ArrayTypeAnnotation",
      elementType: u
    });
  }
  function ct() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function $t(u) {
    return (0, s.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: u
    });
  }
  function Mr() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function xt(u, E = null) {
    return (0, s.default)({
      type: "ClassImplements",
      id: u,
      typeParameters: E
    });
  }
  function or(u, E = null, w = null, U) {
    return (0, s.default)({
      type: "DeclareClass",
      id: u,
      typeParameters: E,
      extends: w,
      body: U
    });
  }
  function qt(u) {
    return (0, s.default)({
      type: "DeclareFunction",
      id: u
    });
  }
  function Vt(u, E = null, w = null, U) {
    return (0, s.default)({
      type: "DeclareInterface",
      id: u,
      typeParameters: E,
      extends: w,
      body: U
    });
  }
  function it(u, E, w = null) {
    return (0, s.default)({
      type: "DeclareModule",
      id: u,
      body: E,
      kind: w
    });
  }
  function wt(u) {
    return (0, s.default)({
      type: "DeclareModuleExports",
      typeAnnotation: u
    });
  }
  function Br(u, E = null, w) {
    return (0, s.default)({
      type: "DeclareTypeAlias",
      id: u,
      typeParameters: E,
      right: w
    });
  }
  function pt(u, E = null, w = null) {
    return (0, s.default)({
      type: "DeclareOpaqueType",
      id: u,
      typeParameters: E,
      supertype: w
    });
  }
  function Kt(u) {
    return (0, s.default)({
      type: "DeclareVariable",
      id: u
    });
  }
  function _r(u = null, E = null, w = null) {
    return (0, s.default)({
      type: "DeclareExportDeclaration",
      declaration: u,
      specifiers: E,
      source: w
    });
  }
  function Wt(u) {
    return (0, s.default)({
      type: "DeclareExportAllDeclaration",
      source: u
    });
  }
  function lr(u) {
    return (0, s.default)({
      type: "DeclaredPredicate",
      value: u
    });
  }
  function ur() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function cr(u = null, E, w = null, U) {
    return (0, s.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: u,
      params: E,
      rest: w,
      returnType: U
    });
  }
  function pr(u = null, E) {
    return (0, s.default)({
      type: "FunctionTypeParam",
      name: u,
      typeAnnotation: E
    });
  }
  function Fr(u, E = null) {
    return (0, s.default)({
      type: "GenericTypeAnnotation",
      id: u,
      typeParameters: E
    });
  }
  function nt() {
    return {
      type: "InferredPredicate"
    };
  }
  function Ht(u, E = null) {
    return (0, s.default)({
      type: "InterfaceExtends",
      id: u,
      typeParameters: E
    });
  }
  function jr(u, E = null, w = null, U) {
    return (0, s.default)({
      type: "InterfaceDeclaration",
      id: u,
      typeParameters: E,
      extends: w,
      body: U
    });
  }
  function Es(u = null, E) {
    return (0, s.default)({
      type: "InterfaceTypeAnnotation",
      extends: u,
      body: E
    });
  }
  function vs(u) {
    return (0, s.default)({
      type: "IntersectionTypeAnnotation",
      types: u
    });
  }
  function Rr() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function Ur() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function Pt(u) {
    return (0, s.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: u
    });
  }
  function As(u) {
    return (0, s.default)({
      type: "NumberLiteralTypeAnnotation",
      value: u
    });
  }
  function Cs() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function ws(u, E = [], w = [], U = [], ge = false) {
    return (0, s.default)({
      type: "ObjectTypeAnnotation",
      properties: u,
      indexers: E,
      callProperties: w,
      internalSlots: U,
      exact: ge
    });
  }
  function Is(u, E, w, U, ge) {
    return (0, s.default)({
      type: "ObjectTypeInternalSlot",
      id: u,
      value: E,
      optional: w,
      static: U,
      method: ge
    });
  }
  function zt(u) {
    return (0, s.default)({
      type: "ObjectTypeCallProperty",
      value: u,
      static: null
    });
  }
  function fr(u = null, E, w, U = null) {
    return (0, s.default)({
      type: "ObjectTypeIndexer",
      id: u,
      key: E,
      value: w,
      variance: U,
      static: null
    });
  }
  function hr(u, E, w = null) {
    return (0, s.default)({
      type: "ObjectTypeProperty",
      key: u,
      value: E,
      variance: w,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  function dr(u) {
    return (0, s.default)({
      type: "ObjectTypeSpreadProperty",
      argument: u
    });
  }
  function Ns(u, E = null, w = null, U) {
    return (0, s.default)({
      type: "OpaqueType",
      id: u,
      typeParameters: E,
      supertype: w,
      impltype: U
    });
  }
  function ks(u, E) {
    return (0, s.default)({
      type: "QualifiedTypeIdentifier",
      id: u,
      qualification: E
    });
  }
  function Os(u) {
    return (0, s.default)({
      type: "StringLiteralTypeAnnotation",
      value: u
    });
  }
  function Ds() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function mr() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function Ls() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function $r(u) {
    return (0, s.default)({
      type: "TupleTypeAnnotation",
      types: u
    });
  }
  function Ms(u) {
    return (0, s.default)({
      type: "TypeofTypeAnnotation",
      argument: u
    });
  }
  function Bt(u, E = null, w) {
    return (0, s.default)({
      type: "TypeAlias",
      id: u,
      typeParameters: E,
      right: w
    });
  }
  function _t(u) {
    return (0, s.default)({
      type: "TypeAnnotation",
      typeAnnotation: u
    });
  }
  function Bs(u, E) {
    return (0, s.default)({
      type: "TypeCastExpression",
      expression: u,
      typeAnnotation: E
    });
  }
  function yr(u = null, E = null, w = null) {
    return (0, s.default)({
      type: "TypeParameter",
      bound: u,
      default: E,
      variance: w,
      name: null
    });
  }
  function Gt(u) {
    return (0, s.default)({
      type: "TypeParameterDeclaration",
      params: u
    });
  }
  function St(u) {
    return (0, s.default)({
      type: "TypeParameterInstantiation",
      params: u
    });
  }
  function br(u) {
    return (0, s.default)({
      type: "UnionTypeAnnotation",
      types: u
    });
  }
  function _s(u) {
    return (0, s.default)({
      type: "Variance",
      kind: u
    });
  }
  function qr() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function Fs(u, E) {
    return (0, s.default)({
      type: "EnumDeclaration",
      id: u,
      body: E
    });
  }
  function gr(u) {
    return (0, s.default)({
      type: "EnumBooleanBody",
      members: u,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function js(u) {
    return (0, s.default)({
      type: "EnumNumberBody",
      members: u,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function Rs(u) {
    return (0, s.default)({
      type: "EnumStringBody",
      members: u,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function Us(u) {
    return (0, s.default)({
      type: "EnumSymbolBody",
      members: u,
      hasUnknownMembers: null
    });
  }
  function $s(u) {
    return (0, s.default)({
      type: "EnumBooleanMember",
      id: u,
      init: null
    });
  }
  function Vr(u, E) {
    return (0, s.default)({
      type: "EnumNumberMember",
      id: u,
      init: E
    });
  }
  function Xt(u, E) {
    return (0, s.default)({
      type: "EnumStringMember",
      id: u,
      init: E
    });
  }
  function ft(u) {
    return (0, s.default)({
      type: "EnumDefaultedMember",
      id: u
    });
  }
  function qs(u, E) {
    return (0, s.default)({
      type: "IndexedAccessType",
      objectType: u,
      indexType: E
    });
  }
  function Tr(u, E) {
    return (0, s.default)({
      type: "OptionalIndexedAccessType",
      objectType: u,
      indexType: E,
      optional: null
    });
  }
  function xr(u, E = null) {
    return (0, s.default)({
      type: "JSXAttribute",
      name: u,
      value: E
    });
  }
  function Vs(u) {
    return (0, s.default)({
      type: "JSXClosingElement",
      name: u
    });
  }
  function Ks(u, E = null, w, U = null) {
    return (0, s.default)({
      type: "JSXElement",
      openingElement: u,
      closingElement: E,
      children: w,
      selfClosing: U
    });
  }
  function Ws() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function Hs(u) {
    return (0, s.default)({
      type: "JSXExpressionContainer",
      expression: u
    });
  }
  function zs(u) {
    return (0, s.default)({
      type: "JSXSpreadChild",
      expression: u
    });
  }
  function Kr(u) {
    return (0, s.default)({
      type: "JSXIdentifier",
      name: u
    });
  }
  function Pr(u, E) {
    return (0, s.default)({
      type: "JSXMemberExpression",
      object: u,
      property: E
    });
  }
  function Wr(u, E) {
    return (0, s.default)({
      type: "JSXNamespacedName",
      namespace: u,
      name: E
    });
  }
  function Jt(u, E, w = false) {
    return (0, s.default)({
      type: "JSXOpeningElement",
      name: u,
      attributes: E,
      selfClosing: w
    });
  }
  function Hr(u) {
    return (0, s.default)({
      type: "JSXSpreadAttribute",
      argument: u
    });
  }
  function Gs(u) {
    return (0, s.default)({
      type: "JSXText",
      value: u
    });
  }
  function Xs(u, E, w) {
    return (0, s.default)({
      type: "JSXFragment",
      openingFragment: u,
      closingFragment: E,
      children: w
    });
  }
  function Js() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function Ys() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function zr() {
    return {
      type: "Noop"
    };
  }
  function It(u, E) {
    return (0, s.default)({
      type: "Placeholder",
      expectedNode: u,
      name: E
    });
  }
  function Gr(u) {
    return (0, s.default)({
      type: "V8IntrinsicIdentifier",
      name: u
    });
  }
  function Yt() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function Xr(u, E) {
    return (0, s.default)({
      type: "BindExpression",
      object: u,
      callee: E
    });
  }
  function Nt(u, E) {
    return (0, s.default)({
      type: "ImportAttribute",
      key: u,
      value: E
    });
  }
  function Qs(u) {
    return (0, s.default)({
      type: "Decorator",
      expression: u
    });
  }
  function Qt(u, E = false) {
    return (0, s.default)({
      type: "DoExpression",
      body: u,
      async: E
    });
  }
  function Zs(u) {
    return (0, s.default)({
      type: "ExportDefaultSpecifier",
      exported: u
    });
  }
  function Zt(u) {
    return (0, s.default)({
      type: "RecordExpression",
      properties: u
    });
  }
  function er(u = []) {
    return (0, s.default)({
      type: "TupleExpression",
      elements: u
    });
  }
  function Sr(u) {
    return (0, s.default)({
      type: "DecimalLiteral",
      value: u
    });
  }
  function ei(u) {
    return (0, s.default)({
      type: "ModuleExpression",
      body: u
    });
  }
  function at() {
    return {
      type: "TopicReference"
    };
  }
  function ti(u) {
    return (0, s.default)({
      type: "PipelineTopicExpression",
      expression: u
    });
  }
  function ri(u) {
    return (0, s.default)({
      type: "PipelineBareFunction",
      callee: u
    });
  }
  function si() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function Ce(u) {
    return (0, s.default)({
      type: "TSParameterProperty",
      parameter: u
    });
  }
  function ii(u = null, E = null, w, U = null) {
    return (0, s.default)({
      type: "TSDeclareFunction",
      id: u,
      typeParameters: E,
      params: w,
      returnType: U
    });
  }
  function Er(u = null, E, w = null, U, ge = null) {
    return (0, s.default)({
      type: "TSDeclareMethod",
      decorators: u,
      key: E,
      typeParameters: w,
      params: U,
      returnType: ge
    });
  }
  function Jr(u, E) {
    return (0, s.default)({
      type: "TSQualifiedName",
      left: u,
      right: E
    });
  }
  function ni(u = null, E, w = null) {
    return (0, s.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: u,
      parameters: E,
      typeAnnotation: w
    });
  }
  function ai(u = null, E, w = null) {
    return (0, s.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: u,
      parameters: E,
      typeAnnotation: w
    });
  }
  function oi(u, E = null, w = null) {
    return (0, s.default)({
      type: "TSPropertySignature",
      key: u,
      typeAnnotation: E,
      initializer: w,
      kind: null
    });
  }
  function li(u, E = null, w, U = null) {
    return (0, s.default)({
      type: "TSMethodSignature",
      key: u,
      typeParameters: E,
      parameters: w,
      typeAnnotation: U,
      kind: null
    });
  }
  function ui(u, E = null) {
    return (0, s.default)({
      type: "TSIndexSignature",
      parameters: u,
      typeAnnotation: E
    });
  }
  function Et() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function ht() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function kt() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function ci() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function pi() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function fi() {
    return {
      type: "TSNullKeyword"
    };
  }
  function hi() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function di() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function Yr() {
    return {
      type: "TSStringKeyword"
    };
  }
  function ve() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function mi() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function Qr() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function yi() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function bi() {
    return {
      type: "TSThisType"
    };
  }
  function gi(u = null, E, w = null) {
    return (0, s.default)({
      type: "TSFunctionType",
      typeParameters: u,
      parameters: E,
      typeAnnotation: w
    });
  }
  function Zr(u = null, E, w = null) {
    return (0, s.default)({
      type: "TSConstructorType",
      typeParameters: u,
      parameters: E,
      typeAnnotation: w
    });
  }
  function es(u, E = null) {
    return (0, s.default)({
      type: "TSTypeReference",
      typeName: u,
      typeParameters: E
    });
  }
  function Ti(u, E = null, w = null) {
    return (0, s.default)({
      type: "TSTypePredicate",
      parameterName: u,
      typeAnnotation: E,
      asserts: w
    });
  }
  function xi(u, E = null) {
    return (0, s.default)({
      type: "TSTypeQuery",
      exprName: u,
      typeParameters: E
    });
  }
  function ze(u) {
    return (0, s.default)({
      type: "TSTypeLiteral",
      members: u
    });
  }
  function Ft(u) {
    return (0, s.default)({
      type: "TSArrayType",
      elementType: u
    });
  }
  function ts(u) {
    return (0, s.default)({
      type: "TSTupleType",
      elementTypes: u
    });
  }
  function rs(u) {
    return (0, s.default)({
      type: "TSOptionalType",
      typeAnnotation: u
    });
  }
  function ss(u) {
    return (0, s.default)({
      type: "TSRestType",
      typeAnnotation: u
    });
  }
  function Pi(u, E, w = false) {
    return (0, s.default)({
      type: "TSNamedTupleMember",
      label: u,
      elementType: E,
      optional: w
    });
  }
  function is(u) {
    return (0, s.default)({
      type: "TSUnionType",
      types: u
    });
  }
  function Si(u) {
    return (0, s.default)({
      type: "TSIntersectionType",
      types: u
    });
  }
  function ns(u, E, w, U) {
    return (0, s.default)({
      type: "TSConditionalType",
      checkType: u,
      extendsType: E,
      trueType: w,
      falseType: U
    });
  }
  function Ei(u) {
    return (0, s.default)({
      type: "TSInferType",
      typeParameter: u
    });
  }
  function vi(u) {
    return (0, s.default)({
      type: "TSParenthesizedType",
      typeAnnotation: u
    });
  }
  function as(u) {
    return (0, s.default)({
      type: "TSTypeOperator",
      typeAnnotation: u,
      operator: null
    });
  }
  function Ai(u, E) {
    return (0, s.default)({
      type: "TSIndexedAccessType",
      objectType: u,
      indexType: E
    });
  }
  function Ci(u, E = null, w = null) {
    return (0, s.default)({
      type: "TSMappedType",
      typeParameter: u,
      typeAnnotation: E,
      nameType: w
    });
  }
  function vr(u) {
    return (0, s.default)({
      type: "TSLiteralType",
      literal: u
    });
  }
  function wi(u, E = null) {
    return (0, s.default)({
      type: "TSExpressionWithTypeArguments",
      expression: u,
      typeParameters: E
    });
  }
  function Ii(u, E = null, w = null, U) {
    return (0, s.default)({
      type: "TSInterfaceDeclaration",
      id: u,
      typeParameters: E,
      extends: w,
      body: U
    });
  }
  function Ar(u) {
    return (0, s.default)({
      type: "TSInterfaceBody",
      body: u
    });
  }
  function os(u, E = null, w) {
    return (0, s.default)({
      type: "TSTypeAliasDeclaration",
      id: u,
      typeParameters: E,
      typeAnnotation: w
    });
  }
  function ls(u, E = null) {
    return (0, s.default)({
      type: "TSInstantiationExpression",
      expression: u,
      typeParameters: E
    });
  }
  function Ni(u, E) {
    return (0, s.default)({
      type: "TSAsExpression",
      expression: u,
      typeAnnotation: E
    });
  }
  function Cr(u, E) {
    return (0, s.default)({
      type: "TSTypeAssertion",
      typeAnnotation: u,
      expression: E
    });
  }
  function ki(u, E) {
    return (0, s.default)({
      type: "TSEnumDeclaration",
      id: u,
      members: E
    });
  }
  function Oi(u, E = null) {
    return (0, s.default)({
      type: "TSEnumMember",
      id: u,
      initializer: E
    });
  }
  function us(u, E) {
    return (0, s.default)({
      type: "TSModuleDeclaration",
      id: u,
      body: E
    });
  }
  function Di(u) {
    return (0, s.default)({
      type: "TSModuleBlock",
      body: u
    });
  }
  function Li(u, E = null, w = null) {
    return (0, s.default)({
      type: "TSImportType",
      argument: u,
      qualifier: E,
      typeParameters: w
    });
  }
  function Mi(u, E) {
    return (0, s.default)({
      type: "TSImportEqualsDeclaration",
      id: u,
      moduleReference: E,
      isExport: null
    });
  }
  function Bi(u) {
    return (0, s.default)({
      type: "TSExternalModuleReference",
      expression: u
    });
  }
  function _i(u) {
    return (0, s.default)({
      type: "TSNonNullExpression",
      expression: u
    });
  }
  function jt(u) {
    return (0, s.default)({
      type: "TSExportAssignment",
      expression: u
    });
  }
  function cs(u) {
    return (0, s.default)({
      type: "TSNamespaceExportDeclaration",
      id: u
    });
  }
  function Fi(u) {
    return (0, s.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: u
    });
  }
  function a(u) {
    return (0, s.default)({
      type: "TSTypeParameterInstantiation",
      params: u
    });
  }
  function e(u) {
    return (0, s.default)({
      type: "TSTypeParameterDeclaration",
      params: u
    });
  }
  function t(u = null, E = null, w) {
    return (0, s.default)({
      type: "TSTypeParameter",
      constraint: u,
      default: E,
      name: w
    });
  }
  function r(u) {
    return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), k(u);
  }
  function i(u, E = "") {
    return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), q(u, E);
  }
  function o(u) {
    return console.trace("The node type RestProperty has been renamed to RestElement"), fe(u);
  }
  function d(u) {
    return console.trace("The node type SpreadProperty has been renamed to SpreadElement"), Me(u);
  }
  return Z;
}
var mf;
function Db() {
  if (mf)
    return Ga;
  mf = 1, Object.defineProperty(Ga, "__esModule", {
    value: true
  }), Ga.default = n;
  var s = ys();
  function n(h, f2) {
    const p = h.value.split(/\r\n|\n|\r/);
    let g = 0;
    for (let x = 0; x < p.length; x++)
      p[x].match(/[^ \t]/) && (g = x);
    let P = "";
    for (let x = 0; x < p.length; x++) {
      const y = p[x], A = x === 0, S = x === p.length - 1, v = x === g;
      let T = y.replace(/\t/g, " ");
      A || (T = T.replace(/^[ ]+/, "")), S || (T = T.replace(/[ ]+$/, "")), T && (v || (T += " "), P += T);
    }
    P && f2.push((0, s.stringLiteral)(P));
  }
  return Ga;
}
var yf;
function Lb() {
  if (yf)
    return za;
  yf = 1, Object.defineProperty(za, "__esModule", {
    value: true
  }), za.default = h;
  var s = rr(), n = Db();
  function h(f2) {
    const p = [];
    for (let g = 0; g < f2.children.length; g++) {
      let P = f2.children[g];
      if ((0, s.isJSXText)(P)) {
        (0, n.default)(P, p);
        continue;
      }
      (0, s.isJSXExpressionContainer)(P) && (P = P.expression), !(0, s.isJSXEmptyExpression)(P) && p.push(P);
    }
    return p;
  }
  return za;
}
var eo = {};
var to = {};
var bf;
function Ny() {
  if (bf)
    return to;
  bf = 1, Object.defineProperty(to, "__esModule", {
    value: true
  }), to.default = n;
  var s = Ui();
  function n(h) {
    return !!(h && s.VISITOR_KEYS[h.type]);
  }
  return to;
}
var gf;
function Mb() {
  if (gf)
    return eo;
  gf = 1, Object.defineProperty(eo, "__esModule", {
    value: true
  }), eo.default = n;
  var s = Ny();
  function n(h) {
    if (!(0, s.default)(h)) {
      var f2;
      const p = (f2 = h == null ? void 0 : h.type) != null ? f2 : JSON.stringify(h);
      throw new TypeError(`Not a valid node of type "${p}"`);
    }
  }
  return eo;
}
var ie = {};
var Tf;
function Bb() {
  if (Tf)
    return ie;
  Tf = 1, Object.defineProperty(ie, "__esModule", {
    value: true
  }), ie.assertAccessor = mu, ie.assertAnyTypeAnnotation = bt, ie.assertArgumentPlaceholder = Xr, ie.assertArrayExpression = h, ie.assertArrayPattern = Ee, ie.assertArrayTypeAnnotation = ct, ie.assertArrowFunctionExpression = J, ie.assertAssignmentExpression = f2, ie.assertAssignmentPattern = Le, ie.assertAwaitExpression = vt, ie.assertBigIntLiteral = ut, ie.assertBinary = d, ie.assertBinaryExpression = p, ie.assertBindExpression = Nt, ie.assertBlock = w, ie.assertBlockParent = E, ie.assertBlockStatement = y, ie.assertBooleanLiteral = q, ie.assertBooleanLiteralTypeAnnotation = Mr, ie.assertBooleanTypeAnnotation = $t, ie.assertBreakStatement = A, ie.assertCallExpression = S, ie.assertCatchClause = v, ie.assertClass = pu, ie.assertClassAccessorProperty = ar, ie.assertClassBody = me, ie.assertClassDeclaration = _e, ie.assertClassExpression = ke, ie.assertClassImplements = or, ie.assertClassMethod = ue, ie.assertClassPrivateMethod = At, ie.assertClassPrivateProperty = Nr, ie.assertClassProperty = sr, ie.assertCompletionStatement = ye, ie.assertConditional = Ae, ie.assertConditionalExpression = T, ie.assertContinueStatement = C, ie.assertDebuggerStatement = I, ie.assertDecimalLiteral = ei, ie.assertDeclaration = Zl, ie.assertDeclareClass = qt, ie.assertDeclareExportAllDeclaration = lr, ie.assertDeclareExportDeclaration = Wt, ie.assertDeclareFunction = Vt, ie.assertDeclareInterface = it, ie.assertDeclareModule = wt, ie.assertDeclareModuleExports = Br, ie.assertDeclareOpaqueType = Kt, ie.assertDeclareTypeAlias = pt, ie.assertDeclareVariable = _r, ie.assertDeclaredPredicate = ur, ie.assertDecorator = Qt, ie.assertDirective = P, ie.assertDirectiveLiteral = x, ie.assertDoExpression = Zs, ie.assertDoWhileStatement = N, ie.assertEmptyStatement = D, ie.assertEmptyTypeAnnotation = Pt, ie.assertEnumBody = Su, ie.assertEnumBooleanBody = js, ie.assertEnumBooleanMember = Vr, ie.assertEnumDeclaration = gr, ie.assertEnumDefaultedMember = qs, ie.assertEnumMember = Eu, ie.assertEnumNumberBody = Rs, ie.assertEnumNumberMember = Xt, ie.assertEnumStringBody = Us, ie.assertEnumStringMember = ft, ie.assertEnumSymbolBody = $s, ie.assertExistsTypeAnnotation = cr, ie.assertExportAllDeclaration = Re, ie.assertExportDeclaration = hu, ie.assertExportDefaultDeclaration = $e, ie.assertExportDefaultSpecifier = Zt, ie.assertExportNamedDeclaration = Ge, ie.assertExportNamespaceSpecifier = qe, ie.assertExportSpecifier = lt, ie.assertExpression = o, ie.assertExpressionStatement = _, ie.assertExpressionWrapper = Ke, ie.assertFile = m, ie.assertFlow = bu, ie.assertFlowBaseAnnotation = Tu, ie.assertFlowDeclaration = xu, ie.assertFlowPredicate = Pu, ie.assertFlowType = gu, ie.assertFor = He, ie.assertForInStatement = L, ie.assertForOfStatement = Ze, ie.assertForStatement = R, ie.assertForXStatement = bs, ie.assertFunction = zi, ie.assertFunctionDeclaration = O, ie.assertFunctionExpression = B, ie.assertFunctionParent = Yl, ie.assertFunctionTypeAnnotation = pr, ie.assertFunctionTypeParam = Fr, ie.assertGenericTypeAnnotation = nt, ie.assertIdentifier = M, ie.assertIfStatement = j, ie.assertImmutable = iu, ie.assertImport = gt, ie.assertImportAttribute = Qs, ie.assertImportDeclaration = Xe, ie.assertImportDefaultSpecifier = et, ie.assertImportNamespaceSpecifier = st, ie.assertImportSpecifier = re, ie.assertIndexedAccessType = Tr, ie.assertInferredPredicate = Ht, ie.assertInterfaceDeclaration = Es, ie.assertInterfaceExtends = jr, ie.assertInterfaceTypeAnnotation = vs, ie.assertInterpreterDirective = g, ie.assertIntersectionTypeAnnotation = Rr, ie.assertJSX = vu, ie.assertJSXAttribute = Vs, ie.assertJSXClosingElement = Ks, ie.assertJSXClosingFragment = zr, ie.assertJSXElement = Ws, ie.assertJSXEmptyExpression = Hs, ie.assertJSXExpressionContainer = zs, ie.assertJSXFragment = Js, ie.assertJSXIdentifier = Pr, ie.assertJSXMemberExpression = Wr, ie.assertJSXNamespacedName = Jt, ie.assertJSXOpeningElement = Hr, ie.assertJSXOpeningFragment = Ys, ie.assertJSXSpreadAttribute = Gs, ie.assertJSXSpreadChild = Kr, ie.assertJSXText = Xs, ie.assertLVal = tu, ie.assertLabeledStatement = $, ie.assertLiteral = su, ie.assertLogicalExpression = K, ie.assertLoop = Oe, ie.assertMemberExpression = G, ie.assertMetaProperty = be, ie.assertMethod = au, ie.assertMiscellaneous = Au, ie.assertMixedTypeAnnotation = Ur, ie.assertModuleDeclaration = fu, ie.assertModuleExpression = at, ie.assertModuleSpecifier = du, ie.assertNewExpression = V, ie.assertNoop = It, ie.assertNullLiteral = Q, ie.assertNullLiteralTypeAnnotation = xt, ie.assertNullableTypeAnnotation = As, ie.assertNumberLiteral = ku, ie.assertNumberLiteralTypeAnnotation = Cs, ie.assertNumberTypeAnnotation = ws, ie.assertNumericLiteral = ne, ie.assertObjectExpression = le, ie.assertObjectMember = ou, ie.assertObjectMethod = oe, ie.assertObjectPattern = Me, ie.assertObjectProperty = fe, ie.assertObjectTypeAnnotation = Is, ie.assertObjectTypeCallProperty = fr, ie.assertObjectTypeIndexer = hr, ie.assertObjectTypeInternalSlot = zt, ie.assertObjectTypeProperty = dr, ie.assertObjectTypeSpreadProperty = Ns, ie.assertOpaqueType = ks, ie.assertOptionalCallExpression = Tt, ie.assertOptionalIndexedAccessType = xr, ie.assertOptionalMemberExpression = De, ie.assertParenthesizedExpression = we, ie.assertPattern = cu, ie.assertPatternLike = eu, ie.assertPipelineBareFunction = si, ie.assertPipelinePrimaryTopicReference = Ce, ie.assertPipelineTopicExpression = ri, ie.assertPlaceholder = Gr, ie.assertPrivate = yu, ie.assertPrivateName = Dt, ie.assertProgram = F, ie.assertProperty = lu, ie.assertPureish = Ql, ie.assertQualifiedTypeIdentifier = Os, ie.assertRecordExpression = er, ie.assertRegExpLiteral = ee, ie.assertRegexLiteral = Ou, ie.assertRestElement = he, ie.assertRestProperty = Du, ie.assertReturnStatement = de, ie.assertScopable = u, ie.assertSequenceExpression = Pe, ie.assertSpreadElement = Y, ie.assertSpreadProperty = b, ie.assertStandardized = i, ie.assertStatement = U, ie.assertStaticBlock = Ye, ie.assertStringLiteral = k, ie.assertStringLiteralTypeAnnotation = Ds, ie.assertStringTypeAnnotation = mr, ie.assertSuper = Ne, ie.assertSwitchCase = H, ie.assertSwitchStatement = te, ie.assertSymbolTypeAnnotation = Ls, ie.assertTSAnyKeyword = ht, ie.assertTSArrayType = ts, ie.assertTSAsExpression = Cr, ie.assertTSBaseType = Nu, ie.assertTSBigIntKeyword = ci, ie.assertTSBooleanKeyword = kt, ie.assertTSCallSignatureDeclaration = ai, ie.assertTSConditionalType = Ei, ie.assertTSConstructSignatureDeclaration = oi, ie.assertTSConstructorType = es, ie.assertTSDeclareFunction = Er, ie.assertTSDeclareMethod = Jr, ie.assertTSEntityName = ru, ie.assertTSEnumDeclaration = Oi, ie.assertTSEnumMember = us, ie.assertTSExportAssignment = cs, ie.assertTSExpressionWithTypeArguments = Ii, ie.assertTSExternalModuleReference = _i, ie.assertTSFunctionType = Zr, ie.assertTSImportEqualsDeclaration = Bi, ie.assertTSImportType = Mi, ie.assertTSIndexSignature = Et, ie.assertTSIndexedAccessType = Ci, ie.assertTSInferType = vi, ie.assertTSInstantiationExpression = Ni, ie.assertTSInterfaceBody = os, ie.assertTSInterfaceDeclaration = Ar, ie.assertTSIntersectionType = ns, ie.assertTSIntrinsicKeyword = pi, ie.assertTSLiteralType = wi, ie.assertTSMappedType = vr, ie.assertTSMethodSignature = ui, ie.assertTSModuleBlock = Li, ie.assertTSModuleDeclaration = Di, ie.assertTSNamedTupleMember = is, ie.assertTSNamespaceExportDeclaration = Fi, ie.assertTSNeverKeyword = fi, ie.assertTSNonNullExpression = jt, ie.assertTSNullKeyword = hi, ie.assertTSNumberKeyword = di, ie.assertTSObjectKeyword = Yr, ie.assertTSOptionalType = ss, ie.assertTSParameterProperty = ii, ie.assertTSParenthesizedType = as, ie.assertTSPropertySignature = li, ie.assertTSQualifiedName = ni, ie.assertTSRestType = Pi, ie.assertTSStringKeyword = ve, ie.assertTSSymbolKeyword = mi, ie.assertTSThisType = gi, ie.assertTSTupleType = rs, ie.assertTSType = Iu, ie.assertTSTypeAliasDeclaration = ls, ie.assertTSTypeAnnotation = a, ie.assertTSTypeAssertion = ki, ie.assertTSTypeElement = wu, ie.assertTSTypeLiteral = Ft, ie.assertTSTypeOperator = Ai, ie.assertTSTypeParameter = r, ie.assertTSTypeParameterDeclaration = t, ie.assertTSTypeParameterInstantiation = e, ie.assertTSTypePredicate = xi, ie.assertTSTypeQuery = ze, ie.assertTSTypeReference = Ti, ie.assertTSUndefinedKeyword = Qr, ie.assertTSUnionType = Si, ie.assertTSUnknownKeyword = yi, ie.assertTSVoidKeyword = bi, ie.assertTaggedTemplateExpression = Be, ie.assertTemplateElement = X, ie.assertTemplateLiteral = je, ie.assertTerminatorless = ge, ie.assertThisExpression = Ie, ie.assertThisTypeAnnotation = $r, ie.assertThrowStatement = Te, ie.assertTopicReference = ti, ie.assertTryStatement = pe, ie.assertTupleExpression = Sr, ie.assertTupleTypeAnnotation = Ms, ie.assertTypeAlias = _t, ie.assertTypeAnnotation = Bs, ie.assertTypeCastExpression = yr, ie.assertTypeParameter = Gt, ie.assertTypeParameterDeclaration = St, ie.assertTypeParameterInstantiation = br, ie.assertTypeScript = Cu, ie.assertTypeofTypeAnnotation = Bt, ie.assertUnaryExpression = z, ie.assertUnaryLike = uu, ie.assertUnionTypeAnnotation = _s, ie.assertUpdateExpression = W, ie.assertUserWhitespacable = nu, ie.assertV8IntrinsicIdentifier = Yt, ie.assertVariableDeclaration = ae, ie.assertVariableDeclarator = ce, ie.assertVariance = qr, ie.assertVoidTypeAnnotation = Fs, ie.assertWhile = Ve, ie.assertWhileStatement = xe, ie.assertWithStatement = Se, ie.assertYieldExpression = rt;
  var s = Ma();
  function n(c, l2, Lp) {
    if (!(0, s.default)(c, l2, Lp))
      throw new Error(`Expected type "${c}" with option ${JSON.stringify(Lp)}, but instead got "${l2.type}".`);
  }
  function h(c, l2) {
    n("ArrayExpression", c, l2);
  }
  function f2(c, l2) {
    n("AssignmentExpression", c, l2);
  }
  function p(c, l2) {
    n("BinaryExpression", c, l2);
  }
  function g(c, l2) {
    n("InterpreterDirective", c, l2);
  }
  function P(c, l2) {
    n("Directive", c, l2);
  }
  function x(c, l2) {
    n("DirectiveLiteral", c, l2);
  }
  function y(c, l2) {
    n("BlockStatement", c, l2);
  }
  function A(c, l2) {
    n("BreakStatement", c, l2);
  }
  function S(c, l2) {
    n("CallExpression", c, l2);
  }
  function v(c, l2) {
    n("CatchClause", c, l2);
  }
  function T(c, l2) {
    n("ConditionalExpression", c, l2);
  }
  function C(c, l2) {
    n("ContinueStatement", c, l2);
  }
  function I(c, l2) {
    n("DebuggerStatement", c, l2);
  }
  function N(c, l2) {
    n("DoWhileStatement", c, l2);
  }
  function D(c, l2) {
    n("EmptyStatement", c, l2);
  }
  function _(c, l2) {
    n("ExpressionStatement", c, l2);
  }
  function m(c, l2) {
    n("File", c, l2);
  }
  function L(c, l2) {
    n("ForInStatement", c, l2);
  }
  function R(c, l2) {
    n("ForStatement", c, l2);
  }
  function O(c, l2) {
    n("FunctionDeclaration", c, l2);
  }
  function B(c, l2) {
    n("FunctionExpression", c, l2);
  }
  function M(c, l2) {
    n("Identifier", c, l2);
  }
  function j(c, l2) {
    n("IfStatement", c, l2);
  }
  function $(c, l2) {
    n("LabeledStatement", c, l2);
  }
  function k(c, l2) {
    n("StringLiteral", c, l2);
  }
  function ne(c, l2) {
    n("NumericLiteral", c, l2);
  }
  function Q(c, l2) {
    n("NullLiteral", c, l2);
  }
  function q(c, l2) {
    n("BooleanLiteral", c, l2);
  }
  function ee(c, l2) {
    n("RegExpLiteral", c, l2);
  }
  function K(c, l2) {
    n("LogicalExpression", c, l2);
  }
  function G(c, l2) {
    n("MemberExpression", c, l2);
  }
  function V(c, l2) {
    n("NewExpression", c, l2);
  }
  function F(c, l2) {
    n("Program", c, l2);
  }
  function le(c, l2) {
    n("ObjectExpression", c, l2);
  }
  function oe(c, l2) {
    n("ObjectMethod", c, l2);
  }
  function fe(c, l2) {
    n("ObjectProperty", c, l2);
  }
  function he(c, l2) {
    n("RestElement", c, l2);
  }
  function de(c, l2) {
    n("ReturnStatement", c, l2);
  }
  function Pe(c, l2) {
    n("SequenceExpression", c, l2);
  }
  function we(c, l2) {
    n("ParenthesizedExpression", c, l2);
  }
  function H(c, l2) {
    n("SwitchCase", c, l2);
  }
  function te(c, l2) {
    n("SwitchStatement", c, l2);
  }
  function Ie(c, l2) {
    n("ThisExpression", c, l2);
  }
  function Te(c, l2) {
    n("ThrowStatement", c, l2);
  }
  function pe(c, l2) {
    n("TryStatement", c, l2);
  }
  function z(c, l2) {
    n("UnaryExpression", c, l2);
  }
  function W(c, l2) {
    n("UpdateExpression", c, l2);
  }
  function ae(c, l2) {
    n("VariableDeclaration", c, l2);
  }
  function ce(c, l2) {
    n("VariableDeclarator", c, l2);
  }
  function xe(c, l2) {
    n("WhileStatement", c, l2);
  }
  function Se(c, l2) {
    n("WithStatement", c, l2);
  }
  function Le(c, l2) {
    n("AssignmentPattern", c, l2);
  }
  function Ee(c, l2) {
    n("ArrayPattern", c, l2);
  }
  function J(c, l2) {
    n("ArrowFunctionExpression", c, l2);
  }
  function me(c, l2) {
    n("ClassBody", c, l2);
  }
  function ke(c, l2) {
    n("ClassExpression", c, l2);
  }
  function _e(c, l2) {
    n("ClassDeclaration", c, l2);
  }
  function Re(c, l2) {
    n("ExportAllDeclaration", c, l2);
  }
  function $e(c, l2) {
    n("ExportDefaultDeclaration", c, l2);
  }
  function Ge(c, l2) {
    n("ExportNamedDeclaration", c, l2);
  }
  function lt(c, l2) {
    n("ExportSpecifier", c, l2);
  }
  function Ze(c, l2) {
    n("ForOfStatement", c, l2);
  }
  function Xe(c, l2) {
    n("ImportDeclaration", c, l2);
  }
  function et(c, l2) {
    n("ImportDefaultSpecifier", c, l2);
  }
  function st(c, l2) {
    n("ImportNamespaceSpecifier", c, l2);
  }
  function re(c, l2) {
    n("ImportSpecifier", c, l2);
  }
  function be(c, l2) {
    n("MetaProperty", c, l2);
  }
  function ue(c, l2) {
    n("ClassMethod", c, l2);
  }
  function Me(c, l2) {
    n("ObjectPattern", c, l2);
  }
  function Y(c, l2) {
    n("SpreadElement", c, l2);
  }
  function Ne(c, l2) {
    n("Super", c, l2);
  }
  function Be(c, l2) {
    n("TaggedTemplateExpression", c, l2);
  }
  function X(c, l2) {
    n("TemplateElement", c, l2);
  }
  function je(c, l2) {
    n("TemplateLiteral", c, l2);
  }
  function rt(c, l2) {
    n("YieldExpression", c, l2);
  }
  function vt(c, l2) {
    n("AwaitExpression", c, l2);
  }
  function gt(c, l2) {
    n("Import", c, l2);
  }
  function ut(c, l2) {
    n("BigIntLiteral", c, l2);
  }
  function qe(c, l2) {
    n("ExportNamespaceSpecifier", c, l2);
  }
  function De(c, l2) {
    n("OptionalMemberExpression", c, l2);
  }
  function Tt(c, l2) {
    n("OptionalCallExpression", c, l2);
  }
  function sr(c, l2) {
    n("ClassProperty", c, l2);
  }
  function ar(c, l2) {
    n("ClassAccessorProperty", c, l2);
  }
  function Nr(c, l2) {
    n("ClassPrivateProperty", c, l2);
  }
  function At(c, l2) {
    n("ClassPrivateMethod", c, l2);
  }
  function Dt(c, l2) {
    n("PrivateName", c, l2);
  }
  function Ye(c, l2) {
    n("StaticBlock", c, l2);
  }
  function bt(c, l2) {
    n("AnyTypeAnnotation", c, l2);
  }
  function ct(c, l2) {
    n("ArrayTypeAnnotation", c, l2);
  }
  function $t(c, l2) {
    n("BooleanTypeAnnotation", c, l2);
  }
  function Mr(c, l2) {
    n("BooleanLiteralTypeAnnotation", c, l2);
  }
  function xt(c, l2) {
    n("NullLiteralTypeAnnotation", c, l2);
  }
  function or(c, l2) {
    n("ClassImplements", c, l2);
  }
  function qt(c, l2) {
    n("DeclareClass", c, l2);
  }
  function Vt(c, l2) {
    n("DeclareFunction", c, l2);
  }
  function it(c, l2) {
    n("DeclareInterface", c, l2);
  }
  function wt(c, l2) {
    n("DeclareModule", c, l2);
  }
  function Br(c, l2) {
    n("DeclareModuleExports", c, l2);
  }
  function pt(c, l2) {
    n("DeclareTypeAlias", c, l2);
  }
  function Kt(c, l2) {
    n("DeclareOpaqueType", c, l2);
  }
  function _r(c, l2) {
    n("DeclareVariable", c, l2);
  }
  function Wt(c, l2) {
    n("DeclareExportDeclaration", c, l2);
  }
  function lr(c, l2) {
    n("DeclareExportAllDeclaration", c, l2);
  }
  function ur(c, l2) {
    n("DeclaredPredicate", c, l2);
  }
  function cr(c, l2) {
    n("ExistsTypeAnnotation", c, l2);
  }
  function pr(c, l2) {
    n("FunctionTypeAnnotation", c, l2);
  }
  function Fr(c, l2) {
    n("FunctionTypeParam", c, l2);
  }
  function nt(c, l2) {
    n("GenericTypeAnnotation", c, l2);
  }
  function Ht(c, l2) {
    n("InferredPredicate", c, l2);
  }
  function jr(c, l2) {
    n("InterfaceExtends", c, l2);
  }
  function Es(c, l2) {
    n("InterfaceDeclaration", c, l2);
  }
  function vs(c, l2) {
    n("InterfaceTypeAnnotation", c, l2);
  }
  function Rr(c, l2) {
    n("IntersectionTypeAnnotation", c, l2);
  }
  function Ur(c, l2) {
    n("MixedTypeAnnotation", c, l2);
  }
  function Pt(c, l2) {
    n("EmptyTypeAnnotation", c, l2);
  }
  function As(c, l2) {
    n("NullableTypeAnnotation", c, l2);
  }
  function Cs(c, l2) {
    n("NumberLiteralTypeAnnotation", c, l2);
  }
  function ws(c, l2) {
    n("NumberTypeAnnotation", c, l2);
  }
  function Is(c, l2) {
    n("ObjectTypeAnnotation", c, l2);
  }
  function zt(c, l2) {
    n("ObjectTypeInternalSlot", c, l2);
  }
  function fr(c, l2) {
    n("ObjectTypeCallProperty", c, l2);
  }
  function hr(c, l2) {
    n("ObjectTypeIndexer", c, l2);
  }
  function dr(c, l2) {
    n("ObjectTypeProperty", c, l2);
  }
  function Ns(c, l2) {
    n("ObjectTypeSpreadProperty", c, l2);
  }
  function ks(c, l2) {
    n("OpaqueType", c, l2);
  }
  function Os(c, l2) {
    n("QualifiedTypeIdentifier", c, l2);
  }
  function Ds(c, l2) {
    n("StringLiteralTypeAnnotation", c, l2);
  }
  function mr(c, l2) {
    n("StringTypeAnnotation", c, l2);
  }
  function Ls(c, l2) {
    n("SymbolTypeAnnotation", c, l2);
  }
  function $r(c, l2) {
    n("ThisTypeAnnotation", c, l2);
  }
  function Ms(c, l2) {
    n("TupleTypeAnnotation", c, l2);
  }
  function Bt(c, l2) {
    n("TypeofTypeAnnotation", c, l2);
  }
  function _t(c, l2) {
    n("TypeAlias", c, l2);
  }
  function Bs(c, l2) {
    n("TypeAnnotation", c, l2);
  }
  function yr(c, l2) {
    n("TypeCastExpression", c, l2);
  }
  function Gt(c, l2) {
    n("TypeParameter", c, l2);
  }
  function St(c, l2) {
    n("TypeParameterDeclaration", c, l2);
  }
  function br(c, l2) {
    n("TypeParameterInstantiation", c, l2);
  }
  function _s(c, l2) {
    n("UnionTypeAnnotation", c, l2);
  }
  function qr(c, l2) {
    n("Variance", c, l2);
  }
  function Fs(c, l2) {
    n("VoidTypeAnnotation", c, l2);
  }
  function gr(c, l2) {
    n("EnumDeclaration", c, l2);
  }
  function js(c, l2) {
    n("EnumBooleanBody", c, l2);
  }
  function Rs(c, l2) {
    n("EnumNumberBody", c, l2);
  }
  function Us(c, l2) {
    n("EnumStringBody", c, l2);
  }
  function $s(c, l2) {
    n("EnumSymbolBody", c, l2);
  }
  function Vr(c, l2) {
    n("EnumBooleanMember", c, l2);
  }
  function Xt(c, l2) {
    n("EnumNumberMember", c, l2);
  }
  function ft(c, l2) {
    n("EnumStringMember", c, l2);
  }
  function qs(c, l2) {
    n("EnumDefaultedMember", c, l2);
  }
  function Tr(c, l2) {
    n("IndexedAccessType", c, l2);
  }
  function xr(c, l2) {
    n("OptionalIndexedAccessType", c, l2);
  }
  function Vs(c, l2) {
    n("JSXAttribute", c, l2);
  }
  function Ks(c, l2) {
    n("JSXClosingElement", c, l2);
  }
  function Ws(c, l2) {
    n("JSXElement", c, l2);
  }
  function Hs(c, l2) {
    n("JSXEmptyExpression", c, l2);
  }
  function zs(c, l2) {
    n("JSXExpressionContainer", c, l2);
  }
  function Kr(c, l2) {
    n("JSXSpreadChild", c, l2);
  }
  function Pr(c, l2) {
    n("JSXIdentifier", c, l2);
  }
  function Wr(c, l2) {
    n("JSXMemberExpression", c, l2);
  }
  function Jt(c, l2) {
    n("JSXNamespacedName", c, l2);
  }
  function Hr(c, l2) {
    n("JSXOpeningElement", c, l2);
  }
  function Gs(c, l2) {
    n("JSXSpreadAttribute", c, l2);
  }
  function Xs(c, l2) {
    n("JSXText", c, l2);
  }
  function Js(c, l2) {
    n("JSXFragment", c, l2);
  }
  function Ys(c, l2) {
    n("JSXOpeningFragment", c, l2);
  }
  function zr(c, l2) {
    n("JSXClosingFragment", c, l2);
  }
  function It(c, l2) {
    n("Noop", c, l2);
  }
  function Gr(c, l2) {
    n("Placeholder", c, l2);
  }
  function Yt(c, l2) {
    n("V8IntrinsicIdentifier", c, l2);
  }
  function Xr(c, l2) {
    n("ArgumentPlaceholder", c, l2);
  }
  function Nt(c, l2) {
    n("BindExpression", c, l2);
  }
  function Qs(c, l2) {
    n("ImportAttribute", c, l2);
  }
  function Qt(c, l2) {
    n("Decorator", c, l2);
  }
  function Zs(c, l2) {
    n("DoExpression", c, l2);
  }
  function Zt(c, l2) {
    n("ExportDefaultSpecifier", c, l2);
  }
  function er(c, l2) {
    n("RecordExpression", c, l2);
  }
  function Sr(c, l2) {
    n("TupleExpression", c, l2);
  }
  function ei(c, l2) {
    n("DecimalLiteral", c, l2);
  }
  function at(c, l2) {
    n("ModuleExpression", c, l2);
  }
  function ti(c, l2) {
    n("TopicReference", c, l2);
  }
  function ri(c, l2) {
    n("PipelineTopicExpression", c, l2);
  }
  function si(c, l2) {
    n("PipelineBareFunction", c, l2);
  }
  function Ce(c, l2) {
    n("PipelinePrimaryTopicReference", c, l2);
  }
  function ii(c, l2) {
    n("TSParameterProperty", c, l2);
  }
  function Er(c, l2) {
    n("TSDeclareFunction", c, l2);
  }
  function Jr(c, l2) {
    n("TSDeclareMethod", c, l2);
  }
  function ni(c, l2) {
    n("TSQualifiedName", c, l2);
  }
  function ai(c, l2) {
    n("TSCallSignatureDeclaration", c, l2);
  }
  function oi(c, l2) {
    n("TSConstructSignatureDeclaration", c, l2);
  }
  function li(c, l2) {
    n("TSPropertySignature", c, l2);
  }
  function ui(c, l2) {
    n("TSMethodSignature", c, l2);
  }
  function Et(c, l2) {
    n("TSIndexSignature", c, l2);
  }
  function ht(c, l2) {
    n("TSAnyKeyword", c, l2);
  }
  function kt(c, l2) {
    n("TSBooleanKeyword", c, l2);
  }
  function ci(c, l2) {
    n("TSBigIntKeyword", c, l2);
  }
  function pi(c, l2) {
    n("TSIntrinsicKeyword", c, l2);
  }
  function fi(c, l2) {
    n("TSNeverKeyword", c, l2);
  }
  function hi(c, l2) {
    n("TSNullKeyword", c, l2);
  }
  function di(c, l2) {
    n("TSNumberKeyword", c, l2);
  }
  function Yr(c, l2) {
    n("TSObjectKeyword", c, l2);
  }
  function ve(c, l2) {
    n("TSStringKeyword", c, l2);
  }
  function mi(c, l2) {
    n("TSSymbolKeyword", c, l2);
  }
  function Qr(c, l2) {
    n("TSUndefinedKeyword", c, l2);
  }
  function yi(c, l2) {
    n("TSUnknownKeyword", c, l2);
  }
  function bi(c, l2) {
    n("TSVoidKeyword", c, l2);
  }
  function gi(c, l2) {
    n("TSThisType", c, l2);
  }
  function Zr(c, l2) {
    n("TSFunctionType", c, l2);
  }
  function es(c, l2) {
    n("TSConstructorType", c, l2);
  }
  function Ti(c, l2) {
    n("TSTypeReference", c, l2);
  }
  function xi(c, l2) {
    n("TSTypePredicate", c, l2);
  }
  function ze(c, l2) {
    n("TSTypeQuery", c, l2);
  }
  function Ft(c, l2) {
    n("TSTypeLiteral", c, l2);
  }
  function ts(c, l2) {
    n("TSArrayType", c, l2);
  }
  function rs(c, l2) {
    n("TSTupleType", c, l2);
  }
  function ss(c, l2) {
    n("TSOptionalType", c, l2);
  }
  function Pi(c, l2) {
    n("TSRestType", c, l2);
  }
  function is(c, l2) {
    n("TSNamedTupleMember", c, l2);
  }
  function Si(c, l2) {
    n("TSUnionType", c, l2);
  }
  function ns(c, l2) {
    n("TSIntersectionType", c, l2);
  }
  function Ei(c, l2) {
    n("TSConditionalType", c, l2);
  }
  function vi(c, l2) {
    n("TSInferType", c, l2);
  }
  function as(c, l2) {
    n("TSParenthesizedType", c, l2);
  }
  function Ai(c, l2) {
    n("TSTypeOperator", c, l2);
  }
  function Ci(c, l2) {
    n("TSIndexedAccessType", c, l2);
  }
  function vr(c, l2) {
    n("TSMappedType", c, l2);
  }
  function wi(c, l2) {
    n("TSLiteralType", c, l2);
  }
  function Ii(c, l2) {
    n("TSExpressionWithTypeArguments", c, l2);
  }
  function Ar(c, l2) {
    n("TSInterfaceDeclaration", c, l2);
  }
  function os(c, l2) {
    n("TSInterfaceBody", c, l2);
  }
  function ls(c, l2) {
    n("TSTypeAliasDeclaration", c, l2);
  }
  function Ni(c, l2) {
    n("TSInstantiationExpression", c, l2);
  }
  function Cr(c, l2) {
    n("TSAsExpression", c, l2);
  }
  function ki(c, l2) {
    n("TSTypeAssertion", c, l2);
  }
  function Oi(c, l2) {
    n("TSEnumDeclaration", c, l2);
  }
  function us(c, l2) {
    n("TSEnumMember", c, l2);
  }
  function Di(c, l2) {
    n("TSModuleDeclaration", c, l2);
  }
  function Li(c, l2) {
    n("TSModuleBlock", c, l2);
  }
  function Mi(c, l2) {
    n("TSImportType", c, l2);
  }
  function Bi(c, l2) {
    n("TSImportEqualsDeclaration", c, l2);
  }
  function _i(c, l2) {
    n("TSExternalModuleReference", c, l2);
  }
  function jt(c, l2) {
    n("TSNonNullExpression", c, l2);
  }
  function cs(c, l2) {
    n("TSExportAssignment", c, l2);
  }
  function Fi(c, l2) {
    n("TSNamespaceExportDeclaration", c, l2);
  }
  function a(c, l2) {
    n("TSTypeAnnotation", c, l2);
  }
  function e(c, l2) {
    n("TSTypeParameterInstantiation", c, l2);
  }
  function t(c, l2) {
    n("TSTypeParameterDeclaration", c, l2);
  }
  function r(c, l2) {
    n("TSTypeParameter", c, l2);
  }
  function i(c, l2) {
    n("Standardized", c, l2);
  }
  function o(c, l2) {
    n("Expression", c, l2);
  }
  function d(c, l2) {
    n("Binary", c, l2);
  }
  function u(c, l2) {
    n("Scopable", c, l2);
  }
  function E(c, l2) {
    n("BlockParent", c, l2);
  }
  function w(c, l2) {
    n("Block", c, l2);
  }
  function U(c, l2) {
    n("Statement", c, l2);
  }
  function ge(c, l2) {
    n("Terminatorless", c, l2);
  }
  function ye(c, l2) {
    n("CompletionStatement", c, l2);
  }
  function Ae(c, l2) {
    n("Conditional", c, l2);
  }
  function Oe(c, l2) {
    n("Loop", c, l2);
  }
  function Ve(c, l2) {
    n("While", c, l2);
  }
  function Ke(c, l2) {
    n("ExpressionWrapper", c, l2);
  }
  function He(c, l2) {
    n("For", c, l2);
  }
  function bs(c, l2) {
    n("ForXStatement", c, l2);
  }
  function zi(c, l2) {
    n("Function", c, l2);
  }
  function Yl(c, l2) {
    n("FunctionParent", c, l2);
  }
  function Ql(c, l2) {
    n("Pureish", c, l2);
  }
  function Zl(c, l2) {
    n("Declaration", c, l2);
  }
  function eu(c, l2) {
    n("PatternLike", c, l2);
  }
  function tu(c, l2) {
    n("LVal", c, l2);
  }
  function ru(c, l2) {
    n("TSEntityName", c, l2);
  }
  function su(c, l2) {
    n("Literal", c, l2);
  }
  function iu(c, l2) {
    n("Immutable", c, l2);
  }
  function nu(c, l2) {
    n("UserWhitespacable", c, l2);
  }
  function au(c, l2) {
    n("Method", c, l2);
  }
  function ou(c, l2) {
    n("ObjectMember", c, l2);
  }
  function lu(c, l2) {
    n("Property", c, l2);
  }
  function uu(c, l2) {
    n("UnaryLike", c, l2);
  }
  function cu(c, l2) {
    n("Pattern", c, l2);
  }
  function pu(c, l2) {
    n("Class", c, l2);
  }
  function fu(c, l2) {
    n("ModuleDeclaration", c, l2);
  }
  function hu(c, l2) {
    n("ExportDeclaration", c, l2);
  }
  function du(c, l2) {
    n("ModuleSpecifier", c, l2);
  }
  function mu(c, l2) {
    n("Accessor", c, l2);
  }
  function yu(c, l2) {
    n("Private", c, l2);
  }
  function bu(c, l2) {
    n("Flow", c, l2);
  }
  function gu(c, l2) {
    n("FlowType", c, l2);
  }
  function Tu(c, l2) {
    n("FlowBaseAnnotation", c, l2);
  }
  function xu(c, l2) {
    n("FlowDeclaration", c, l2);
  }
  function Pu(c, l2) {
    n("FlowPredicate", c, l2);
  }
  function Su(c, l2) {
    n("EnumBody", c, l2);
  }
  function Eu(c, l2) {
    n("EnumMember", c, l2);
  }
  function vu(c, l2) {
    n("JSX", c, l2);
  }
  function Au(c, l2) {
    n("Miscellaneous", c, l2);
  }
  function Cu(c, l2) {
    n("TypeScript", c, l2);
  }
  function wu(c, l2) {
    n("TSTypeElement", c, l2);
  }
  function Iu(c, l2) {
    n("TSType", c, l2);
  }
  function Nu(c, l2) {
    n("TSBaseType", c, l2);
  }
  function ku(c, l2) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), n("NumberLiteral", c, l2);
  }
  function Ou(c, l2) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), n("RegexLiteral", c, l2);
  }
  function Du(c, l2) {
    console.trace("The node type RestProperty has been renamed to RestElement"), n("RestProperty", c, l2);
  }
  function b(c, l2) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement"), n("SpreadProperty", c, l2);
  }
  return ie;
}
var ta = {};
var xf;
function _b() {
  if (xf)
    return ta;
  xf = 1, Object.defineProperty(ta, "__esModule", {
    value: true
  }), ta.default = void 0;
  var s = ys(), n = h;
  ta.default = n;
  function h(f2) {
    switch (f2) {
      case "string":
        return (0, s.stringTypeAnnotation)();
      case "number":
        return (0, s.numberTypeAnnotation)();
      case "undefined":
        return (0, s.voidTypeAnnotation)();
      case "boolean":
        return (0, s.booleanTypeAnnotation)();
      case "function":
        return (0, s.genericTypeAnnotation)((0, s.identifier)("Function"));
      case "object":
        return (0, s.genericTypeAnnotation)((0, s.identifier)("Object"));
      case "symbol":
        return (0, s.genericTypeAnnotation)((0, s.identifier)("Symbol"));
      case "bigint":
        return (0, s.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + f2);
  }
  return ta;
}
var ro = {};
var so = {};
var Pf;
function ky() {
  if (Pf)
    return so;
  Pf = 1, Object.defineProperty(so, "__esModule", {
    value: true
  }), so.default = h;
  var s = rr();
  function n(f2) {
    return (0, s.isIdentifier)(f2) ? f2.name : `${f2.id.name}.${n(f2.qualification)}`;
  }
  function h(f2) {
    const p = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), P = /* @__PURE__ */ new Set(), x = [];
    for (let y = 0; y < f2.length; y++) {
      const A = f2[y];
      if (!!A && !(x.indexOf(A) >= 0)) {
        if ((0, s.isAnyTypeAnnotation)(A))
          return [A];
        if ((0, s.isFlowBaseAnnotation)(A)) {
          g.set(A.type, A);
          continue;
        }
        if ((0, s.isUnionTypeAnnotation)(A)) {
          P.has(A.types) || (f2 = f2.concat(A.types), P.add(A.types));
          continue;
        }
        if ((0, s.isGenericTypeAnnotation)(A)) {
          const S = n(A.id);
          if (p.has(S)) {
            let v = p.get(S);
            v.typeParameters ? A.typeParameters && (v.typeParameters.params = h(v.typeParameters.params.concat(A.typeParameters.params))) : v = A.typeParameters;
          } else
            p.set(S, A);
          continue;
        }
        x.push(A);
      }
    }
    for (const [, y] of g)
      x.push(y);
    for (const [, y] of p)
      x.push(y);
    return x;
  }
  return so;
}
var Sf;
function Fb() {
  if (Sf)
    return ro;
  Sf = 1, Object.defineProperty(ro, "__esModule", {
    value: true
  }), ro.default = h;
  var s = ys(), n = ky();
  function h(f2) {
    const p = (0, n.default)(f2);
    return p.length === 1 ? p[0] : (0, s.unionTypeAnnotation)(p);
  }
  return ro;
}
var io = {};
var no = {};
var Ef;
function jb() {
  if (Ef)
    return no;
  Ef = 1, Object.defineProperty(no, "__esModule", {
    value: true
  }), no.default = h;
  var s = rr();
  function n(f2) {
    return (0, s.isIdentifier)(f2) ? f2.name : `${f2.right.name}.${n(f2.left)}`;
  }
  function h(f2) {
    const p = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), P = /* @__PURE__ */ new Set(), x = [];
    for (let y = 0; y < f2.length; y++) {
      const A = f2[y];
      if (!!A && !(x.indexOf(A) >= 0)) {
        if ((0, s.isTSAnyKeyword)(A))
          return [A];
        if ((0, s.isTSBaseType)(A)) {
          g.set(A.type, A);
          continue;
        }
        if ((0, s.isTSUnionType)(A)) {
          P.has(A.types) || (f2.push(...A.types), P.add(A.types));
          continue;
        }
        if ((0, s.isTSTypeReference)(A) && A.typeParameters) {
          const S = n(A.typeName);
          if (p.has(S)) {
            let v = p.get(S);
            v.typeParameters ? A.typeParameters && (v.typeParameters.params = h(v.typeParameters.params.concat(A.typeParameters.params))) : v = A.typeParameters;
          } else
            p.set(S, A);
          continue;
        }
        x.push(A);
      }
    }
    for (const [, y] of g)
      x.push(y);
    for (const [, y] of p)
      x.push(y);
    return x;
  }
  return no;
}
var vf;
function Rb() {
  if (vf)
    return io;
  vf = 1, Object.defineProperty(io, "__esModule", {
    value: true
  }), io.default = f2;
  var s = ys(), n = jb(), h = rr();
  function f2(p) {
    const g = p.map((x) => (0, h.isTSTypeAnnotation)(x) ? x.typeAnnotation : x), P = (0, n.default)(g);
    return P.length === 1 ? P[0] : (0, s.tsUnionType)(P);
  }
  return io;
}
var Ru = {};
var Af;
function Ub() {
  return Af || (Af = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.anyTypeAnnotation;
      }
    }), Object.defineProperty(s, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return n.argumentPlaceholder;
      }
    }), Object.defineProperty(s, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return n.arrayExpression;
      }
    }), Object.defineProperty(s, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return n.arrayPattern;
      }
    }), Object.defineProperty(s, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.arrayTypeAnnotation;
      }
    }), Object.defineProperty(s, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return n.arrowFunctionExpression;
      }
    }), Object.defineProperty(s, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return n.assignmentExpression;
      }
    }), Object.defineProperty(s, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return n.assignmentPattern;
      }
    }), Object.defineProperty(s, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return n.awaitExpression;
      }
    }), Object.defineProperty(s, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return n.bigIntLiteral;
      }
    }), Object.defineProperty(s, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return n.binaryExpression;
      }
    }), Object.defineProperty(s, "BindExpression", {
      enumerable: true,
      get: function() {
        return n.bindExpression;
      }
    }), Object.defineProperty(s, "BlockStatement", {
      enumerable: true,
      get: function() {
        return n.blockStatement;
      }
    }), Object.defineProperty(s, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return n.booleanLiteral;
      }
    }), Object.defineProperty(s, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.booleanLiteralTypeAnnotation;
      }
    }), Object.defineProperty(s, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.booleanTypeAnnotation;
      }
    }), Object.defineProperty(s, "BreakStatement", {
      enumerable: true,
      get: function() {
        return n.breakStatement;
      }
    }), Object.defineProperty(s, "CallExpression", {
      enumerable: true,
      get: function() {
        return n.callExpression;
      }
    }), Object.defineProperty(s, "CatchClause", {
      enumerable: true,
      get: function() {
        return n.catchClause;
      }
    }), Object.defineProperty(s, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return n.classAccessorProperty;
      }
    }), Object.defineProperty(s, "ClassBody", {
      enumerable: true,
      get: function() {
        return n.classBody;
      }
    }), Object.defineProperty(s, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return n.classDeclaration;
      }
    }), Object.defineProperty(s, "ClassExpression", {
      enumerable: true,
      get: function() {
        return n.classExpression;
      }
    }), Object.defineProperty(s, "ClassImplements", {
      enumerable: true,
      get: function() {
        return n.classImplements;
      }
    }), Object.defineProperty(s, "ClassMethod", {
      enumerable: true,
      get: function() {
        return n.classMethod;
      }
    }), Object.defineProperty(s, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return n.classPrivateMethod;
      }
    }), Object.defineProperty(s, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return n.classPrivateProperty;
      }
    }), Object.defineProperty(s, "ClassProperty", {
      enumerable: true,
      get: function() {
        return n.classProperty;
      }
    }), Object.defineProperty(s, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return n.conditionalExpression;
      }
    }), Object.defineProperty(s, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return n.continueStatement;
      }
    }), Object.defineProperty(s, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return n.debuggerStatement;
      }
    }), Object.defineProperty(s, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return n.decimalLiteral;
      }
    }), Object.defineProperty(s, "DeclareClass", {
      enumerable: true,
      get: function() {
        return n.declareClass;
      }
    }), Object.defineProperty(s, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return n.declareExportAllDeclaration;
      }
    }), Object.defineProperty(s, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return n.declareExportDeclaration;
      }
    }), Object.defineProperty(s, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return n.declareFunction;
      }
    }), Object.defineProperty(s, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return n.declareInterface;
      }
    }), Object.defineProperty(s, "DeclareModule", {
      enumerable: true,
      get: function() {
        return n.declareModule;
      }
    }), Object.defineProperty(s, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return n.declareModuleExports;
      }
    }), Object.defineProperty(s, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return n.declareOpaqueType;
      }
    }), Object.defineProperty(s, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return n.declareTypeAlias;
      }
    }), Object.defineProperty(s, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return n.declareVariable;
      }
    }), Object.defineProperty(s, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return n.declaredPredicate;
      }
    }), Object.defineProperty(s, "Decorator", {
      enumerable: true,
      get: function() {
        return n.decorator;
      }
    }), Object.defineProperty(s, "Directive", {
      enumerable: true,
      get: function() {
        return n.directive;
      }
    }), Object.defineProperty(s, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return n.directiveLiteral;
      }
    }), Object.defineProperty(s, "DoExpression", {
      enumerable: true,
      get: function() {
        return n.doExpression;
      }
    }), Object.defineProperty(s, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return n.doWhileStatement;
      }
    }), Object.defineProperty(s, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return n.emptyStatement;
      }
    }), Object.defineProperty(s, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.emptyTypeAnnotation;
      }
    }), Object.defineProperty(s, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return n.enumBooleanBody;
      }
    }), Object.defineProperty(s, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return n.enumBooleanMember;
      }
    }), Object.defineProperty(s, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return n.enumDeclaration;
      }
    }), Object.defineProperty(s, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return n.enumDefaultedMember;
      }
    }), Object.defineProperty(s, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return n.enumNumberBody;
      }
    }), Object.defineProperty(s, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return n.enumNumberMember;
      }
    }), Object.defineProperty(s, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return n.enumStringBody;
      }
    }), Object.defineProperty(s, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return n.enumStringMember;
      }
    }), Object.defineProperty(s, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return n.enumSymbolBody;
      }
    }), Object.defineProperty(s, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.existsTypeAnnotation;
      }
    }), Object.defineProperty(s, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return n.exportAllDeclaration;
      }
    }), Object.defineProperty(s, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return n.exportDefaultDeclaration;
      }
    }), Object.defineProperty(s, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return n.exportDefaultSpecifier;
      }
    }), Object.defineProperty(s, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return n.exportNamedDeclaration;
      }
    }), Object.defineProperty(s, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return n.exportNamespaceSpecifier;
      }
    }), Object.defineProperty(s, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return n.exportSpecifier;
      }
    }), Object.defineProperty(s, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return n.expressionStatement;
      }
    }), Object.defineProperty(s, "File", {
      enumerable: true,
      get: function() {
        return n.file;
      }
    }), Object.defineProperty(s, "ForInStatement", {
      enumerable: true,
      get: function() {
        return n.forInStatement;
      }
    }), Object.defineProperty(s, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return n.forOfStatement;
      }
    }), Object.defineProperty(s, "ForStatement", {
      enumerable: true,
      get: function() {
        return n.forStatement;
      }
    }), Object.defineProperty(s, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return n.functionDeclaration;
      }
    }), Object.defineProperty(s, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return n.functionExpression;
      }
    }), Object.defineProperty(s, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.functionTypeAnnotation;
      }
    }), Object.defineProperty(s, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return n.functionTypeParam;
      }
    }), Object.defineProperty(s, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.genericTypeAnnotation;
      }
    }), Object.defineProperty(s, "Identifier", {
      enumerable: true,
      get: function() {
        return n.identifier;
      }
    }), Object.defineProperty(s, "IfStatement", {
      enumerable: true,
      get: function() {
        return n.ifStatement;
      }
    }), Object.defineProperty(s, "Import", {
      enumerable: true,
      get: function() {
        return n.import;
      }
    }), Object.defineProperty(s, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return n.importAttribute;
      }
    }), Object.defineProperty(s, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return n.importDeclaration;
      }
    }), Object.defineProperty(s, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return n.importDefaultSpecifier;
      }
    }), Object.defineProperty(s, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return n.importNamespaceSpecifier;
      }
    }), Object.defineProperty(s, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return n.importSpecifier;
      }
    }), Object.defineProperty(s, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return n.indexedAccessType;
      }
    }), Object.defineProperty(s, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return n.inferredPredicate;
      }
    }), Object.defineProperty(s, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return n.interfaceDeclaration;
      }
    }), Object.defineProperty(s, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return n.interfaceExtends;
      }
    }), Object.defineProperty(s, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.interfaceTypeAnnotation;
      }
    }), Object.defineProperty(s, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return n.interpreterDirective;
      }
    }), Object.defineProperty(s, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.intersectionTypeAnnotation;
      }
    }), Object.defineProperty(s, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return n.jsxAttribute;
      }
    }), Object.defineProperty(s, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return n.jsxClosingElement;
      }
    }), Object.defineProperty(s, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return n.jsxClosingFragment;
      }
    }), Object.defineProperty(s, "JSXElement", {
      enumerable: true,
      get: function() {
        return n.jsxElement;
      }
    }), Object.defineProperty(s, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return n.jsxEmptyExpression;
      }
    }), Object.defineProperty(s, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return n.jsxExpressionContainer;
      }
    }), Object.defineProperty(s, "JSXFragment", {
      enumerable: true,
      get: function() {
        return n.jsxFragment;
      }
    }), Object.defineProperty(s, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return n.jsxIdentifier;
      }
    }), Object.defineProperty(s, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return n.jsxMemberExpression;
      }
    }), Object.defineProperty(s, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return n.jsxNamespacedName;
      }
    }), Object.defineProperty(s, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return n.jsxOpeningElement;
      }
    }), Object.defineProperty(s, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return n.jsxOpeningFragment;
      }
    }), Object.defineProperty(s, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return n.jsxSpreadAttribute;
      }
    }), Object.defineProperty(s, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return n.jsxSpreadChild;
      }
    }), Object.defineProperty(s, "JSXText", {
      enumerable: true,
      get: function() {
        return n.jsxText;
      }
    }), Object.defineProperty(s, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return n.labeledStatement;
      }
    }), Object.defineProperty(s, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return n.logicalExpression;
      }
    }), Object.defineProperty(s, "MemberExpression", {
      enumerable: true,
      get: function() {
        return n.memberExpression;
      }
    }), Object.defineProperty(s, "MetaProperty", {
      enumerable: true,
      get: function() {
        return n.metaProperty;
      }
    }), Object.defineProperty(s, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.mixedTypeAnnotation;
      }
    }), Object.defineProperty(s, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return n.moduleExpression;
      }
    }), Object.defineProperty(s, "NewExpression", {
      enumerable: true,
      get: function() {
        return n.newExpression;
      }
    }), Object.defineProperty(s, "Noop", {
      enumerable: true,
      get: function() {
        return n.noop;
      }
    }), Object.defineProperty(s, "NullLiteral", {
      enumerable: true,
      get: function() {
        return n.nullLiteral;
      }
    }), Object.defineProperty(s, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.nullLiteralTypeAnnotation;
      }
    }), Object.defineProperty(s, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.nullableTypeAnnotation;
      }
    }), Object.defineProperty(s, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return n.numberLiteral;
      }
    }), Object.defineProperty(s, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.numberLiteralTypeAnnotation;
      }
    }), Object.defineProperty(s, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.numberTypeAnnotation;
      }
    }), Object.defineProperty(s, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return n.numericLiteral;
      }
    }), Object.defineProperty(s, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return n.objectExpression;
      }
    }), Object.defineProperty(s, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return n.objectMethod;
      }
    }), Object.defineProperty(s, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return n.objectPattern;
      }
    }), Object.defineProperty(s, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return n.objectProperty;
      }
    }), Object.defineProperty(s, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.objectTypeAnnotation;
      }
    }), Object.defineProperty(s, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return n.objectTypeCallProperty;
      }
    }), Object.defineProperty(s, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return n.objectTypeIndexer;
      }
    }), Object.defineProperty(s, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return n.objectTypeInternalSlot;
      }
    }), Object.defineProperty(s, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return n.objectTypeProperty;
      }
    }), Object.defineProperty(s, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return n.objectTypeSpreadProperty;
      }
    }), Object.defineProperty(s, "OpaqueType", {
      enumerable: true,
      get: function() {
        return n.opaqueType;
      }
    }), Object.defineProperty(s, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return n.optionalCallExpression;
      }
    }), Object.defineProperty(s, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return n.optionalIndexedAccessType;
      }
    }), Object.defineProperty(s, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return n.optionalMemberExpression;
      }
    }), Object.defineProperty(s, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return n.parenthesizedExpression;
      }
    }), Object.defineProperty(s, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return n.pipelineBareFunction;
      }
    }), Object.defineProperty(s, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return n.pipelinePrimaryTopicReference;
      }
    }), Object.defineProperty(s, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return n.pipelineTopicExpression;
      }
    }), Object.defineProperty(s, "Placeholder", {
      enumerable: true,
      get: function() {
        return n.placeholder;
      }
    }), Object.defineProperty(s, "PrivateName", {
      enumerable: true,
      get: function() {
        return n.privateName;
      }
    }), Object.defineProperty(s, "Program", {
      enumerable: true,
      get: function() {
        return n.program;
      }
    }), Object.defineProperty(s, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return n.qualifiedTypeIdentifier;
      }
    }), Object.defineProperty(s, "RecordExpression", {
      enumerable: true,
      get: function() {
        return n.recordExpression;
      }
    }), Object.defineProperty(s, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return n.regExpLiteral;
      }
    }), Object.defineProperty(s, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return n.regexLiteral;
      }
    }), Object.defineProperty(s, "RestElement", {
      enumerable: true,
      get: function() {
        return n.restElement;
      }
    }), Object.defineProperty(s, "RestProperty", {
      enumerable: true,
      get: function() {
        return n.restProperty;
      }
    }), Object.defineProperty(s, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return n.returnStatement;
      }
    }), Object.defineProperty(s, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return n.sequenceExpression;
      }
    }), Object.defineProperty(s, "SpreadElement", {
      enumerable: true,
      get: function() {
        return n.spreadElement;
      }
    }), Object.defineProperty(s, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return n.spreadProperty;
      }
    }), Object.defineProperty(s, "StaticBlock", {
      enumerable: true,
      get: function() {
        return n.staticBlock;
      }
    }), Object.defineProperty(s, "StringLiteral", {
      enumerable: true,
      get: function() {
        return n.stringLiteral;
      }
    }), Object.defineProperty(s, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.stringLiteralTypeAnnotation;
      }
    }), Object.defineProperty(s, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.stringTypeAnnotation;
      }
    }), Object.defineProperty(s, "Super", {
      enumerable: true,
      get: function() {
        return n.super;
      }
    }), Object.defineProperty(s, "SwitchCase", {
      enumerable: true,
      get: function() {
        return n.switchCase;
      }
    }), Object.defineProperty(s, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return n.switchStatement;
      }
    }), Object.defineProperty(s, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.symbolTypeAnnotation;
      }
    }), Object.defineProperty(s, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return n.tsAnyKeyword;
      }
    }), Object.defineProperty(s, "TSArrayType", {
      enumerable: true,
      get: function() {
        return n.tsArrayType;
      }
    }), Object.defineProperty(s, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return n.tsAsExpression;
      }
    }), Object.defineProperty(s, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return n.tsBigIntKeyword;
      }
    }), Object.defineProperty(s, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return n.tsBooleanKeyword;
      }
    }), Object.defineProperty(s, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsCallSignatureDeclaration;
      }
    }), Object.defineProperty(s, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return n.tsConditionalType;
      }
    }), Object.defineProperty(s, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsConstructSignatureDeclaration;
      }
    }), Object.defineProperty(s, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return n.tsConstructorType;
      }
    }), Object.defineProperty(s, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return n.tsDeclareFunction;
      }
    }), Object.defineProperty(s, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return n.tsDeclareMethod;
      }
    }), Object.defineProperty(s, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsEnumDeclaration;
      }
    }), Object.defineProperty(s, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return n.tsEnumMember;
      }
    }), Object.defineProperty(s, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return n.tsExportAssignment;
      }
    }), Object.defineProperty(s, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return n.tsExpressionWithTypeArguments;
      }
    }), Object.defineProperty(s, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return n.tsExternalModuleReference;
      }
    }), Object.defineProperty(s, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return n.tsFunctionType;
      }
    }), Object.defineProperty(s, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsImportEqualsDeclaration;
      }
    }), Object.defineProperty(s, "TSImportType", {
      enumerable: true,
      get: function() {
        return n.tsImportType;
      }
    }), Object.defineProperty(s, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return n.tsIndexSignature;
      }
    }), Object.defineProperty(s, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return n.tsIndexedAccessType;
      }
    }), Object.defineProperty(s, "TSInferType", {
      enumerable: true,
      get: function() {
        return n.tsInferType;
      }
    }), Object.defineProperty(s, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return n.tsInstantiationExpression;
      }
    }), Object.defineProperty(s, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return n.tsInterfaceBody;
      }
    }), Object.defineProperty(s, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsInterfaceDeclaration;
      }
    }), Object.defineProperty(s, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return n.tsIntersectionType;
      }
    }), Object.defineProperty(s, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return n.tsIntrinsicKeyword;
      }
    }), Object.defineProperty(s, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return n.tsLiteralType;
      }
    }), Object.defineProperty(s, "TSMappedType", {
      enumerable: true,
      get: function() {
        return n.tsMappedType;
      }
    }), Object.defineProperty(s, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return n.tsMethodSignature;
      }
    }), Object.defineProperty(s, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return n.tsModuleBlock;
      }
    }), Object.defineProperty(s, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsModuleDeclaration;
      }
    }), Object.defineProperty(s, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return n.tsNamedTupleMember;
      }
    }), Object.defineProperty(s, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsNamespaceExportDeclaration;
      }
    }), Object.defineProperty(s, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return n.tsNeverKeyword;
      }
    }), Object.defineProperty(s, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return n.tsNonNullExpression;
      }
    }), Object.defineProperty(s, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return n.tsNullKeyword;
      }
    }), Object.defineProperty(s, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return n.tsNumberKeyword;
      }
    }), Object.defineProperty(s, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return n.tsObjectKeyword;
      }
    }), Object.defineProperty(s, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return n.tsOptionalType;
      }
    }), Object.defineProperty(s, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return n.tsParameterProperty;
      }
    }), Object.defineProperty(s, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return n.tsParenthesizedType;
      }
    }), Object.defineProperty(s, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return n.tsPropertySignature;
      }
    }), Object.defineProperty(s, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return n.tsQualifiedName;
      }
    }), Object.defineProperty(s, "TSRestType", {
      enumerable: true,
      get: function() {
        return n.tsRestType;
      }
    }), Object.defineProperty(s, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return n.tsStringKeyword;
      }
    }), Object.defineProperty(s, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return n.tsSymbolKeyword;
      }
    }), Object.defineProperty(s, "TSThisType", {
      enumerable: true,
      get: function() {
        return n.tsThisType;
      }
    }), Object.defineProperty(s, "TSTupleType", {
      enumerable: true,
      get: function() {
        return n.tsTupleType;
      }
    }), Object.defineProperty(s, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsTypeAliasDeclaration;
      }
    }), Object.defineProperty(s, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.tsTypeAnnotation;
      }
    }), Object.defineProperty(s, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return n.tsTypeAssertion;
      }
    }), Object.defineProperty(s, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return n.tsTypeLiteral;
      }
    }), Object.defineProperty(s, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return n.tsTypeOperator;
      }
    }), Object.defineProperty(s, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return n.tsTypeParameter;
      }
    }), Object.defineProperty(s, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return n.tsTypeParameterDeclaration;
      }
    }), Object.defineProperty(s, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return n.tsTypeParameterInstantiation;
      }
    }), Object.defineProperty(s, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return n.tsTypePredicate;
      }
    }), Object.defineProperty(s, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return n.tsTypeQuery;
      }
    }), Object.defineProperty(s, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return n.tsTypeReference;
      }
    }), Object.defineProperty(s, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return n.tsUndefinedKeyword;
      }
    }), Object.defineProperty(s, "TSUnionType", {
      enumerable: true,
      get: function() {
        return n.tsUnionType;
      }
    }), Object.defineProperty(s, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return n.tsUnknownKeyword;
      }
    }), Object.defineProperty(s, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return n.tsVoidKeyword;
      }
    }), Object.defineProperty(s, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return n.taggedTemplateExpression;
      }
    }), Object.defineProperty(s, "TemplateElement", {
      enumerable: true,
      get: function() {
        return n.templateElement;
      }
    }), Object.defineProperty(s, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return n.templateLiteral;
      }
    }), Object.defineProperty(s, "ThisExpression", {
      enumerable: true,
      get: function() {
        return n.thisExpression;
      }
    }), Object.defineProperty(s, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.thisTypeAnnotation;
      }
    }), Object.defineProperty(s, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return n.throwStatement;
      }
    }), Object.defineProperty(s, "TopicReference", {
      enumerable: true,
      get: function() {
        return n.topicReference;
      }
    }), Object.defineProperty(s, "TryStatement", {
      enumerable: true,
      get: function() {
        return n.tryStatement;
      }
    }), Object.defineProperty(s, "TupleExpression", {
      enumerable: true,
      get: function() {
        return n.tupleExpression;
      }
    }), Object.defineProperty(s, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.tupleTypeAnnotation;
      }
    }), Object.defineProperty(s, "TypeAlias", {
      enumerable: true,
      get: function() {
        return n.typeAlias;
      }
    }), Object.defineProperty(s, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.typeAnnotation;
      }
    }), Object.defineProperty(s, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return n.typeCastExpression;
      }
    }), Object.defineProperty(s, "TypeParameter", {
      enumerable: true,
      get: function() {
        return n.typeParameter;
      }
    }), Object.defineProperty(s, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return n.typeParameterDeclaration;
      }
    }), Object.defineProperty(s, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return n.typeParameterInstantiation;
      }
    }), Object.defineProperty(s, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.typeofTypeAnnotation;
      }
    }), Object.defineProperty(s, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return n.unaryExpression;
      }
    }), Object.defineProperty(s, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.unionTypeAnnotation;
      }
    }), Object.defineProperty(s, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return n.updateExpression;
      }
    }), Object.defineProperty(s, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return n.v8IntrinsicIdentifier;
      }
    }), Object.defineProperty(s, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return n.variableDeclaration;
      }
    }), Object.defineProperty(s, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return n.variableDeclarator;
      }
    }), Object.defineProperty(s, "Variance", {
      enumerable: true,
      get: function() {
        return n.variance;
      }
    }), Object.defineProperty(s, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return n.voidTypeAnnotation;
      }
    }), Object.defineProperty(s, "WhileStatement", {
      enumerable: true,
      get: function() {
        return n.whileStatement;
      }
    }), Object.defineProperty(s, "WithStatement", {
      enumerable: true,
      get: function() {
        return n.withStatement;
      }
    }), Object.defineProperty(s, "YieldExpression", {
      enumerable: true,
      get: function() {
        return n.yieldExpression;
      }
    });
    var n = ys();
  }(Ru)), Ru;
}
var ao = {};
var Cf;
function xn() {
  if (Cf)
    return ao;
  Cf = 1, Object.defineProperty(ao, "__esModule", {
    value: true
  }), ao.default = g;
  var s = Ui(), n = rr();
  const h = Function.call.bind(Object.prototype.hasOwnProperty);
  function f2(y, A, S, v) {
    return y && typeof y.type == "string" ? P(y, A, S, v) : y;
  }
  function p(y, A, S, v) {
    return Array.isArray(y) ? y.map((T) => f2(T, A, S, v)) : f2(y, A, S, v);
  }
  function g(y, A = true, S = false) {
    return P(y, A, S, /* @__PURE__ */ new Map());
  }
  function P(y, A = true, S = false, v) {
    if (!y)
      return y;
    const {
      type: T
    } = y, C = {
      type: y.type
    };
    if ((0, n.isIdentifier)(y))
      C.name = y.name, h(y, "optional") && typeof y.optional == "boolean" && (C.optional = y.optional), h(y, "typeAnnotation") && (C.typeAnnotation = A ? p(y.typeAnnotation, true, S, v) : y.typeAnnotation);
    else if (h(s.NODE_FIELDS, T))
      for (const I of Object.keys(s.NODE_FIELDS[T]))
        h(y, I) && (A ? C[I] = (0, n.isFile)(y) && I === "comments" ? x(y.comments, A, S, v) : p(y[I], true, S, v) : C[I] = y[I]);
    else
      throw new Error(`Unknown node type: "${T}"`);
    return h(y, "loc") && (S ? C.loc = null : C.loc = y.loc), h(y, "leadingComments") && (C.leadingComments = x(y.leadingComments, A, S, v)), h(y, "innerComments") && (C.innerComments = x(y.innerComments, A, S, v)), h(y, "trailingComments") && (C.trailingComments = x(y.trailingComments, A, S, v)), h(y, "extra") && (C.extra = Object.assign({}, y.extra)), C;
  }
  function x(y, A, S, v) {
    return !y || !A ? y : y.map((T) => {
      const C = v.get(T);
      if (C)
        return C;
      const {
        type: I,
        value: N,
        loc: D
      } = T, _ = {
        type: I,
        value: N,
        loc: D
      };
      return S && (_.loc = null), v.set(T, _), _;
    });
  }
  return ao;
}
var oo = {};
var wf;
function $b() {
  if (wf)
    return oo;
  wf = 1, Object.defineProperty(oo, "__esModule", {
    value: true
  }), oo.default = n;
  var s = xn();
  function n(h) {
    return (0, s.default)(h, false);
  }
  return oo;
}
var lo = {};
var If;
function qb() {
  if (If)
    return lo;
  If = 1, Object.defineProperty(lo, "__esModule", {
    value: true
  }), lo.default = n;
  var s = xn();
  function n(h) {
    return (0, s.default)(h);
  }
  return lo;
}
var uo = {};
var Nf;
function Vb() {
  if (Nf)
    return uo;
  Nf = 1, Object.defineProperty(uo, "__esModule", {
    value: true
  }), uo.default = n;
  var s = xn();
  function n(h) {
    return (0, s.default)(h, true, true);
  }
  return uo;
}
var co = {};
var kf;
function Kb() {
  if (kf)
    return co;
  kf = 1, Object.defineProperty(co, "__esModule", {
    value: true
  }), co.default = n;
  var s = xn();
  function n(h) {
    return (0, s.default)(h, false, true);
  }
  return co;
}
var po = {};
var fo = {};
var Of;
function Oy() {
  if (Of)
    return fo;
  Of = 1, Object.defineProperty(fo, "__esModule", {
    value: true
  }), fo.default = s;
  function s(n, h, f2) {
    if (!f2 || !n)
      return n;
    const p = `${h}Comments`;
    return n[p] ? h === "leading" ? n[p] = f2.concat(n[p]) : n[p].push(...f2) : n[p] = f2, n;
  }
  return fo;
}
var Df;
function Wb() {
  if (Df)
    return po;
  Df = 1, Object.defineProperty(po, "__esModule", {
    value: true
  }), po.default = n;
  var s = Oy();
  function n(h, f2, p, g) {
    return (0, s.default)(h, f2, [{
      type: g ? "CommentLine" : "CommentBlock",
      value: p
    }]);
  }
  return po;
}
var ho = {};
var mo = {};
var Lf;
function Jc() {
  if (Lf)
    return mo;
  Lf = 1, Object.defineProperty(mo, "__esModule", {
    value: true
  }), mo.default = s;
  function s(n, h, f2) {
    h && f2 && (h[n] = Array.from(new Set([].concat(h[n], f2[n]).filter(Boolean))));
  }
  return mo;
}
var Mf;
function Dy() {
  if (Mf)
    return ho;
  Mf = 1, Object.defineProperty(ho, "__esModule", {
    value: true
  }), ho.default = n;
  var s = Jc();
  function n(h, f2) {
    (0, s.default)("innerComments", h, f2);
  }
  return ho;
}
var yo = {};
var Bf;
function Ly() {
  if (Bf)
    return yo;
  Bf = 1, Object.defineProperty(yo, "__esModule", {
    value: true
  }), yo.default = n;
  var s = Jc();
  function n(h, f2) {
    (0, s.default)("leadingComments", h, f2);
  }
  return yo;
}
var bo = {};
var go = {};
var _f;
function My() {
  if (_f)
    return go;
  _f = 1, Object.defineProperty(go, "__esModule", {
    value: true
  }), go.default = n;
  var s = Jc();
  function n(h, f2) {
    (0, s.default)("trailingComments", h, f2);
  }
  return go;
}
var Ff;
function By() {
  if (Ff)
    return bo;
  Ff = 1, Object.defineProperty(bo, "__esModule", {
    value: true
  }), bo.default = f2;
  var s = My(), n = Ly(), h = Dy();
  function f2(p, g) {
    return (0, s.default)(p, g), (0, n.default)(p, g), (0, h.default)(p, g), p;
  }
  return bo;
}
var To = {};
var jf;
function Hb() {
  if (jf)
    return To;
  jf = 1, Object.defineProperty(To, "__esModule", {
    value: true
  }), To.default = n;
  var s = Tn();
  function n(h) {
    return s.COMMENT_KEYS.forEach((f2) => {
      h[f2] = null;
    }), h;
  }
  return To;
}
var Ue = {};
var Rf;
function zb() {
  if (Rf)
    return Ue;
  Rf = 1, Object.defineProperty(Ue, "__esModule", {
    value: true
  }), Ue.WHILE_TYPES = Ue.USERWHITESPACABLE_TYPES = Ue.UNARYLIKE_TYPES = Ue.TYPESCRIPT_TYPES = Ue.TSTYPE_TYPES = Ue.TSTYPEELEMENT_TYPES = Ue.TSENTITYNAME_TYPES = Ue.TSBASETYPE_TYPES = Ue.TERMINATORLESS_TYPES = Ue.STATEMENT_TYPES = Ue.STANDARDIZED_TYPES = Ue.SCOPABLE_TYPES = Ue.PUREISH_TYPES = Ue.PROPERTY_TYPES = Ue.PRIVATE_TYPES = Ue.PATTERN_TYPES = Ue.PATTERNLIKE_TYPES = Ue.OBJECTMEMBER_TYPES = Ue.MODULESPECIFIER_TYPES = Ue.MODULEDECLARATION_TYPES = Ue.MISCELLANEOUS_TYPES = Ue.METHOD_TYPES = Ue.LVAL_TYPES = Ue.LOOP_TYPES = Ue.LITERAL_TYPES = Ue.JSX_TYPES = Ue.IMMUTABLE_TYPES = Ue.FUNCTION_TYPES = Ue.FUNCTIONPARENT_TYPES = Ue.FOR_TYPES = Ue.FORXSTATEMENT_TYPES = Ue.FLOW_TYPES = Ue.FLOWTYPE_TYPES = Ue.FLOWPREDICATE_TYPES = Ue.FLOWDECLARATION_TYPES = Ue.FLOWBASEANNOTATION_TYPES = Ue.EXPRESSION_TYPES = Ue.EXPRESSIONWRAPPER_TYPES = Ue.EXPORTDECLARATION_TYPES = Ue.ENUMMEMBER_TYPES = Ue.ENUMBODY_TYPES = Ue.DECLARATION_TYPES = Ue.CONDITIONAL_TYPES = Ue.COMPLETIONSTATEMENT_TYPES = Ue.CLASS_TYPES = Ue.BLOCK_TYPES = Ue.BLOCKPARENT_TYPES = Ue.BINARY_TYPES = Ue.ACCESSOR_TYPES = void 0;
  var s = Ui();
  const n = s.FLIPPED_ALIAS_KEYS.Standardized;
  Ue.STANDARDIZED_TYPES = n;
  const h = s.FLIPPED_ALIAS_KEYS.Expression;
  Ue.EXPRESSION_TYPES = h;
  const f2 = s.FLIPPED_ALIAS_KEYS.Binary;
  Ue.BINARY_TYPES = f2;
  const p = s.FLIPPED_ALIAS_KEYS.Scopable;
  Ue.SCOPABLE_TYPES = p;
  const g = s.FLIPPED_ALIAS_KEYS.BlockParent;
  Ue.BLOCKPARENT_TYPES = g;
  const P = s.FLIPPED_ALIAS_KEYS.Block;
  Ue.BLOCK_TYPES = P;
  const x = s.FLIPPED_ALIAS_KEYS.Statement;
  Ue.STATEMENT_TYPES = x;
  const y = s.FLIPPED_ALIAS_KEYS.Terminatorless;
  Ue.TERMINATORLESS_TYPES = y;
  const A = s.FLIPPED_ALIAS_KEYS.CompletionStatement;
  Ue.COMPLETIONSTATEMENT_TYPES = A;
  const S = s.FLIPPED_ALIAS_KEYS.Conditional;
  Ue.CONDITIONAL_TYPES = S;
  const v = s.FLIPPED_ALIAS_KEYS.Loop;
  Ue.LOOP_TYPES = v;
  const T = s.FLIPPED_ALIAS_KEYS.While;
  Ue.WHILE_TYPES = T;
  const C = s.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
  Ue.EXPRESSIONWRAPPER_TYPES = C;
  const I = s.FLIPPED_ALIAS_KEYS.For;
  Ue.FOR_TYPES = I;
  const N = s.FLIPPED_ALIAS_KEYS.ForXStatement;
  Ue.FORXSTATEMENT_TYPES = N;
  const D = s.FLIPPED_ALIAS_KEYS.Function;
  Ue.FUNCTION_TYPES = D;
  const _ = s.FLIPPED_ALIAS_KEYS.FunctionParent;
  Ue.FUNCTIONPARENT_TYPES = _;
  const m = s.FLIPPED_ALIAS_KEYS.Pureish;
  Ue.PUREISH_TYPES = m;
  const L = s.FLIPPED_ALIAS_KEYS.Declaration;
  Ue.DECLARATION_TYPES = L;
  const R = s.FLIPPED_ALIAS_KEYS.PatternLike;
  Ue.PATTERNLIKE_TYPES = R;
  const O = s.FLIPPED_ALIAS_KEYS.LVal;
  Ue.LVAL_TYPES = O;
  const B = s.FLIPPED_ALIAS_KEYS.TSEntityName;
  Ue.TSENTITYNAME_TYPES = B;
  const M = s.FLIPPED_ALIAS_KEYS.Literal;
  Ue.LITERAL_TYPES = M;
  const j = s.FLIPPED_ALIAS_KEYS.Immutable;
  Ue.IMMUTABLE_TYPES = j;
  const $ = s.FLIPPED_ALIAS_KEYS.UserWhitespacable;
  Ue.USERWHITESPACABLE_TYPES = $;
  const k = s.FLIPPED_ALIAS_KEYS.Method;
  Ue.METHOD_TYPES = k;
  const ne = s.FLIPPED_ALIAS_KEYS.ObjectMember;
  Ue.OBJECTMEMBER_TYPES = ne;
  const Q = s.FLIPPED_ALIAS_KEYS.Property;
  Ue.PROPERTY_TYPES = Q;
  const q = s.FLIPPED_ALIAS_KEYS.UnaryLike;
  Ue.UNARYLIKE_TYPES = q;
  const ee = s.FLIPPED_ALIAS_KEYS.Pattern;
  Ue.PATTERN_TYPES = ee;
  const K = s.FLIPPED_ALIAS_KEYS.Class;
  Ue.CLASS_TYPES = K;
  const G = s.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
  Ue.MODULEDECLARATION_TYPES = G;
  const V = s.FLIPPED_ALIAS_KEYS.ExportDeclaration;
  Ue.EXPORTDECLARATION_TYPES = V;
  const F = s.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
  Ue.MODULESPECIFIER_TYPES = F;
  const le = s.FLIPPED_ALIAS_KEYS.Accessor;
  Ue.ACCESSOR_TYPES = le;
  const oe = s.FLIPPED_ALIAS_KEYS.Private;
  Ue.PRIVATE_TYPES = oe;
  const fe = s.FLIPPED_ALIAS_KEYS.Flow;
  Ue.FLOW_TYPES = fe;
  const he = s.FLIPPED_ALIAS_KEYS.FlowType;
  Ue.FLOWTYPE_TYPES = he;
  const de = s.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
  Ue.FLOWBASEANNOTATION_TYPES = de;
  const Pe = s.FLIPPED_ALIAS_KEYS.FlowDeclaration;
  Ue.FLOWDECLARATION_TYPES = Pe;
  const we = s.FLIPPED_ALIAS_KEYS.FlowPredicate;
  Ue.FLOWPREDICATE_TYPES = we;
  const H = s.FLIPPED_ALIAS_KEYS.EnumBody;
  Ue.ENUMBODY_TYPES = H;
  const te = s.FLIPPED_ALIAS_KEYS.EnumMember;
  Ue.ENUMMEMBER_TYPES = te;
  const Ie = s.FLIPPED_ALIAS_KEYS.JSX;
  Ue.JSX_TYPES = Ie;
  const Te = s.FLIPPED_ALIAS_KEYS.Miscellaneous;
  Ue.MISCELLANEOUS_TYPES = Te;
  const pe = s.FLIPPED_ALIAS_KEYS.TypeScript;
  Ue.TYPESCRIPT_TYPES = pe;
  const z = s.FLIPPED_ALIAS_KEYS.TSTypeElement;
  Ue.TSTYPEELEMENT_TYPES = z;
  const W = s.FLIPPED_ALIAS_KEYS.TSType;
  Ue.TSTYPE_TYPES = W;
  const ae = s.FLIPPED_ALIAS_KEYS.TSBaseType;
  return Ue.TSBASETYPE_TYPES = ae, Ue;
}
var xo = {};
var Po = {};
var Uf;
function _y() {
  if (Uf)
    return Po;
  Uf = 1, Object.defineProperty(Po, "__esModule", {
    value: true
  }), Po.default = h;
  var s = rr(), n = ys();
  function h(f2, p) {
    if ((0, s.isBlockStatement)(f2))
      return f2;
    let g = [];
    return (0, s.isEmptyStatement)(f2) ? g = [] : ((0, s.isStatement)(f2) || ((0, s.isFunction)(p) ? f2 = (0, n.returnStatement)(f2) : f2 = (0, n.expressionStatement)(f2)), g = [f2]), (0, n.blockStatement)(g);
  }
  return Po;
}
var $f;
function Gb() {
  if ($f)
    return xo;
  $f = 1, Object.defineProperty(xo, "__esModule", {
    value: true
  }), xo.default = n;
  var s = _y();
  function n(h, f2 = "body") {
    const p = (0, s.default)(h[f2], h);
    return h[f2] = p, p;
  }
  return xo;
}
var So = {};
var Eo = {};
var qf;
function Fy() {
  if (qf)
    return Eo;
  qf = 1, Object.defineProperty(Eo, "__esModule", {
    value: true
  }), Eo.default = h;
  var s = _a(), n = Ba();
  function h(f2) {
    f2 = f2 + "";
    let p = "";
    for (const g of f2)
      p += (0, n.isIdentifierChar)(g.codePointAt(0)) ? g : "-";
    return p = p.replace(/^[-0-9]+/, ""), p = p.replace(/[-\s]+(.)?/g, function(g, P) {
      return P ? P.toUpperCase() : "";
    }), (0, s.default)(p) || (p = `_${p}`), p || "_";
  }
  return Eo;
}
var Vf;
function Xb() {
  if (Vf)
    return So;
  Vf = 1, Object.defineProperty(So, "__esModule", {
    value: true
  }), So.default = n;
  var s = Fy();
  function n(h) {
    return h = (0, s.default)(h), (h === "eval" || h === "arguments") && (h = "_" + h), h;
  }
  return So;
}
var vo = {};
var Kf;
function Jb() {
  if (Kf)
    return vo;
  Kf = 1, Object.defineProperty(vo, "__esModule", {
    value: true
  }), vo.default = h;
  var s = rr(), n = ys();
  function h(f2, p = f2.key || f2.property) {
    return !f2.computed && (0, s.isIdentifier)(p) && (p = (0, n.stringLiteral)(p.name)), p;
  }
  return vo;
}
var ra = {};
var Wf;
function Yb() {
  if (Wf)
    return ra;
  Wf = 1, Object.defineProperty(ra, "__esModule", {
    value: true
  }), ra.default = void 0;
  var s = rr(), n = h;
  ra.default = n;
  function h(f2) {
    if ((0, s.isExpressionStatement)(f2) && (f2 = f2.expression), (0, s.isExpression)(f2))
      return f2;
    if ((0, s.isClass)(f2) ? f2.type = "ClassExpression" : (0, s.isFunction)(f2) && (f2.type = "FunctionExpression"), !(0, s.isExpression)(f2))
      throw new Error(`cannot turn ${f2.type} to an expression`);
    return f2;
  }
  return ra;
}
var Ao = {};
var Co = {};
var wo = {};
var Hf;
function jy() {
  if (Hf)
    return wo;
  Hf = 1, Object.defineProperty(wo, "__esModule", {
    value: true
  }), wo.default = n;
  var s = Ui();
  function n(h, f2, p) {
    if (!h)
      return;
    const g = s.VISITOR_KEYS[h.type];
    if (!!g) {
      p = p || {}, f2(h, p);
      for (const P of g) {
        const x = h[P];
        if (Array.isArray(x))
          for (const y of x)
            n(y, f2, p);
        else
          n(x, f2, p);
      }
    }
  }
  return wo;
}
var Io = {};
var zf;
function Ry() {
  if (zf)
    return Io;
  zf = 1, Object.defineProperty(Io, "__esModule", {
    value: true
  }), Io.default = f2;
  var s = Tn();
  const n = ["tokens", "start", "end", "loc", "raw", "rawValue"], h = [...s.COMMENT_KEYS, "comments", ...n];
  function f2(p, g = {}) {
    const P = g.preserveComments ? n : h;
    for (const y of P)
      p[y] != null && (p[y] = void 0);
    for (const y of Object.keys(p))
      y[0] === "_" && p[y] != null && (p[y] = void 0);
    const x = Object.getOwnPropertySymbols(p);
    for (const y of x)
      p[y] = null;
  }
  return Io;
}
var Gf;
function Uy() {
  if (Gf)
    return Co;
  Gf = 1, Object.defineProperty(Co, "__esModule", {
    value: true
  }), Co.default = h;
  var s = jy(), n = Ry();
  function h(f2, p) {
    return (0, s.default)(f2, n.default, p), f2;
  }
  return Co;
}
var Xf;
function Qb() {
  if (Xf)
    return Ao;
  Xf = 1, Object.defineProperty(Ao, "__esModule", {
    value: true
  }), Ao.default = f2;
  var s = rr(), n = xn(), h = Uy();
  function f2(p, g = p.key) {
    let P;
    return p.kind === "method" ? f2.increment() + "" : ((0, s.isIdentifier)(g) ? P = g.name : (0, s.isStringLiteral)(g) ? P = JSON.stringify(g.value) : P = JSON.stringify((0, h.default)((0, n.default)(g))), p.computed && (P = `[${P}]`), p.static && (P = `static:${P}`), P);
  }
  return f2.uid = 0, f2.increment = function() {
    return f2.uid >= Number.MAX_SAFE_INTEGER ? f2.uid = 0 : f2.uid++;
  }, Ao;
}
var No = {};
var ko = {};
var Oo = {};
var Jf;
function Ml() {
  if (Jf)
    return Oo;
  Jf = 1, Object.defineProperty(Oo, "__esModule", {
    value: true
  }), Oo.default = n;
  var s = rr();
  function n(h, f2, p) {
    const g = [].concat(h), P = /* @__PURE__ */ Object.create(null);
    for (; g.length; ) {
      const x = g.shift();
      if (!x)
        continue;
      const y = n.keys[x.type];
      if ((0, s.isIdentifier)(x)) {
        f2 ? (P[x.name] = P[x.name] || []).push(x) : P[x.name] = x;
        continue;
      }
      if ((0, s.isExportDeclaration)(x) && !(0, s.isExportAllDeclaration)(x)) {
        (0, s.isDeclaration)(x.declaration) && g.push(x.declaration);
        continue;
      }
      if (p) {
        if ((0, s.isFunctionDeclaration)(x)) {
          g.push(x.id);
          continue;
        }
        if ((0, s.isFunctionExpression)(x))
          continue;
      }
      if (y)
        for (let A = 0; A < y.length; A++) {
          const S = y[A], v = x[S];
          v && (Array.isArray(v) ? g.push(...v) : g.push(v));
        }
    }
    return P;
  }
  return n.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  }, Oo;
}
var Yf;
function Zb() {
  if (Yf)
    return ko;
  Yf = 1, Object.defineProperty(ko, "__esModule", {
    value: true
  }), ko.default = p;
  var s = Ml(), n = rr(), h = ys(), f2 = xn();
  function p(g, P, x) {
    const y = [];
    let A = true;
    for (const S of g)
      if ((0, n.isEmptyStatement)(S) || (A = false), (0, n.isExpression)(S))
        y.push(S);
      else if ((0, n.isExpressionStatement)(S))
        y.push(S.expression);
      else if ((0, n.isVariableDeclaration)(S)) {
        if (S.kind !== "var")
          return;
        for (const v of S.declarations) {
          const T = (0, s.default)(v);
          for (const C of Object.keys(T))
            x.push({
              kind: S.kind,
              id: (0, f2.default)(T[C])
            });
          v.init && y.push((0, h.assignmentExpression)("=", v.id, v.init));
        }
        A = true;
      } else if ((0, n.isIfStatement)(S)) {
        const v = S.consequent ? p([S.consequent], P, x) : P.buildUndefinedNode(), T = S.alternate ? p([S.alternate], P, x) : P.buildUndefinedNode();
        if (!v || !T)
          return;
        y.push((0, h.conditionalExpression)(S.test, v, T));
      } else if ((0, n.isBlockStatement)(S)) {
        const v = p(S.body, P, x);
        if (!v)
          return;
        y.push(v);
      } else if ((0, n.isEmptyStatement)(S))
        g.indexOf(S) === 0 && (A = true);
      else
        return;
    return A && y.push(P.buildUndefinedNode()), y.length === 1 ? y[0] : (0, h.sequenceExpression)(y);
  }
  return ko;
}
var Qf;
function eg() {
  if (Qf)
    return No;
  Qf = 1, Object.defineProperty(No, "__esModule", {
    value: true
  }), No.default = n;
  var s = Zb();
  function n(h, f2) {
    if (!(h != null && h.length))
      return;
    const p = [], g = (0, s.default)(h, f2, p);
    if (!!g) {
      for (const P of p)
        f2.push(P);
      return g;
    }
  }
  return No;
}
var sa = {};
var Zf;
function tg() {
  if (Zf)
    return sa;
  Zf = 1, Object.defineProperty(sa, "__esModule", {
    value: true
  }), sa.default = void 0;
  var s = rr(), n = ys(), h = f2;
  sa.default = h;
  function f2(p, g) {
    if ((0, s.isStatement)(p))
      return p;
    let P = false, x;
    if ((0, s.isClass)(p))
      P = true, x = "ClassDeclaration";
    else if ((0, s.isFunction)(p))
      P = true, x = "FunctionDeclaration";
    else if ((0, s.isAssignmentExpression)(p))
      return (0, n.expressionStatement)(p);
    if (P && !p.id && (x = false), !x) {
      if (g)
        return false;
      throw new Error(`cannot turn ${p.type} to a statement`);
    }
    return p.type = x, p;
  }
  return sa;
}
var ia = {};
var eh;
function rg() {
  if (eh)
    return ia;
  eh = 1, Object.defineProperty(ia, "__esModule", {
    value: true
  }), ia.default = void 0;
  var s = _a(), n = ys(), h = P;
  ia.default = h;
  const f2 = Function.call.bind(Object.prototype.toString);
  function p(x) {
    return f2(x) === "[object RegExp]";
  }
  function g(x) {
    if (typeof x != "object" || x === null || Object.prototype.toString.call(x) !== "[object Object]")
      return false;
    const y = Object.getPrototypeOf(x);
    return y === null || Object.getPrototypeOf(y) === null;
  }
  function P(x) {
    if (x === void 0)
      return (0, n.identifier)("undefined");
    if (x === true || x === false)
      return (0, n.booleanLiteral)(x);
    if (x === null)
      return (0, n.nullLiteral)();
    if (typeof x == "string")
      return (0, n.stringLiteral)(x);
    if (typeof x == "number") {
      let y;
      if (Number.isFinite(x))
        y = (0, n.numericLiteral)(Math.abs(x));
      else {
        let A;
        Number.isNaN(x) ? A = (0, n.numericLiteral)(0) : A = (0, n.numericLiteral)(1), y = (0, n.binaryExpression)("/", A, (0, n.numericLiteral)(0));
      }
      return (x < 0 || Object.is(x, -0)) && (y = (0, n.unaryExpression)("-", y)), y;
    }
    if (p(x)) {
      const y = x.source, A = x.toString().match(/\/([a-z]+|)$/)[1];
      return (0, n.regExpLiteral)(y, A);
    }
    if (Array.isArray(x))
      return (0, n.arrayExpression)(x.map(P));
    if (g(x)) {
      const y = [];
      for (const A of Object.keys(x)) {
        let S;
        (0, s.default)(A) ? S = (0, n.identifier)(A) : S = (0, n.stringLiteral)(A), y.push((0, n.objectProperty)(S, P(x[A])));
      }
      return (0, n.objectExpression)(y);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return ia;
}
var Do = {};
var th;
function sg() {
  if (th)
    return Do;
  th = 1, Object.defineProperty(Do, "__esModule", {
    value: true
  }), Do.default = n;
  var s = ys();
  function n(h, f2, p = false) {
    return h.object = (0, s.memberExpression)(h.object, h.property, h.computed), h.property = f2, h.computed = !!p, h;
  }
  return Do;
}
var Lo = {};
var rh;
function ig() {
  if (rh)
    return Lo;
  rh = 1, Object.defineProperty(Lo, "__esModule", {
    value: true
  }), Lo.default = h;
  var s = Tn(), n = By();
  function h(f2, p) {
    if (!f2 || !p)
      return f2;
    for (const g of s.INHERIT_KEYS.optional)
      f2[g] == null && (f2[g] = p[g]);
    for (const g of Object.keys(p))
      g[0] === "_" && g !== "__clone" && (f2[g] = p[g]);
    for (const g of s.INHERIT_KEYS.force)
      f2[g] = p[g];
    return (0, n.default)(f2, p), f2;
  }
  return Lo;
}
var Mo = {};
var sh;
function ng() {
  if (sh)
    return Mo;
  sh = 1, Object.defineProperty(Mo, "__esModule", {
    value: true
  }), Mo.default = h;
  var s = ys(), n = Je();
  function h(f2, p) {
    if ((0, n.isSuper)(f2.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return f2.object = (0, s.memberExpression)(p, f2.object), f2;
  }
  return Mo;
}
var na = {};
var ih;
function ag() {
  if (ih)
    return na;
  ih = 1, Object.defineProperty(na, "__esModule", {
    value: true
  }), na.default = void 0;
  var s = Ml(), n = h;
  na.default = n;
  function h(f2, p) {
    return (0, s.default)(f2, p, true);
  }
  return na;
}
var Bo = {};
var nh;
function og() {
  if (nh)
    return Bo;
  nh = 1, Object.defineProperty(Bo, "__esModule", {
    value: true
  }), Bo.default = n;
  var s = Ui();
  function n(f2, p, g) {
    typeof p == "function" && (p = {
      enter: p
    });
    const {
      enter: P,
      exit: x
    } = p;
    h(f2, P, x, g, []);
  }
  function h(f2, p, g, P, x) {
    const y = s.VISITOR_KEYS[f2.type];
    if (!!y) {
      p && p(f2, x, P);
      for (const A of y) {
        const S = f2[A];
        if (Array.isArray(S))
          for (let v = 0; v < S.length; v++) {
            const T = S[v];
            !T || (x.push({
              node: f2,
              key: A,
              index: v
            }), h(T, p, g, P, x), x.pop());
          }
        else
          S && (x.push({
            node: f2,
            key: A
          }), h(S, p, g, P, x), x.pop());
      }
      g && g(f2, x, P);
    }
  }
  return Bo;
}
var _o = {};
var ah;
function lg() {
  if (ah)
    return _o;
  ah = 1, Object.defineProperty(_o, "__esModule", {
    value: true
  }), _o.default = n;
  var s = Ml();
  function n(h, f2, p) {
    if (p && h.type === "Identifier" && f2.type === "ObjectProperty" && p.type === "ObjectExpression")
      return false;
    const g = s.default.keys[f2.type];
    if (g)
      for (let P = 0; P < g.length; P++) {
        const x = g[P], y = f2[x];
        if (Array.isArray(y)) {
          if (y.indexOf(h) >= 0)
            return true;
        } else if (y === h)
          return true;
      }
    return false;
  }
  return _o;
}
var Fo = {};
var jo = {};
var oh;
function $y() {
  if (oh)
    return jo;
  oh = 1, Object.defineProperty(jo, "__esModule", {
    value: true
  }), jo.default = h;
  var s = rr(), n = Tn();
  function h(f2) {
    return (0, s.isVariableDeclaration)(f2) && (f2.kind !== "var" || f2[n.BLOCK_SCOPED_SYMBOL]);
  }
  return jo;
}
var lh;
function ug() {
  if (lh)
    return Fo;
  lh = 1, Object.defineProperty(Fo, "__esModule", {
    value: true
  }), Fo.default = h;
  var s = rr(), n = $y();
  function h(f2) {
    return (0, s.isFunctionDeclaration)(f2) || (0, s.isClassDeclaration)(f2) || (0, n.default)(f2);
  }
  return Fo;
}
var Ro = {};
var uh;
function cg() {
  if (uh)
    return Ro;
  uh = 1, Object.defineProperty(Ro, "__esModule", {
    value: true
  }), Ro.default = h;
  var s = Gc(), n = rr();
  function h(f2) {
    return (0, s.default)(f2.type, "Immutable") ? true : (0, n.isIdentifier)(f2) ? f2.name === "undefined" : false;
  }
  return Ro;
}
var Uo = {};
var ch;
function pg() {
  if (ch)
    return Uo;
  ch = 1, Object.defineProperty(Uo, "__esModule", {
    value: true
  }), Uo.default = n;
  var s = Ui();
  function n(h, f2) {
    if (typeof h != "object" || typeof f2 != "object" || h == null || f2 == null)
      return h === f2;
    if (h.type !== f2.type)
      return false;
    const p = Object.keys(s.NODE_FIELDS[h.type] || h.type), g = s.VISITOR_KEYS[h.type];
    for (const P of p) {
      const x = h[P], y = f2[P];
      if (typeof x != typeof y)
        return false;
      if (!(x == null && y == null)) {
        if (x == null || y == null)
          return false;
        if (Array.isArray(x)) {
          if (!Array.isArray(y) || x.length !== y.length)
            return false;
          for (let A = 0; A < x.length; A++)
            if (!n(x[A], y[A]))
              return false;
          continue;
        }
        if (typeof x == "object" && !(g != null && g.includes(P))) {
          for (const A of Object.keys(x))
            if (x[A] !== y[A])
              return false;
          continue;
        }
        if (!n(x, y))
          return false;
      }
    }
    return true;
  }
  return Uo;
}
var $o = {};
var ph;
function fg() {
  if (ph)
    return $o;
  ph = 1, Object.defineProperty($o, "__esModule", {
    value: true
  }), $o.default = s;
  function s(n, h, f2) {
    switch (h.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return h.property === n ? !!h.computed : h.object === n;
      case "JSXMemberExpression":
        return h.object === n;
      case "VariableDeclarator":
        return h.init === n;
      case "ArrowFunctionExpression":
        return h.body === n;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return h.key === n ? !!h.computed : false;
      case "ObjectProperty":
        return h.key === n ? !!h.computed : !f2 || f2.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return h.key === n ? !!h.computed : true;
      case "ClassPrivateProperty":
        return h.key !== n;
      case "ClassDeclaration":
      case "ClassExpression":
        return h.superClass === n;
      case "AssignmentExpression":
        return h.right === n;
      case "AssignmentPattern":
        return h.right === n;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        return f2 != null && f2.source ? false : h.local === n;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return h.key !== n;
      case "TSEnumMember":
        return h.id !== n;
      case "TSPropertySignature":
        return h.key === n ? !!h.computed : true;
    }
    return true;
  }
  return $o;
}
var qo = {};
var fh;
function hg() {
  if (fh)
    return qo;
  fh = 1, Object.defineProperty(qo, "__esModule", {
    value: true
  }), qo.default = n;
  var s = rr();
  function n(h, f2) {
    return (0, s.isBlockStatement)(h) && ((0, s.isFunction)(f2) || (0, s.isCatchClause)(f2)) ? false : (0, s.isPattern)(h) && ((0, s.isFunction)(f2) || (0, s.isCatchClause)(f2)) ? true : (0, s.isScopable)(h);
  }
  return qo;
}
var Vo = {};
var hh;
function dg() {
  if (hh)
    return Vo;
  hh = 1, Object.defineProperty(Vo, "__esModule", {
    value: true
  }), Vo.default = n;
  var s = rr();
  function n(h) {
    return (0, s.isImportDefaultSpecifier)(h) || (0, s.isIdentifier)(h.imported || h.exported, {
      name: "default"
    });
  }
  return Vo;
}
var Ko = {};
var dh;
function mg() {
  if (dh)
    return Ko;
  dh = 1, Object.defineProperty(Ko, "__esModule", {
    value: true
  }), Ko.default = h;
  var s = _a();
  const n = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function h(f2) {
    return (0, s.default)(f2) && !n.has(f2);
  }
  return Ko;
}
var Wo = {};
var mh;
function yg() {
  if (mh)
    return Wo;
  mh = 1, Object.defineProperty(Wo, "__esModule", {
    value: true
  }), Wo.default = h;
  var s = rr(), n = Tn();
  function h(f2) {
    return (0, s.isVariableDeclaration)(f2, {
      kind: "var"
    }) && !f2[n.BLOCK_SCOPED_SYMBOL];
  }
  return Wo;
}
var yh = {};
var bh;
function bg() {
  return bh || (bh = 1), yh;
}
var gh;
function Je() {
  return gh || (gh = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    });
    var n = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true
    };
    Object.defineProperty(s, "addComment", {
      enumerable: true,
      get: function() {
        return _.default;
      }
    }), Object.defineProperty(s, "addComments", {
      enumerable: true,
      get: function() {
        return m.default;
      }
    }), Object.defineProperty(s, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return fe.default;
      }
    }), Object.defineProperty(s, "assertNode", {
      enumerable: true,
      get: function() {
        return g.default;
      }
    }), Object.defineProperty(s, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return et.default;
      }
    }), Object.defineProperty(s, "clone", {
      enumerable: true,
      get: function() {
        return C.default;
      }
    }), Object.defineProperty(s, "cloneDeep", {
      enumerable: true,
      get: function() {
        return I.default;
      }
    }), Object.defineProperty(s, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return N.default;
      }
    }), Object.defineProperty(s, "cloneNode", {
      enumerable: true,
      get: function() {
        return T.default;
      }
    }), Object.defineProperty(s, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return D.default;
      }
    }), Object.defineProperty(s, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(s, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return A.default;
      }
    }), Object.defineProperty(s, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(s, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(s, "ensureBlock", {
      enumerable: true,
      get: function() {
        return k.default;
      }
    }), Object.defineProperty(s, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return te.default;
      }
    }), Object.defineProperty(s, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return Ie.default;
      }
    }), Object.defineProperty(s, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return L.default;
      }
    }), Object.defineProperty(s, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return R.default;
      }
    }), Object.defineProperty(s, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return B.default;
      }
    }), Object.defineProperty(s, "inherits", {
      enumerable: true,
      get: function() {
        return he.default;
      }
    }), Object.defineProperty(s, "inheritsComments", {
      enumerable: true,
      get: function() {
        return O.default;
      }
    }), Object.defineProperty(s, "is", {
      enumerable: true,
      get: function() {
        return W.default;
      }
    }), Object.defineProperty(s, "isBinding", {
      enumerable: true,
      get: function() {
        return ae.default;
      }
    }), Object.defineProperty(s, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return ce.default;
      }
    }), Object.defineProperty(s, "isImmutable", {
      enumerable: true,
      get: function() {
        return xe.default;
      }
    }), Object.defineProperty(s, "isLet", {
      enumerable: true,
      get: function() {
        return Se.default;
      }
    }), Object.defineProperty(s, "isNode", {
      enumerable: true,
      get: function() {
        return Le.default;
      }
    }), Object.defineProperty(s, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return Ee.default;
      }
    }), Object.defineProperty(s, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return J.default;
      }
    }), Object.defineProperty(s, "isReferenced", {
      enumerable: true,
      get: function() {
        return me.default;
      }
    }), Object.defineProperty(s, "isScope", {
      enumerable: true,
      get: function() {
        return ke.default;
      }
    }), Object.defineProperty(s, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _e.default;
      }
    }), Object.defineProperty(s, "isType", {
      enumerable: true,
      get: function() {
        return Re.default;
      }
    }), Object.defineProperty(s, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return $e.default;
      }
    }), Object.defineProperty(s, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return Ge.default;
      }
    }), Object.defineProperty(s, "isVar", {
      enumerable: true,
      get: function() {
        return lt.default;
      }
    }), Object.defineProperty(s, "matchesPattern", {
      enumerable: true,
      get: function() {
        return Ze.default;
      }
    }), Object.defineProperty(s, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return de.default;
      }
    }), s.react = void 0, Object.defineProperty(s, "removeComments", {
      enumerable: true,
      get: function() {
        return M.default;
      }
    }), Object.defineProperty(s, "removeProperties", {
      enumerable: true,
      get: function() {
        return Pe.default;
      }
    }), Object.defineProperty(s, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return we.default;
      }
    }), Object.defineProperty(s, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return H.default;
      }
    }), Object.defineProperty(s, "shallowEqual", {
      enumerable: true,
      get: function() {
        return z.default;
      }
    }), Object.defineProperty(s, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return ne.default;
      }
    }), Object.defineProperty(s, "toBlock", {
      enumerable: true,
      get: function() {
        return Q.default;
      }
    }), Object.defineProperty(s, "toComputedKey", {
      enumerable: true,
      get: function() {
        return q.default;
      }
    }), Object.defineProperty(s, "toExpression", {
      enumerable: true,
      get: function() {
        return ee.default;
      }
    }), Object.defineProperty(s, "toIdentifier", {
      enumerable: true,
      get: function() {
        return K.default;
      }
    }), Object.defineProperty(s, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return G.default;
      }
    }), Object.defineProperty(s, "toSequenceExpression", {
      enumerable: true,
      get: function() {
        return V.default;
      }
    }), Object.defineProperty(s, "toStatement", {
      enumerable: true,
      get: function() {
        return F.default;
      }
    }), Object.defineProperty(s, "traverse", {
      enumerable: true,
      get: function() {
        return Te.default;
      }
    }), Object.defineProperty(s, "traverseFast", {
      enumerable: true,
      get: function() {
        return pe.default;
      }
    }), Object.defineProperty(s, "validate", {
      enumerable: true,
      get: function() {
        return Xe.default;
      }
    }), Object.defineProperty(s, "valueToNode", {
      enumerable: true,
      get: function() {
        return le.default;
      }
    });
    var h = Pb(), f2 = Sb(), p = Lb(), g = Mb(), P = Bb();
    Object.keys(P).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === P[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return P[ue];
        }
      });
    });
    var x = _b(), y = Fb(), A = Rb(), S = ys();
    Object.keys(S).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === S[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return S[ue];
        }
      });
    });
    var v = Ub();
    Object.keys(v).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === v[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return v[ue];
        }
      });
    });
    var T = xn(), C = $b(), I = qb(), N = Vb(), D = Kb(), _ = Wb(), m = Oy(), L = Dy(), R = Ly(), O = By(), B = My(), M = Hb(), j = zb();
    Object.keys(j).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === j[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return j[ue];
        }
      });
    });
    var $ = Tn();
    Object.keys($).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === $[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return $[ue];
        }
      });
    });
    var k = Gb(), ne = Xb(), Q = _y(), q = Jb(), ee = Yb(), K = Fy(), G = Qb(), V = eg(), F = tg(), le = rg(), oe = Ui();
    Object.keys(oe).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === oe[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return oe[ue];
        }
      });
    });
    var fe = sg(), he = ig(), de = ng(), Pe = Ry(), we = Uy(), H = ky(), te = Ml(), Ie = ag(), Te = og();
    Object.keys(Te).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === Te[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return Te[ue];
        }
      });
    });
    var pe = jy(), z = zc(), W = Ma(), ae = lg(), ce = ug(), xe = cg(), Se = $y(), Le = Ny(), Ee = pg(), J = Cy(), me = fg(), ke = hg(), _e = dg(), Re = Gc(), $e = mg(), Ge = _a(), lt = yg(), Ze = vy(), Xe = Xc(), et = Ay(), st = rr();
    Object.keys(st).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === st[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return st[ue];
        }
      });
    });
    var re = bg();
    Object.keys(re).forEach(function(ue) {
      ue === "default" || ue === "__esModule" || Object.prototype.hasOwnProperty.call(n, ue) || ue in s && s[ue] === re[ue] || Object.defineProperty(s, ue, {
        enumerable: true,
        get: function() {
          return re[ue];
        }
      });
    });
    const be = {
      isReactComponent: h.default,
      isCompatTag: f2.default,
      buildChildren: p.default
    };
    s.react = be;
  }(Bu)), Bu;
}
var Th;
function qy() {
  if (Th)
    return tt;
  Th = 1, Object.defineProperty(tt, "__esModule", {
    value: true
  }), tt.Var = tt.User = tt.Statement = tt.SpreadProperty = tt.Scope = tt.RestProperty = tt.ReferencedMemberExpression = tt.ReferencedIdentifier = tt.Referenced = tt.Pure = tt.NumericLiteralTypeAnnotation = tt.Generated = tt.ForAwaitStatement = tt.Flow = tt.Expression = tt.ExistentialTypeParam = tt.BlockScoped = tt.BindingIdentifier = void 0;
  var s = Je();
  const {
    isBinding: n,
    isBlockScoped: h,
    isExportDeclaration: f2,
    isExpression: p,
    isFlow: g,
    isForStatement: P,
    isForXStatement: x,
    isIdentifier: y,
    isImportDeclaration: A,
    isImportSpecifier: S,
    isJSXIdentifier: v,
    isJSXMemberExpression: T,
    isMemberExpression: C,
    isReferenced: I,
    isScope: N,
    isStatement: D,
    isVar: _,
    isVariableDeclaration: m,
    react: L
  } = s, {
    isCompatTag: R
  } = L, O = {
    types: ["Identifier", "JSXIdentifier"],
    checkPath(de, Pe) {
      const {
        node: we,
        parent: H
      } = de;
      if (!y(we, Pe) && !T(H, Pe))
        if (v(we, Pe)) {
          if (R(we.name))
            return false;
        } else
          return false;
      return I(we, H, de.parentPath.parent);
    }
  };
  tt.ReferencedIdentifier = O;
  const B = {
    types: ["MemberExpression"],
    checkPath({
      node: de,
      parent: Pe
    }) {
      return C(de) && I(de, Pe);
    }
  };
  tt.ReferencedMemberExpression = B;
  const M = {
    types: ["Identifier"],
    checkPath(de) {
      const {
        node: Pe,
        parent: we
      } = de, H = de.parentPath.parent;
      return y(Pe) && n(Pe, we, H);
    }
  };
  tt.BindingIdentifier = M;
  const j = {
    types: ["Statement"],
    checkPath({
      node: de,
      parent: Pe
    }) {
      return D(de) ? !(m(de) && (x(Pe, {
        left: de
      }) || P(Pe, {
        init: de
      }))) : false;
    }
  };
  tt.Statement = j;
  const $ = {
    types: ["Expression"],
    checkPath(de) {
      return de.isIdentifier() ? de.isReferencedIdentifier() : p(de.node);
    }
  };
  tt.Expression = $;
  const k = {
    types: ["Scopable", "Pattern"],
    checkPath(de) {
      return N(de.node, de.parent);
    }
  };
  tt.Scope = k;
  const ne = {
    checkPath(de) {
      return I(de.node, de.parent);
    }
  };
  tt.Referenced = ne;
  const Q = {
    checkPath(de) {
      return h(de.node);
    }
  };
  tt.BlockScoped = Q;
  const q = {
    types: ["VariableDeclaration"],
    checkPath(de) {
      return _(de.node);
    }
  };
  tt.Var = q;
  const ee = {
    checkPath(de) {
      return de.node && !!de.node.loc;
    }
  };
  tt.User = ee;
  const K = {
    checkPath(de) {
      return !de.isUser();
    }
  };
  tt.Generated = K;
  const G = {
    checkPath(de, Pe) {
      return de.scope.isPure(de.node, Pe);
    }
  };
  tt.Pure = G;
  const V = {
    types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
    checkPath({
      node: de
    }) {
      return g(de) ? true : A(de) ? de.importKind === "type" || de.importKind === "typeof" : f2(de) ? de.exportKind === "type" : S(de) ? de.importKind === "type" || de.importKind === "typeof" : false;
    }
  };
  tt.Flow = V;
  const F = {
    types: ["RestElement"],
    checkPath(de) {
      return de.parentPath && de.parentPath.isObjectPattern();
    }
  };
  tt.RestProperty = F;
  const le = {
    types: ["RestElement"],
    checkPath(de) {
      return de.parentPath && de.parentPath.isObjectExpression();
    }
  };
  tt.SpreadProperty = le;
  const oe = {
    types: ["ExistsTypeAnnotation"]
  };
  tt.ExistentialTypeParam = oe;
  const fe = {
    types: ["NumberLiteralTypeAnnotation"]
  };
  tt.NumericLiteralTypeAnnotation = fe;
  const he = {
    types: ["ForOfStatement"],
    checkPath({
      node: de
    }) {
      return de.await === true;
    }
  };
  return tt.ForAwaitStatement = he, tt;
}
var xh;
function Vy() {
  if (xh)
    return vn;
  xh = 1, Object.defineProperty(vn, "__esModule", {
    value: true
  }), vn.explode = g, vn.merge = y, vn.verify = P;
  var s = qy(), n = Je();
  const {
    DEPRECATED_KEYS: h,
    FLIPPED_ALIAS_KEYS: f2,
    TYPES: p
  } = n;
  function g(N) {
    if (N._exploded)
      return N;
    N._exploded = true;
    for (const D of Object.keys(N)) {
      if (C(D))
        continue;
      const _ = D.split("|");
      if (_.length === 1)
        continue;
      const m = N[D];
      delete N[D];
      for (const L of _)
        N[L] = m;
    }
    P(N), delete N.__esModule, S(N), v(N);
    for (const D of Object.keys(N)) {
      if (C(D))
        continue;
      const _ = s[D];
      if (!_)
        continue;
      const m = N[D];
      for (const L of Object.keys(m))
        m[L] = T(_, m[L]);
      if (delete N[D], _.types)
        for (const L of _.types)
          N[L] ? I(N[L], m) : N[L] = m;
      else
        I(N, m);
    }
    for (const D of Object.keys(N)) {
      if (C(D))
        continue;
      const _ = N[D];
      let m = f2[D];
      const L = h[D];
      if (L && (console.trace(`Visitor defined for ${D} but it has been renamed to ${L}`), m = [L]), !!m) {
        delete N[D];
        for (const R of m) {
          const O = N[R];
          O ? I(O, _) : N[R] = Object.assign({}, _);
        }
      }
    }
    for (const D of Object.keys(N))
      C(D) || v(N[D]);
    return N;
  }
  function P(N) {
    if (!N._verified) {
      if (typeof N == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      for (const D of Object.keys(N)) {
        if ((D === "enter" || D === "exit") && x(D, N[D]), C(D))
          continue;
        if (p.indexOf(D) < 0)
          throw new Error(`You gave us a visitor for the node type ${D} but it's not a valid type`);
        const _ = N[D];
        if (typeof _ == "object")
          for (const m of Object.keys(_))
            if (m === "enter" || m === "exit")
              x(`${D}.${m}`, _[m]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${D} that has the invalid property ${m}`);
      }
      N._verified = true;
    }
  }
  function x(N, D) {
    const _ = [].concat(D);
    for (const m of _)
      if (typeof m != "function")
        throw new TypeError(`Non-function found defined in ${N} with type ${typeof m}`);
  }
  function y(N, D = [], _) {
    const m = {};
    for (let L = 0; L < N.length; L++) {
      const R = N[L], O = D[L];
      g(R);
      for (const B of Object.keys(R)) {
        let M = R[B];
        (O || _) && (M = A(M, O, _));
        const j = m[B] = m[B] || {};
        I(j, M);
      }
    }
    return m;
  }
  function A(N, D, _) {
    const m = {};
    for (const L of Object.keys(N)) {
      let R = N[L];
      !Array.isArray(R) || (R = R.map(function(O) {
        let B = O;
        return D && (B = function(M) {
          return O.call(D, M, D);
        }), _ && (B = _(D.key, L, B)), B !== O && (B.toString = () => O.toString()), B;
      }), m[L] = R);
    }
    return m;
  }
  function S(N) {
    for (const D of Object.keys(N)) {
      if (C(D))
        continue;
      const _ = N[D];
      typeof _ == "function" && (N[D] = {
        enter: _
      });
    }
  }
  function v(N) {
    N.enter && !Array.isArray(N.enter) && (N.enter = [N.enter]), N.exit && !Array.isArray(N.exit) && (N.exit = [N.exit]);
  }
  function T(N, D) {
    const _ = function(m) {
      if (N.checkPath(m))
        return D.apply(this, arguments);
    };
    return _.toString = () => D.toString(), _;
  }
  function C(N) {
    return N[0] === "_" || N === "enter" || N === "exit" || N === "shouldSkip" || N === "denylist" || N === "noScope" || N === "skipKeys" || N === "blacklist";
  }
  function I(N, D) {
    for (const _ of Object.keys(D))
      N[_] = [].concat(N[_] || [], D[_]);
  }
  return vn;
}
var gs = {};
var Ph;
function Wn() {
  if (Ph)
    return gs;
  Ph = 1, Object.defineProperty(gs, "__esModule", {
    value: true
  }), gs.clear = h, gs.clearPath = f2, gs.clearScope = p, gs.scope = gs.path = void 0;
  let s = /* @__PURE__ */ new WeakMap();
  gs.path = s;
  let n = /* @__PURE__ */ new WeakMap();
  gs.scope = n;
  function h() {
    f2(), p();
  }
  function f2() {
    gs.path = s = /* @__PURE__ */ new WeakMap();
  }
  function p() {
    gs.scope = n = /* @__PURE__ */ new WeakMap();
  }
  return gs;
}
var Ho = {};
var aa = {};
var Ri = {};
var zo = { exports: {} };
var Uu;
var Sh;
function gg() {
  if (Sh)
    return Uu;
  Sh = 1;
  var s = 1e3, n = s * 60, h = n * 60, f2 = h * 24, p = f2 * 7, g = f2 * 365.25;
  Uu = function(S, v) {
    v = v || {};
    var T = typeof S;
    if (T === "string" && S.length > 0)
      return P(S);
    if (T === "number" && isFinite(S))
      return v.long ? y(S) : x(S);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(S));
  };
  function P(S) {
    if (S = String(S), !(S.length > 100)) {
      var v = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(S);
      if (!!v) {
        var T = parseFloat(v[1]), C = (v[2] || "ms").toLowerCase();
        switch (C) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return T * g;
          case "weeks":
          case "week":
          case "w":
            return T * p;
          case "days":
          case "day":
          case "d":
            return T * f2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return T * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return T * n;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return T * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return T;
          default:
            return;
        }
      }
    }
  }
  function x(S) {
    var v = Math.abs(S);
    return v >= f2 ? Math.round(S / f2) + "d" : v >= h ? Math.round(S / h) + "h" : v >= n ? Math.round(S / n) + "m" : v >= s ? Math.round(S / s) + "s" : S + "ms";
  }
  function y(S) {
    var v = Math.abs(S);
    return v >= f2 ? A(S, v, f2, "day") : v >= h ? A(S, v, h, "hour") : v >= n ? A(S, v, n, "minute") : v >= s ? A(S, v, s, "second") : S + " ms";
  }
  function A(S, v, T, C) {
    var I = v >= T * 1.5;
    return Math.round(S / T) + " " + C + (I ? "s" : "");
  }
  return Uu;
}
var $u;
var Eh;
function Tg() {
  if (Eh)
    return $u;
  Eh = 1;
  function s(n) {
    f2.debug = f2, f2.default = f2, f2.coerce = A, f2.disable = P, f2.enable = g, f2.enabled = x, f2.humanize = gg(), f2.destroy = S, Object.keys(n).forEach((v) => {
      f2[v] = n[v];
    }), f2.names = [], f2.skips = [], f2.formatters = {};
    function h(v) {
      let T = 0;
      for (let C = 0; C < v.length; C++)
        T = (T << 5) - T + v.charCodeAt(C), T |= 0;
      return f2.colors[Math.abs(T) % f2.colors.length];
    }
    f2.selectColor = h;
    function f2(v) {
      let T, C = null, I, N;
      function D(..._) {
        if (!D.enabled)
          return;
        const m = D, L = Number(/* @__PURE__ */ new Date()), R = L - (T || L);
        m.diff = R, m.prev = T, m.curr = L, T = L, _[0] = f2.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
        let O = 0;
        _[0] = _[0].replace(/%([a-zA-Z%])/g, (M, j) => {
          if (M === "%%")
            return "%";
          O++;
          const $ = f2.formatters[j];
          if (typeof $ == "function") {
            const k = _[O];
            M = $.call(m, k), _.splice(O, 1), O--;
          }
          return M;
        }), f2.formatArgs.call(m, _), (m.log || f2.log).apply(m, _);
      }
      return D.namespace = v, D.useColors = f2.useColors(), D.color = f2.selectColor(v), D.extend = p, D.destroy = f2.destroy, Object.defineProperty(D, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => C !== null ? C : (I !== f2.namespaces && (I = f2.namespaces, N = f2.enabled(v)), N),
        set: (_) => {
          C = _;
        }
      }), typeof f2.init == "function" && f2.init(D), D;
    }
    function p(v, T) {
      const C = f2(this.namespace + (typeof T > "u" ? ":" : T) + v);
      return C.log = this.log, C;
    }
    function g(v) {
      f2.save(v), f2.namespaces = v, f2.names = [], f2.skips = [];
      let T;
      const C = (typeof v == "string" ? v : "").split(/[\s,]+/), I = C.length;
      for (T = 0; T < I; T++)
        !C[T] || (v = C[T].replace(/\*/g, ".*?"), v[0] === "-" ? f2.skips.push(new RegExp("^" + v.slice(1) + "$")) : f2.names.push(new RegExp("^" + v + "$")));
    }
    function P() {
      const v = [
        ...f2.names.map(y),
        ...f2.skips.map(y).map((T) => "-" + T)
      ].join(",");
      return f2.enable(""), v;
    }
    function x(v) {
      if (v[v.length - 1] === "*")
        return true;
      let T, C;
      for (T = 0, C = f2.skips.length; T < C; T++)
        if (f2.skips[T].test(v))
          return false;
      for (T = 0, C = f2.names.length; T < C; T++)
        if (f2.names[T].test(v))
          return true;
      return false;
    }
    function y(v) {
      return v.toString().substring(2, v.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function A(v) {
      return v instanceof Error ? v.stack || v.message : v;
    }
    function S() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return f2.enable(f2.load()), f2;
  }
  return $u = s, $u;
}
var vh;
function Yc() {
  return vh || (vh = 1, function(s, n) {
    n.formatArgs = f2, n.save = p, n.load = g, n.useColors = h, n.storage = P(), n.destroy = (() => {
      let y = false;
      return () => {
        y || (y = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), n.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function h() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function f2(y) {
      if (y[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + y[0] + (this.useColors ? "%c " : " ") + "+" + s.exports.humanize(this.diff), !this.useColors)
        return;
      const A = "color: " + this.color;
      y.splice(1, 0, A, "color: inherit");
      let S = 0, v = 0;
      y[0].replace(/%[a-zA-Z%]/g, (T) => {
        T !== "%%" && (S++, T === "%c" && (v = S));
      }), y.splice(v, 0, A);
    }
    n.log = console.debug || console.log || (() => {
    });
    function p(y) {
      try {
        y ? n.storage.setItem("debug", y) : n.storage.removeItem("debug");
      } catch {
      }
    }
    function g() {
      let y;
      try {
        y = n.storage.getItem("debug");
      } catch {
      }
      return !y && typeof process < "u" && "env" in process && (y = process.env.DEBUG), y;
    }
    function P() {
      try {
        return localStorage;
      } catch {
      }
    }
    s.exports = Tg()(n);
    const { formatters: x } = s.exports;
    x.j = function(y) {
      try {
        return JSON.stringify(y);
      } catch (A) {
        return "[UnexpectedJSONParseError]: " + A.message;
      }
    };
  }(zo, zo.exports)), zo.exports;
}
var oa = {};
var la = {};
var ua = {};
var Ah;
function Ky() {
  if (Ah)
    return ua;
  Ah = 1, Object.defineProperty(ua, "__esModule", {
    value: true
  }), ua.default = void 0;
  class s {
    constructor({
      identifier: h,
      scope: f2,
      path: p,
      kind: g
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = h, this.scope = f2, this.path = p, this.kind = g, this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = true;
    }
    setValue(h) {
      this.hasDeoptedValue || (this.hasValue = true, this.value = h);
    }
    clearValue() {
      this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
    }
    reassign(h) {
      this.constant = false, this.constantViolations.indexOf(h) === -1 && this.constantViolations.push(h);
    }
    reference(h) {
      this.referencePaths.indexOf(h) === -1 && (this.referenced = true, this.references++, this.referencePaths.push(h));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  }
  return ua.default = s, ua;
}
var Fa = {};
Object.defineProperty(Fa, "__esModule", {
  value: true
});
Fa.default = Eg;
var xg = Je();
var {
  cloneNode: qu,
  exportNamedDeclaration: Ch,
  exportSpecifier: wh,
  identifier: Vu,
  variableDeclaration: Pg,
  variableDeclarator: Sg
} = xg;
function Eg(s) {
  if (!s.isExportDeclaration() || s.isExportAllDeclaration())
    throw new Error("Only default and named export declarations can be split.");
  if (s.isExportDefaultDeclaration()) {
    const g = s.get("declaration"), P = g.isFunctionDeclaration() || g.isClassDeclaration(), x = g.isScope() ? g.scope.parent : g.scope;
    let y = g.node.id, A = false;
    y || (A = true, y = x.generateUidIdentifier("default"), (P || g.isFunctionExpression() || g.isClassExpression()) && (g.node.id = qu(y)));
    const S = P ? g.node : Pg("var", [Sg(qu(y), g.node)]), v = Ch(null, [wh(qu(y), Vu("default"))]);
    return s.insertAfter(v), s.replaceWith(S), A && x.registerDeclaration(s), s;
  } else if (s.get("specifiers").length > 0)
    throw new Error("It doesn't make sense to split exported specifiers.");
  const n = s.get("declaration"), h = n.getOuterBindingIdentifiers(), f2 = Object.keys(h).map((g) => wh(Vu(g), Vu(g))), p = Ch(null, f2);
  return s.insertAfter(p), s.replaceWith(n.node), s;
}
var $i = {};
Object.defineProperty($i, "__esModule", {
  value: true
});
$i.default = void 0;
$i.requeueComputedKeyAndDecorators = Oc;
$i.skipAllButComputedKey = vg;
function vg(s) {
  s.skip(), s.node.computed && s.context.maybeQueue(s.get("key"));
}
function Oc(s) {
  const {
    context: n,
    node: h
  } = s;
  if (h.computed && n.maybeQueue(s.get("key")), h.decorators)
    for (const f2 of s.get("decorators"))
      n.maybeQueue(f2);
}
var Ag = {
  FunctionParent(s) {
    s.isArrowFunctionExpression() || (s.skip(), s.isMethod() && Oc(s));
  },
  Property(s) {
    s.isObjectProperty() || (s.skip(), Oc(s));
  }
};
var Cg = Ag;
$i.default = Cg;
var Ih;
function wg() {
  if (Ih)
    return la;
  Ih = 1, Object.defineProperty(la, "__esModule", {
    value: true
  }), la.default = void 0, Ky();
  var s = Fa, n = Je(), h = $i;
  const f2 = {
    ReferencedIdentifier({
      node: g
    }, P) {
      g.name === P.oldName && (g.name = P.newName);
    },
    Scope(g, P) {
      g.scope.bindingIdentifierEquals(P.oldName, P.binding.identifier) || (g.skip(), g.isMethod() && (0, h.requeueComputedKeyAndDecorators)(g));
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(g, P) {
      if (g.isVariableDeclaration())
        return;
      const x = g.getOuterBindingIdentifiers();
      for (const y in x)
        y === P.oldName && (x[y].name = P.newName);
    }
  };
  class p {
    constructor(P, x, y) {
      this.newName = y, this.oldName = x, this.binding = P;
    }
    maybeConvertFromExportDeclaration(P) {
      const x = P.parentPath;
      if (!!x.isExportDeclaration()) {
        if (x.isExportDefaultDeclaration()) {
          const {
            declaration: y
          } = x.node;
          if (n.isDeclaration(y) && !y.id)
            return;
        }
        x.isExportAllDeclaration() || (0, s.default)(x);
      }
    }
    maybeConvertFromClassFunctionDeclaration(P) {
      return P;
    }
    maybeConvertFromClassFunctionExpression(P) {
      return P;
    }
    rename(P) {
      const {
        binding: x,
        oldName: y,
        newName: A
      } = this, {
        scope: S,
        path: v
      } = x, T = v.find((I) => I.isDeclaration() || I.isFunctionExpression() || I.isClassExpression());
      T && T.getOuterBindingIdentifiers()[y] === x.identifier && this.maybeConvertFromExportDeclaration(T);
      const C = P || S.block;
      (C == null ? void 0 : C.type) === "SwitchStatement" ? C.cases.forEach((I) => {
        S.traverse(I, f2, this);
      }) : S.traverse(C, f2, this), P || (S.removeOwnBinding(y), S.bindings[A] = x, this.binding.identifier.name = A), T && (this.maybeConvertFromClassFunctionDeclaration(v), this.maybeConvertFromClassFunctionExpression(v));
    }
  }
  return la.default = p, la;
}
var Ku = { exports: {} };
var Ig = {
  Array: false,
  ArrayBuffer: false,
  Atomics: false,
  BigInt: false,
  BigInt64Array: false,
  BigUint64Array: false,
  Boolean: false,
  constructor: false,
  DataView: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Float32Array: false,
  Float64Array: false,
  Function: false,
  globalThis: false,
  hasOwnProperty: false,
  Infinity: false,
  Int16Array: false,
  Int32Array: false,
  Int8Array: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Map: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  Promise: false,
  propertyIsEnumerable: false,
  Proxy: false,
  RangeError: false,
  ReferenceError: false,
  Reflect: false,
  RegExp: false,
  Set: false,
  SharedArrayBuffer: false,
  String: false,
  Symbol: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  Uint16Array: false,
  Uint32Array: false,
  Uint8Array: false,
  Uint8ClampedArray: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
  WeakMap: false,
  WeakSet: false
};
var Ng = {
  Array: false,
  Boolean: false,
  constructor: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Function: false,
  hasOwnProperty: false,
  Infinity: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  propertyIsEnumerable: false,
  RangeError: false,
  ReferenceError: false,
  RegExp: false,
  String: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false
};
var kg = {
  Array: false,
  ArrayBuffer: false,
  Boolean: false,
  constructor: false,
  DataView: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Float32Array: false,
  Float64Array: false,
  Function: false,
  hasOwnProperty: false,
  Infinity: false,
  Int16Array: false,
  Int32Array: false,
  Int8Array: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Map: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  Promise: false,
  propertyIsEnumerable: false,
  Proxy: false,
  RangeError: false,
  ReferenceError: false,
  Reflect: false,
  RegExp: false,
  Set: false,
  String: false,
  Symbol: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  Uint16Array: false,
  Uint32Array: false,
  Uint8Array: false,
  Uint8ClampedArray: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
  WeakMap: false,
  WeakSet: false
};
var Og = {
  Array: false,
  ArrayBuffer: false,
  Atomics: false,
  Boolean: false,
  constructor: false,
  DataView: false,
  Date: false,
  decodeURI: false,
  decodeURIComponent: false,
  encodeURI: false,
  encodeURIComponent: false,
  Error: false,
  escape: false,
  eval: false,
  EvalError: false,
  Float32Array: false,
  Float64Array: false,
  Function: false,
  hasOwnProperty: false,
  Infinity: false,
  Int16Array: false,
  Int32Array: false,
  Int8Array: false,
  isFinite: false,
  isNaN: false,
  isPrototypeOf: false,
  JSON: false,
  Map: false,
  Math: false,
  NaN: false,
  Number: false,
  Object: false,
  parseFloat: false,
  parseInt: false,
  Promise: false,
  propertyIsEnumerable: false,
  Proxy: false,
  RangeError: false,
  ReferenceError: false,
  Reflect: false,
  RegExp: false,
  Set: false,
  SharedArrayBuffer: false,
  String: false,
  Symbol: false,
  SyntaxError: false,
  toLocaleString: false,
  toString: false,
  TypeError: false,
  Uint16Array: false,
  Uint32Array: false,
  Uint8Array: false,
  Uint8ClampedArray: false,
  undefined: false,
  unescape: false,
  URIError: false,
  valueOf: false,
  WeakMap: false,
  WeakSet: false
};
var Dg = {
  AbortController: false,
  AbortSignal: false,
  addEventListener: false,
  alert: false,
  AnalyserNode: false,
  Animation: false,
  AnimationEffectReadOnly: false,
  AnimationEffectTiming: false,
  AnimationEffectTimingReadOnly: false,
  AnimationEvent: false,
  AnimationPlaybackEvent: false,
  AnimationTimeline: false,
  applicationCache: false,
  ApplicationCache: false,
  ApplicationCacheErrorEvent: false,
  atob: false,
  Attr: false,
  Audio: false,
  AudioBuffer: false,
  AudioBufferSourceNode: false,
  AudioContext: false,
  AudioDestinationNode: false,
  AudioListener: false,
  AudioNode: false,
  AudioParam: false,
  AudioProcessingEvent: false,
  AudioScheduledSourceNode: false,
  "AudioWorkletGlobalScope ": false,
  AudioWorkletNode: false,
  AudioWorkletProcessor: false,
  BarProp: false,
  BaseAudioContext: false,
  BatteryManager: false,
  BeforeUnloadEvent: false,
  BiquadFilterNode: false,
  Blob: false,
  BlobEvent: false,
  blur: false,
  BroadcastChannel: false,
  btoa: false,
  BudgetService: false,
  ByteLengthQueuingStrategy: false,
  Cache: false,
  caches: false,
  CacheStorage: false,
  cancelAnimationFrame: false,
  cancelIdleCallback: false,
  CanvasCaptureMediaStreamTrack: false,
  CanvasGradient: false,
  CanvasPattern: false,
  CanvasRenderingContext2D: false,
  ChannelMergerNode: false,
  ChannelSplitterNode: false,
  CharacterData: false,
  clearInterval: false,
  clearTimeout: false,
  clientInformation: false,
  ClipboardEvent: false,
  close: false,
  closed: false,
  CloseEvent: false,
  Comment: false,
  CompositionEvent: false,
  confirm: false,
  console: false,
  ConstantSourceNode: false,
  ConvolverNode: false,
  CountQueuingStrategy: false,
  createImageBitmap: false,
  Credential: false,
  CredentialsContainer: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CSS: false,
  CSSConditionRule: false,
  CSSFontFaceRule: false,
  CSSGroupingRule: false,
  CSSImportRule: false,
  CSSKeyframeRule: false,
  CSSKeyframesRule: false,
  CSSMediaRule: false,
  CSSNamespaceRule: false,
  CSSPageRule: false,
  CSSRule: false,
  CSSRuleList: false,
  CSSStyleDeclaration: false,
  CSSStyleRule: false,
  CSSStyleSheet: false,
  CSSSupportsRule: false,
  CustomElementRegistry: false,
  customElements: false,
  CustomEvent: false,
  DataTransfer: false,
  DataTransferItem: false,
  DataTransferItemList: false,
  defaultstatus: false,
  defaultStatus: false,
  DelayNode: false,
  DeviceMotionEvent: false,
  DeviceOrientationEvent: false,
  devicePixelRatio: false,
  dispatchEvent: false,
  document: false,
  Document: false,
  DocumentFragment: false,
  DocumentType: false,
  DOMError: false,
  DOMException: false,
  DOMImplementation: false,
  DOMMatrix: false,
  DOMMatrixReadOnly: false,
  DOMParser: false,
  DOMPoint: false,
  DOMPointReadOnly: false,
  DOMQuad: false,
  DOMRect: false,
  DOMRectReadOnly: false,
  DOMStringList: false,
  DOMStringMap: false,
  DOMTokenList: false,
  DragEvent: false,
  DynamicsCompressorNode: false,
  Element: false,
  ErrorEvent: false,
  event: false,
  Event: false,
  EventSource: false,
  EventTarget: false,
  external: false,
  fetch: false,
  File: false,
  FileList: false,
  FileReader: false,
  find: false,
  focus: false,
  FocusEvent: false,
  FontFace: false,
  FontFaceSetLoadEvent: false,
  FormData: false,
  frameElement: false,
  frames: false,
  GainNode: false,
  Gamepad: false,
  GamepadButton: false,
  GamepadEvent: false,
  getComputedStyle: false,
  getSelection: false,
  HashChangeEvent: false,
  Headers: false,
  history: false,
  History: false,
  HTMLAllCollection: false,
  HTMLAnchorElement: false,
  HTMLAreaElement: false,
  HTMLAudioElement: false,
  HTMLBaseElement: false,
  HTMLBodyElement: false,
  HTMLBRElement: false,
  HTMLButtonElement: false,
  HTMLCanvasElement: false,
  HTMLCollection: false,
  HTMLContentElement: false,
  HTMLDataElement: false,
  HTMLDataListElement: false,
  HTMLDetailsElement: false,
  HTMLDialogElement: false,
  HTMLDirectoryElement: false,
  HTMLDivElement: false,
  HTMLDListElement: false,
  HTMLDocument: false,
  HTMLElement: false,
  HTMLEmbedElement: false,
  HTMLFieldSetElement: false,
  HTMLFontElement: false,
  HTMLFormControlsCollection: false,
  HTMLFormElement: false,
  HTMLFrameElement: false,
  HTMLFrameSetElement: false,
  HTMLHeadElement: false,
  HTMLHeadingElement: false,
  HTMLHRElement: false,
  HTMLHtmlElement: false,
  HTMLIFrameElement: false,
  HTMLImageElement: false,
  HTMLInputElement: false,
  HTMLLabelElement: false,
  HTMLLegendElement: false,
  HTMLLIElement: false,
  HTMLLinkElement: false,
  HTMLMapElement: false,
  HTMLMarqueeElement: false,
  HTMLMediaElement: false,
  HTMLMenuElement: false,
  HTMLMetaElement: false,
  HTMLMeterElement: false,
  HTMLModElement: false,
  HTMLObjectElement: false,
  HTMLOListElement: false,
  HTMLOptGroupElement: false,
  HTMLOptionElement: false,
  HTMLOptionsCollection: false,
  HTMLOutputElement: false,
  HTMLParagraphElement: false,
  HTMLParamElement: false,
  HTMLPictureElement: false,
  HTMLPreElement: false,
  HTMLProgressElement: false,
  HTMLQuoteElement: false,
  HTMLScriptElement: false,
  HTMLSelectElement: false,
  HTMLShadowElement: false,
  HTMLSlotElement: false,
  HTMLSourceElement: false,
  HTMLSpanElement: false,
  HTMLStyleElement: false,
  HTMLTableCaptionElement: false,
  HTMLTableCellElement: false,
  HTMLTableColElement: false,
  HTMLTableElement: false,
  HTMLTableRowElement: false,
  HTMLTableSectionElement: false,
  HTMLTemplateElement: false,
  HTMLTextAreaElement: false,
  HTMLTimeElement: false,
  HTMLTitleElement: false,
  HTMLTrackElement: false,
  HTMLUListElement: false,
  HTMLUnknownElement: false,
  HTMLVideoElement: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  IdleDeadline: false,
  IIRFilterNode: false,
  Image: false,
  ImageBitmap: false,
  ImageBitmapRenderingContext: false,
  ImageCapture: false,
  ImageData: false,
  indexedDB: false,
  innerHeight: false,
  innerWidth: false,
  InputEvent: false,
  IntersectionObserver: false,
  IntersectionObserverEntry: false,
  Intl: false,
  isSecureContext: false,
  KeyboardEvent: false,
  KeyframeEffect: false,
  KeyframeEffectReadOnly: false,
  length: false,
  localStorage: false,
  location: true,
  Location: false,
  locationbar: false,
  matchMedia: false,
  MediaDeviceInfo: false,
  MediaDevices: false,
  MediaElementAudioSourceNode: false,
  MediaEncryptedEvent: false,
  MediaError: false,
  MediaKeyMessageEvent: false,
  MediaKeySession: false,
  MediaKeyStatusMap: false,
  MediaKeySystemAccess: false,
  MediaList: false,
  MediaQueryList: false,
  MediaQueryListEvent: false,
  MediaRecorder: false,
  MediaSettingsRange: false,
  MediaSource: false,
  MediaStream: false,
  MediaStreamAudioDestinationNode: false,
  MediaStreamAudioSourceNode: false,
  MediaStreamEvent: false,
  MediaStreamTrack: false,
  MediaStreamTrackEvent: false,
  menubar: false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  MIDIAccess: false,
  MIDIConnectionEvent: false,
  MIDIInput: false,
  MIDIInputMap: false,
  MIDIMessageEvent: false,
  MIDIOutput: false,
  MIDIOutputMap: false,
  MIDIPort: false,
  MimeType: false,
  MimeTypeArray: false,
  MouseEvent: false,
  moveBy: false,
  moveTo: false,
  MutationEvent: false,
  MutationObserver: false,
  MutationRecord: false,
  name: false,
  NamedNodeMap: false,
  NavigationPreloadManager: false,
  navigator: false,
  Navigator: false,
  NetworkInformation: false,
  Node: false,
  NodeFilter: false,
  NodeIterator: false,
  NodeList: false,
  Notification: false,
  OfflineAudioCompletionEvent: false,
  OfflineAudioContext: false,
  offscreenBuffering: false,
  OffscreenCanvas: true,
  onabort: true,
  onafterprint: true,
  onanimationend: true,
  onanimationiteration: true,
  onanimationstart: true,
  onappinstalled: true,
  onauxclick: true,
  onbeforeinstallprompt: true,
  onbeforeprint: true,
  onbeforeunload: true,
  onblur: true,
  oncancel: true,
  oncanplay: true,
  oncanplaythrough: true,
  onchange: true,
  onclick: true,
  onclose: true,
  oncontextmenu: true,
  oncuechange: true,
  ondblclick: true,
  ondevicemotion: true,
  ondeviceorientation: true,
  ondeviceorientationabsolute: true,
  ondrag: true,
  ondragend: true,
  ondragenter: true,
  ondragleave: true,
  ondragover: true,
  ondragstart: true,
  ondrop: true,
  ondurationchange: true,
  onemptied: true,
  onended: true,
  onerror: true,
  onfocus: true,
  ongotpointercapture: true,
  onhashchange: true,
  oninput: true,
  oninvalid: true,
  onkeydown: true,
  onkeypress: true,
  onkeyup: true,
  onlanguagechange: true,
  onload: true,
  onloadeddata: true,
  onloadedmetadata: true,
  onloadstart: true,
  onlostpointercapture: true,
  onmessage: true,
  onmessageerror: true,
  onmousedown: true,
  onmouseenter: true,
  onmouseleave: true,
  onmousemove: true,
  onmouseout: true,
  onmouseover: true,
  onmouseup: true,
  onmousewheel: true,
  onoffline: true,
  ononline: true,
  onpagehide: true,
  onpageshow: true,
  onpause: true,
  onplay: true,
  onplaying: true,
  onpointercancel: true,
  onpointerdown: true,
  onpointerenter: true,
  onpointerleave: true,
  onpointermove: true,
  onpointerout: true,
  onpointerover: true,
  onpointerup: true,
  onpopstate: true,
  onprogress: true,
  onratechange: true,
  onrejectionhandled: true,
  onreset: true,
  onresize: true,
  onscroll: true,
  onsearch: true,
  onseeked: true,
  onseeking: true,
  onselect: true,
  onstalled: true,
  onstorage: true,
  onsubmit: true,
  onsuspend: true,
  ontimeupdate: true,
  ontoggle: true,
  ontransitionend: true,
  onunhandledrejection: true,
  onunload: true,
  onvolumechange: true,
  onwaiting: true,
  onwheel: true,
  open: false,
  openDatabase: false,
  opener: false,
  Option: false,
  origin: false,
  OscillatorNode: false,
  outerHeight: false,
  outerWidth: false,
  PageTransitionEvent: false,
  pageXOffset: false,
  pageYOffset: false,
  PannerNode: false,
  parent: false,
  Path2D: false,
  PaymentAddress: false,
  PaymentRequest: false,
  PaymentRequestUpdateEvent: false,
  PaymentResponse: false,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceLongTaskTiming: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceNavigationTiming: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformancePaintTiming: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  PeriodicWave: false,
  Permissions: false,
  PermissionStatus: false,
  personalbar: false,
  PhotoCapabilities: false,
  Plugin: false,
  PluginArray: false,
  PointerEvent: false,
  PopStateEvent: false,
  postMessage: false,
  Presentation: false,
  PresentationAvailability: false,
  PresentationConnection: false,
  PresentationConnectionAvailableEvent: false,
  PresentationConnectionCloseEvent: false,
  PresentationConnectionList: false,
  PresentationReceiver: false,
  PresentationRequest: false,
  print: false,
  ProcessingInstruction: false,
  ProgressEvent: false,
  PromiseRejectionEvent: false,
  prompt: false,
  PushManager: false,
  PushSubscription: false,
  PushSubscriptionOptions: false,
  queueMicrotask: false,
  RadioNodeList: false,
  Range: false,
  ReadableStream: false,
  registerProcessor: false,
  RemotePlayback: false,
  removeEventListener: false,
  Request: false,
  requestAnimationFrame: false,
  requestIdleCallback: false,
  resizeBy: false,
  ResizeObserver: false,
  ResizeObserverEntry: false,
  resizeTo: false,
  Response: false,
  RTCCertificate: false,
  RTCDataChannel: false,
  RTCDataChannelEvent: false,
  RTCDtlsTransport: false,
  RTCIceCandidate: false,
  RTCIceGatherer: false,
  RTCIceTransport: false,
  RTCPeerConnection: false,
  RTCPeerConnectionIceEvent: false,
  RTCRtpContributingSource: false,
  RTCRtpReceiver: false,
  RTCRtpSender: false,
  RTCSctpTransport: false,
  RTCSessionDescription: false,
  RTCStatsReport: false,
  RTCTrackEvent: false,
  screen: false,
  Screen: false,
  screenLeft: false,
  ScreenOrientation: false,
  screenTop: false,
  screenX: false,
  screenY: false,
  ScriptProcessorNode: false,
  scroll: false,
  scrollbars: false,
  scrollBy: false,
  scrollTo: false,
  scrollX: false,
  scrollY: false,
  SecurityPolicyViolationEvent: false,
  Selection: false,
  self: false,
  ServiceWorker: false,
  ServiceWorkerContainer: false,
  ServiceWorkerRegistration: false,
  sessionStorage: false,
  setInterval: false,
  setTimeout: false,
  ShadowRoot: false,
  SharedWorker: false,
  SourceBuffer: false,
  SourceBufferList: false,
  speechSynthesis: false,
  SpeechSynthesisEvent: false,
  SpeechSynthesisUtterance: false,
  StaticRange: false,
  status: false,
  statusbar: false,
  StereoPannerNode: false,
  stop: false,
  Storage: false,
  StorageEvent: false,
  StorageManager: false,
  styleMedia: false,
  StyleSheet: false,
  StyleSheetList: false,
  SubtleCrypto: false,
  SVGAElement: false,
  SVGAngle: false,
  SVGAnimatedAngle: false,
  SVGAnimatedBoolean: false,
  SVGAnimatedEnumeration: false,
  SVGAnimatedInteger: false,
  SVGAnimatedLength: false,
  SVGAnimatedLengthList: false,
  SVGAnimatedNumber: false,
  SVGAnimatedNumberList: false,
  SVGAnimatedPreserveAspectRatio: false,
  SVGAnimatedRect: false,
  SVGAnimatedString: false,
  SVGAnimatedTransformList: false,
  SVGAnimateElement: false,
  SVGAnimateMotionElement: false,
  SVGAnimateTransformElement: false,
  SVGAnimationElement: false,
  SVGCircleElement: false,
  SVGClipPathElement: false,
  SVGComponentTransferFunctionElement: false,
  SVGDefsElement: false,
  SVGDescElement: false,
  SVGDiscardElement: false,
  SVGElement: false,
  SVGEllipseElement: false,
  SVGFEBlendElement: false,
  SVGFEColorMatrixElement: false,
  SVGFEComponentTransferElement: false,
  SVGFECompositeElement: false,
  SVGFEConvolveMatrixElement: false,
  SVGFEDiffuseLightingElement: false,
  SVGFEDisplacementMapElement: false,
  SVGFEDistantLightElement: false,
  SVGFEDropShadowElement: false,
  SVGFEFloodElement: false,
  SVGFEFuncAElement: false,
  SVGFEFuncBElement: false,
  SVGFEFuncGElement: false,
  SVGFEFuncRElement: false,
  SVGFEGaussianBlurElement: false,
  SVGFEImageElement: false,
  SVGFEMergeElement: false,
  SVGFEMergeNodeElement: false,
  SVGFEMorphologyElement: false,
  SVGFEOffsetElement: false,
  SVGFEPointLightElement: false,
  SVGFESpecularLightingElement: false,
  SVGFESpotLightElement: false,
  SVGFETileElement: false,
  SVGFETurbulenceElement: false,
  SVGFilterElement: false,
  SVGForeignObjectElement: false,
  SVGGElement: false,
  SVGGeometryElement: false,
  SVGGradientElement: false,
  SVGGraphicsElement: false,
  SVGImageElement: false,
  SVGLength: false,
  SVGLengthList: false,
  SVGLinearGradientElement: false,
  SVGLineElement: false,
  SVGMarkerElement: false,
  SVGMaskElement: false,
  SVGMatrix: false,
  SVGMetadataElement: false,
  SVGMPathElement: false,
  SVGNumber: false,
  SVGNumberList: false,
  SVGPathElement: false,
  SVGPatternElement: false,
  SVGPoint: false,
  SVGPointList: false,
  SVGPolygonElement: false,
  SVGPolylineElement: false,
  SVGPreserveAspectRatio: false,
  SVGRadialGradientElement: false,
  SVGRect: false,
  SVGRectElement: false,
  SVGScriptElement: false,
  SVGSetElement: false,
  SVGStopElement: false,
  SVGStringList: false,
  SVGStyleElement: false,
  SVGSVGElement: false,
  SVGSwitchElement: false,
  SVGSymbolElement: false,
  SVGTextContentElement: false,
  SVGTextElement: false,
  SVGTextPathElement: false,
  SVGTextPositioningElement: false,
  SVGTitleElement: false,
  SVGTransform: false,
  SVGTransformList: false,
  SVGTSpanElement: false,
  SVGUnitTypes: false,
  SVGUseElement: false,
  SVGViewElement: false,
  TaskAttributionTiming: false,
  Text: false,
  TextDecoder: false,
  TextEncoder: false,
  TextEvent: false,
  TextMetrics: false,
  TextTrack: false,
  TextTrackCue: false,
  TextTrackCueList: false,
  TextTrackList: false,
  TimeRanges: false,
  toolbar: false,
  top: false,
  Touch: false,
  TouchEvent: false,
  TouchList: false,
  TrackEvent: false,
  TransitionEvent: false,
  TreeWalker: false,
  UIEvent: false,
  URL: false,
  URLSearchParams: false,
  ValidityState: false,
  visualViewport: false,
  VisualViewport: false,
  VTTCue: false,
  WaveShaperNode: false,
  WebAssembly: false,
  WebGL2RenderingContext: false,
  WebGLActiveInfo: false,
  WebGLBuffer: false,
  WebGLContextEvent: false,
  WebGLFramebuffer: false,
  WebGLProgram: false,
  WebGLQuery: false,
  WebGLRenderbuffer: false,
  WebGLRenderingContext: false,
  WebGLSampler: false,
  WebGLShader: false,
  WebGLShaderPrecisionFormat: false,
  WebGLSync: false,
  WebGLTexture: false,
  WebGLTransformFeedback: false,
  WebGLUniformLocation: false,
  WebGLVertexArrayObject: false,
  WebSocket: false,
  WheelEvent: false,
  window: false,
  Window: false,
  Worker: false,
  WritableStream: false,
  XMLDocument: false,
  XMLHttpRequest: false,
  XMLHttpRequestEventTarget: false,
  XMLHttpRequestUpload: false,
  XMLSerializer: false,
  XPathEvaluator: false,
  XPathExpression: false,
  XPathResult: false,
  XSLTProcessor: false
};
var Lg = {
  addEventListener: false,
  applicationCache: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  Cache: false,
  caches: false,
  clearInterval: false,
  clearTimeout: false,
  close: true,
  console: false,
  fetch: false,
  FileReaderSync: false,
  FormData: false,
  Headers: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  ImageData: false,
  importScripts: true,
  indexedDB: false,
  location: false,
  MessageChannel: false,
  MessagePort: false,
  name: false,
  navigator: false,
  Notification: false,
  onclose: true,
  onconnect: true,
  onerror: true,
  onlanguagechange: true,
  onmessage: true,
  onoffline: true,
  ononline: true,
  onrejectionhandled: true,
  onunhandledrejection: true,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  postMessage: true,
  Promise: false,
  queueMicrotask: false,
  removeEventListener: false,
  Request: false,
  Response: false,
  self: true,
  ServiceWorkerRegistration: false,
  setInterval: false,
  setTimeout: false,
  TextDecoder: false,
  TextEncoder: false,
  URL: false,
  URLSearchParams: false,
  WebSocket: false,
  Worker: false,
  WorkerGlobalScope: false,
  XMLHttpRequest: false
};
var Mg = {
  __dirname: false,
  __filename: false,
  Buffer: false,
  clearImmediate: false,
  clearInterval: false,
  clearTimeout: false,
  console: false,
  exports: true,
  global: false,
  Intl: false,
  module: false,
  process: false,
  queueMicrotask: false,
  require: false,
  setImmediate: false,
  setInterval: false,
  setTimeout: false,
  TextDecoder: false,
  TextEncoder: false,
  URL: false,
  URLSearchParams: false
};
var Bg = {
  exports: true,
  global: false,
  module: false,
  require: false
};
var _g = {
  define: false,
  require: false
};
var Fg = {
  after: false,
  afterEach: false,
  before: false,
  beforeEach: false,
  context: false,
  describe: false,
  it: false,
  mocha: false,
  run: false,
  setup: false,
  specify: false,
  suite: false,
  suiteSetup: false,
  suiteTeardown: false,
  teardown: false,
  test: false,
  xcontext: false,
  xdescribe: false,
  xit: false,
  xspecify: false
};
var jg = {
  afterAll: false,
  afterEach: false,
  beforeAll: false,
  beforeEach: false,
  describe: false,
  expect: false,
  fail: false,
  fdescribe: false,
  fit: false,
  it: false,
  jasmine: false,
  pending: false,
  runs: false,
  spyOn: false,
  spyOnProperty: false,
  waits: false,
  waitsFor: false,
  xdescribe: false,
  xit: false
};
var Rg = {
  afterAll: false,
  afterEach: false,
  beforeAll: false,
  beforeEach: false,
  describe: false,
  expect: false,
  fdescribe: false,
  fit: false,
  it: false,
  jest: false,
  pit: false,
  require: false,
  test: false,
  xdescribe: false,
  xit: false,
  xtest: false
};
var Ug = {
  asyncTest: false,
  deepEqual: false,
  equal: false,
  expect: false,
  module: false,
  notDeepEqual: false,
  notEqual: false,
  notOk: false,
  notPropEqual: false,
  notStrictEqual: false,
  ok: false,
  propEqual: false,
  QUnit: false,
  raises: false,
  start: false,
  stop: false,
  strictEqual: false,
  test: false,
  throws: false
};
var $g = {
  console: true,
  exports: true,
  phantom: true,
  require: true,
  WebPage: true
};
var qg = {
  emit: false,
  exports: false,
  getRow: false,
  log: false,
  module: false,
  provides: false,
  require: false,
  respond: false,
  send: false,
  start: false,
  sum: false
};
var Vg = {
  defineClass: false,
  deserialize: false,
  gc: false,
  help: false,
  importClass: false,
  importPackage: false,
  java: false,
  load: false,
  loadClass: false,
  Packages: false,
  print: false,
  quit: false,
  readFile: false,
  readUrl: false,
  runCommand: false,
  seal: false,
  serialize: false,
  spawn: false,
  sync: false,
  toint32: false,
  version: false
};
var Kg = {
  __DIR__: false,
  __FILE__: false,
  __LINE__: false,
  com: false,
  edu: false,
  exit: false,
  java: false,
  Java: false,
  javafx: false,
  JavaImporter: false,
  javax: false,
  JSAdapter: false,
  load: false,
  loadWithNewGlobal: false,
  org: false,
  Packages: false,
  print: false,
  quit: false
};
var Wg = {
  ActiveXObject: true,
  Enumerator: true,
  GetObject: true,
  ScriptEngine: true,
  ScriptEngineBuildVersion: true,
  ScriptEngineMajorVersion: true,
  ScriptEngineMinorVersion: true,
  VBArray: true,
  WScript: true,
  WSH: true,
  XDomainRequest: true
};
var Hg = {
  $: false,
  jQuery: false
};
var zg = {
  YAHOO: false,
  YAHOO_config: false,
  YUI: false,
  YUI_config: false
};
var Gg = {
  cat: false,
  cd: false,
  chmod: false,
  config: false,
  cp: false,
  dirs: false,
  echo: false,
  env: false,
  error: false,
  exec: false,
  exit: false,
  find: false,
  grep: false,
  ln: false,
  ls: false,
  mkdir: false,
  mv: false,
  popd: false,
  pushd: false,
  pwd: false,
  rm: false,
  sed: false,
  set: false,
  target: false,
  tempdir: false,
  test: false,
  touch: false,
  which: false
};
var Xg = {
  $: false,
  $$: false,
  $A: false,
  $break: false,
  $continue: false,
  $F: false,
  $H: false,
  $R: false,
  $w: false,
  Abstract: false,
  Ajax: false,
  Autocompleter: false,
  Builder: false,
  Class: false,
  Control: false,
  Draggable: false,
  Draggables: false,
  Droppables: false,
  Effect: false,
  Element: false,
  Enumerable: false,
  Event: false,
  Field: false,
  Form: false,
  Hash: false,
  Insertion: false,
  ObjectRange: false,
  PeriodicalExecuter: false,
  Position: false,
  Prototype: false,
  Scriptaculous: false,
  Selector: false,
  Sortable: false,
  SortableObserver: false,
  Sound: false,
  Template: false,
  Toggle: false,
  Try: false
};
var Jg = {
  _: false,
  $: false,
  Accounts: false,
  AccountsClient: false,
  AccountsCommon: false,
  AccountsServer: false,
  App: false,
  Assets: false,
  Blaze: false,
  check: false,
  Cordova: false,
  DDP: false,
  DDPRateLimiter: false,
  DDPServer: false,
  Deps: false,
  EJSON: false,
  Email: false,
  HTTP: false,
  Log: false,
  Match: false,
  Meteor: false,
  Mongo: false,
  MongoInternals: false,
  Npm: false,
  Package: false,
  Plugin: false,
  process: false,
  Random: false,
  ReactiveDict: false,
  ReactiveVar: false,
  Router: false,
  ServiceConfiguration: false,
  Session: false,
  share: false,
  Spacebars: false,
  Template: false,
  Tinytest: false,
  Tracker: false,
  UI: false,
  Utils: false,
  WebApp: false,
  WebAppInternals: false
};
var Yg = {
  _isWindows: false,
  _rand: false,
  BulkWriteResult: false,
  cat: false,
  cd: false,
  connect: false,
  db: false,
  getHostName: false,
  getMemInfo: false,
  hostname: false,
  ISODate: false,
  listFiles: false,
  load: false,
  ls: false,
  md5sumFile: false,
  mkdir: false,
  Mongo: false,
  NumberInt: false,
  NumberLong: false,
  ObjectId: false,
  PlanCache: false,
  print: false,
  printjson: false,
  pwd: false,
  quit: false,
  removeFile: false,
  rs: false,
  sh: false,
  UUID: false,
  version: false,
  WriteResult: false
};
var Qg = {
  $: false,
  Application: false,
  Automation: false,
  console: false,
  delay: false,
  Library: false,
  ObjC: false,
  ObjectSpecifier: false,
  Path: false,
  Progress: false,
  Ref: false
};
var Zg = {
  addEventListener: false,
  applicationCache: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  Cache: false,
  caches: false,
  CacheStorage: false,
  clearInterval: false,
  clearTimeout: false,
  Client: false,
  clients: false,
  Clients: false,
  close: true,
  console: false,
  ExtendableEvent: false,
  ExtendableMessageEvent: false,
  fetch: false,
  FetchEvent: false,
  FileReaderSync: false,
  FormData: false,
  Headers: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  ImageData: false,
  importScripts: false,
  indexedDB: false,
  location: false,
  MessageChannel: false,
  MessagePort: false,
  name: false,
  navigator: false,
  Notification: false,
  onclose: true,
  onconnect: true,
  onerror: true,
  onfetch: true,
  oninstall: true,
  onlanguagechange: true,
  onmessage: true,
  onmessageerror: true,
  onnotificationclick: true,
  onnotificationclose: true,
  onoffline: true,
  ononline: true,
  onpush: true,
  onpushsubscriptionchange: true,
  onrejectionhandled: true,
  onsync: true,
  onunhandledrejection: true,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  postMessage: true,
  Promise: false,
  queueMicrotask: false,
  registration: false,
  removeEventListener: false,
  Request: false,
  Response: false,
  self: false,
  ServiceWorker: false,
  ServiceWorkerContainer: false,
  ServiceWorkerGlobalScope: false,
  ServiceWorkerMessageEvent: false,
  ServiceWorkerRegistration: false,
  setInterval: false,
  setTimeout: false,
  skipWaiting: false,
  TextDecoder: false,
  TextEncoder: false,
  URL: false,
  URLSearchParams: false,
  WebSocket: false,
  WindowClient: false,
  Worker: false,
  WorkerGlobalScope: false,
  XMLHttpRequest: false
};
var eT = {
  advanceClock: false,
  fakeClearInterval: false,
  fakeClearTimeout: false,
  fakeSetInterval: false,
  fakeSetTimeout: false,
  resetTimeouts: false,
  waitsForPromise: false
};
var tT = {
  andThen: false,
  click: false,
  currentPath: false,
  currentRouteName: false,
  currentURL: false,
  fillIn: false,
  find: false,
  findAll: false,
  findWithAssert: false,
  keyEvent: false,
  pauseTest: false,
  resumeTest: false,
  triggerEvent: false,
  visit: false,
  wait: false
};
var rT = {
  $: false,
  $$: false,
  browser: false,
  by: false,
  By: false,
  DartObject: false,
  element: false,
  protractor: false
};
var sT = {
  browser: false,
  chrome: false,
  opr: false
};
var iT = {
  cloneInto: false,
  createObjectIn: false,
  exportFunction: false,
  GM: false,
  GM_addStyle: false,
  GM_deleteValue: false,
  GM_getResourceText: false,
  GM_getResourceURL: false,
  GM_getValue: false,
  GM_info: false,
  GM_listValues: false,
  GM_log: false,
  GM_openInTab: false,
  GM_registerMenuCommand: false,
  GM_setClipboard: false,
  GM_setValue: false,
  GM_xmlhttpRequest: false,
  unsafeWindow: false
};
var nT = {
  $: false,
  $_: false,
  $$: false,
  $0: false,
  $1: false,
  $2: false,
  $3: false,
  $4: false,
  $x: false,
  chrome: false,
  clear: false,
  copy: false,
  debug: false,
  dir: false,
  dirxml: false,
  getEventListeners: false,
  inspect: false,
  keys: false,
  monitor: false,
  monitorEvents: false,
  profile: false,
  profileEnd: false,
  queryObjects: false,
  table: false,
  undebug: false,
  unmonitor: false,
  unmonitorEvents: false,
  values: false
};
var aT = {
  builtin: Ig,
  es5: Ng,
  es2015: kg,
  es2017: Og,
  browser: Dg,
  worker: Lg,
  node: Mg,
  commonjs: Bg,
  amd: _g,
  mocha: Fg,
  jasmine: jg,
  jest: Rg,
  qunit: Ug,
  phantomjs: $g,
  couch: qg,
  rhino: Vg,
  nashorn: Kg,
  wsh: Wg,
  jquery: Hg,
  yui: zg,
  shelljs: Gg,
  prototypejs: Xg,
  meteor: Jg,
  mongo: Yg,
  applescript: Qg,
  serviceworker: Zg,
  atomtest: eT,
  embertest: tT,
  protractor: rT,
  "shared-node-browser": {
    clearInterval: false,
    clearTimeout: false,
    console: false,
    setInterval: false,
    setTimeout: false,
    URL: false,
    URLSearchParams: false
  },
  webextensions: sT,
  greasemonkey: iT,
  devtools: nT
};
var Nh;
function oT() {
  return Nh || (Nh = 1, function(s) {
    s.exports = aT;
  }(Ku)), Ku.exports;
}
var kh;
function Wy() {
  if (kh)
    return oa;
  kh = 1, Object.defineProperty(oa, "__esModule", {
    value: true
  }), oa.default = void 0;
  var s = wg(), n = qi(), h = Ky(), f2 = oT(), p = Je(), g = Wn();
  const {
    NOT_LOCAL_BINDING: P,
    callExpression: x,
    cloneNode: y,
    getBindingIdentifiers: A,
    identifier: S,
    isArrayExpression: v,
    isBinary: T,
    isClass: C,
    isClassBody: I,
    isClassDeclaration: N,
    isExportAllDeclaration: D,
    isExportDefaultDeclaration: _,
    isExportNamedDeclaration: m,
    isFunctionDeclaration: L,
    isIdentifier: R,
    isImportDeclaration: O,
    isLiteral: B,
    isMethod: M,
    isModuleDeclaration: j,
    isModuleSpecifier: $,
    isNullLiteral: k,
    isObjectExpression: ne,
    isProperty: Q,
    isPureish: q,
    isRegExpLiteral: ee,
    isSuper: K,
    isTaggedTemplateExpression: G,
    isTemplateLiteral: V,
    isThisExpression: F,
    isUnaryExpression: le,
    isVariableDeclaration: oe,
    matchesPattern: fe,
    memberExpression: he,
    numericLiteral: de,
    toIdentifier: Pe,
    unaryExpression: we,
    variableDeclaration: H,
    variableDeclarator: te,
    isRecordExpression: Ie,
    isTupleExpression: Te,
    isObjectProperty: pe,
    isTopicReference: z,
    isMetaProperty: W,
    isPrivateName: ae
  } = p;
  function ce(Ee, J) {
    switch (Ee == null ? void 0 : Ee.type) {
      default:
        if (j(Ee))
          if ((D(Ee) || m(Ee) || O(Ee)) && Ee.source)
            ce(Ee.source, J);
          else if ((m(Ee) || O(Ee)) && Ee.specifiers && Ee.specifiers.length)
            for (const me of Ee.specifiers)
              ce(me, J);
          else
            (_(Ee) || m(Ee)) && Ee.declaration && ce(Ee.declaration, J);
        else
          $(Ee) ? ce(Ee.local, J) : B(Ee) && !k(Ee) && !ee(Ee) && !V(Ee) && J.push(Ee.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        ce(Ee.object, J), ce(Ee.property, J);
        break;
      case "Identifier":
      case "JSXIdentifier":
        J.push(Ee.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        ce(Ee.callee, J);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const me of Ee.properties)
          ce(me, J);
        break;
      case "SpreadElement":
      case "RestElement":
        ce(Ee.argument, J);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        ce(Ee.key, J);
        break;
      case "ThisExpression":
        J.push("this");
        break;
      case "Super":
        J.push("super");
        break;
      case "Import":
        J.push("import");
        break;
      case "DoExpression":
        J.push("do");
        break;
      case "YieldExpression":
        J.push("yield"), ce(Ee.argument, J);
        break;
      case "AwaitExpression":
        J.push("await"), ce(Ee.argument, J);
        break;
      case "AssignmentExpression":
        ce(Ee.left, J);
        break;
      case "VariableDeclarator":
        ce(Ee.id, J);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        ce(Ee.id, J);
        break;
      case "PrivateName":
        ce(Ee.id, J);
        break;
      case "ParenthesizedExpression":
        ce(Ee.expression, J);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        ce(Ee.argument, J);
        break;
      case "MetaProperty":
        ce(Ee.meta, J), ce(Ee.property, J);
        break;
      case "JSXElement":
        ce(Ee.openingElement, J);
        break;
      case "JSXOpeningElement":
        ce(Ee.name, J);
        break;
      case "JSXFragment":
        ce(Ee.openingFragment, J);
        break;
      case "JSXOpeningFragment":
        J.push("Fragment");
        break;
      case "JSXNamespacedName":
        ce(Ee.namespace, J), ce(Ee.name, J);
        break;
    }
  }
  const xe = {
    ForStatement(Ee) {
      const J = Ee.get("init");
      if (J.isVar()) {
        const {
          scope: me
        } = Ee;
        (me.getFunctionParent() || me.getProgramParent()).registerBinding("var", J);
      }
    },
    Declaration(Ee) {
      if (Ee.isBlockScoped() || Ee.isImportDeclaration() || Ee.isExportDeclaration())
        return;
      (Ee.scope.getFunctionParent() || Ee.scope.getProgramParent()).registerDeclaration(Ee);
    },
    ImportDeclaration(Ee) {
      Ee.scope.getBlockParent().registerDeclaration(Ee);
    },
    ReferencedIdentifier(Ee, J) {
      J.references.push(Ee);
    },
    ForXStatement(Ee, J) {
      const me = Ee.get("left");
      if (me.isPattern() || me.isIdentifier())
        J.constantViolations.push(Ee);
      else if (me.isVar()) {
        const {
          scope: ke
        } = Ee;
        (ke.getFunctionParent() || ke.getProgramParent()).registerBinding("var", me);
      }
    },
    ExportDeclaration: {
      exit(Ee) {
        const {
          node: J,
          scope: me
        } = Ee;
        if (D(J))
          return;
        const ke = J.declaration;
        if (N(ke) || L(ke)) {
          const _e = ke.id;
          if (!_e)
            return;
          const Re = me.getBinding(_e.name);
          Re == null || Re.reference(Ee);
        } else if (oe(ke))
          for (const _e of ke.declarations)
            for (const Re of Object.keys(A(_e))) {
              const $e = me.getBinding(Re);
              $e == null || $e.reference(Ee);
            }
      }
    },
    LabeledStatement(Ee) {
      Ee.scope.getBlockParent().registerDeclaration(Ee);
    },
    AssignmentExpression(Ee, J) {
      J.assignments.push(Ee);
    },
    UpdateExpression(Ee, J) {
      J.constantViolations.push(Ee);
    },
    UnaryExpression(Ee, J) {
      Ee.node.operator === "delete" && J.constantViolations.push(Ee);
    },
    BlockScoped(Ee) {
      let J = Ee.scope;
      if (J.path === Ee && (J = J.parent), J.getBlockParent().registerDeclaration(Ee), Ee.isClassDeclaration() && Ee.node.id) {
        const _e = Ee.node.id.name;
        Ee.scope.bindings[_e] = Ee.scope.parent.getBinding(_e);
      }
    },
    CatchClause(Ee) {
      Ee.scope.registerBinding("let", Ee);
    },
    Function(Ee) {
      const J = Ee.get("params");
      for (const me of J)
        Ee.scope.registerBinding("param", me);
      Ee.isFunctionExpression() && Ee.has("id") && !Ee.get("id").node[P] && Ee.scope.registerBinding("local", Ee.get("id"), Ee);
    },
    ClassExpression(Ee) {
      Ee.has("id") && !Ee.get("id").node[P] && Ee.scope.registerBinding("local", Ee);
    }
  };
  let Se = 0;
  class Le {
    constructor(J) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const {
        node: me
      } = J, ke = g.scope.get(me);
      if ((ke == null ? void 0 : ke.path) === J)
        return ke;
      g.scope.set(me, this), this.uid = Se++, this.block = me, this.path = J, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
    }
    get parent() {
      var J;
      let me, ke = this.path;
      do {
        const _e = ke.key === "key" || ke.listKey === "decorators";
        ke = ke.parentPath, _e && ke.isMethod() && (ke = ke.parentPath), ke && ke.isScope() && (me = ke);
      } while (ke && !me);
      return (J = me) == null ? void 0 : J.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(J, me, ke) {
      (0, n.default)(J, me, this, ke, this.path);
    }
    generateDeclaredUidIdentifier(J) {
      const me = this.generateUidIdentifier(J);
      return this.push({
        id: me
      }), y(me);
    }
    generateUidIdentifier(J) {
      return S(this.generateUid(J));
    }
    generateUid(J = "temp") {
      J = Pe(J).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let me, ke = 1;
      do
        me = this._generateUid(J, ke), ke++;
      while (this.hasLabel(me) || this.hasBinding(me) || this.hasGlobal(me) || this.hasReference(me));
      const _e = this.getProgramParent();
      return _e.references[me] = true, _e.uids[me] = true, me;
    }
    _generateUid(J, me) {
      let ke = J;
      return me > 1 && (ke += me), `_${ke}`;
    }
    generateUidBasedOnNode(J, me) {
      const ke = [];
      ce(J, ke);
      let _e = ke.join("$");
      return _e = _e.replace(/^_/, "") || me || "ref", this.generateUid(_e.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(J, me) {
      return S(this.generateUidBasedOnNode(J, me));
    }
    isStatic(J) {
      if (F(J) || K(J) || z(J))
        return true;
      if (R(J)) {
        const me = this.getBinding(J.name);
        return me ? me.constant : this.hasBinding(J.name);
      }
      return false;
    }
    maybeGenerateMemoised(J, me) {
      if (this.isStatic(J))
        return null;
      {
        const ke = this.generateUidIdentifierBasedOnNode(J);
        return me ? ke : (this.push({
          id: ke
        }), y(ke));
      }
    }
    checkBlockScopedCollisions(J, me, ke, _e) {
      if (me === "param" || J.kind === "local")
        return;
      if (me === "let" || J.kind === "let" || J.kind === "const" || J.kind === "module" || J.kind === "param" && me === "const")
        throw this.hub.buildError(_e, `Duplicate declaration "${ke}"`, TypeError);
    }
    rename(J, me, ke) {
      const _e = this.getBinding(J);
      if (_e)
        return me = me || this.generateUidIdentifier(J).name, new s.default(_e, J, me).rename(ke);
    }
    _renameFromMap(J, me, ke, _e) {
      J[me] && (J[ke] = _e, J[me] = null);
    }
    dump() {
      const J = "-".repeat(60);
      console.log(J);
      let me = this;
      do {
        console.log("#", me.block.type);
        for (const ke of Object.keys(me.bindings)) {
          const _e = me.bindings[ke];
          console.log(" -", ke, {
            constant: _e.constant,
            references: _e.references,
            violations: _e.constantViolations.length,
            kind: _e.kind
          });
        }
      } while (me = me.parent);
      console.log(J);
    }
    toArray(J, me, ke) {
      if (R(J)) {
        const $e = this.getBinding(J.name);
        if ($e != null && $e.constant && $e.path.isGenericType("Array"))
          return J;
      }
      if (v(J))
        return J;
      if (R(J, {
        name: "arguments"
      }))
        return x(he(he(he(S("Array"), S("prototype")), S("slice")), S("call")), [J]);
      let _e;
      const Re = [J];
      return me === true ? _e = "toConsumableArray" : me ? (Re.push(de(me)), _e = "slicedToArray") : _e = "toArray", ke && (Re.unshift(this.hub.addHelper(_e)), _e = "maybeArrayLike"), x(this.hub.addHelper(_e), Re);
    }
    hasLabel(J) {
      return !!this.getLabel(J);
    }
    getLabel(J) {
      return this.labels.get(J);
    }
    registerLabel(J) {
      this.labels.set(J.node.label.name, J);
    }
    registerDeclaration(J) {
      if (J.isLabeledStatement())
        this.registerLabel(J);
      else if (J.isFunctionDeclaration())
        this.registerBinding("hoisted", J.get("id"), J);
      else if (J.isVariableDeclaration()) {
        const me = J.get("declarations");
        for (const ke of me)
          this.registerBinding(J.node.kind, ke);
      } else if (J.isClassDeclaration()) {
        if (J.node.declare)
          return;
        this.registerBinding("let", J);
      } else if (J.isImportDeclaration()) {
        const me = J.get("specifiers");
        for (const ke of me)
          this.registerBinding("module", ke);
      } else if (J.isExportDeclaration()) {
        const me = J.get("declaration");
        (me.isClassDeclaration() || me.isFunctionDeclaration() || me.isVariableDeclaration()) && this.registerDeclaration(me);
      } else
        this.registerBinding("unknown", J);
    }
    buildUndefinedNode() {
      return we("void", de(0), true);
    }
    registerConstantViolation(J) {
      const me = J.getBindingIdentifiers();
      for (const ke of Object.keys(me)) {
        const _e = this.getBinding(ke);
        _e && _e.reassign(J);
      }
    }
    registerBinding(J, me, ke = me) {
      if (!J)
        throw new ReferenceError("no `kind`");
      if (me.isVariableDeclaration()) {
        const $e = me.get("declarations");
        for (const Ge of $e)
          this.registerBinding(J, Ge);
        return;
      }
      const _e = this.getProgramParent(), Re = me.getOuterBindingIdentifiers(true);
      for (const $e of Object.keys(Re)) {
        _e.references[$e] = true;
        for (const Ge of Re[$e]) {
          const lt = this.getOwnBinding($e);
          if (lt) {
            if (lt.identifier === Ge)
              continue;
            this.checkBlockScopedCollisions(lt, J, $e, Ge);
          }
          lt ? this.registerConstantViolation(ke) : this.bindings[$e] = new h.default({
            identifier: Ge,
            scope: this,
            path: ke,
            kind: J
          });
        }
      }
    }
    addGlobal(J) {
      this.globals[J.name] = J;
    }
    hasUid(J) {
      let me = this;
      do
        if (me.uids[J])
          return true;
      while (me = me.parent);
      return false;
    }
    hasGlobal(J) {
      let me = this;
      do
        if (me.globals[J])
          return true;
      while (me = me.parent);
      return false;
    }
    hasReference(J) {
      return !!this.getProgramParent().references[J];
    }
    isPure(J, me) {
      if (R(J)) {
        const $e = this.getBinding(J.name);
        return $e ? me ? $e.constant : true : false;
      } else {
        if (F(J) || W(J) || z(J) || ae(J))
          return true;
        if (C(J)) {
          var ke;
          return J.superClass && !this.isPure(J.superClass, me) || ((ke = J.decorators) == null ? void 0 : ke.length) > 0 ? false : this.isPure(J.body, me);
        } else if (I(J)) {
          for (const $e of J.body)
            if (!this.isPure($e, me))
              return false;
          return true;
        } else {
          if (T(J))
            return this.isPure(J.left, me) && this.isPure(J.right, me);
          if (v(J) || Te(J)) {
            for (const $e of J.elements)
              if ($e !== null && !this.isPure($e, me))
                return false;
            return true;
          } else if (ne(J) || Ie(J)) {
            for (const $e of J.properties)
              if (!this.isPure($e, me))
                return false;
            return true;
          } else if (M(J)) {
            var _e;
            return !(J.computed && !this.isPure(J.key, me) || ((_e = J.decorators) == null ? void 0 : _e.length) > 0);
          } else if (Q(J)) {
            var Re;
            return !(J.computed && !this.isPure(J.key, me) || ((Re = J.decorators) == null ? void 0 : Re.length) > 0 || (pe(J) || J.static) && J.value !== null && !this.isPure(J.value, me));
          } else {
            if (le(J))
              return this.isPure(J.argument, me);
            if (G(J))
              return fe(J.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(J.quasi, me);
            if (V(J)) {
              for (const $e of J.expressions)
                if (!this.isPure($e, me))
                  return false;
              return true;
            } else
              return q(J);
          }
        }
      }
    }
    setData(J, me) {
      return this.data[J] = me;
    }
    getData(J) {
      let me = this;
      do {
        const ke = me.data[J];
        if (ke != null)
          return ke;
      } while (me = me.parent);
    }
    removeData(J) {
      let me = this;
      do
        me.data[J] != null && (me.data[J] = null);
      while (me = me.parent);
    }
    init() {
      this.inited || (this.inited = true, this.crawl());
    }
    crawl() {
      const J = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      const me = this.getProgramParent();
      if (me.crawling)
        return;
      const ke = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = true, J.type !== "Program" && xe._exploded) {
        for (const Re of xe.enter)
          Re(J, ke);
        const _e = xe[J.type];
        if (_e)
          for (const Re of _e.enter)
            Re(J, ke);
      }
      J.traverse(xe, ke), this.crawling = false;
      for (const _e of ke.assignments) {
        const Re = _e.getBindingIdentifiers();
        for (const $e of Object.keys(Re))
          _e.scope.getBinding($e) || me.addGlobal(Re[$e]);
        _e.scope.registerConstantViolation(_e);
      }
      for (const _e of ke.references) {
        const Re = _e.scope.getBinding(_e.node.name);
        Re ? Re.reference(_e) : me.addGlobal(_e.node);
      }
      for (const _e of ke.constantViolations)
        _e.scope.registerConstantViolation(_e);
    }
    push(J) {
      let me = this.path;
      me.isPattern() ? me = this.getPatternParent().path : !me.isBlockStatement() && !me.isProgram() && (me = this.getBlockParent().path), me.isSwitchStatement() && (me = (this.getFunctionParent() || this.getProgramParent()).path), (me.isLoop() || me.isCatchClause() || me.isFunction()) && (me.ensureBlock(), me = me.get("body"));
      const ke = J.unique, _e = J.kind || "var", Re = J._blockHoist == null ? 2 : J._blockHoist, $e = `declaration:${_e}:${Re}`;
      let Ge = !ke && me.getData($e);
      if (!Ge) {
        const Xe = H(_e, []);
        Xe._blockHoist = Re, [Ge] = me.unshiftContainer("body", [Xe]), ke || me.setData($e, Ge);
      }
      const lt = te(J.id, J.init), Ze = Ge.node.declarations.push(lt);
      me.scope.registerBinding(_e, Ge.get("declarations")[Ze - 1]);
    }
    getProgramParent() {
      let J = this;
      do
        if (J.path.isProgram())
          return J;
      while (J = J.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let J = this;
      do
        if (J.path.isFunctionParent())
          return J;
      while (J = J.parent);
      return null;
    }
    getBlockParent() {
      let J = this;
      do
        if (J.path.isBlockParent())
          return J;
      while (J = J.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let J = this;
      do
        if (!J.path.isPattern())
          return J.getBlockParent();
      while (J = J.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const J = /* @__PURE__ */ Object.create(null);
      let me = this;
      do {
        for (const ke of Object.keys(me.bindings))
          ke in J || (J[ke] = me.bindings[ke]);
        me = me.parent;
      } while (me);
      return J;
    }
    getAllBindingsOfKind(...J) {
      const me = /* @__PURE__ */ Object.create(null);
      for (const ke of J) {
        let _e = this;
        do {
          for (const Re of Object.keys(_e.bindings)) {
            const $e = _e.bindings[Re];
            $e.kind === ke && (me[Re] = $e);
          }
          _e = _e.parent;
        } while (_e);
      }
      return me;
    }
    bindingIdentifierEquals(J, me) {
      return this.getBindingIdentifier(J) === me;
    }
    getBinding(J) {
      let me = this, ke;
      do {
        const Re = me.getOwnBinding(J);
        if (Re) {
          var _e;
          if (!((_e = ke) != null && _e.isPattern() && Re.kind !== "param" && Re.kind !== "local"))
            return Re;
        } else if (!Re && J === "arguments" && me.path.isFunction() && !me.path.isArrowFunctionExpression())
          break;
        ke = me.path;
      } while (me = me.parent);
    }
    getOwnBinding(J) {
      return this.bindings[J];
    }
    getBindingIdentifier(J) {
      var me;
      return (me = this.getBinding(J)) == null ? void 0 : me.identifier;
    }
    getOwnBindingIdentifier(J) {
      const me = this.bindings[J];
      return me == null ? void 0 : me.identifier;
    }
    hasOwnBinding(J) {
      return !!this.getOwnBinding(J);
    }
    hasBinding(J, me) {
      return J ? !!(this.hasOwnBinding(J) || this.parentHasBinding(J, me) || this.hasUid(J) || !me && Le.globals.includes(J) || !me && Le.contextVariables.includes(J)) : false;
    }
    parentHasBinding(J, me) {
      var ke;
      return (ke = this.parent) == null ? void 0 : ke.hasBinding(J, me);
    }
    moveBindingTo(J, me) {
      const ke = this.getBinding(J);
      ke && (ke.scope.removeOwnBinding(J), ke.scope = me, me.bindings[J] = ke);
    }
    removeOwnBinding(J) {
      delete this.bindings[J];
    }
    removeBinding(J) {
      var me;
      (me = this.getBinding(J)) == null || me.scope.removeOwnBinding(J);
      let ke = this;
      do
        ke.uids[J] && (ke.uids[J] = false);
      while (ke = ke.parent);
    }
  }
  return oa.default = Le, Le.globals = Object.keys(f2.builtin), Le.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], oa;
}
var wn = {};
var ca = {};
var Go = { exports: {} };
var Xo = { exports: {} };
var Oh;
function Hy() {
  return Oh || (Oh = 1, function(s, n) {
    (function(h, f2) {
      f2(n);
    })(f, function(h) {
      h.get = void 0, h.put = void 0, h.pop = void 0;
      class f2 {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      h.get = (p, g) => p._indexes[g], h.put = (p, g) => {
        const P = h.get(p, g);
        if (P !== void 0)
          return P;
        const { array: x, _indexes: y } = p;
        return y[g] = x.push(g) - 1;
      }, h.pop = (p) => {
        const { array: g, _indexes: P } = p;
        if (g.length === 0)
          return;
        const x = g.pop();
        P[x] = void 0;
      }, h.SetArray = f2, Object.defineProperty(h, "__esModule", { value: true });
    });
  }(Xo, Xo.exports)), Xo.exports;
}
var Jo = { exports: {} };
var Dh;
function Qc() {
  return Dh || (Dh = 1, function(s, n) {
    (function(h, f2) {
      f2(n);
    })(f, function(h) {
      const f2 = ",".charCodeAt(0), p = ";".charCodeAt(0), g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", P = new Uint8Array(64), x = new Uint8Array(128);
      for (let _ = 0; _ < g.length; _++) {
        const m = g.charCodeAt(_);
        P[_] = m, x[m] = _;
      }
      const y = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? {
        decode(_) {
          return Buffer.from(_.buffer, _.byteOffset, _.byteLength).toString();
        }
      } : {
        decode(_) {
          let m = "";
          for (let L = 0; L < _.length; L++)
            m += String.fromCharCode(_[L]);
          return m;
        }
      };
      function A(_) {
        const m = new Int32Array(5), L = [];
        let R = 0;
        do {
          const O = S(_, R), B = [];
          let M = true, j = 0;
          m[0] = 0;
          for (let $ = R; $ < O; $++) {
            let k;
            $ = v(_, $, m, 0);
            const ne = m[0];
            ne < j && (M = false), j = ne, T(_, $, O) ? ($ = v(_, $, m, 1), $ = v(_, $, m, 2), $ = v(_, $, m, 3), T(_, $, O) ? ($ = v(_, $, m, 4), k = [ne, m[1], m[2], m[3], m[4]]) : k = [ne, m[1], m[2], m[3]]) : k = [ne], B.push(k);
          }
          M || C(B), L.push(B), R = O + 1;
        } while (R <= _.length);
        return L;
      }
      function S(_, m) {
        const L = _.indexOf(";", m);
        return L === -1 ? _.length : L;
      }
      function v(_, m, L, R) {
        let O = 0, B = 0, M = 0;
        do {
          const $ = _.charCodeAt(m++);
          M = x[$], O |= (M & 31) << B, B += 5;
        } while (M & 32);
        const j = O & 1;
        return O >>>= 1, j && (O = -2147483648 | -O), L[R] += O, m;
      }
      function T(_, m, L) {
        return m >= L ? false : _.charCodeAt(m) !== f2;
      }
      function C(_) {
        _.sort(I);
      }
      function I(_, m) {
        return _[0] - m[0];
      }
      function N(_) {
        const m = new Int32Array(5), L = 1024 * 16, R = L - 36, O = new Uint8Array(L), B = O.subarray(0, R);
        let M = 0, j = "";
        for (let $ = 0; $ < _.length; $++) {
          const k = _[$];
          if ($ > 0 && (M === L && (j += y.decode(O), M = 0), O[M++] = p), k.length !== 0) {
            m[0] = 0;
            for (let ne = 0; ne < k.length; ne++) {
              const Q = k[ne];
              M > R && (j += y.decode(B), O.copyWithin(0, R, M), M -= R), ne > 0 && (O[M++] = f2), M = D(O, M, m, Q, 0), Q.length !== 1 && (M = D(O, M, m, Q, 1), M = D(O, M, m, Q, 2), M = D(O, M, m, Q, 3), Q.length !== 4 && (M = D(O, M, m, Q, 4)));
            }
          }
        }
        return j + y.decode(O.subarray(0, M));
      }
      function D(_, m, L, R, O) {
        const B = R[O];
        let M = B - L[O];
        L[O] = B, M = M < 0 ? -M << 1 | 1 : M << 1;
        do {
          let j = M & 31;
          M >>>= 5, M > 0 && (j |= 32), _[m++] = P[j];
        } while (M > 0);
        return m;
      }
      h.decode = A, h.encode = N, Object.defineProperty(h, "__esModule", { value: true });
    });
  }(Jo, Jo.exports)), Jo.exports;
}
var Yo = { exports: {} };
var Wu = { exports: {} };
var Lh;
function lT() {
  return Lh || (Lh = 1, function(s, n) {
    (function(h, f2) {
      s.exports = f2();
    })(f, function() {
      const h = /^[\w+.-]+:\/\//, f2 = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, p = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var g;
      (function(L) {
        L[L.Empty = 1] = "Empty", L[L.Hash = 2] = "Hash", L[L.Query = 3] = "Query", L[L.RelativePath = 4] = "RelativePath", L[L.AbsolutePath = 5] = "AbsolutePath", L[L.SchemeRelative = 6] = "SchemeRelative", L[L.Absolute = 7] = "Absolute";
      })(g || (g = {}));
      function P(L) {
        return h.test(L);
      }
      function x(L) {
        return L.startsWith("//");
      }
      function y(L) {
        return L.startsWith("/");
      }
      function A(L) {
        return L.startsWith("file:");
      }
      function S(L) {
        return /^[.?#]/.test(L);
      }
      function v(L) {
        const R = f2.exec(L);
        return C(R[1], R[2] || "", R[3], R[4] || "", R[5] || "/", R[6] || "", R[7] || "");
      }
      function T(L) {
        const R = p.exec(L), O = R[2];
        return C("file:", "", R[1] || "", "", y(O) ? O : "/" + O, R[3] || "", R[4] || "");
      }
      function C(L, R, O, B, M, j, $) {
        return {
          scheme: L,
          user: R,
          host: O,
          port: B,
          path: M,
          query: j,
          hash: $,
          type: g.Absolute
        };
      }
      function I(L) {
        if (x(L)) {
          const O = v("http:" + L);
          return O.scheme = "", O.type = g.SchemeRelative, O;
        }
        if (y(L)) {
          const O = v("http://foo.com" + L);
          return O.scheme = "", O.host = "", O.type = g.AbsolutePath, O;
        }
        if (A(L))
          return T(L);
        if (P(L))
          return v(L);
        const R = v("http://foo.com/" + L);
        return R.scheme = "", R.host = "", R.type = L ? L.startsWith("?") ? g.Query : L.startsWith("#") ? g.Hash : g.RelativePath : g.Empty, R;
      }
      function N(L) {
        if (L.endsWith("/.."))
          return L;
        const R = L.lastIndexOf("/");
        return L.slice(0, R + 1);
      }
      function D(L, R) {
        _(R, R.type), L.path === "/" ? L.path = R.path : L.path = N(R.path) + L.path;
      }
      function _(L, R) {
        const O = R <= g.RelativePath, B = L.path.split("/");
        let M = 1, j = 0, $ = false;
        for (let ne = 1; ne < B.length; ne++) {
          const Q = B[ne];
          if (!Q) {
            $ = true;
            continue;
          }
          if ($ = false, Q !== ".") {
            if (Q === "..") {
              j ? ($ = true, j--, M--) : O && (B[M++] = Q);
              continue;
            }
            B[M++] = Q, j++;
          }
        }
        let k = "";
        for (let ne = 1; ne < M; ne++)
          k += "/" + B[ne];
        (!k || $ && !k.endsWith("/..")) && (k += "/"), L.path = k;
      }
      function m(L, R) {
        if (!L && !R)
          return "";
        const O = I(L);
        let B = O.type;
        if (R && B !== g.Absolute) {
          const j = I(R), $ = j.type;
          switch (B) {
            case g.Empty:
              O.hash = j.hash;
            case g.Hash:
              O.query = j.query;
            case g.Query:
            case g.RelativePath:
              D(O, j);
            case g.AbsolutePath:
              O.user = j.user, O.host = j.host, O.port = j.port;
            case g.SchemeRelative:
              O.scheme = j.scheme;
          }
          $ > B && (B = $);
        }
        _(O, B);
        const M = O.query + O.hash;
        switch (B) {
          case g.Hash:
          case g.Query:
            return M;
          case g.RelativePath: {
            const j = O.path.slice(1);
            return j ? S(R || L) && !S(j) ? "./" + j + M : j + M : M || ".";
          }
          case g.AbsolutePath:
            return O.path + M;
          default:
            return O.scheme + "//" + O.user + O.host + O.port + O.path + M;
        }
      }
      return m;
    });
  }(Wu)), Wu.exports;
}
var Mh;
function zy() {
  return Mh || (Mh = 1, function(s, n) {
    (function(h, f2) {
      f2(n, Qc(), lT());
    })(f, function(h, f2, p) {
      function g(te) {
        return te && typeof te == "object" && "default" in te ? te : { default: te };
      }
      var P = g(p);
      function x(te, Ie) {
        return Ie && !Ie.endsWith("/") && (Ie += "/"), P.default(te, Ie);
      }
      function y(te) {
        if (!te)
          return "";
        const Ie = te.lastIndexOf("/");
        return te.slice(0, Ie + 1);
      }
      const A = 0, S = 1, v = 2, T = 3, C = 4, I = 1, N = 2;
      function D(te, Ie) {
        const Te = _(te, 0);
        if (Te === te.length)
          return te;
        Ie || (te = te.slice());
        for (let pe = Te; pe < te.length; pe = _(te, pe + 1))
          te[pe] = L(te[pe], Ie);
        return te;
      }
      function _(te, Ie) {
        for (let Te = Ie; Te < te.length; Te++)
          if (!m(te[Te]))
            return Te;
        return te.length;
      }
      function m(te) {
        for (let Ie = 1; Ie < te.length; Ie++)
          if (te[Ie][A] < te[Ie - 1][A])
            return false;
        return true;
      }
      function L(te, Ie) {
        return Ie || (te = te.slice()), te.sort(R);
      }
      function R(te, Ie) {
        return te[A] - Ie[A];
      }
      let O = false;
      function B(te, Ie, Te, pe) {
        for (; Te <= pe; ) {
          const z = Te + (pe - Te >> 1), W = te[z][A] - Ie;
          if (W === 0)
            return O = true, z;
          W < 0 ? Te = z + 1 : pe = z - 1;
        }
        return O = false, Te - 1;
      }
      function M(te, Ie, Te) {
        for (let pe = Te + 1; pe < te.length && te[pe][A] === Ie; Te = pe++)
          ;
        return Te;
      }
      function j(te, Ie, Te) {
        for (let pe = Te - 1; pe >= 0 && te[pe][A] === Ie; Te = pe--)
          ;
        return Te;
      }
      function $() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function k(te, Ie, Te, pe) {
        const { lastKey: z, lastNeedle: W, lastIndex: ae } = Te;
        let ce = 0, xe = te.length - 1;
        if (pe === z) {
          if (Ie === W)
            return O = ae !== -1 && te[ae][A] === Ie, ae;
          Ie >= W ? ce = ae === -1 ? 0 : ae : xe = ae;
        }
        return Te.lastKey = pe, Te.lastNeedle = Ie, Te.lastIndex = B(te, Ie, ce, xe);
      }
      function ne(te, Ie) {
        const Te = Ie.map(q);
        for (let pe = 0; pe < te.length; pe++) {
          const z = te[pe];
          for (let W = 0; W < z.length; W++) {
            const ae = z[W];
            if (ae.length === 1)
              continue;
            const ce = ae[S], xe = ae[v], Se = ae[T], Le = Te[ce], Ee = Le[xe] || (Le[xe] = []), J = Ie[ce], me = M(Ee, Se, k(Ee, Se, J, xe));
            Q(Ee, J.lastIndex = me + 1, [Se, pe, ae[A]]);
          }
        }
        return Te;
      }
      function Q(te, Ie, Te) {
        for (let pe = te.length; pe > Ie; pe--)
          te[pe] = te[pe - 1];
        te[Ie] = Te;
      }
      function q() {
        return { __proto__: null };
      }
      const ee = function(te, Ie) {
        const Te = typeof te == "string" ? JSON.parse(te) : te;
        if (!("sections" in Te))
          return new de(Te, Ie);
        const pe = [], z = [], W = [], ae = [];
        K(Te, Ie, pe, z, W, ae, 0, 0, 1 / 0, 1 / 0);
        const ce = {
          version: 3,
          file: Te.file,
          names: ae,
          sources: z,
          sourcesContent: W,
          mappings: pe
        };
        return h.presortedDecodedMap(ce);
      };
      function K(te, Ie, Te, pe, z, W, ae, ce, xe, Se) {
        const { sections: Le } = te;
        for (let Ee = 0; Ee < Le.length; Ee++) {
          const { map: J, offset: me } = Le[Ee];
          let ke = xe, _e = Se;
          if (Ee + 1 < Le.length) {
            const Re = Le[Ee + 1].offset;
            ke = Math.min(xe, ae + Re.line), ke === xe ? _e = Math.min(Se, ce + Re.column) : ke < xe && (_e = ce + Re.column);
          }
          G(J, Ie, Te, pe, z, W, ae + me.line, ce + me.column, ke, _e);
        }
      }
      function G(te, Ie, Te, pe, z, W, ae, ce, xe, Se) {
        if ("sections" in te)
          return K(...arguments);
        const Le = new de(te, Ie), Ee = pe.length, J = W.length, me = h.decodedMappings(Le), { resolvedSources: ke, sourcesContent: _e } = Le;
        if (V(pe, ke), V(W, Le.names), _e)
          V(z, _e);
        else
          for (let Re = 0; Re < ke.length; Re++)
            z.push(null);
        for (let Re = 0; Re < me.length; Re++) {
          const $e = ae + Re;
          if ($e > xe)
            return;
          const Ge = F(Te, $e), lt = Re === 0 ? ce : 0, Ze = me[Re];
          for (let Xe = 0; Xe < Ze.length; Xe++) {
            const et = Ze[Xe], st = lt + et[A];
            if ($e === xe && st >= Se)
              return;
            if (et.length === 1) {
              Ge.push([st]);
              continue;
            }
            const re = Ee + et[S], be = et[v], ue = et[T];
            Ge.push(et.length === 4 ? [st, re, be, ue] : [st, re, be, ue, J + et[C]]);
          }
        }
      }
      function V(te, Ie) {
        for (let Te = 0; Te < Ie.length; Te++)
          te.push(Ie[Te]);
      }
      function F(te, Ie) {
        for (let Te = te.length; Te <= Ie; Te++)
          te[Te] = [];
        return te[Ie];
      }
      const le = "`line` must be greater than 0 (lines start at line 1)", oe = "`column` must be greater than or equal to 0 (columns start at column 0)", fe = -1, he = 1;
      h.encodedMappings = void 0, h.decodedMappings = void 0, h.traceSegment = void 0, h.originalPositionFor = void 0, h.generatedPositionFor = void 0, h.eachMapping = void 0, h.sourceContentFor = void 0, h.presortedDecodedMap = void 0, h.decodedMap = void 0, h.encodedMap = void 0;
      class de {
        constructor(Ie, Te) {
          this._decodedMemo = $(), this._bySources = void 0, this._bySourceMemos = void 0;
          const pe = typeof Ie == "string";
          if (!pe && Ie._decodedMemo)
            return Ie;
          const z = pe ? JSON.parse(Ie) : Ie, { version: W, file: ae, names: ce, sourceRoot: xe, sources: Se, sourcesContent: Le } = z;
          this.version = W, this.file = ae, this.names = ce, this.sourceRoot = xe, this.sources = Se, this.sourcesContent = Le;
          const Ee = x(xe || "", y(Te));
          this.resolvedSources = Se.map((me) => x(me || "", Ee));
          const { mappings: J } = z;
          typeof J == "string" ? (this._encoded = J, this._decoded = void 0) : (this._encoded = void 0, this._decoded = D(J, pe));
        }
      }
      h.encodedMappings = (te) => {
        var Ie;
        return (Ie = te._encoded) !== null && Ie !== void 0 ? Ie : te._encoded = f2.encode(te._decoded);
      }, h.decodedMappings = (te) => te._decoded || (te._decoded = f2.decode(te._encoded)), h.traceSegment = (te, Ie, Te) => {
        const pe = h.decodedMappings(te);
        return Ie >= pe.length ? null : H(pe[Ie], te._decodedMemo, Ie, Te, he);
      }, h.originalPositionFor = (te, { line: Ie, column: Te, bias: pe }) => {
        if (Ie--, Ie < 0)
          throw new Error(le);
        if (Te < 0)
          throw new Error(oe);
        const z = h.decodedMappings(te);
        if (Ie >= z.length)
          return Pe(null, null, null, null);
        const W = H(z[Ie], te._decodedMemo, Ie, Te, pe || he);
        if (W == null || W.length == 1)
          return Pe(null, null, null, null);
        const { names: ae, resolvedSources: ce } = te;
        return Pe(ce[W[S]], W[v] + 1, W[T], W.length === 5 ? ae[W[C]] : null);
      }, h.generatedPositionFor = (te, { source: Ie, line: Te, column: pe, bias: z }) => {
        if (Te--, Te < 0)
          throw new Error(le);
        if (pe < 0)
          throw new Error(oe);
        const { sources: W, resolvedSources: ae } = te;
        let ce = W.indexOf(Ie);
        if (ce === -1 && (ce = ae.indexOf(Ie)), ce === -1)
          return we(null, null);
        const xe = te._bySources || (te._bySources = ne(h.decodedMappings(te), te._bySourceMemos = W.map($))), Se = te._bySourceMemos, Le = xe[ce][Te];
        if (Le == null)
          return we(null, null);
        const Ee = H(Le, Se[ce], Te, pe, z || he);
        return Ee == null ? we(null, null) : we(Ee[I] + 1, Ee[N]);
      }, h.eachMapping = (te, Ie) => {
        const Te = h.decodedMappings(te), { names: pe, resolvedSources: z } = te;
        for (let W = 0; W < Te.length; W++) {
          const ae = Te[W];
          for (let ce = 0; ce < ae.length; ce++) {
            const xe = ae[ce], Se = W + 1, Le = xe[0];
            let Ee = null, J = null, me = null, ke = null;
            xe.length !== 1 && (Ee = z[xe[1]], J = xe[2] + 1, me = xe[3]), xe.length === 5 && (ke = pe[xe[4]]), Ie({
              generatedLine: Se,
              generatedColumn: Le,
              source: Ee,
              originalLine: J,
              originalColumn: me,
              name: ke
            });
          }
        }
      }, h.sourceContentFor = (te, Ie) => {
        const { sources: Te, resolvedSources: pe, sourcesContent: z } = te;
        if (z == null)
          return null;
        let W = Te.indexOf(Ie);
        return W === -1 && (W = pe.indexOf(Ie)), W === -1 ? null : z[W];
      }, h.presortedDecodedMap = (te, Ie) => {
        const Te = Object.assign({}, te);
        Te.mappings = [];
        const pe = new de(Te, Ie);
        return pe._decoded = te.mappings, pe;
      }, h.decodedMap = (te) => ({
        version: 3,
        file: te.file,
        names: te.names,
        sourceRoot: te.sourceRoot,
        sources: te.sources,
        sourcesContent: te.sourcesContent,
        mappings: h.decodedMappings(te)
      }), h.encodedMap = (te) => ({
        version: 3,
        file: te.file,
        names: te.names,
        sourceRoot: te.sourceRoot,
        sources: te.sources,
        sourcesContent: te.sourcesContent,
        mappings: h.encodedMappings(te)
      });
      function Pe(te, Ie, Te, pe) {
        return { source: te, line: Ie, column: Te, name: pe };
      }
      function we(te, Ie) {
        return { line: te, column: Ie };
      }
      function H(te, Ie, Te, pe, z) {
        let W = k(te, pe, Ie, Te);
        return O ? W = (z === fe ? M : j)(te, pe, W) : z === fe && W++, W === -1 || W === te.length ? null : te[W];
      }
      h.AnyMap = ee, h.GREATEST_LOWER_BOUND = he, h.LEAST_UPPER_BOUND = fe, h.TraceMap = de, Object.defineProperty(h, "__esModule", { value: true });
    });
  }(Yo, Yo.exports)), Yo.exports;
}
var Bh;
function uT() {
  return Bh || (Bh = 1, function(s, n) {
    (function(h, f2) {
      f2(n, Hy(), Qc(), zy());
    })(f, function(h, f2, p, g) {
      h.addSegment = void 0, h.addMapping = void 0, h.maybeAddSegment = void 0, h.maybeAddMapping = void 0, h.setSourceContent = void 0, h.toDecodedMap = void 0, h.toEncodedMap = void 0, h.fromMap = void 0, h.allMappings = void 0;
      let T;
      class C {
        constructor({ file: M, sourceRoot: j } = {}) {
          this._names = new f2.SetArray(), this._sources = new f2.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = M, this.sourceRoot = j;
        }
      }
      h.addSegment = (B, M, j, $, k, ne, Q, q) => T(false, B, M, j, $, k, ne, Q, q), h.maybeAddSegment = (B, M, j, $, k, ne, Q, q) => T(true, B, M, j, $, k, ne, Q, q), h.addMapping = (B, M) => O(false, B, M), h.maybeAddMapping = (B, M) => O(true, B, M), h.setSourceContent = (B, M, j) => {
        const { _sources: $, _sourcesContent: k } = B;
        k[f2.put($, M)] = j;
      }, h.toDecodedMap = (B) => {
        const { file: M, sourceRoot: j, _mappings: $, _sources: k, _sourcesContent: ne, _names: Q } = B;
        return _($), {
          version: 3,
          file: M || void 0,
          names: Q.array,
          sourceRoot: j || void 0,
          sources: k.array,
          sourcesContent: ne,
          mappings: $
        };
      }, h.toEncodedMap = (B) => {
        const M = h.toDecodedMap(B);
        return Object.assign(Object.assign({}, M), { mappings: p.encode(M.mappings) });
      }, h.allMappings = (B) => {
        const M = [], { _mappings: j, _sources: $, _names: k } = B;
        for (let ne = 0; ne < j.length; ne++) {
          const Q = j[ne];
          for (let q = 0; q < Q.length; q++) {
            const ee = Q[q], K = { line: ne + 1, column: ee[0] };
            let G, V, F;
            ee.length !== 1 && (G = $.array[ee[1]], V = { line: ee[2] + 1, column: ee[3] }, ee.length === 5 && (F = k.array[ee[4]])), M.push({ generated: K, source: G, original: V, name: F });
          }
        }
        return M;
      }, h.fromMap = (B) => {
        const M = new g.TraceMap(B), j = new C({ file: M.file, sourceRoot: M.sourceRoot });
        return m(j._names, M.names), m(j._sources, M.sources), j._sourcesContent = M.sourcesContent || M.sources.map(() => null), j._mappings = g.decodedMappings(M), j;
      }, T = (B, M, j, $, k, ne, Q, q, ee) => {
        const { _mappings: K, _sources: G, _sourcesContent: V, _names: F } = M, le = I(K, j), oe = N(le, $);
        if (!k)
          return B && L(le, oe) ? void 0 : D(le, oe, [$]);
        const fe = f2.put(G, k), he = q ? f2.put(F, q) : -1;
        if (fe === V.length && (V[fe] = ee != null ? ee : null), !(B && R(le, oe, fe, ne, Q, he)))
          return D(le, oe, q ? [$, fe, ne, Q, he] : [$, fe, ne, Q]);
      };
      function I(B, M) {
        for (let j = B.length; j <= M; j++)
          B[j] = [];
        return B[M];
      }
      function N(B, M) {
        let j = B.length;
        for (let $ = j - 1; $ >= 0; j = $--) {
          const k = B[$];
          if (M >= k[0])
            break;
        }
        return j;
      }
      function D(B, M, j) {
        for (let $ = B.length; $ > M; $--)
          B[$] = B[$ - 1];
        B[M] = j;
      }
      function _(B) {
        const { length: M } = B;
        let j = M;
        for (let $ = j - 1; $ >= 0 && !(B[$].length > 0); j = $, $--)
          ;
        j < M && (B.length = j);
      }
      function m(B, M) {
        for (let j = 0; j < M.length; j++)
          f2.put(B, M[j]);
      }
      function L(B, M) {
        return M === 0 ? true : B[M - 1].length === 1;
      }
      function R(B, M, j, $, k, ne) {
        if (M === 0)
          return false;
        const Q = B[M - 1];
        return Q.length === 1 ? false : j === Q[1] && $ === Q[2] && k === Q[3] && ne === (Q.length === 5 ? Q[4] : -1);
      }
      function O(B, M, j) {
        const { generated: $, source: k, original: ne, name: Q, content: q } = j;
        if (!k)
          return T(B, M, $.line - 1, $.column, null, null, null, null, null);
        const ee = k;
        return T(B, M, $.line - 1, $.column, ee, ne.line - 1, ne.column, Q, q);
      }
      h.GenMapping = C, Object.defineProperty(h, "__esModule", { value: true });
    });
  }(Go, Go.exports)), Go.exports;
}
var _h;
function cT() {
  if (_h)
    return ca;
  _h = 1, Object.defineProperty(ca, "__esModule", {
    value: true
  }), ca.default = void 0;
  var s = uT();
  class n {
    constructor(f2, p) {
      var g;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0;
      const P = this._map = new s.GenMapping({
        sourceRoot: f2.sourceRoot
      });
      this._sourceFileName = (g = f2.sourceFileName) == null ? void 0 : g.replace(/\\/g, "/"), this._rawMappings = void 0, typeof p == "string" ? (0, s.setSourceContent)(P, this._sourceFileName, p) : typeof p == "object" && Object.keys(p).forEach((x) => {
        (0, s.setSourceContent)(P, x.replace(/\\/g, "/"), p[x]);
      });
    }
    get() {
      return (0, s.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, s.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, s.allMappings)(this._map));
    }
    mark(f2, p, g, P, x) {
      this._rawMappings = void 0, (0, s.maybeAddMapping)(this._map, {
        name: P,
        generated: f2,
        source: p == null ? void 0 : (x == null ? void 0 : x.replace(/\\/g, "/")) || this._sourceFileName,
        original: p == null ? void 0 : {
          line: p,
          column: g
        }
      });
    }
  }
  return ca.default = n, ca;
}
var pa = {};
var fa = {};
var Fh;
function pT() {
  if (Fh)
    return fa;
  Fh = 1, Object.defineProperty(fa, "__esModule", {
    value: true
  }), fa.default = void 0;
  function s() {
    return {
      identifierName: void 0,
      line: void 0,
      column: void 0,
      filename: void 0
    };
  }
  class n {
    constructor(f2) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = s(), this._disallowedPop = {
        identifierName: void 0,
        line: void 0,
        column: void 0,
        filename: void 0,
        objectReusable: true
      }, this._map = f2, this._allocQueue();
    }
    _allocQueue() {
      const f2 = this._queue;
      for (let p = 0; p < 16; p++)
        f2.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          filename: ""
        });
    }
    _pushQueue(f2, p, g, P, x, y) {
      const A = this._queueCursor;
      A === this._queue.length && this._allocQueue();
      const S = this._queue[A];
      S.char = f2, S.repeat = p, S.line = g, S.column = P, S.identifierName = x, S.filename = y, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const f2 = this._map, p = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: f2 == null ? void 0 : f2.getDecoded(),
        get map() {
          const g = f2 ? f2.get() : null;
          return p.map = g, g;
        },
        set map(g) {
          Object.defineProperty(p, "map", {
            value: g,
            writable: true
          });
        },
        get rawMappings() {
          const g = f2 == null ? void 0 : f2.getRawMappings();
          return p.rawMappings = g, g;
        },
        set rawMappings(g) {
          Object.defineProperty(p, "rawMappings", {
            value: g,
            writable: true
          });
        }
      };
      return p;
    }
    append(f2, p) {
      this._flush(), this._append(f2, this._sourcePosition, p);
    }
    appendChar(f2) {
      this._flush(), this._appendChar(f2, 1, this._sourcePosition);
    }
    queue(f2) {
      if (f2 === 10)
        for (; this._queueCursor !== 0; ) {
          const g = this._queue[this._queueCursor - 1].char;
          if (g !== 32 && g !== 9)
            break;
          this._queueCursor--;
        }
      const p = this._sourcePosition;
      this._pushQueue(f2, 1, p.line, p.column, p.identifierName, p.filename);
    }
    queueIndentation(f2, p) {
      this._pushQueue(f2, p, void 0, void 0, void 0, void 0);
    }
    _flush() {
      const f2 = this._queueCursor, p = this._queue;
      for (let g = 0; g < f2; g++) {
        const P = p[g];
        this._appendChar(P.char, P.repeat, P);
      }
      this._queueCursor = 0;
    }
    _appendChar(f2, p, g) {
      this._last = f2, this._str += p > 1 ? String.fromCharCode(f2).repeat(p) : String.fromCharCode(f2), f2 !== 10 ? (this._mark(g.line, g.column, g.identifierName, g.filename), this._position.column += p) : (this._position.line++, this._position.column = 0);
    }
    _append(f2, p, g) {
      const P = f2.length;
      if (this._last = f2.charCodeAt(P - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = f2, this._appendCount = 0) : this._str += f2, !g && !this._map) {
        this._position.column += P;
        return;
      }
      const {
        column: x,
        identifierName: y,
        filename: A
      } = p;
      let S = p.line, v = f2.indexOf(`
`), T = 0;
      for (v !== 0 && this._mark(S, x, y, A); v !== -1; )
        this._position.line++, this._position.column = 0, T = v + 1, T < f2.length && this._mark(++S, 0, y, A), v = f2.indexOf(`
`, T);
      this._position.column += f2.length - T;
    }
    _mark(f2, p, g, P) {
      var x;
      (x = this._map) == null || x.mark(this._position, f2, p, g, P);
    }
    removeTrailingNewline() {
      const f2 = this._queueCursor;
      f2 !== 0 && this._queue[f2 - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      const f2 = this._queueCursor;
      f2 !== 0 && this._queue[f2 - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      const f2 = this._queueCursor;
      return f2 !== 0 ? this._queue[f2 - 1].char : this._last;
    }
    endsWithCharAndNewline() {
      const f2 = this._queue, p = this._queueCursor;
      if (p !== 0)
        return f2[p - 1].char !== 10 ? void 0 : p > 1 ? f2[p - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(f2, p) {
      if (!this._map)
        return p();
      this.source("start", f2), p(), this.source("end", f2), this._disallowPop("start", f2);
    }
    source(f2, p) {
      !p || this._normalizePosition(f2, p, this._sourcePosition);
    }
    withSource(f2, p, g) {
      if (!this._map)
        return g();
      const P = this._sourcePosition.line, x = this._sourcePosition.column, y = this._sourcePosition.filename, A = this._sourcePosition.identifierName;
      this.source(f2, p), g(), (this._disallowedPop.objectReusable || this._disallowedPop.line !== P || this._disallowedPop.column !== x || this._disallowedPop.filename !== y) && (this._sourcePosition.line = P, this._sourcePosition.column = x, this._sourcePosition.filename = y, this._sourcePosition.identifierName = A, this._disallowedPop.objectReusable = true);
    }
    _disallowPop(f2, p) {
      if (!p)
        return;
      const g = this._disallowedPop;
      this._normalizePosition(f2, p, g), g.objectReusable = false;
    }
    _normalizePosition(f2, p, g) {
      const P = p[f2];
      g.identifierName = f2 === "start" && p.identifierName || void 0, P ? (g.line = P.line, g.column = P.column, g.filename = p.filename) : (g.line = null, g.column = null, g.filename = null);
    }
    getCurrentColumn() {
      const f2 = this._queue;
      let p = -1, g = 0;
      for (let P = 0; P < this._queueCursor; P++) {
        const x = f2[P];
        x.char === 10 && (p = P, g += x.repeat);
      }
      return p === -1 ? this._position.column + g : g - 1 - p;
    }
    getCurrentLine() {
      let f2 = 0;
      const p = this._queue;
      for (let g = 0; g < this._queueCursor; g++)
        p[g].char === 10 && f2++;
      return this._position.line + f2;
    }
  }
  return fa.default = n, fa;
}
var hn = {};
var ha = {};
var jh;
function fT() {
  if (jh)
    return ha;
  jh = 1, Object.defineProperty(ha, "__esModule", {
    value: true
  }), ha.nodes = void 0;
  var s = Je();
  const {
    FLIPPED_ALIAS_KEYS: n,
    isArrayExpression: h,
    isAssignmentExpression: f2,
    isBinary: p,
    isBlockStatement: g,
    isCallExpression: P,
    isFunction: x,
    isIdentifier: y,
    isLiteral: A,
    isMemberExpression: S,
    isObjectExpression: v,
    isOptionalCallExpression: T,
    isOptionalMemberExpression: C,
    isStringLiteral: I
  } = s;
  var N = {
    before: 1,
    after: 2
  };
  function D(O, B) {
    return O && (S(O) || C(O) ? (D(O.object, B), O.computed && D(O.property, B)) : p(O) || f2(O) ? (D(O.left, B), D(O.right, B)) : P(O) || T(O) ? (B.hasCall = true, D(O.callee, B)) : x(O) ? B.hasFunction = true : y(O) && (B.hasHelper = B.hasHelper || O.callee && m(O.callee))), B;
  }
  function _(O) {
    return D(O, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  }
  function m(O) {
    return O ? S(O) ? m(O.object) || m(O.property) : y(O) ? O.name === "require" || O.name.charCodeAt(0) === 95 : P(O) ? m(O.callee) : p(O) || f2(O) ? y(O.left) && m(O.left) || m(O.right) : false : false;
  }
  function L(O) {
    return A(O) || v(O) || h(O) || y(O) || S(O);
  }
  const R = {
    AssignmentExpression(O) {
      const B = _(O.right);
      if (B.hasCall && B.hasHelper || B.hasFunction)
        return B.hasFunction ? N.before | N.after : N.after;
    },
    SwitchCase(O, B) {
      return (!!O.consequent.length || B.cases[0] === O ? N.before : 0) | (!O.consequent.length && B.cases[B.cases.length - 1] === O ? N.after : 0);
    },
    LogicalExpression(O) {
      if (x(O.left) || x(O.right))
        return N.after;
    },
    Literal(O) {
      if (I(O) && O.value === "use strict")
        return N.after;
    },
    CallExpression(O) {
      if (x(O.callee) || m(O))
        return N.before | N.after;
    },
    OptionalCallExpression(O) {
      if (x(O.callee))
        return N.before | N.after;
    },
    VariableDeclaration(O) {
      for (let B = 0; B < O.declarations.length; B++) {
        const M = O.declarations[B];
        let j = m(M.id) && !L(M.init);
        if (!j && M.init) {
          const $ = _(M.init);
          j = m(M.init) && $.hasCall || $.hasFunction;
        }
        if (j)
          return N.before | N.after;
      }
    },
    IfStatement(O) {
      if (g(O.consequent))
        return N.before | N.after;
    }
  };
  return ha.nodes = R, R.ObjectProperty = R.ObjectTypeProperty = R.ObjectMethod = function(O, B) {
    if (B.properties[0] === O)
      return N.before;
  }, R.ObjectTypeCallProperty = function(O, B) {
    var M;
    if (B.callProperties[0] === O && !((M = B.properties) != null && M.length))
      return N.before;
  }, R.ObjectTypeIndexer = function(O, B) {
    var M, j;
    if (B.indexers[0] === O && !((M = B.properties) != null && M.length) && !((j = B.callProperties) != null && j.length))
      return N.before;
  }, R.ObjectTypeInternalSlot = function(O, B) {
    var M, j, $;
    if (B.internalSlots[0] === O && !((M = B.properties) != null && M.length) && !((j = B.callProperties) != null && j.length) && !(($ = B.indexers) != null && $.length))
      return N.before;
  }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([O, B]) {
    [O].concat(n[O] || []).forEach(function(M) {
      const j = B ? N.before | N.after : 0;
      R[M] = () => j;
    });
  }), ha;
}
var dt = {};
var Rh;
function hT() {
  if (Rh)
    return dt;
  Rh = 1, Object.defineProperty(dt, "__esModule", {
    value: true
  }), dt.ArrowFunctionExpression = Be, dt.AssignmentExpression = rt, dt.Binary = Re, dt.BinaryExpression = re, dt.ClassExpression = Me, dt.ConditionalExpression = X, dt.DoExpression = _e, dt.FunctionExpression = Ne, dt.FunctionTypeAnnotation = J, dt.Identifier = gt, dt.LogicalExpression = vt, dt.NullableTypeAnnotation = Ee, dt.ObjectExpression = ke, dt.OptionalIndexedAccessType = Ge, dt.OptionalCallExpression = dt.OptionalMemberExpression = je, dt.SequenceExpression = be, dt.TSAsExpression = lt, dt.TSInferType = et, dt.TSInstantiationExpression = st, dt.TSTypeAssertion = Ze, dt.TSIntersectionType = dt.TSUnionType = Xe, dt.UnaryLike = Y, dt.IntersectionTypeAnnotation = dt.UnionTypeAnnotation = $e, dt.UpdateExpression = me, dt.AwaitExpression = dt.YieldExpression = ue;
  var s = Je();
  const {
    isArrayTypeAnnotation: n,
    isArrowFunctionExpression: h,
    isAssignmentExpression: f2,
    isAwaitExpression: p,
    isBinary: g,
    isBinaryExpression: P,
    isUpdateExpression: x,
    isCallExpression: y,
    isClass: A,
    isClassExpression: S,
    isConditional: v,
    isConditionalExpression: T,
    isExportDeclaration: C,
    isExportDefaultDeclaration: I,
    isExpressionStatement: N,
    isFor: D,
    isForInStatement: _,
    isForOfStatement: m,
    isForStatement: L,
    isFunctionExpression: R,
    isIfStatement: O,
    isIndexedAccessType: B,
    isIntersectionTypeAnnotation: M,
    isLogicalExpression: j,
    isMemberExpression: $,
    isNewExpression: k,
    isNullableTypeAnnotation: ne,
    isObjectPattern: Q,
    isOptionalCallExpression: q,
    isOptionalMemberExpression: ee,
    isReturnStatement: K,
    isSequenceExpression: G,
    isSwitchStatement: V,
    isTSArrayType: F,
    isTSAsExpression: le,
    isTSInstantiationExpression: oe,
    isTSIntersectionType: fe,
    isTSNonNullExpression: he,
    isTSOptionalType: de,
    isTSRestType: Pe,
    isTSTypeAssertion: we,
    isTSUnionType: H,
    isTaggedTemplateExpression: te,
    isThrowStatement: Ie,
    isTypeAnnotation: Te,
    isUnaryLike: pe,
    isUnionTypeAnnotation: z,
    isVariableDeclarator: W,
    isWhileStatement: ae,
    isYieldExpression: ce
  } = s, xe = {
    "||": 0,
    "??": 0,
    "|>": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    in: 6,
    instanceof: 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10
  }, Se = (qe, De) => A(De, {
    superClass: qe
  }), Le = (qe, De) => ($(De) || ee(De)) && De.object === qe || (y(De) || q(De) || k(De)) && De.callee === qe || te(De) && De.tag === qe || he(De);
  function Ee(qe, De) {
    return n(De);
  }
  function J(qe, De, Tt) {
    if (!(Tt.length < 3))
      return z(De) || M(De) || n(De) || Te(De) && h(Tt[Tt.length - 3]);
  }
  function me(qe, De) {
    return Le(qe, De) || Se(qe, De);
  }
  function ke(qe, De, Tt) {
    return ut(Tt, 3);
  }
  function _e(qe, De, Tt) {
    return !qe.async && ut(Tt, 1);
  }
  function Re(qe, De) {
    if (qe.operator === "**" && P(De, {
      operator: "**"
    }))
      return De.left === qe;
    if (Se(qe, De) || Le(qe, De) || pe(De) || p(De))
      return true;
    if (g(De)) {
      const Tt = De.operator, sr = xe[Tt], ar = qe.operator, Nr = xe[ar];
      if (sr === Nr && De.right === qe && !j(De) || sr > Nr)
        return true;
    }
  }
  function $e(qe, De) {
    return n(De) || ne(De) || M(De) || z(De);
  }
  function Ge(qe, De) {
    return B(De, {
      objectType: qe
    });
  }
  function lt() {
    return true;
  }
  function Ze() {
    return true;
  }
  function Xe(qe, De) {
    return F(De) || de(De) || fe(De) || H(De) || Pe(De);
  }
  function et(qe, De) {
    return F(De) || de(De);
  }
  function st(qe, De) {
    return (y(De) || q(De) || k(De) || oe(De)) && !!De.typeParameters;
  }
  function re(qe, De) {
    return qe.operator === "in" && (W(De) || D(De));
  }
  function be(qe, De) {
    return !(L(De) || Ie(De) || K(De) || O(De) && De.test === qe || ae(De) && De.test === qe || _(De) && De.right === qe || V(De) && De.discriminant === qe || N(De) && De.expression === qe);
  }
  function ue(qe, De) {
    return g(De) || pe(De) || Le(qe, De) || p(De) && ce(qe) || T(De) && qe === De.test || Se(qe, De);
  }
  function Me(qe, De, Tt) {
    return ut(Tt, 5);
  }
  function Y(qe, De) {
    return Le(qe, De) || P(De, {
      operator: "**",
      left: qe
    }) || Se(qe, De);
  }
  function Ne(qe, De, Tt) {
    return ut(Tt, 5);
  }
  function Be(qe, De) {
    return C(De) || X(qe, De);
  }
  function X(qe, De) {
    return pe(De) || g(De) || T(De, {
      test: qe
    }) || p(De) || we(De) || le(De) ? true : Y(qe, De);
  }
  function je(qe, De) {
    return y(De, {
      callee: qe
    }) || $(De, {
      object: qe
    });
  }
  function rt(qe, De) {
    return Q(qe.left) ? true : X(qe, De);
  }
  function vt(qe, De) {
    switch (qe.operator) {
      case "||":
        return j(De) ? De.operator === "??" || De.operator === "&&" : false;
      case "&&":
        return j(De, {
          operator: "??"
        });
      case "??":
        return j(De) && De.operator !== "??";
    }
  }
  function gt(qe, De, Tt) {
    var sr;
    if ((sr = qe.extra) != null && sr.parenthesized && f2(De, {
      left: qe
    }) && (R(De.right) || S(De.right)) && De.right.id == null)
      return true;
    if (qe.name === "let") {
      const ar = $(De, {
        object: qe,
        computed: true
      }) || ee(De, {
        object: qe,
        computed: true,
        optional: false
      });
      return ut(Tt, ar ? 57 : 32);
    }
    return qe.name === "async" && m(De) && qe === De.left;
  }
  function ut(qe, De) {
    const Tt = De & 1, sr = De & 2, ar = De & 4, Nr = De & 8, At = De & 16, Dt = De & 32;
    let Ye = qe.length - 1;
    if (Ye <= 0)
      return;
    let bt = qe[Ye];
    Ye--;
    let ct = qe[Ye];
    for (; Ye >= 0; ) {
      if (Tt && N(ct, {
        expression: bt
      }) || ar && I(ct, {
        declaration: bt
      }) || sr && h(ct, {
        body: bt
      }) || Nr && L(ct, {
        init: bt
      }) || At && _(ct, {
        left: bt
      }) || Dt && m(ct, {
        left: bt
      }))
        return true;
      if (Ye > 0 && (Le(bt, ct) && !k(ct) || G(ct) && ct.expressions[0] === bt || x(ct) && !ct.prefix || v(ct, {
        test: bt
      }) || g(ct, {
        left: bt
      }) || f2(ct, {
        left: bt
      })))
        bt = ct, Ye--, ct = qe[Ye];
      else
        return false;
    }
    return false;
  }
  return dt;
}
var Uh;
function Gy() {
  if (Uh)
    return hn;
  Uh = 1, Object.defineProperty(hn, "__esModule", {
    value: true
  }), hn.needsParens = D, hn.needsWhitespace = C, hn.needsWhitespaceAfter = N, hn.needsWhitespaceBefore = I;
  var s = fT(), n = hT(), h = Je();
  const {
    FLIPPED_ALIAS_KEYS: f2,
    isCallExpression: p,
    isExpressionStatement: g,
    isMemberExpression: P,
    isNewExpression: x
  } = h;
  function y(_) {
    const m = {};
    function L(R, O) {
      const B = m[R];
      m[R] = B ? function(M, j, $) {
        const k = B(M, j, $);
        return k == null ? O(M, j, $) : k;
      } : O;
    }
    for (const R of Object.keys(_)) {
      const O = f2[R];
      if (O)
        for (const B of O)
          L(B, _[R]);
      else
        L(R, _[R]);
    }
    return m;
  }
  const A = y(n), S = y(s.nodes);
  function v(_, m, L, R) {
    const O = _[m.type];
    return O ? O(m, L, R) : null;
  }
  function T(_) {
    return p(_) ? true : P(_) && T(_.object);
  }
  function C(_, m, L) {
    if (!_)
      return false;
    g(_) && (_ = _.expression);
    const R = v(S, _, m);
    return typeof R == "number" ? (R & L) !== 0 : false;
  }
  function I(_, m) {
    return C(_, m, 1);
  }
  function N(_, m) {
    return C(_, m, 2);
  }
  function D(_, m, L) {
    return m ? x(m) && m.callee === _ && T(_) ? true : v(A, _, m, L) : false;
  }
  return hn;
}
var Hu = {};
var In = {};
var $h;
function dT() {
  if ($h)
    return In;
  $h = 1, Object.defineProperty(In, "__esModule", {
    value: true
  }), In.TaggedTemplateExpression = s, In.TemplateElement = n, In.TemplateLiteral = h;
  function s(f2) {
    this.print(f2.tag, f2), this.print(f2.typeParameters, f2), this.print(f2.quasi, f2);
  }
  function n(f2, p) {
    const g = p.quasis[0] === f2, P = p.quasis[p.quasis.length - 1] === f2, x = (g ? "`" : "}") + f2.value.raw + (P ? "`" : "${");
    this.token(x, true);
  }
  function h(f2) {
    const p = f2.quasis;
    for (let g = 0; g < p.length; g++)
      this.print(p[g], f2), g + 1 < p.length && this.print(f2.expressions[g], f2);
  }
  return In;
}
var yt = {};
var qh;
function mT() {
  if (qh)
    return yt;
  qh = 1, Object.defineProperty(yt, "__esModule", {
    value: true
  }), yt.LogicalExpression = yt.BinaryExpression = yt.AssignmentExpression = ne, yt.AssignmentPattern = k, yt.AwaitExpression = B, yt.BindExpression = Q, yt.CallExpression = R, yt.ConditionalExpression = S, yt.Decorator = _, yt.DoExpression = x, yt.EmptyStatement = j, yt.ExpressionStatement = $, yt.Import = O, yt.MemberExpression = q, yt.MetaProperty = ee, yt.ModuleExpression = V, yt.NewExpression = v, yt.OptionalCallExpression = L, yt.OptionalMemberExpression = m, yt.ParenthesizedExpression = y, yt.PrivateName = K, yt.SequenceExpression = T, yt.Super = I, yt.ThisExpression = C, yt.UnaryExpression = P, yt.UpdateExpression = A, yt.V8IntrinsicIdentifier = G, yt.YieldExpression = M;
  var s = Je(), n = Gy();
  const {
    isCallExpression: h,
    isLiteral: f2,
    isMemberExpression: p,
    isNewExpression: g
  } = s;
  function P(F) {
    F.operator === "void" || F.operator === "delete" || F.operator === "typeof" || F.operator === "throw" ? (this.word(F.operator), this.space()) : this.token(F.operator), this.print(F.argument, F);
  }
  function x(F) {
    F.async && (this.word("async"), this.space()), this.word("do"), this.space(), this.print(F.body, F);
  }
  function y(F) {
    this.tokenChar(40), this.print(F.expression, F), this.tokenChar(41);
  }
  function A(F) {
    F.prefix ? (this.token(F.operator), this.print(F.argument, F)) : (this.printTerminatorless(F.argument, F, true), this.token(F.operator));
  }
  function S(F) {
    this.print(F.test, F), this.space(), this.tokenChar(63), this.space(), this.print(F.consequent, F), this.space(), this.tokenChar(58), this.space(), this.print(F.alternate, F);
  }
  function v(F, le) {
    this.word("new"), this.space(), this.print(F.callee, F), !(this.format.minified && F.arguments.length === 0 && !F.optional && !h(le, {
      callee: F
    }) && !p(le) && !g(le)) && (this.print(F.typeArguments, F), this.print(F.typeParameters, F), F.optional && this.token("?."), this.tokenChar(40), this.printList(F.arguments, F), this.tokenChar(41));
  }
  function T(F) {
    this.printList(F.expressions, F);
  }
  function C() {
    this.word("this");
  }
  function I() {
    this.word("super");
  }
  function N(F) {
    switch (F.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !F.computed && F.property.type === "Identifier" && N(F.object);
      default:
        return false;
    }
  }
  function D(F) {
    return F.type === "CallExpression" && (F = F.callee), F.type === "ParenthesizedExpression" ? false : !N(F);
  }
  function _(F) {
    this.tokenChar(64);
    const {
      expression: le
    } = F;
    D(le) ? (this.tokenChar(40), this.print(le, F), this.tokenChar(41)) : this.print(le, F), this.newline();
  }
  function m(F) {
    if (this.print(F.object, F), !F.computed && p(F.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let le = F.computed;
    f2(F.property) && typeof F.property.value == "number" && (le = true), F.optional && this.token("?."), le ? (this.tokenChar(91), this.print(F.property, F), this.tokenChar(93)) : (F.optional || this.tokenChar(46), this.print(F.property, F));
  }
  function L(F) {
    this.print(F.callee, F), this.print(F.typeArguments, F), this.print(F.typeParameters, F), F.optional && this.token("?."), this.tokenChar(40), this.printList(F.arguments, F), this.tokenChar(41);
  }
  function R(F) {
    this.print(F.callee, F), this.print(F.typeArguments, F), this.print(F.typeParameters, F), this.tokenChar(40), this.printList(F.arguments, F), this.tokenChar(41);
  }
  function O() {
    this.word("import");
  }
  function B(F) {
    this.word("await"), F.argument && (this.space(), this.printTerminatorless(F.argument, F, false));
  }
  function M(F) {
    this.word("yield"), F.delegate && this.tokenChar(42), F.argument && (this.space(), this.printTerminatorless(F.argument, F, false));
  }
  function j() {
    this.semicolon(true);
  }
  function $(F) {
    this.print(F.expression, F), this.semicolon();
  }
  function k(F) {
    this.print(F.left, F), F.left.optional && this.tokenChar(63), this.print(F.left.typeAnnotation, F), this.space(), this.tokenChar(61), this.space(), this.print(F.right, F);
  }
  function ne(F, le) {
    const oe = this.inForStatementInitCounter && F.operator === "in" && !n.needsParens(F, le);
    oe && this.tokenChar(40), this.print(F.left, F), this.space(), F.operator === "in" || F.operator === "instanceof" ? this.word(F.operator) : this.token(F.operator), this.space(), this.print(F.right, F), oe && this.tokenChar(41);
  }
  function Q(F) {
    this.print(F.object, F), this.token("::"), this.print(F.callee, F);
  }
  function q(F) {
    if (this.print(F.object, F), !F.computed && p(F.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let le = F.computed;
    f2(F.property) && typeof F.property.value == "number" && (le = true), le ? (this.tokenChar(91), this.print(F.property, F), this.tokenChar(93)) : (this.tokenChar(46), this.print(F.property, F));
  }
  function ee(F) {
    this.print(F.meta, F), this.tokenChar(46), this.print(F.property, F);
  }
  function K(F) {
    this.tokenChar(35), this.print(F.id, F);
  }
  function G(F) {
    this.tokenChar(37), this.word(F.name);
  }
  function V(F) {
    this.word("module"), this.space(), this.tokenChar(123), F.body.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(F.body.body, F, {
      indent: true
    }), this.rightBrace());
  }
  return yt;
}
var Lt = {};
var Vh;
function yT() {
  if (Vh)
    return Lt;
  Vh = 1, Object.defineProperty(Lt, "__esModule", {
    value: true
  }), Lt.BreakStatement = N, Lt.CatchClause = O, Lt.ContinueStatement = D, Lt.DebuggerStatement = j, Lt.DoWhileStatement = C, Lt.ForOfStatement = Lt.ForInStatement = void 0, Lt.ForStatement = y, Lt.IfStatement = P, Lt.LabeledStatement = L, Lt.ReturnStatement = _, Lt.SwitchCase = M, Lt.SwitchStatement = B, Lt.ThrowStatement = m, Lt.TryStatement = R, Lt.VariableDeclaration = ne, Lt.VariableDeclarator = Q, Lt.WhileStatement = A, Lt.WithStatement = g;
  var s = Je();
  const {
    isFor: n,
    isForStatement: h,
    isIfStatement: f2,
    isStatement: p
  } = s;
  function g(q) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(q.object, q), this.tokenChar(41), this.printBlock(q);
  }
  function P(q) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(q.test, q), this.tokenChar(41), this.space();
    const ee = q.alternate && f2(x(q.consequent));
    ee && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(q.consequent, q), ee && (this.dedent(), this.newline(), this.tokenChar(125)), q.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(q.alternate, q));
  }
  function x(q) {
    const {
      body: ee
    } = q;
    return p(ee) === false ? q : x(ee);
  }
  function y(q) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(q.init, q), this.inForStatementInitCounter--, this.tokenChar(59), q.test && (this.space(), this.print(q.test, q)), this.tokenChar(59), q.update && (this.space(), this.print(q.update, q)), this.tokenChar(41), this.printBlock(q);
  }
  function A(q) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(q.test, q), this.tokenChar(41), this.printBlock(q);
  }
  function S(q) {
    this.word("for"), this.space();
    const ee = q.type === "ForOfStatement";
    ee && q.await && (this.word("await"), this.space()), this.tokenChar(40), this.print(q.left, q), this.space(), this.word(ee ? "of" : "in"), this.space(), this.print(q.right, q), this.tokenChar(41), this.printBlock(q);
  }
  const v = S;
  Lt.ForInStatement = v;
  const T = S;
  Lt.ForOfStatement = T;
  function C(q) {
    this.word("do"), this.space(), this.print(q.body, q), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(q.test, q), this.tokenChar(41), this.semicolon();
  }
  function I(q, ee, K, G) {
    ee && (q.space(), q.printTerminatorless(ee, K, G)), q.semicolon();
  }
  function N(q) {
    this.word("break"), I(this, q.label, q, true);
  }
  function D(q) {
    this.word("continue"), I(this, q.label, q, true);
  }
  function _(q) {
    this.word("return"), I(this, q.argument, q, false);
  }
  function m(q) {
    this.word("throw"), I(this, q.argument, q, false);
  }
  function L(q) {
    this.print(q.label, q), this.tokenChar(58), this.space(), this.print(q.body, q);
  }
  function R(q) {
    this.word("try"), this.space(), this.print(q.block, q), this.space(), q.handlers ? this.print(q.handlers[0], q) : this.print(q.handler, q), q.finalizer && (this.space(), this.word("finally"), this.space(), this.print(q.finalizer, q));
  }
  function O(q) {
    this.word("catch"), this.space(), q.param && (this.tokenChar(40), this.print(q.param, q), this.print(q.param.typeAnnotation, q), this.tokenChar(41), this.space()), this.print(q.body, q);
  }
  function B(q) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(q.discriminant, q), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(q.cases, q, {
      indent: true,
      addNewlines(ee, K) {
        if (!ee && q.cases[q.cases.length - 1] === K)
          return -1;
      }
    }), this.tokenChar(125);
  }
  function M(q) {
    q.test ? (this.word("case"), this.space(), this.print(q.test, q), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), q.consequent.length && (this.newline(), this.printSequence(q.consequent, q, {
      indent: true
    }));
  }
  function j() {
    this.word("debugger"), this.semicolon();
  }
  function $() {
    if (this.tokenChar(44), this.newline(), this.endsWith(10))
      for (let q = 0; q < 4; q++)
        this.space(true);
  }
  function k() {
    if (this.tokenChar(44), this.newline(), this.endsWith(10))
      for (let q = 0; q < 6; q++)
        this.space(true);
  }
  function ne(q, ee) {
    q.declare && (this.word("declare"), this.space()), this.word(q.kind), this.space();
    let K = false;
    if (!n(ee))
      for (const V of q.declarations)
        V.init && (K = true);
    let G;
    if (K && (G = q.kind === "const" ? k : $), this.printList(q.declarations, q, {
      separator: G
    }), n(ee)) {
      if (h(ee)) {
        if (ee.init === q)
          return;
      } else if (ee.left === q)
        return;
    }
    this.semicolon();
  }
  function Q(q) {
    this.print(q.id, q), q.definite && this.tokenChar(33), this.print(q.id.typeAnnotation, q), q.init && (this.space(), this.tokenChar(61), this.space(), this.print(q.init, q));
  }
  return Lt;
}
var fs = {};
var Kh;
function bT() {
  if (Kh)
    return fs;
  Kh = 1, Object.defineProperty(fs, "__esModule", {
    value: true
  }), fs.ClassAccessorProperty = P, fs.ClassBody = p, fs.ClassExpression = fs.ClassDeclaration = f2, fs.ClassMethod = y, fs.ClassPrivateMethod = A, fs.ClassPrivateProperty = x, fs.ClassProperty = g, fs.StaticBlock = v, fs._classMethodHead = S;
  var s = Je();
  const {
    isExportDefaultDeclaration: n,
    isExportNamedDeclaration: h
  } = s;
  function f2(T, C) {
    (!this.format.decoratorsBeforeExport || !n(C) && !h(C)) && this.printJoin(T.decorators, T), T.declare && (this.word("declare"), this.space()), T.abstract && (this.word("abstract"), this.space()), this.word("class"), this.printInnerComments(T), T.id && (this.space(), this.print(T.id, T)), this.print(T.typeParameters, T), T.superClass && (this.space(), this.word("extends"), this.space(), this.print(T.superClass, T), this.print(T.superTypeParameters, T)), T.implements && (this.space(), this.word("implements"), this.space(), this.printList(T.implements, T)), this.space(), this.print(T.body, T);
  }
  function p(T) {
    this.tokenChar(123), this.printInnerComments(T), T.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.indent(), this.printSequence(T.body, T), this.dedent(), this.endsWith(10) || this.newline(), this.rightBrace());
  }
  function g(T) {
    this.printJoin(T.decorators, T), this.source("end", T.key.loc), this.tsPrintClassMemberModifiers(T), T.computed ? (this.tokenChar(91), this.print(T.key, T), this.tokenChar(93)) : (this._variance(T), this.print(T.key, T)), T.optional && this.tokenChar(63), T.definite && this.tokenChar(33), this.print(T.typeAnnotation, T), T.value && (this.space(), this.tokenChar(61), this.space(), this.print(T.value, T)), this.semicolon();
  }
  function P(T) {
    this.printJoin(T.decorators, T), this.source("end", T.key.loc), this.tsPrintClassMemberModifiers(T), this.word("accessor"), this.printInnerComments(T), this.space(), T.computed ? (this.tokenChar(91), this.print(T.key, T), this.tokenChar(93)) : (this._variance(T), this.print(T.key, T)), T.optional && this.tokenChar(63), T.definite && this.tokenChar(33), this.print(T.typeAnnotation, T), T.value && (this.space(), this.tokenChar(61), this.space(), this.print(T.value, T)), this.semicolon();
  }
  function x(T) {
    this.printJoin(T.decorators, T), T.static && (this.word("static"), this.space()), this.print(T.key, T), this.print(T.typeAnnotation, T), T.value && (this.space(), this.tokenChar(61), this.space(), this.print(T.value, T)), this.semicolon();
  }
  function y(T) {
    this._classMethodHead(T), this.space(), this.print(T.body, T);
  }
  function A(T) {
    this._classMethodHead(T), this.space(), this.print(T.body, T);
  }
  function S(T) {
    this.printJoin(T.decorators, T), this.source("end", T.key.loc), this.tsPrintClassMemberModifiers(T), this._methodHead(T);
  }
  function v(T) {
    this.word("static"), this.space(), this.tokenChar(123), T.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(T.body, T, {
      indent: true
    }), this.rightBrace());
  }
  return fs;
}
var Ts = {};
var Wh;
function gT() {
  if (Wh)
    return Ts;
  Wh = 1, Object.defineProperty(Ts, "__esModule", {
    value: true
  }), Ts.ArrowFunctionExpression = A, Ts.FunctionDeclaration = Ts.FunctionExpression = y, Ts._functionHead = x, Ts._methodHead = g, Ts._param = p, Ts._parameters = f2, Ts._params = h, Ts._predicate = P;
  var s = Je();
  const {
    isIdentifier: n
  } = s;
  function h(v) {
    this.print(v.typeParameters, v), this.tokenChar(40), this._parameters(v.params, v), this.tokenChar(41), v.returnType && (v.type === "ArrowFunctionExpression" ? (this._noLineTerminator = true, this.print(v.returnType, v), this._noLineTerminator = false) : this.print(v.returnType, v));
  }
  function f2(v, T) {
    for (let C = 0; C < v.length; C++)
      this._param(v[C], T), C < v.length - 1 && (this.tokenChar(44), this.space());
  }
  function p(v, T) {
    this.printJoin(v.decorators, v), this.print(v, T), v.optional && this.tokenChar(63), this.print(v.typeAnnotation, v);
  }
  function g(v) {
    const T = v.kind, C = v.key;
    (T === "get" || T === "set") && (this.word(T), this.space()), v.async && (this._catchUp("start", C.loc), this.word("async"), this.space()), (T === "method" || T === "init") && v.generator && this.tokenChar(42), v.computed ? (this.tokenChar(91), this.print(C, v), this.tokenChar(93)) : this.print(C, v), v.optional && this.tokenChar(63), this._params(v);
  }
  function P(v) {
    v.predicate && (v.returnType || this.tokenChar(58), this.space(), this.print(v.predicate, v));
  }
  function x(v) {
    v.async && (this.word("async"), this.space()), this.word("function"), v.generator && this.tokenChar(42), this.printInnerComments(v), this.space(), v.id && this.print(v.id, v), this._params(v), v.type !== "TSDeclareFunction" && this._predicate(v);
  }
  function y(v) {
    this._functionHead(v), this.space(), this.print(v.body, v);
  }
  function A(v) {
    v.async && (this.word("async"), this.space());
    const T = v.params[0];
    !this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && v.params.length === 1 && n(T) && !S(v, T) ? this.print(T, v) : this._params(v), this._predicate(v), this.space(), this.token("=>"), this.space(), this.print(v.body, v);
  }
  function S(v, T) {
    var C, I;
    return !!(v.typeParameters || v.returnType || v.predicate || T.typeAnnotation || T.optional || (C = T.leadingComments) != null && C.length || (I = T.trailingComments) != null && I.length);
  }
  return Ts;
}
var ps = {};
var Hh;
function Xy() {
  if (Hh)
    return ps;
  Hh = 1, Object.defineProperty(ps, "__esModule", {
    value: true
  }), ps.ExportAllDeclaration = T, ps.ExportDefaultDeclaration = I, ps.ExportDefaultSpecifier = A, ps.ExportNamedDeclaration = C, ps.ExportNamespaceSpecifier = v, ps.ExportSpecifier = S, ps.ImportAttribute = D, ps.ImportDeclaration = N, ps.ImportDefaultSpecifier = y, ps.ImportNamespaceSpecifier = _, ps.ImportSpecifier = x;
  var s = Je();
  const {
    isClassDeclaration: n,
    isExportDefaultSpecifier: h,
    isExportNamespaceSpecifier: f2,
    isImportDefaultSpecifier: p,
    isImportNamespaceSpecifier: g,
    isStatement: P
  } = s;
  function x(m) {
    (m.importKind === "type" || m.importKind === "typeof") && (this.word(m.importKind), this.space()), this.print(m.imported, m), m.local && m.local.name !== m.imported.name && (this.space(), this.word("as"), this.space(), this.print(m.local, m));
  }
  function y(m) {
    this.print(m.local, m);
  }
  function A(m) {
    this.print(m.exported, m);
  }
  function S(m) {
    m.exportKind === "type" && (this.word("type"), this.space()), this.print(m.local, m), m.exported && m.local.name !== m.exported.name && (this.space(), this.word("as"), this.space(), this.print(m.exported, m));
  }
  function v(m) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(m.exported, m);
  }
  function T(m) {
    this.word("export"), this.space(), m.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), this.print(m.source, m), this.printAssertions(m), this.semicolon();
  }
  function C(m) {
    if (this.format.decoratorsBeforeExport && n(m.declaration) && this.printJoin(m.declaration.decorators, m), this.word("export"), this.space(), m.declaration) {
      const L = m.declaration;
      this.print(L, m), P(L) || this.semicolon();
    } else {
      m.exportKind === "type" && (this.word("type"), this.space());
      const L = m.specifiers.slice(0);
      let R = false;
      for (; ; ) {
        const O = L[0];
        if (h(O) || f2(O))
          R = true, this.print(L.shift(), m), L.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      (L.length || !L.length && !R) && (this.tokenChar(123), L.length && (this.space(), this.printList(L, m), this.space()), this.tokenChar(125)), m.source && (this.space(), this.word("from"), this.space(), this.print(m.source, m), this.printAssertions(m)), this.semicolon();
    }
  }
  function I(m) {
    this.format.decoratorsBeforeExport && n(m.declaration) && this.printJoin(m.declaration.decorators, m), this.word("export"), this.space(), this.word("default"), this.space();
    const L = m.declaration;
    this.print(L, m), P(L) || this.semicolon();
  }
  function N(m) {
    this.word("import"), this.space();
    const L = m.importKind === "type" || m.importKind === "typeof";
    L && (this.word(m.importKind), this.space());
    const R = m.specifiers.slice(0), O = !!R.length;
    for (; O; ) {
      const M = R[0];
      if (p(M) || g(M))
        this.print(R.shift(), m), R.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    R.length ? (this.tokenChar(123), this.space(), this.printList(R, m), this.space(), this.tokenChar(125)) : L && !O && (this.tokenChar(123), this.tokenChar(125)), (O || L) && (this.space(), this.word("from"), this.space()), this.print(m.source, m), this.printAssertions(m);
    {
      var B;
      (B = m.attributes) != null && B.length && (this.space(), this.word("with"), this.space(), this.printList(m.attributes, m));
    }
    this.semicolon();
  }
  function D(m) {
    this.print(m.key), this.tokenChar(58), this.space(), this.print(m.value);
  }
  function _(m) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(m.local, m);
  }
  return ps;
}
var Ot = {};
var zu;
var zh;
function TT() {
  if (zh)
    return zu;
  zh = 1;
  const s = {}, n = s.hasOwnProperty, h = (L, R) => {
    for (const O in L)
      n.call(L, O) && R(O, L[O]);
  }, f2 = (L, R) => (R && h(R, (O, B) => {
    L[O] = B;
  }), L), p = (L, R) => {
    const O = L.length;
    let B = -1;
    for (; ++B < O; )
      R(L[B]);
  }, g = s.toString, P = Array.isArray, x = Buffer.isBuffer, y = (L) => g.call(L) == "[object Object]", A = (L) => typeof L == "string" || g.call(L) == "[object String]", S = (L) => typeof L == "number" || g.call(L) == "[object Number]", v = (L) => typeof L == "function", T = (L) => g.call(L) == "[object Map]", C = (L) => g.call(L) == "[object Set]", I = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
  }, N = /["'\\\b\f\n\r\t]/, D = /[0-9]/, _ = /[ !#-&\(-\[\]-_a-~]/, m = (L, R) => {
    const O = () => {
      Q = ne, ++R.indentLevel, ne = R.indent.repeat(R.indentLevel);
    }, B = {
      escapeEverything: false,
      minimal: false,
      isScriptContext: false,
      quotes: "single",
      wrap: false,
      es6: false,
      json: false,
      compact: true,
      lowercaseHex: false,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: false,
      __inline2__: false
    }, M = R && R.json;
    M && (B.quotes = "double", B.wrap = true), R = f2(B, R), R.quotes != "single" && R.quotes != "double" && R.quotes != "backtick" && (R.quotes = "single");
    const j = R.quotes == "double" ? '"' : R.quotes == "backtick" ? "`" : "'", $ = R.compact, k = R.lowercaseHex;
    let ne = R.indent.repeat(R.indentLevel), Q = "";
    const q = R.__inline1__, ee = R.__inline2__, K = $ ? "" : `
`;
    let G, V = true;
    const F = R.numbers == "binary", le = R.numbers == "octal", oe = R.numbers == "decimal", fe = R.numbers == "hexadecimal";
    if (M && L && v(L.toJSON) && (L = L.toJSON()), !A(L)) {
      if (T(L))
        return L.size == 0 ? "new Map()" : ($ || (R.__inline1__ = true, R.__inline2__ = false), "new Map(" + m(Array.from(L), R) + ")");
      if (C(L))
        return L.size == 0 ? "new Set()" : "new Set(" + m(Array.from(L), R) + ")";
      if (x(L))
        return L.length == 0 ? "Buffer.from([])" : "Buffer.from(" + m(Array.from(L), R) + ")";
      if (P(L))
        return G = [], R.wrap = true, q && (R.__inline1__ = false, R.__inline2__ = true), ee || O(), p(L, (we) => {
          V = false, ee && (R.__inline2__ = false), G.push(($ || ee ? "" : ne) + m(we, R));
        }), V ? "[]" : ee ? "[" + G.join(", ") + "]" : "[" + K + G.join("," + K) + K + ($ ? "" : Q) + "]";
      if (S(L)) {
        if (M)
          return JSON.stringify(L);
        if (oe)
          return String(L);
        if (fe) {
          let we = L.toString(16);
          return k || (we = we.toUpperCase()), "0x" + we;
        }
        if (F)
          return "0b" + L.toString(2);
        if (le)
          return "0o" + L.toString(8);
      } else
        return y(L) ? (G = [], R.wrap = true, O(), h(L, (we, H) => {
          V = false, G.push(($ ? "" : ne) + m(we, R) + ":" + ($ ? "" : " ") + m(H, R));
        }), V ? "{}" : "{" + K + G.join("," + K) + K + ($ ? "" : Q) + "}") : M ? JSON.stringify(L) || "null" : String(L);
    }
    const he = L;
    let de = -1;
    const Pe = he.length;
    for (G = ""; ++de < Pe; ) {
      const we = he.charAt(de);
      if (R.es6) {
        const pe = he.charCodeAt(de);
        if (pe >= 55296 && pe <= 56319 && Pe > de + 1) {
          const z = he.charCodeAt(de + 1);
          if (z >= 56320 && z <= 57343) {
            let ae = ((pe - 55296) * 1024 + z - 56320 + 65536).toString(16);
            k || (ae = ae.toUpperCase()), G += "\\u{" + ae + "}", ++de;
            continue;
          }
        }
      }
      if (!R.escapeEverything) {
        if (_.test(we)) {
          G += we;
          continue;
        }
        if (we == '"') {
          G += j == we ? '\\"' : we;
          continue;
        }
        if (we == "`") {
          G += j == we ? "\\`" : we;
          continue;
        }
        if (we == "'") {
          G += j == we ? "\\'" : we;
          continue;
        }
      }
      if (we == "\0" && !M && !D.test(he.charAt(de + 1))) {
        G += "\\0";
        continue;
      }
      if (N.test(we)) {
        G += I[we];
        continue;
      }
      const H = we.charCodeAt(0);
      if (R.minimal && H != 8232 && H != 8233) {
        G += we;
        continue;
      }
      let te = H.toString(16);
      k || (te = te.toUpperCase());
      const Ie = te.length > 2 || M;
      G += "\\" + (Ie ? "u" : "x") + ("0000" + te).slice(Ie ? -4 : -2);
    }
    return R.wrap && (G = j + G + j), j == "`" && (G = G.replace(/\$\{/g, "\\${")), R.isScriptContext ? G.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, M ? "\\u003C!--" : "\\x3C!--") : G;
  };
  return m.version = "2.5.2", zu = m, zu;
}
var Gh;
function Jy() {
  if (Gh)
    return Ot;
  Gh = 1, Object.defineProperty(Ot, "__esModule", {
    value: true
  }), Ot.ArgumentPlaceholder = g, Ot.ArrayPattern = Ot.ArrayExpression = S, Ot.BigIntLiteral = m, Ot.BooleanLiteral = I, Ot.DecimalLiteral = L, Ot.Identifier = p, Ot.NullLiteral = N, Ot.NumericLiteral = D, Ot.ObjectPattern = Ot.ObjectExpression = x, Ot.ObjectMethod = y, Ot.ObjectProperty = A, Ot.PipelineBareFunction = M, Ot.PipelinePrimaryTopicReference = j, Ot.PipelineTopicExpression = B, Ot.RecordExpression = v, Ot.RegExpLiteral = C, Ot.SpreadElement = Ot.RestElement = P, Ot.StringLiteral = _, Ot.TopicReference = O, Ot.TupleExpression = T;
  var s = Je(), n = TT();
  const {
    isAssignmentPattern: h,
    isIdentifier: f2
  } = s;
  function p($) {
    this.exactSource($.loc, () => {
      this.word($.name);
    });
  }
  function g() {
    this.tokenChar(63);
  }
  function P($) {
    this.token("..."), this.print($.argument, $);
  }
  function x($) {
    const k = $.properties;
    this.tokenChar(123), this.printInnerComments($), k.length && (this.space(), this.printList(k, $, {
      indent: true,
      statement: true
    }), this.space()), this.tokenChar(125);
  }
  function y($) {
    this.printJoin($.decorators, $), this._methodHead($), this.space(), this.print($.body, $);
  }
  function A($) {
    if (this.printJoin($.decorators, $), $.computed)
      this.tokenChar(91), this.print($.key, $), this.tokenChar(93);
    else {
      if (h($.value) && f2($.key) && $.key.name === $.value.left.name) {
        this.print($.value, $);
        return;
      }
      if (this.print($.key, $), $.shorthand && f2($.key) && f2($.value) && $.key.name === $.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print($.value, $);
  }
  function S($) {
    const k = $.elements, ne = k.length;
    this.tokenChar(91), this.printInnerComments($);
    for (let Q = 0; Q < k.length; Q++) {
      const q = k[Q];
      q ? (Q > 0 && this.space(), this.print(q, $), Q < ne - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  function v($) {
    const k = $.properties;
    let ne, Q;
    if (this.format.recordAndTupleSyntaxType === "bar")
      ne = "{|", Q = "|}";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      ne = "#{", Q = "}";
    else
      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    this.token(ne), this.printInnerComments($), k.length && (this.space(), this.printList(k, $, {
      indent: true,
      statement: true
    }), this.space()), this.token(Q);
  }
  function T($) {
    const k = $.elements, ne = k.length;
    let Q, q;
    if (this.format.recordAndTupleSyntaxType === "bar")
      Q = "[|", q = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      Q = "#[", q = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(Q), this.printInnerComments($);
    for (let ee = 0; ee < k.length; ee++) {
      const K = k[ee];
      K && (ee > 0 && this.space(), this.print(K, $), ee < ne - 1 && this.tokenChar(44));
    }
    this.token(q);
  }
  function C($) {
    this.word(`/${$.pattern}/${$.flags}`);
  }
  function I($) {
    this.word($.value ? "true" : "false");
  }
  function N() {
    this.word("null");
  }
  function D($) {
    const k = this.getPossibleRaw($), ne = this.format.jsescOption, Q = $.value + "";
    ne.numbers ? this.number(n($.value, ne)) : k == null ? this.number(Q) : this.format.minified ? this.number(k.length < Q.length ? k : Q) : this.number(k);
  }
  function _($) {
    const k = this.getPossibleRaw($);
    if (!this.format.minified && k !== void 0) {
      this.token(k);
      return;
    }
    const ne = n($.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
      json: true
    }));
    return this.token(ne);
  }
  function m($) {
    const k = this.getPossibleRaw($);
    if (!this.format.minified && k !== void 0) {
      this.word(k);
      return;
    }
    this.word($.value + "n");
  }
  function L($) {
    const k = this.getPossibleRaw($);
    if (!this.format.minified && k !== void 0) {
      this.word(k);
      return;
    }
    this.word($.value + "m");
  }
  const R = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function O() {
    const {
      topicToken: $
    } = this.format;
    if (R.has($))
      this.token($);
    else {
      const k = JSON.stringify($), ne = Array.from(R, (Q) => JSON.stringify(Q));
      throw new Error(`The "topicToken" generator option must be one of ${ne.join(", ")} (${k} received instead).`);
    }
  }
  function B($) {
    this.print($.expression, $);
  }
  function M($) {
    this.print($.callee, $);
  }
  function j() {
    this.tokenChar(35);
  }
  return Ot;
}
var Gu = {};
var Xh;
function xT() {
  return Xh || (Xh = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), s.AnyTypeAnnotation = P, s.ArrayTypeAnnotation = x, s.BooleanLiteralTypeAnnotation = A, s.BooleanTypeAnnotation = y, s.DeclareClass = v, s.DeclareExportAllDeclaration = B, s.DeclareExportDeclaration = O, s.DeclareFunction = T, s.DeclareInterface = N, s.DeclareModule = D, s.DeclareModuleExports = _, s.DeclareOpaqueType = L, s.DeclareTypeAlias = m, s.DeclareVariable = R, s.DeclaredPredicate = I, s.EmptyTypeAnnotation = z, s.EnumBooleanBody = k, s.EnumBooleanMember = G, s.EnumDeclaration = M, s.EnumDefaultedMember = ee, s.EnumNumberBody = ne, s.EnumNumberMember = V, s.EnumStringBody = Q, s.EnumStringMember = F, s.EnumSymbolBody = q, s.ExistsTypeAnnotation = oe, s.FunctionTypeAnnotation = fe, s.FunctionTypeParam = he, s.IndexedAccessType = Ne, s.InferredPredicate = C, s.InterfaceDeclaration = H, s.GenericTypeAnnotation = s.ClassImplements = s.InterfaceExtends = de, s.InterfaceTypeAnnotation = Ie, s.IntersectionTypeAnnotation = Te, s.MixedTypeAnnotation = pe, s.NullLiteralTypeAnnotation = S, s.NullableTypeAnnotation = W, Object.defineProperty(s, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return f2.NumericLiteral;
      }
    }), s.NumberTypeAnnotation = ae, s.ObjectTypeAnnotation = Re, s.ObjectTypeCallProperty = Ge, s.ObjectTypeIndexer = lt, s.ObjectTypeInternalSlot = $e, s.ObjectTypeProperty = Ze, s.ObjectTypeSpreadProperty = Xe, s.OpaqueType = _e, s.OptionalIndexedAccessType = Be, s.QualifiedTypeIdentifier = et, Object.defineProperty(s, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return f2.StringLiteral;
      }
    }), s.StringTypeAnnotation = ce, s.SymbolTypeAnnotation = st, s.ThisTypeAnnotation = xe, s.TupleTypeAnnotation = Se, s.TypeAlias = Ee, s.TypeAnnotation = J, s.TypeCastExpression = ue, s.TypeParameter = ke, s.TypeParameterDeclaration = s.TypeParameterInstantiation = me, s.TypeofTypeAnnotation = Le, s.UnionTypeAnnotation = be, s.Variance = Me, s.VoidTypeAnnotation = Y, s._interfaceish = Pe, s._variance = we;
    var n = Je(), h = Xy(), f2 = Jy();
    const {
      isDeclareExportDeclaration: p,
      isStatement: g
    } = n;
    function P() {
      this.word("any");
    }
    function x(X) {
      this.print(X.elementType, X), this.tokenChar(91), this.tokenChar(93);
    }
    function y() {
      this.word("boolean");
    }
    function A(X) {
      this.word(X.value ? "true" : "false");
    }
    function S() {
      this.word("null");
    }
    function v(X, je) {
      p(je) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(X);
    }
    function T(X, je) {
      p(je) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(X.id, X), this.print(X.id.typeAnnotation.typeAnnotation, X), X.predicate && (this.space(), this.print(X.predicate, X)), this.semicolon();
    }
    function C() {
      this.tokenChar(37), this.word("checks");
    }
    function I(X) {
      this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(X.value, X), this.tokenChar(41);
    }
    function N(X) {
      this.word("declare"), this.space(), this.InterfaceDeclaration(X);
    }
    function D(X) {
      this.word("declare"), this.space(), this.word("module"), this.space(), this.print(X.id, X), this.space(), this.print(X.body, X);
    }
    function _(X) {
      this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(X.typeAnnotation, X);
    }
    function m(X) {
      this.word("declare"), this.space(), this.TypeAlias(X);
    }
    function L(X, je) {
      p(je) || (this.word("declare"), this.space()), this.OpaqueType(X);
    }
    function R(X, je) {
      p(je) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(X.id, X), this.print(X.id.typeAnnotation, X), this.semicolon();
    }
    function O(X) {
      this.word("declare"), this.space(), this.word("export"), this.space(), X.default && (this.word("default"), this.space()), le.call(this, X);
    }
    function B(X) {
      this.word("declare"), this.space(), h.ExportAllDeclaration.call(this, X);
    }
    function M(X) {
      const {
        id: je,
        body: rt
      } = X;
      this.word("enum"), this.space(), this.print(je, X), this.print(rt, X);
    }
    function j(X, je, rt) {
      rt && (X.space(), X.word("of"), X.space(), X.word(je)), X.space();
    }
    function $(X, je) {
      const {
        members: rt
      } = je;
      X.token("{"), X.indent(), X.newline();
      for (const vt of rt)
        X.print(vt, je), X.newline();
      je.hasUnknownMembers && (X.token("..."), X.newline()), X.dedent(), X.token("}");
    }
    function k(X) {
      const {
        explicitType: je
      } = X;
      j(this, "boolean", je), $(this, X);
    }
    function ne(X) {
      const {
        explicitType: je
      } = X;
      j(this, "number", je), $(this, X);
    }
    function Q(X) {
      const {
        explicitType: je
      } = X;
      j(this, "string", je), $(this, X);
    }
    function q(X) {
      j(this, "symbol", true), $(this, X);
    }
    function ee(X) {
      const {
        id: je
      } = X;
      this.print(je, X), this.tokenChar(44);
    }
    function K(X, je) {
      const {
        id: rt,
        init: vt
      } = je;
      X.print(rt, je), X.space(), X.token("="), X.space(), X.print(vt, je), X.token(",");
    }
    function G(X) {
      K(this, X);
    }
    function V(X) {
      K(this, X);
    }
    function F(X) {
      K(this, X);
    }
    function le(X) {
      if (X.declaration) {
        const je = X.declaration;
        this.print(je, X), g(je) || this.semicolon();
      } else
        this.tokenChar(123), X.specifiers.length && (this.space(), this.printList(X.specifiers, X), this.space()), this.tokenChar(125), X.source && (this.space(), this.word("from"), this.space(), this.print(X.source, X)), this.semicolon();
    }
    function oe() {
      this.tokenChar(42);
    }
    function fe(X, je) {
      this.print(X.typeParameters, X), this.tokenChar(40), X.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(X.this.typeAnnotation, X), (X.params.length || X.rest) && (this.tokenChar(44), this.space())), this.printList(X.params, X), X.rest && (X.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(X.rest, X)), this.tokenChar(41), je && (je.type === "ObjectTypeCallProperty" || je.type === "DeclareFunction" || je.type === "ObjectTypeProperty" && je.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(X.returnType, X);
    }
    function he(X) {
      this.print(X.name, X), X.optional && this.tokenChar(63), X.name && (this.tokenChar(58), this.space()), this.print(X.typeAnnotation, X);
    }
    function de(X) {
      this.print(X.id, X), this.print(X.typeParameters, X);
    }
    function Pe(X) {
      var je;
      this.print(X.id, X), this.print(X.typeParameters, X), (je = X.extends) != null && je.length && (this.space(), this.word("extends"), this.space(), this.printList(X.extends, X)), X.mixins && X.mixins.length && (this.space(), this.word("mixins"), this.space(), this.printList(X.mixins, X)), X.implements && X.implements.length && (this.space(), this.word("implements"), this.space(), this.printList(X.implements, X)), this.space(), this.print(X.body, X);
    }
    function we(X) {
      X.variance && (X.variance.kind === "plus" ? this.tokenChar(43) : X.variance.kind === "minus" && this.tokenChar(45));
    }
    function H(X) {
      this.word("interface"), this.space(), this._interfaceish(X);
    }
    function te() {
      this.space(), this.tokenChar(38), this.space();
    }
    function Ie(X) {
      this.word("interface"), X.extends && X.extends.length && (this.space(), this.word("extends"), this.space(), this.printList(X.extends, X)), this.space(), this.print(X.body, X);
    }
    function Te(X) {
      this.printJoin(X.types, X, {
        separator: te
      });
    }
    function pe() {
      this.word("mixed");
    }
    function z() {
      this.word("empty");
    }
    function W(X) {
      this.tokenChar(63), this.print(X.typeAnnotation, X);
    }
    function ae() {
      this.word("number");
    }
    function ce() {
      this.word("string");
    }
    function xe() {
      this.word("this");
    }
    function Se(X) {
      this.tokenChar(91), this.printList(X.types, X), this.tokenChar(93);
    }
    function Le(X) {
      this.word("typeof"), this.space(), this.print(X.argument, X);
    }
    function Ee(X) {
      this.word("type"), this.space(), this.print(X.id, X), this.print(X.typeParameters, X), this.space(), this.tokenChar(61), this.space(), this.print(X.right, X), this.semicolon();
    }
    function J(X) {
      this.tokenChar(58), this.space(), X.optional && this.tokenChar(63), this.print(X.typeAnnotation, X);
    }
    function me(X) {
      this.tokenChar(60), this.printList(X.params, X, {}), this.tokenChar(62);
    }
    function ke(X) {
      this._variance(X), this.word(X.name), X.bound && this.print(X.bound, X), X.default && (this.space(), this.tokenChar(61), this.space(), this.print(X.default, X));
    }
    function _e(X) {
      this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(X.id, X), this.print(X.typeParameters, X), X.supertype && (this.tokenChar(58), this.space(), this.print(X.supertype, X)), X.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(X.impltype, X)), this.semicolon();
    }
    function Re(X) {
      X.exact ? this.token("{|") : this.tokenChar(123);
      const je = [...X.properties, ...X.callProperties || [], ...X.indexers || [], ...X.internalSlots || []];
      je.length && (this.space(), this.printJoin(je, X, {
        addNewlines(rt) {
          if (rt && !je[0])
            return 1;
        },
        indent: true,
        statement: true,
        iterator: () => {
          (je.length !== 1 || X.inexact) && (this.tokenChar(44), this.space());
        }
      }), this.space()), X.inexact && (this.indent(), this.token("..."), je.length && this.newline(), this.dedent()), X.exact ? this.token("|}") : this.tokenChar(125);
    }
    function $e(X) {
      X.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(X.id, X), this.tokenChar(93), this.tokenChar(93), X.optional && this.tokenChar(63), X.method || (this.tokenChar(58), this.space()), this.print(X.value, X);
    }
    function Ge(X) {
      X.static && (this.word("static"), this.space()), this.print(X.value, X);
    }
    function lt(X) {
      X.static && (this.word("static"), this.space()), this._variance(X), this.tokenChar(91), X.id && (this.print(X.id, X), this.tokenChar(58), this.space()), this.print(X.key, X), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(X.value, X);
    }
    function Ze(X) {
      X.proto && (this.word("proto"), this.space()), X.static && (this.word("static"), this.space()), (X.kind === "get" || X.kind === "set") && (this.word(X.kind), this.space()), this._variance(X), this.print(X.key, X), X.optional && this.tokenChar(63), X.method || (this.tokenChar(58), this.space()), this.print(X.value, X);
    }
    function Xe(X) {
      this.token("..."), this.print(X.argument, X);
    }
    function et(X) {
      this.print(X.qualification, X), this.tokenChar(46), this.print(X.id, X);
    }
    function st() {
      this.word("symbol");
    }
    function re() {
      this.space(), this.tokenChar(124), this.space();
    }
    function be(X) {
      this.printJoin(X.types, X, {
        separator: re
      });
    }
    function ue(X) {
      this.tokenChar(40), this.print(X.expression, X), this.print(X.typeAnnotation, X), this.tokenChar(41);
    }
    function Me(X) {
      X.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
    }
    function Y() {
      this.word("void");
    }
    function Ne(X) {
      this.print(X.objectType, X), this.tokenChar(91), this.print(X.indexType, X), this.tokenChar(93);
    }
    function Be(X) {
      this.print(X.objectType, X), X.optional && this.token("?."), this.tokenChar(91), this.print(X.indexType, X), this.tokenChar(93);
    }
  }(Gu)), Gu;
}
var Vi = {};
var Jh;
function PT() {
  if (Jh)
    return Vi;
  Jh = 1, Object.defineProperty(Vi, "__esModule", {
    value: true
  }), Vi.BlockStatement = h, Vi.Directive = f2, Vi.DirectiveLiteral = P, Vi.File = s, Vi.InterpreterDirective = x, Vi.Placeholder = y, Vi.Program = n;
  function s(A) {
    A.program && this.print(A.program.interpreter, A), this.print(A.program, A);
  }
  function n(A) {
    this.printInnerComments(A, false), this.printSequence(A.directives, A), A.directives && A.directives.length && this.newline(), this.printSequence(A.body, A);
  }
  function h(A) {
    var S;
    this.tokenChar(123), this.printInnerComments(A);
    const v = (S = A.directives) == null ? void 0 : S.length;
    A.body.length || v ? (this.newline(), this.printSequence(A.directives, A, {
      indent: true
    }), v && this.newline(), this.printSequence(A.body, A, {
      indent: true
    }), this.removeTrailingNewline(), this.source("end", A.loc), this.endsWith(10) || this.newline(), this.rightBrace()) : (this.source("end", A.loc), this.tokenChar(125));
  }
  function f2(A) {
    this.print(A.value, A), this.semicolon();
  }
  const p = /(?:^|[^\\])(?:\\\\)*'/, g = /(?:^|[^\\])(?:\\\\)*"/;
  function P(A) {
    const S = this.getPossibleRaw(A);
    if (!this.format.minified && S !== void 0) {
      this.token(S);
      return;
    }
    const {
      value: v
    } = A;
    if (!g.test(v))
      this.token(`"${v}"`);
    else if (!p.test(v))
      this.token(`'${v}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  function x(A) {
    this.token(`#!${A.value}
`, true);
  }
  function y(A) {
    this.token("%%"), this.print(A.name), this.token("%%"), A.expectedNode === "Statement" && this.semicolon();
  }
  return Vi;
}
var nr = {};
var Yh;
function ST() {
  if (Yh)
    return nr;
  Yh = 1, Object.defineProperty(nr, "__esModule", {
    value: true
  }), nr.JSXAttribute = s, nr.JSXClosingElement = v, nr.JSXClosingFragment = N, nr.JSXElement = y, nr.JSXEmptyExpression = T, nr.JSXExpressionContainer = g, nr.JSXFragment = C, nr.JSXIdentifier = n, nr.JSXMemberExpression = f2, nr.JSXNamespacedName = h, nr.JSXOpeningElement = S, nr.JSXOpeningFragment = I, nr.JSXSpreadAttribute = p, nr.JSXSpreadChild = P, nr.JSXText = x;
  function s(D) {
    this.print(D.name, D), D.value && (this.tokenChar(61), this.print(D.value, D));
  }
  function n(D) {
    this.word(D.name);
  }
  function h(D) {
    this.print(D.namespace, D), this.tokenChar(58), this.print(D.name, D);
  }
  function f2(D) {
    this.print(D.object, D), this.tokenChar(46), this.print(D.property, D);
  }
  function p(D) {
    this.tokenChar(123), this.token("..."), this.print(D.argument, D), this.tokenChar(125);
  }
  function g(D) {
    this.tokenChar(123), this.print(D.expression, D), this.tokenChar(125);
  }
  function P(D) {
    this.tokenChar(123), this.token("..."), this.print(D.expression, D), this.tokenChar(125);
  }
  function x(D) {
    const _ = this.getPossibleRaw(D);
    _ !== void 0 ? this.token(_) : this.token(D.value);
  }
  function y(D) {
    const _ = D.openingElement;
    if (this.print(_, D), !_.selfClosing) {
      this.indent();
      for (const m of D.children)
        this.print(m, D);
      this.dedent(), this.print(D.closingElement, D);
    }
  }
  function A() {
    this.space();
  }
  function S(D) {
    this.tokenChar(60), this.print(D.name, D), this.print(D.typeParameters, D), D.attributes.length > 0 && (this.space(), this.printJoin(D.attributes, D, {
      separator: A
    })), D.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  function v(D) {
    this.token("</"), this.print(D.name, D), this.tokenChar(62);
  }
  function T(D) {
    this.printInnerComments(D);
  }
  function C(D) {
    this.print(D.openingFragment, D), this.indent();
    for (const _ of D.children)
      this.print(_, D);
    this.dedent(), this.print(D.closingFragment, D);
  }
  function I() {
    this.tokenChar(60), this.tokenChar(62);
  }
  function N() {
    this.token("</"), this.tokenChar(62);
  }
  return nr;
}
var We = {};
var Qh;
function ET() {
  if (Qh)
    return We;
  Qh = 1, Object.defineProperty(We, "__esModule", {
    value: true
  }), We.TSAnyKeyword = C, We.TSArrayType = oe, We.TSAsExpression = me, We.TSBigIntKeyword = I, We.TSBooleanKeyword = m, We.TSCallSignatureDeclaration = x, We.TSConditionalType = Ie, We.TSConstructSignatureDeclaration = y, We.TSConstructorType = Q, We.TSDeclareFunction = p, We.TSDeclareMethod = g, We.TSEnumDeclaration = Re, We.TSEnumMember = $e, We.TSExportAssignment = re, We.TSExpressionWithTypeArguments = Se, We.TSExternalModuleReference = et, We.TSFunctionType = ne, We.TSImportEqualsDeclaration = Xe, We.TSImportType = Ze, We.TSIndexSignature = T, We.TSIndexedAccessType = W, We.TSInferType = Te, We.TSInstantiationExpression = _e, We.TSInterfaceBody = Ee, We.TSInterfaceDeclaration = Le, We.TSIntersectionType = H, We.TSIntrinsicKeyword = $, We.TSLiteralType = xe, We.TSMappedType = ae, We.TSMethodSignature = v, We.TSModuleBlock = lt, We.TSModuleDeclaration = Ge, We.TSNamedTupleMember = Pe, We.TSNamespaceExportDeclaration = be, We.TSNeverKeyword = j, We.TSNonNullExpression = st, We.TSNullKeyword = M, We.TSNumberKeyword = D, We.TSObjectKeyword = _, We.TSOptionalType = he, We.TSParameterProperty = f2, We.TSParenthesizedType = pe, We.TSPropertySignature = A, We.TSQualifiedName = P, We.TSRestType = de, We.TSStringKeyword = L, We.TSSymbolKeyword = R, We.TSThisType = k, We.TSTupleType = fe, We.TSTypeAliasDeclaration = J, We.TSTypeAnnotation = s, We.TSTypeAssertion = ke, We.TSTypeLiteral = V, We.TSTypeOperator = z, We.TSTypeParameter = h, We.TSTypeParameterDeclaration = We.TSTypeParameterInstantiation = n, We.TSTypePredicate = K, We.TSTypeQuery = G, We.TSTypeReference = ee, We.TSUndefinedKeyword = B, We.TSUnionType = we, We.TSUnknownKeyword = N, We.TSVoidKeyword = O, We.tsPrintClassMemberModifiers = Me, We.tsPrintFunctionOrConstructorType = q, We.tsPrintPropertyOrMethodName = S, We.tsPrintSignatureDeclarationBase = ue, We.tsPrintTypeLiteralOrInterfaceBody = F;
  function s(Y) {
    this.tokenChar(58), this.space(), Y.optional && this.tokenChar(63), this.print(Y.typeAnnotation, Y);
  }
  function n(Y, Ne) {
    this.tokenChar(60), this.printList(Y.params, Y, {}), Ne.type === "ArrowFunctionExpression" && Y.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
  }
  function h(Y) {
    Y.in && (this.word("in"), this.space()), Y.out && (this.word("out"), this.space()), this.word(Y.name), Y.constraint && (this.space(), this.word("extends"), this.space(), this.print(Y.constraint, Y)), Y.default && (this.space(), this.tokenChar(61), this.space(), this.print(Y.default, Y));
  }
  function f2(Y) {
    Y.accessibility && (this.word(Y.accessibility), this.space()), Y.readonly && (this.word("readonly"), this.space()), this._param(Y.parameter);
  }
  function p(Y) {
    Y.declare && (this.word("declare"), this.space()), this._functionHead(Y), this.tokenChar(59);
  }
  function g(Y) {
    this._classMethodHead(Y), this.tokenChar(59);
  }
  function P(Y) {
    this.print(Y.left, Y), this.tokenChar(46), this.print(Y.right, Y);
  }
  function x(Y) {
    this.tsPrintSignatureDeclarationBase(Y), this.tokenChar(59);
  }
  function y(Y) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(Y), this.tokenChar(59);
  }
  function A(Y) {
    const {
      readonly: Ne,
      initializer: Be
    } = Y;
    Ne && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(Y), this.print(Y.typeAnnotation, Y), Be && (this.space(), this.tokenChar(61), this.space(), this.print(Be, Y)), this.tokenChar(59);
  }
  function S(Y) {
    Y.computed && this.tokenChar(91), this.print(Y.key, Y), Y.computed && this.tokenChar(93), Y.optional && this.tokenChar(63);
  }
  function v(Y) {
    const {
      kind: Ne
    } = Y;
    (Ne === "set" || Ne === "get") && (this.word(Ne), this.space()), this.tsPrintPropertyOrMethodName(Y), this.tsPrintSignatureDeclarationBase(Y), this.tokenChar(59);
  }
  function T(Y) {
    const {
      readonly: Ne,
      static: Be
    } = Y;
    Be && (this.word("static"), this.space()), Ne && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(Y.parameters, Y), this.tokenChar(93), this.print(Y.typeAnnotation, Y), this.tokenChar(59);
  }
  function C() {
    this.word("any");
  }
  function I() {
    this.word("bigint");
  }
  function N() {
    this.word("unknown");
  }
  function D() {
    this.word("number");
  }
  function _() {
    this.word("object");
  }
  function m() {
    this.word("boolean");
  }
  function L() {
    this.word("string");
  }
  function R() {
    this.word("symbol");
  }
  function O() {
    this.word("void");
  }
  function B() {
    this.word("undefined");
  }
  function M() {
    this.word("null");
  }
  function j() {
    this.word("never");
  }
  function $() {
    this.word("intrinsic");
  }
  function k() {
    this.word("this");
  }
  function ne(Y) {
    this.tsPrintFunctionOrConstructorType(Y);
  }
  function Q(Y) {
    Y.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(Y);
  }
  function q(Y) {
    const {
      typeParameters: Ne
    } = Y, Be = Y.parameters;
    this.print(Ne, Y), this.tokenChar(40), this._parameters(Be, Y), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    const X = Y.typeAnnotation;
    this.print(X.typeAnnotation, Y);
  }
  function ee(Y) {
    this.print(Y.typeName, Y), this.print(Y.typeParameters, Y);
  }
  function K(Y) {
    Y.asserts && (this.word("asserts"), this.space()), this.print(Y.parameterName), Y.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(Y.typeAnnotation.typeAnnotation));
  }
  function G(Y) {
    this.word("typeof"), this.space(), this.print(Y.exprName), Y.typeParameters && this.print(Y.typeParameters, Y);
  }
  function V(Y) {
    this.tsPrintTypeLiteralOrInterfaceBody(Y.members, Y);
  }
  function F(Y, Ne) {
    le(this, Y, Ne);
  }
  function le(Y, Ne, Be) {
    if (Y.token("{"), Ne.length) {
      Y.indent(), Y.newline();
      for (const X of Ne)
        Y.print(X, Be), Y.newline();
      Y.dedent(), Y.rightBrace();
    } else
      Y.token("}");
  }
  function oe(Y) {
    this.print(Y.elementType, Y), this.token("[]");
  }
  function fe(Y) {
    this.tokenChar(91), this.printList(Y.elementTypes, Y), this.tokenChar(93);
  }
  function he(Y) {
    this.print(Y.typeAnnotation, Y), this.tokenChar(63);
  }
  function de(Y) {
    this.token("..."), this.print(Y.typeAnnotation, Y);
  }
  function Pe(Y) {
    this.print(Y.label, Y), Y.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(Y.elementType, Y);
  }
  function we(Y) {
    te(this, Y, "|");
  }
  function H(Y) {
    te(this, Y, "&");
  }
  function te(Y, Ne, Be) {
    Y.printJoin(Ne.types, Ne, {
      separator() {
        this.space(), this.token(Be), this.space();
      }
    });
  }
  function Ie(Y) {
    this.print(Y.checkType), this.space(), this.word("extends"), this.space(), this.print(Y.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(Y.trueType), this.space(), this.tokenChar(58), this.space(), this.print(Y.falseType);
  }
  function Te(Y) {
    this.token("infer"), this.space(), this.print(Y.typeParameter);
  }
  function pe(Y) {
    this.tokenChar(40), this.print(Y.typeAnnotation, Y), this.tokenChar(41);
  }
  function z(Y) {
    this.word(Y.operator), this.space(), this.print(Y.typeAnnotation, Y);
  }
  function W(Y) {
    this.print(Y.objectType, Y), this.tokenChar(91), this.print(Y.indexType, Y), this.tokenChar(93);
  }
  function ae(Y) {
    const {
      nameType: Ne,
      optional: Be,
      readonly: X,
      typeParameter: je
    } = Y;
    this.tokenChar(123), this.space(), X && (ce(this, X), this.word("readonly"), this.space()), this.tokenChar(91), this.word(je.name), this.space(), this.word("in"), this.space(), this.print(je.constraint, je), Ne && (this.space(), this.word("as"), this.space(), this.print(Ne, Y)), this.tokenChar(93), Be && (ce(this, Be), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(Y.typeAnnotation, Y), this.space(), this.tokenChar(125);
  }
  function ce(Y, Ne) {
    Ne !== true && Y.token(Ne);
  }
  function xe(Y) {
    this.print(Y.literal, Y);
  }
  function Se(Y) {
    this.print(Y.expression, Y), this.print(Y.typeParameters, Y);
  }
  function Le(Y) {
    const {
      declare: Ne,
      id: Be,
      typeParameters: X,
      extends: je,
      body: rt
    } = Y;
    Ne && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(Be, Y), this.print(X, Y), je != null && je.length && (this.space(), this.word("extends"), this.space(), this.printList(je, Y)), this.space(), this.print(rt, Y);
  }
  function Ee(Y) {
    this.tsPrintTypeLiteralOrInterfaceBody(Y.body, Y);
  }
  function J(Y) {
    const {
      declare: Ne,
      id: Be,
      typeParameters: X,
      typeAnnotation: je
    } = Y;
    Ne && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(Be, Y), this.print(X, Y), this.space(), this.tokenChar(61), this.space(), this.print(je, Y), this.tokenChar(59);
  }
  function me(Y) {
    const {
      expression: Ne,
      typeAnnotation: Be
    } = Y;
    this.print(Ne, Y), this.space(), this.word("as"), this.space(), this.print(Be, Y);
  }
  function ke(Y) {
    const {
      typeAnnotation: Ne,
      expression: Be
    } = Y;
    this.tokenChar(60), this.print(Ne, Y), this.tokenChar(62), this.space(), this.print(Be, Y);
  }
  function _e(Y) {
    this.print(Y.expression, Y), this.print(Y.typeParameters, Y);
  }
  function Re(Y) {
    const {
      declare: Ne,
      const: Be,
      id: X,
      members: je
    } = Y;
    Ne && (this.word("declare"), this.space()), Be && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(X, Y), this.space(), le(this, je, Y);
  }
  function $e(Y) {
    const {
      id: Ne,
      initializer: Be
    } = Y;
    this.print(Ne, Y), Be && (this.space(), this.tokenChar(61), this.space(), this.print(Be, Y)), this.tokenChar(44);
  }
  function Ge(Y) {
    const {
      declare: Ne,
      id: Be
    } = Y;
    if (Ne && (this.word("declare"), this.space()), Y.global || (this.word(Be.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(Be, Y), !Y.body) {
      this.tokenChar(59);
      return;
    }
    let X = Y.body;
    for (; X.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(X.id, X), X = X.body;
    this.space(), this.print(X, Y);
  }
  function lt(Y) {
    le(this, Y.body, Y);
  }
  function Ze(Y) {
    const {
      argument: Ne,
      qualifier: Be,
      typeParameters: X
    } = Y;
    this.word("import"), this.tokenChar(40), this.print(Ne, Y), this.tokenChar(41), Be && (this.tokenChar(46), this.print(Be, Y)), X && this.print(X, Y);
  }
  function Xe(Y) {
    const {
      isExport: Ne,
      id: Be,
      moduleReference: X
    } = Y;
    Ne && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(Be, Y), this.space(), this.tokenChar(61), this.space(), this.print(X, Y), this.tokenChar(59);
  }
  function et(Y) {
    this.token("require("), this.print(Y.expression, Y), this.tokenChar(41);
  }
  function st(Y) {
    this.print(Y.expression, Y), this.tokenChar(33);
  }
  function re(Y) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(Y.expression, Y), this.tokenChar(59);
  }
  function be(Y) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(Y.id, Y);
  }
  function ue(Y) {
    const {
      typeParameters: Ne
    } = Y, Be = Y.parameters;
    this.print(Ne, Y), this.tokenChar(40), this._parameters(Be, Y), this.tokenChar(41);
    const X = Y.typeAnnotation;
    this.print(X, Y);
  }
  function Me(Y) {
    const Ne = Y.type === "ClassAccessorProperty" || Y.type === "ClassProperty";
    Ne && Y.declare && (this.word("declare"), this.space()), Y.accessibility && (this.word(Y.accessibility), this.space()), Y.static && (this.word("static"), this.space()), Y.override && (this.word("override"), this.space()), Y.abstract && (this.word("abstract"), this.space()), Ne && Y.readonly && (this.word("readonly"), this.space());
  }
  return We;
}
var Zh;
function vT() {
  return Zh || (Zh = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    });
    var n = dT();
    Object.keys(n).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === n[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return n[T];
        }
      });
    });
    var h = mT();
    Object.keys(h).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === h[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return h[T];
        }
      });
    });
    var f2 = yT();
    Object.keys(f2).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === f2[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return f2[T];
        }
      });
    });
    var p = bT();
    Object.keys(p).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === p[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return p[T];
        }
      });
    });
    var g = gT();
    Object.keys(g).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === g[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return g[T];
        }
      });
    });
    var P = Xy();
    Object.keys(P).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === P[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return P[T];
        }
      });
    });
    var x = Jy();
    Object.keys(x).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === x[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return x[T];
        }
      });
    });
    var y = xT();
    Object.keys(y).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === y[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return y[T];
        }
      });
    });
    var A = PT();
    Object.keys(A).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === A[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return A[T];
        }
      });
    });
    var S = ST();
    Object.keys(S).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === S[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return S[T];
        }
      });
    });
    var v = ET();
    Object.keys(v).forEach(function(T) {
      T === "default" || T === "__esModule" || T in s && s[T] === v[T] || Object.defineProperty(s, T, {
        enumerable: true,
        get: function() {
          return v[T];
        }
      });
    });
  }(Hu)), Hu;
}
var ed;
function AT() {
  if (ed)
    return pa;
  ed = 1, Object.defineProperty(pa, "__esModule", {
    value: true
  }), pa.default = void 0;
  var s = pT(), n = Gy(), h = Je(), f2 = vT();
  const {
    isProgram: p,
    isFile: g,
    isEmptyStatement: P
  } = h, x = /e/i, y = /\.0+$/, A = /^0[box]/, S = /^\s*[@#]__PURE__\s*$/, {
    needsParens: v,
    needsWhitespaceAfter: T,
    needsWhitespaceBefore: C
  } = n;
  class I {
    constructor(m, L) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentChar = 0, this._indentRepeat = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this.format = m, this._buf = new s.default(L), this._indentChar = m.indent.style.charCodeAt(0), this._indentRepeat = m.indent.style.length;
    }
    generate(m) {
      return this.print(m), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(m = false) {
      this._maybeAddAuxComment(), m ? this._appendChar(59) : this._queue(59);
    }
    rightBrace() {
      this.format.minified && this._buf.removeLastSemicolon(), this.tokenChar(125);
    }
    space(m = false) {
      if (!this.format.compact) {
        if (m)
          this._space();
        else if (this._buf.hasContent()) {
          const L = this.getLastChar();
          L !== 32 && L !== 10 && this._space();
        }
      }
    }
    word(m) {
      (this._endsWithWord || m.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(m, false), this._endsWithWord = true;
    }
    number(m) {
      this.word(m), this._endsWithInteger = Number.isInteger(+m) && !A.test(m) && !x.test(m) && !y.test(m) && m.charCodeAt(m.length - 1) !== 46;
    }
    token(m, L = false) {
      const R = this.getLastChar(), O = m.charCodeAt(0);
      (R === 33 && m === "--" || O === 43 && R === 43 || O === 45 && R === 45 || O === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(m, L);
    }
    tokenChar(m) {
      const L = this.getLastChar();
      (m === 43 && L === 43 || m === 45 && L === 45 || m === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(m);
    }
    newline(m = 1) {
      if (this.format.retainLines || this.format.compact)
        return;
      if (this.format.concise) {
        this.space();
        return;
      }
      const L = this.endsWithCharAndNewline();
      if (L !== 10 && ((L === 123 || L === 58) && m--, !(m <= 0)))
        for (let R = 0; R < m; R++)
          this._newline();
    }
    endsWith(m) {
      return this.getLastChar() === m;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(m, L) {
      this._catchUp("start", m), this._buf.exactSource(m, L);
    }
    source(m, L) {
      this._catchUp(m, L), this._buf.source(m, L);
    }
    withSource(m, L, R) {
      this._catchUp(m, L), this._buf.withSource(m, L, R);
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(m, L) {
      this._maybeAddParen(m), this._maybeIndent(m.charCodeAt(0)), this._buf.append(m, L), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _appendChar(m) {
      this._maybeAddParenChar(m), this._maybeIndent(m), this._buf.appendChar(m), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _queue(m) {
      this._maybeAddParenChar(m), this._maybeIndent(m), this._buf.queue(m), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _maybeIndent(m) {
      this._indent && m !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._indentChar, this._getIndent());
    }
    _maybeAddParenChar(m) {
      const L = this._parenPushNewlineState;
      if (!!L && m !== 32) {
        if (m !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), L.printed = true;
      }
    }
    _maybeAddParen(m) {
      const L = this._parenPushNewlineState;
      if (!L)
        return;
      const R = m.length;
      let O;
      for (O = 0; O < R && m.charCodeAt(O) === 32; O++)
        ;
      if (O === R)
        return;
      const B = m.charCodeAt(O);
      if (B !== 10) {
        if (B !== 47 || O + 1 === R) {
          this._parenPushNewlineState = null;
          return;
        }
        const M = m.charCodeAt(O + 1);
        if (M === 42) {
          if (S.test(m.slice(O + 2, R - 2)))
            return;
        } else if (M !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), L.printed = true;
    }
    _catchUp(m, L) {
      if (!this.format.retainLines)
        return;
      const R = L ? L[m] : null;
      if ((R == null ? void 0 : R.line) != null) {
        const O = R.line - this._buf.getCurrentLine();
        for (let B = 0; B < O; B++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(m, L, R) {
      if (R)
        this._noLineTerminator = true, this.print(m, L), this._noLineTerminator = false;
      else {
        const O = {
          printed: false
        };
        this._parenPushNewlineState = O, this.print(m, L), O.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(m, L) {
      if (!m)
        return;
      const R = this.format.concise;
      m._compact && (this.format.concise = true);
      const O = this[m.type];
      if (!O)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(m.type)} with constructor ${JSON.stringify(m == null ? void 0 : m.constructor.name)}`);
      this._printStack.push(m);
      const B = this._insideAux;
      this._insideAux = !m.loc, this._maybeAddAuxComment(this._insideAux && !B);
      let M;
      this.format.retainFunctionParens && m.type === "FunctionExpression" && m.extra && m.extra.parenthesized ? M = true : M = v(m, L, this._printStack), M && this.tokenChar(40), this._printLeadingComments(m);
      const j = p(m) || g(m) ? null : m.loc;
      this.withSource("start", j, O.bind(this, m, L)), this._printTrailingComments(m), M && this.tokenChar(41), this._printStack.pop(), this.format.concise = R, this._insideAux = B;
    }
    _maybeAddAuxComment(m) {
      m && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode)
        return;
      this._printAuxAfterOnNextUserNode = true;
      const m = this.format.auxiliaryCommentBefore;
      m && this._printComment({
        type: "CommentBlock",
        value: m
      });
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode)
        return;
      this._printAuxAfterOnNextUserNode = false;
      const m = this.format.auxiliaryCommentAfter;
      m && this._printComment({
        type: "CommentBlock",
        value: m
      });
    }
    getPossibleRaw(m) {
      const L = m.extra;
      if (L && L.raw != null && L.rawValue != null && m.value === L.rawValue)
        return L.raw;
    }
    printJoin(m, L, R = {}) {
      if (!(m != null && m.length))
        return;
      R.indent && this.indent();
      const O = {
        addNewlines: R.addNewlines
      }, B = m.length;
      for (let M = 0; M < B; M++) {
        const j = m[M];
        !j || (R.statement && this._printNewline(true, j, L, O), this.print(j, L), R.iterator && R.iterator(j, M), R.separator && M < B - 1 && R.separator.call(this), R.statement && this._printNewline(false, j, L, O));
      }
      R.indent && this.dedent();
    }
    printAndIndentOnComments(m, L) {
      const R = m.leadingComments && m.leadingComments.length > 0;
      R && this.indent(), this.print(m, L), R && this.dedent();
    }
    printBlock(m) {
      const L = m.body;
      P(L) || this.space(), this.print(L, m);
    }
    _printTrailingComments(m) {
      this._printComments(this._getComments(false, m));
    }
    _printLeadingComments(m) {
      this._printComments(this._getComments(true, m), true);
    }
    printInnerComments(m, L = true) {
      var R;
      !((R = m.innerComments) != null && R.length) || (L && this.indent(), this._printComments(m.innerComments), L && this.dedent());
    }
    printSequence(m, L, R = {}) {
      return R.statement = true, this.printJoin(m, L, R);
    }
    printList(m, L, R = {}) {
      return R.separator == null && (R.separator = D), this.printJoin(m, L, R);
    }
    _printNewline(m, L, R, O) {
      if (this.format.retainLines || this.format.compact)
        return;
      if (this.format.concise) {
        this.space();
        return;
      }
      let B = 0;
      this._buf.hasContent() && (m || B++, O.addNewlines && (B += O.addNewlines(m, L) || 0), (m ? C : T)(L, R) && B++), this.newline(Math.min(2, B));
    }
    _getComments(m, L) {
      return L && (m ? L.leadingComments : L.trailingComments) || null;
    }
    _printComment(m, L) {
      if (m.ignore || this._printedComments.has(m) || !this.format.shouldPrintComment(m.value))
        return;
      this._printedComments.add(m);
      const R = m.type === "CommentBlock", O = R && !L && !this._noLineTerminator;
      O && this._buf.hasContent() && this.newline(1);
      const B = this.getLastChar();
      B !== 91 && B !== 123 && this.space();
      let M, j = false;
      if (R) {
        if (M = `/*${m.value}*/`, this.format.indent.adjustMultilineComment) {
          var $;
          const k = ($ = m.loc) == null ? void 0 : $.start.column;
          if (k) {
            const Q = new RegExp("\\n\\s{1," + k + "}", "g");
            M = M.replace(Q, `
`);
          }
          const ne = Math.max(this._getIndent(), this.format.retainLines ? 0 : this._buf.getCurrentColumn());
          M = M.replace(/\n(?!$)/g, `
${" ".repeat(ne)}`), j = true;
        }
      } else
        this._noLineTerminator || (M = `//${m.value}
`, j = true);
      this.endsWith(47) && this._space(), this.withSource("start", m.loc, this._append.bind(this, M, j)), O && this.newline(1);
    }
    _printComments(m, L) {
      if (!!(m != null && m.length))
        if (L && m.length === 1 && S.test(m[0].value))
          this._printComment(m[0], this._buf.hasContent() && !this.endsWith(10));
        else
          for (const R of m)
            this._printComment(R);
    }
    printAssertions(m) {
      var L;
      (L = m.assertions) != null && L.length && (this.space(), this.word("assert"), this.space(), this.tokenChar(123), this.space(), this.printList(m.assertions, m), this.space(), this.tokenChar(125));
    }
  }
  Object.assign(I.prototype, f2), I.prototype.Noop = function() {
  };
  var N = I;
  pa.default = N;
  function D() {
    this.tokenChar(44), this.space();
  }
  return pa;
}
var td;
function Zc() {
  if (td)
    return wn;
  td = 1, Object.defineProperty(wn, "__esModule", {
    value: true
  }), wn.CodeGenerator = void 0, wn.default = g;
  var s = cT(), n = AT();
  class h extends n.default {
    constructor(x, y = {}, A) {
      const S = f2(A, y), v = y.sourceMaps ? new s.default(y, A) : null;
      super(S, v), this.ast = void 0, this.ast = x;
    }
    generate() {
      return super.generate(this.ast);
    }
  }
  function f2(P, x) {
    const y = {
      auxiliaryCommentBefore: x.auxiliaryCommentBefore,
      auxiliaryCommentAfter: x.auxiliaryCommentAfter,
      shouldPrintComment: x.shouldPrintComment,
      retainLines: x.retainLines,
      retainFunctionParens: x.retainFunctionParens,
      comments: x.comments == null || x.comments,
      compact: x.compact,
      minified: x.minified,
      concise: x.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  ",
        base: 0
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, x.jsescOption),
      recordAndTupleSyntaxType: x.recordAndTupleSyntaxType,
      topicToken: x.topicToken
    };
    return y.decoratorsBeforeExport = !!x.decoratorsBeforeExport, y.jsonCompatibleStrings = x.jsonCompatibleStrings, y.minified ? (y.compact = true, y.shouldPrintComment = y.shouldPrintComment || (() => y.comments)) : y.shouldPrintComment = y.shouldPrintComment || ((A) => y.comments || A.includes("@license") || A.includes("@preserve")), y.compact === "auto" && (y.compact = P.length > 5e5, y.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${x.filename} as it exceeds the max of 500KB.`)), y.compact && (y.indent.adjustMultilineComment = false), y;
  }
  class p {
    constructor(x, y, A) {
      this._generator = void 0, this._generator = new h(x, y, A);
    }
    generate() {
      return this._generator.generate();
    }
  }
  wn.CodeGenerator = p;
  function g(P, x, y) {
    return new h(P, x, y).generate();
  }
  return wn;
}
var hs = {};
var rd;
function CT() {
  if (rd)
    return hs;
  rd = 1, Object.defineProperty(hs, "__esModule", {
    value: true
  }), hs.find = f2, hs.findParent = h, hs.getAncestry = y, hs.getDeepestCommonAncestorFrom = x, hs.getEarliestCommonAncestorFrom = P, hs.getFunctionParent = p, hs.getStatementParent = g, hs.inType = v, hs.isAncestor = A, hs.isDescendant = S;
  var s = Je();
  nn();
  const {
    VISITOR_KEYS: n
  } = s;
  function h(T) {
    let C = this;
    for (; C = C.parentPath; )
      if (T(C))
        return C;
    return null;
  }
  function f2(T) {
    let C = this;
    do
      if (T(C))
        return C;
    while (C = C.parentPath);
    return null;
  }
  function p() {
    return this.findParent((T) => T.isFunction());
  }
  function g() {
    let T = this;
    do {
      if (!T.parentPath || Array.isArray(T.container) && T.isStatement())
        break;
      T = T.parentPath;
    } while (T);
    if (T && (T.isProgram() || T.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return T;
  }
  function P(T) {
    return this.getDeepestCommonAncestorFrom(T, function(C, I, N) {
      let D;
      const _ = n[C.type];
      for (const m of N) {
        const L = m[I + 1];
        if (!D) {
          D = L;
          continue;
        }
        if (L.listKey && D.listKey === L.listKey && L.key < D.key) {
          D = L;
          continue;
        }
        const R = _.indexOf(D.parentKey), O = _.indexOf(L.parentKey);
        R > O && (D = L);
      }
      return D;
    });
  }
  function x(T, C) {
    if (!T.length)
      return this;
    if (T.length === 1)
      return T[0];
    let I = 1 / 0, N, D;
    const _ = T.map((L) => {
      const R = [];
      do
        R.unshift(L);
      while ((L = L.parentPath) && L !== this);
      return R.length < I && (I = R.length), R;
    }), m = _[0];
    e:
      for (let L = 0; L < I; L++) {
        const R = m[L];
        for (const O of _)
          if (O[L] !== R)
            break e;
        N = L, D = R;
      }
    if (D)
      return C ? C(D, N, _) : D;
    throw new Error("Couldn't find intersection");
  }
  function y() {
    let T = this;
    const C = [];
    do
      C.push(T);
    while (T = T.parentPath);
    return C;
  }
  function A(T) {
    return T.isDescendant(this);
  }
  function S(T) {
    return !!this.findParent((C) => C === T);
  }
  function v(...T) {
    let C = this;
    for (; C; ) {
      for (const I of T)
        if (C.node.type === I)
          return true;
      C = C.parentPath;
    }
    return false;
  }
  return hs;
}
var Xi = {};
var Xu = {};
var Qo = {};
var Zo = {};
var sd;
function Yy() {
  if (sd)
    return Zo;
  sd = 1, Object.defineProperty(Zo, "__esModule", {
    value: true
  }), Zo.createUnionType = P;
  var s = Je();
  const {
    createFlowUnionType: n,
    createTSUnionType: h,
    createUnionTypeAnnotation: f2,
    isFlowType: p,
    isTSType: g
  } = s;
  function P(x) {
    {
      if (p(x[0]))
        return n ? n(x) : f2(x);
      if (h)
        return h(x);
    }
  }
  return Zo;
}
var id;
function wT() {
  if (id)
    return Qo;
  id = 1, Object.defineProperty(Qo, "__esModule", {
    value: true
  }), Qo.default = P;
  var s = Je(), n = Yy();
  const {
    BOOLEAN_NUMBER_BINARY_OPERATORS: h,
    createTypeAnnotationBasedOnTypeof: f2,
    numberTypeAnnotation: p,
    voidTypeAnnotation: g
  } = s;
  function P(T) {
    if (!this.isReferenced())
      return;
    const C = this.scope.getBinding(T.name);
    if (C)
      return C.identifier.typeAnnotation ? C.identifier.typeAnnotation : x(C, this, T.name);
    if (T.name === "undefined")
      return g();
    if (T.name === "NaN" || T.name === "Infinity")
      return p();
    T.name;
  }
  function x(T, C, I) {
    const N = [], D = [];
    let _ = y(T, C, D);
    const m = v(T, C, I);
    if (m) {
      const L = y(T, m.ifStatement);
      _ = _.filter((R) => L.indexOf(R) < 0), N.push(m.typeAnnotation);
    }
    if (_.length) {
      _.push(...D);
      for (const L of _)
        N.push(L.getTypeAnnotation());
    }
    if (!!N.length)
      return (0, n.createUnionType)(N);
  }
  function y(T, C, I) {
    const N = T.constantViolations.slice();
    return N.unshift(T.path), N.filter((D) => {
      D = D.resolve();
      const _ = D._guessExecutionStatusRelativeTo(C);
      return I && _ === "unknown" && I.push(D), _ === "before";
    });
  }
  function A(T, C) {
    const I = C.node.operator, N = C.get("right").resolve(), D = C.get("left").resolve();
    let _;
    if (D.isIdentifier({
      name: T
    }) ? _ = N : N.isIdentifier({
      name: T
    }) && (_ = D), _)
      return I === "===" ? _.getTypeAnnotation() : h.indexOf(I) >= 0 ? p() : void 0;
    if (I !== "===" && I !== "==")
      return;
    let m, L;
    if (D.isUnaryExpression({
      operator: "typeof"
    }) ? (m = D, L = N) : N.isUnaryExpression({
      operator: "typeof"
    }) && (m = N, L = D), !m || !m.get("argument").isIdentifier({
      name: T
    }) || (L = L.resolve(), !L.isLiteral()))
      return;
    const R = L.node.value;
    if (typeof R == "string")
      return f2(R);
  }
  function S(T, C, I) {
    let N;
    for (; N = C.parentPath; ) {
      if (N.isIfStatement() || N.isConditionalExpression())
        return C.key === "test" ? void 0 : N;
      if (N.isFunction() && N.parentPath.scope.getBinding(I) !== T)
        return;
      C = N;
    }
  }
  function v(T, C, I) {
    const N = S(T, C, I);
    if (!N)
      return;
    const _ = [N.get("test")], m = [];
    for (let L = 0; L < _.length; L++) {
      const R = _[L];
      if (R.isLogicalExpression())
        R.node.operator === "&&" && (_.push(R.get("left")), _.push(R.get("right")));
      else if (R.isBinaryExpression()) {
        const O = A(I, R);
        O && m.push(O);
      }
    }
    return m.length ? {
      typeAnnotation: (0, n.createUnionType)(m),
      ifStatement: N
    } : v(T, N, I);
  }
  return Qo;
}
var nd;
function IT() {
  return nd || (nd = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), s.ArrayExpression = H, s.AssignmentExpression = F, s.BinaryExpression = q, s.BooleanLiteral = he, s.CallExpression = ae, s.ConditionalExpression = K, s.ClassDeclaration = s.ClassExpression = s.FunctionDeclaration = s.ArrowFunctionExpression = s.FunctionExpression = Ie, Object.defineProperty(s, "Identifier", {
      enumerable: true,
      get: function() {
        return h.default;
      }
    }), s.LogicalExpression = ee, s.NewExpression = k, s.NullLiteral = de, s.NumericLiteral = fe, s.ObjectExpression = we, s.ParenthesizedExpression = V, s.RegExpLiteral = Pe, s.RestElement = te, s.SequenceExpression = G, s.StringLiteral = oe, s.TSAsExpression = j, s.TSNonNullExpression = $, s.TaggedTemplateExpression = ce, s.TemplateLiteral = ne, s.TypeCastExpression = M, s.UnaryExpression = Q, s.UpdateExpression = le, s.VariableDeclarator = B;
    var n = Je(), h = wT(), f2 = Yy();
    const {
      BOOLEAN_BINARY_OPERATORS: p,
      BOOLEAN_UNARY_OPERATORS: g,
      NUMBER_BINARY_OPERATORS: P,
      NUMBER_UNARY_OPERATORS: x,
      STRING_UNARY_OPERATORS: y,
      anyTypeAnnotation: A,
      arrayTypeAnnotation: S,
      booleanTypeAnnotation: v,
      buildMatchMemberExpression: T,
      genericTypeAnnotation: C,
      identifier: I,
      nullLiteralTypeAnnotation: N,
      numberTypeAnnotation: D,
      stringTypeAnnotation: _,
      tupleTypeAnnotation: m,
      unionTypeAnnotation: L,
      voidTypeAnnotation: R,
      isIdentifier: O
    } = n;
    function B() {
      if (!!this.get("id").isIdentifier())
        return this.get("init").getTypeAnnotation();
    }
    function M(Se) {
      return Se.typeAnnotation;
    }
    M.validParent = true;
    function j(Se) {
      return Se.typeAnnotation;
    }
    j.validParent = true;
    function $() {
      return this.get("expression").getTypeAnnotation();
    }
    function k(Se) {
      if (Se.callee.type === "Identifier")
        return C(Se.callee);
    }
    function ne() {
      return _();
    }
    function Q(Se) {
      const Le = Se.operator;
      if (Le === "void")
        return R();
      if (x.indexOf(Le) >= 0)
        return D();
      if (y.indexOf(Le) >= 0)
        return _();
      if (g.indexOf(Le) >= 0)
        return v();
    }
    function q(Se) {
      const Le = Se.operator;
      if (P.indexOf(Le) >= 0)
        return D();
      if (p.indexOf(Le) >= 0)
        return v();
      if (Le === "+") {
        const Ee = this.get("right"), J = this.get("left");
        return J.isBaseType("number") && Ee.isBaseType("number") ? D() : J.isBaseType("string") || Ee.isBaseType("string") ? _() : L([_(), D()]);
      }
    }
    function ee() {
      const Se = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, f2.createUnionType)(Se);
    }
    function K() {
      const Se = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, f2.createUnionType)(Se);
    }
    function G() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function V() {
      return this.get("expression").getTypeAnnotation();
    }
    function F() {
      return this.get("right").getTypeAnnotation();
    }
    function le(Se) {
      const Le = Se.operator;
      if (Le === "++" || Le === "--")
        return D();
    }
    function oe() {
      return _();
    }
    function fe() {
      return D();
    }
    function he() {
      return v();
    }
    function de() {
      return N();
    }
    function Pe() {
      return C(I("RegExp"));
    }
    function we() {
      return C(I("Object"));
    }
    function H() {
      return C(I("Array"));
    }
    function te() {
      return H();
    }
    te.validParent = true;
    function Ie() {
      return C(I("Function"));
    }
    const Te = T("Array.from"), pe = T("Object.keys"), z = T("Object.values"), W = T("Object.entries");
    function ae() {
      const {
        callee: Se
      } = this.node;
      return pe(Se) ? S(_()) : Te(Se) || z(Se) || O(Se, {
        name: "Array"
      }) ? S(A()) : W(Se) ? S(m([_(), A()])) : xe(this.get("callee"));
    }
    function ce() {
      return xe(this.get("tag"));
    }
    function xe(Se) {
      if (Se = Se.resolve(), Se.isFunction()) {
        const {
          node: Le
        } = Se;
        if (Le.async)
          return Le.generator ? C(I("AsyncIterator")) : C(I("Promise"));
        if (Le.generator)
          return C(I("Iterator"));
        if (Se.node.returnType)
          return Se.node.returnType;
      }
    }
  }(Xu)), Xu;
}
var ad;
function NT() {
  if (ad)
    return Xi;
  ad = 1, Object.defineProperty(Xi, "__esModule", {
    value: true
  }), Xi._getTypeAnnotation = j, Xi.baseTypeStrictlyMatches = Q, Xi.couldBeBaseType = ne, Xi.getTypeAnnotation = B, Xi.isBaseType = $, Xi.isGenericType = q;
  var s = IT(), n = Je();
  const {
    anyTypeAnnotation: h,
    isAnyTypeAnnotation: f2,
    isArrayTypeAnnotation: p,
    isBooleanTypeAnnotation: g,
    isEmptyTypeAnnotation: P,
    isFlowBaseAnnotation: x,
    isGenericTypeAnnotation: y,
    isIdentifier: A,
    isMixedTypeAnnotation: S,
    isNumberTypeAnnotation: v,
    isStringTypeAnnotation: T,
    isTSArrayType: C,
    isTSTypeAnnotation: I,
    isTSTypeReference: N,
    isTupleTypeAnnotation: D,
    isTypeAnnotation: _,
    isUnionTypeAnnotation: m,
    isVoidTypeAnnotation: L,
    stringTypeAnnotation: R,
    voidTypeAnnotation: O
  } = n;
  function B() {
    let ee = this.getData("typeAnnotation");
    return ee != null || (ee = this._getTypeAnnotation() || h(), (_(ee) || I(ee)) && (ee = ee.typeAnnotation), this.setData("typeAnnotation", ee)), ee;
  }
  const M = /* @__PURE__ */ new WeakSet();
  function j() {
    const ee = this.node;
    if (!ee)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const G = this.parentPath.parentPath, V = G.parentPath;
        return G.key === "left" && V.isForInStatement() ? R() : G.key === "left" && V.isForOfStatement() ? h() : O();
      } else
        return;
    if (ee.typeAnnotation)
      return ee.typeAnnotation;
    if (!M.has(ee)) {
      M.add(ee);
      try {
        var K;
        let G = s[ee.type];
        if (G)
          return G.call(this, ee);
        if (G = s[this.parentPath.type], (K = G) != null && K.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        M.delete(ee);
      }
    }
  }
  function $(ee, K) {
    return k(ee, this.getTypeAnnotation(), K);
  }
  function k(ee, K, G) {
    if (ee === "string")
      return T(K);
    if (ee === "number")
      return v(K);
    if (ee === "boolean")
      return g(K);
    if (ee === "any")
      return f2(K);
    if (ee === "mixed")
      return S(K);
    if (ee === "empty")
      return P(K);
    if (ee === "void")
      return L(K);
    if (G)
      return false;
    throw new Error(`Unknown base type ${ee}`);
  }
  function ne(ee) {
    const K = this.getTypeAnnotation();
    if (f2(K))
      return true;
    if (m(K)) {
      for (const G of K.types)
        if (f2(G) || k(ee, G, true))
          return true;
      return false;
    } else
      return k(ee, K, true);
  }
  function Q(ee) {
    const K = this.getTypeAnnotation(), G = ee.getTypeAnnotation();
    return !f2(K) && x(K) ? G.type === K.type : false;
  }
  function q(ee) {
    const K = this.getTypeAnnotation();
    return ee === "Array" && (C(K) || p(K) || D(K)) ? true : y(K) && A(K.id, {
      name: ee
    }) || N(K) && A(K.typeName, {
      name: ee
    });
  }
  return Xi;
}
var Ji = {};
var da = {};
var Nn = {};
var ma = {};
var od;
function kT() {
  return od || (od = 1, Object.defineProperty(ma, "__esModule", {
    value: true
  }), ma.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, ma.matchToToken = function(s) {
    var n = { type: "invalid", value: s[0], closed: void 0 };
    return s[1] ? (n.type = "string", n.closed = !!(s[3] || s[4])) : s[5] ? n.type = "comment" : s[6] ? (n.type = "comment", n.closed = !!s[7]) : s[8] ? n.type = "regex" : s[9] ? n.type = "number" : s[10] ? n.type = "name" : s[11] ? n.type = "punctuator" : s[12] && (n.type = "whitespace"), n;
  }), ma;
}
var Ju = { exports: {} };
var Yu;
var ld;
function OT() {
  if (ld)
    return Yu;
  ld = 1;
  var s = /[|\\{}()[\]^$+*?.]/g;
  return Yu = function(n) {
    if (typeof n != "string")
      throw new TypeError("Expected a string");
    return n.replace(s, "\\$&");
  }, Yu;
}
var Qu = { exports: {} };
var Zu = { exports: {} };
var ec;
var ud;
function DT() {
  return ud || (ud = 1, ec = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), ec;
}
var cd;
function Qy() {
  if (cd)
    return Zu.exports;
  cd = 1;
  var s = DT(), n = {};
  for (var h in s)
    s.hasOwnProperty(h) && (n[s[h]] = h);
  var f2 = Zu.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var p in f2)
    if (f2.hasOwnProperty(p)) {
      if (!("channels" in f2[p]))
        throw new Error("missing channels property: " + p);
      if (!("labels" in f2[p]))
        throw new Error("missing channel labels property: " + p);
      if (f2[p].labels.length !== f2[p].channels)
        throw new Error("channel and label counts mismatch: " + p);
      var g = f2[p].channels, P = f2[p].labels;
      delete f2[p].channels, delete f2[p].labels, Object.defineProperty(f2[p], "channels", { value: g }), Object.defineProperty(f2[p], "labels", { value: P });
    }
  f2.rgb.hsl = function(y) {
    var A = y[0] / 255, S = y[1] / 255, v = y[2] / 255, T = Math.min(A, S, v), C = Math.max(A, S, v), I = C - T, N, D, _;
    return C === T ? N = 0 : A === C ? N = (S - v) / I : S === C ? N = 2 + (v - A) / I : v === C && (N = 4 + (A - S) / I), N = Math.min(N * 60, 360), N < 0 && (N += 360), _ = (T + C) / 2, C === T ? D = 0 : _ <= 0.5 ? D = I / (C + T) : D = I / (2 - C - T), [N, D * 100, _ * 100];
  }, f2.rgb.hsv = function(y) {
    var A, S, v, T, C, I = y[0] / 255, N = y[1] / 255, D = y[2] / 255, _ = Math.max(I, N, D), m = _ - Math.min(I, N, D), L = function(R) {
      return (_ - R) / 6 / m + 1 / 2;
    };
    return m === 0 ? T = C = 0 : (C = m / _, A = L(I), S = L(N), v = L(D), I === _ ? T = v - S : N === _ ? T = 1 / 3 + A - v : D === _ && (T = 2 / 3 + S - A), T < 0 ? T += 1 : T > 1 && (T -= 1)), [
      T * 360,
      C * 100,
      _ * 100
    ];
  }, f2.rgb.hwb = function(y) {
    var A = y[0], S = y[1], v = y[2], T = f2.rgb.hsl(y)[0], C = 1 / 255 * Math.min(A, Math.min(S, v));
    return v = 1 - 1 / 255 * Math.max(A, Math.max(S, v)), [T, C * 100, v * 100];
  }, f2.rgb.cmyk = function(y) {
    var A = y[0] / 255, S = y[1] / 255, v = y[2] / 255, T, C, I, N;
    return N = Math.min(1 - A, 1 - S, 1 - v), T = (1 - A - N) / (1 - N) || 0, C = (1 - S - N) / (1 - N) || 0, I = (1 - v - N) / (1 - N) || 0, [T * 100, C * 100, I * 100, N * 100];
  };
  function x(y, A) {
    return Math.pow(y[0] - A[0], 2) + Math.pow(y[1] - A[1], 2) + Math.pow(y[2] - A[2], 2);
  }
  return f2.rgb.keyword = function(y) {
    var A = n[y];
    if (A)
      return A;
    var S = 1 / 0, v;
    for (var T in s)
      if (s.hasOwnProperty(T)) {
        var C = s[T], I = x(y, C);
        I < S && (S = I, v = T);
      }
    return v;
  }, f2.keyword.rgb = function(y) {
    return s[y];
  }, f2.rgb.xyz = function(y) {
    var A = y[0] / 255, S = y[1] / 255, v = y[2] / 255;
    A = A > 0.04045 ? Math.pow((A + 0.055) / 1.055, 2.4) : A / 12.92, S = S > 0.04045 ? Math.pow((S + 0.055) / 1.055, 2.4) : S / 12.92, v = v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
    var T = A * 0.4124 + S * 0.3576 + v * 0.1805, C = A * 0.2126 + S * 0.7152 + v * 0.0722, I = A * 0.0193 + S * 0.1192 + v * 0.9505;
    return [T * 100, C * 100, I * 100];
  }, f2.rgb.lab = function(y) {
    var A = f2.rgb.xyz(y), S = A[0], v = A[1], T = A[2], C, I, N;
    return S /= 95.047, v /= 100, T /= 108.883, S = S > 8856e-6 ? Math.pow(S, 1 / 3) : 7.787 * S + 16 / 116, v = v > 8856e-6 ? Math.pow(v, 1 / 3) : 7.787 * v + 16 / 116, T = T > 8856e-6 ? Math.pow(T, 1 / 3) : 7.787 * T + 16 / 116, C = 116 * v - 16, I = 500 * (S - v), N = 200 * (v - T), [C, I, N];
  }, f2.hsl.rgb = function(y) {
    var A = y[0] / 360, S = y[1] / 100, v = y[2] / 100, T, C, I, N, D;
    if (S === 0)
      return D = v * 255, [D, D, D];
    v < 0.5 ? C = v * (1 + S) : C = v + S - v * S, T = 2 * v - C, N = [0, 0, 0];
    for (var _ = 0; _ < 3; _++)
      I = A + 1 / 3 * -(_ - 1), I < 0 && I++, I > 1 && I--, 6 * I < 1 ? D = T + (C - T) * 6 * I : 2 * I < 1 ? D = C : 3 * I < 2 ? D = T + (C - T) * (2 / 3 - I) * 6 : D = T, N[_] = D * 255;
    return N;
  }, f2.hsl.hsv = function(y) {
    var A = y[0], S = y[1] / 100, v = y[2] / 100, T = S, C = Math.max(v, 0.01), I, N;
    return v *= 2, S *= v <= 1 ? v : 2 - v, T *= C <= 1 ? C : 2 - C, N = (v + S) / 2, I = v === 0 ? 2 * T / (C + T) : 2 * S / (v + S), [A, I * 100, N * 100];
  }, f2.hsv.rgb = function(y) {
    var A = y[0] / 60, S = y[1] / 100, v = y[2] / 100, T = Math.floor(A) % 6, C = A - Math.floor(A), I = 255 * v * (1 - S), N = 255 * v * (1 - S * C), D = 255 * v * (1 - S * (1 - C));
    switch (v *= 255, T) {
      case 0:
        return [v, D, I];
      case 1:
        return [N, v, I];
      case 2:
        return [I, v, D];
      case 3:
        return [I, N, v];
      case 4:
        return [D, I, v];
      case 5:
        return [v, I, N];
    }
  }, f2.hsv.hsl = function(y) {
    var A = y[0], S = y[1] / 100, v = y[2] / 100, T = Math.max(v, 0.01), C, I, N;
    return N = (2 - S) * v, C = (2 - S) * T, I = S * T, I /= C <= 1 ? C : 2 - C, I = I || 0, N /= 2, [A, I * 100, N * 100];
  }, f2.hwb.rgb = function(y) {
    var A = y[0] / 360, S = y[1] / 100, v = y[2] / 100, T = S + v, C, I, N, D;
    T > 1 && (S /= T, v /= T), C = Math.floor(6 * A), I = 1 - v, N = 6 * A - C, (C & 1) !== 0 && (N = 1 - N), D = S + N * (I - S);
    var _, m, L;
    switch (C) {
      default:
      case 6:
      case 0:
        _ = I, m = D, L = S;
        break;
      case 1:
        _ = D, m = I, L = S;
        break;
      case 2:
        _ = S, m = I, L = D;
        break;
      case 3:
        _ = S, m = D, L = I;
        break;
      case 4:
        _ = D, m = S, L = I;
        break;
      case 5:
        _ = I, m = S, L = D;
        break;
    }
    return [_ * 255, m * 255, L * 255];
  }, f2.cmyk.rgb = function(y) {
    var A = y[0] / 100, S = y[1] / 100, v = y[2] / 100, T = y[3] / 100, C, I, N;
    return C = 1 - Math.min(1, A * (1 - T) + T), I = 1 - Math.min(1, S * (1 - T) + T), N = 1 - Math.min(1, v * (1 - T) + T), [C * 255, I * 255, N * 255];
  }, f2.xyz.rgb = function(y) {
    var A = y[0] / 100, S = y[1] / 100, v = y[2] / 100, T, C, I;
    return T = A * 3.2406 + S * -1.5372 + v * -0.4986, C = A * -0.9689 + S * 1.8758 + v * 0.0415, I = A * 0.0557 + S * -0.204 + v * 1.057, T = T > 31308e-7 ? 1.055 * Math.pow(T, 1 / 2.4) - 0.055 : T * 12.92, C = C > 31308e-7 ? 1.055 * Math.pow(C, 1 / 2.4) - 0.055 : C * 12.92, I = I > 31308e-7 ? 1.055 * Math.pow(I, 1 / 2.4) - 0.055 : I * 12.92, T = Math.min(Math.max(0, T), 1), C = Math.min(Math.max(0, C), 1), I = Math.min(Math.max(0, I), 1), [T * 255, C * 255, I * 255];
  }, f2.xyz.lab = function(y) {
    var A = y[0], S = y[1], v = y[2], T, C, I;
    return A /= 95.047, S /= 100, v /= 108.883, A = A > 8856e-6 ? Math.pow(A, 1 / 3) : 7.787 * A + 16 / 116, S = S > 8856e-6 ? Math.pow(S, 1 / 3) : 7.787 * S + 16 / 116, v = v > 8856e-6 ? Math.pow(v, 1 / 3) : 7.787 * v + 16 / 116, T = 116 * S - 16, C = 500 * (A - S), I = 200 * (S - v), [T, C, I];
  }, f2.lab.xyz = function(y) {
    var A = y[0], S = y[1], v = y[2], T, C, I;
    C = (A + 16) / 116, T = S / 500 + C, I = C - v / 200;
    var N = Math.pow(C, 3), D = Math.pow(T, 3), _ = Math.pow(I, 3);
    return C = N > 8856e-6 ? N : (C - 16 / 116) / 7.787, T = D > 8856e-6 ? D : (T - 16 / 116) / 7.787, I = _ > 8856e-6 ? _ : (I - 16 / 116) / 7.787, T *= 95.047, C *= 100, I *= 108.883, [T, C, I];
  }, f2.lab.lch = function(y) {
    var A = y[0], S = y[1], v = y[2], T, C, I;
    return T = Math.atan2(v, S), C = T * 360 / 2 / Math.PI, C < 0 && (C += 360), I = Math.sqrt(S * S + v * v), [A, I, C];
  }, f2.lch.lab = function(y) {
    var A = y[0], S = y[1], v = y[2], T, C, I;
    return I = v / 360 * 2 * Math.PI, T = S * Math.cos(I), C = S * Math.sin(I), [A, T, C];
  }, f2.rgb.ansi16 = function(y) {
    var A = y[0], S = y[1], v = y[2], T = 1 in arguments ? arguments[1] : f2.rgb.hsv(y)[2];
    if (T = Math.round(T / 50), T === 0)
      return 30;
    var C = 30 + (Math.round(v / 255) << 2 | Math.round(S / 255) << 1 | Math.round(A / 255));
    return T === 2 && (C += 60), C;
  }, f2.hsv.ansi16 = function(y) {
    return f2.rgb.ansi16(f2.hsv.rgb(y), y[2]);
  }, f2.rgb.ansi256 = function(y) {
    var A = y[0], S = y[1], v = y[2];
    if (A === S && S === v)
      return A < 8 ? 16 : A > 248 ? 231 : Math.round((A - 8) / 247 * 24) + 232;
    var T = 16 + 36 * Math.round(A / 255 * 5) + 6 * Math.round(S / 255 * 5) + Math.round(v / 255 * 5);
    return T;
  }, f2.ansi16.rgb = function(y) {
    var A = y % 10;
    if (A === 0 || A === 7)
      return y > 50 && (A += 3.5), A = A / 10.5 * 255, [A, A, A];
    var S = (~~(y > 50) + 1) * 0.5, v = (A & 1) * S * 255, T = (A >> 1 & 1) * S * 255, C = (A >> 2 & 1) * S * 255;
    return [v, T, C];
  }, f2.ansi256.rgb = function(y) {
    if (y >= 232) {
      var A = (y - 232) * 10 + 8;
      return [A, A, A];
    }
    y -= 16;
    var S, v = Math.floor(y / 36) / 5 * 255, T = Math.floor((S = y % 36) / 6) / 5 * 255, C = S % 6 / 5 * 255;
    return [v, T, C];
  }, f2.rgb.hex = function(y) {
    var A = ((Math.round(y[0]) & 255) << 16) + ((Math.round(y[1]) & 255) << 8) + (Math.round(y[2]) & 255), S = A.toString(16).toUpperCase();
    return "000000".substring(S.length) + S;
  }, f2.hex.rgb = function(y) {
    var A = y.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!A)
      return [0, 0, 0];
    var S = A[0];
    A[0].length === 3 && (S = S.split("").map(function(N) {
      return N + N;
    }).join(""));
    var v = parseInt(S, 16), T = v >> 16 & 255, C = v >> 8 & 255, I = v & 255;
    return [T, C, I];
  }, f2.rgb.hcg = function(y) {
    var A = y[0] / 255, S = y[1] / 255, v = y[2] / 255, T = Math.max(Math.max(A, S), v), C = Math.min(Math.min(A, S), v), I = T - C, N, D;
    return I < 1 ? N = C / (1 - I) : N = 0, I <= 0 ? D = 0 : T === A ? D = (S - v) / I % 6 : T === S ? D = 2 + (v - A) / I : D = 4 + (A - S) / I + 4, D /= 6, D %= 1, [D * 360, I * 100, N * 100];
  }, f2.hsl.hcg = function(y) {
    var A = y[1] / 100, S = y[2] / 100, v = 1, T = 0;
    return S < 0.5 ? v = 2 * A * S : v = 2 * A * (1 - S), v < 1 && (T = (S - 0.5 * v) / (1 - v)), [y[0], v * 100, T * 100];
  }, f2.hsv.hcg = function(y) {
    var A = y[1] / 100, S = y[2] / 100, v = A * S, T = 0;
    return v < 1 && (T = (S - v) / (1 - v)), [y[0], v * 100, T * 100];
  }, f2.hcg.rgb = function(y) {
    var A = y[0] / 360, S = y[1] / 100, v = y[2] / 100;
    if (S === 0)
      return [v * 255, v * 255, v * 255];
    var T = [0, 0, 0], C = A % 1 * 6, I = C % 1, N = 1 - I, D = 0;
    switch (Math.floor(C)) {
      case 0:
        T[0] = 1, T[1] = I, T[2] = 0;
        break;
      case 1:
        T[0] = N, T[1] = 1, T[2] = 0;
        break;
      case 2:
        T[0] = 0, T[1] = 1, T[2] = I;
        break;
      case 3:
        T[0] = 0, T[1] = N, T[2] = 1;
        break;
      case 4:
        T[0] = I, T[1] = 0, T[2] = 1;
        break;
      default:
        T[0] = 1, T[1] = 0, T[2] = N;
    }
    return D = (1 - S) * v, [
      (S * T[0] + D) * 255,
      (S * T[1] + D) * 255,
      (S * T[2] + D) * 255
    ];
  }, f2.hcg.hsv = function(y) {
    var A = y[1] / 100, S = y[2] / 100, v = A + S * (1 - A), T = 0;
    return v > 0 && (T = A / v), [y[0], T * 100, v * 100];
  }, f2.hcg.hsl = function(y) {
    var A = y[1] / 100, S = y[2] / 100, v = S * (1 - A) + 0.5 * A, T = 0;
    return v > 0 && v < 0.5 ? T = A / (2 * v) : v >= 0.5 && v < 1 && (T = A / (2 * (1 - v))), [y[0], T * 100, v * 100];
  }, f2.hcg.hwb = function(y) {
    var A = y[1] / 100, S = y[2] / 100, v = A + S * (1 - A);
    return [y[0], (v - A) * 100, (1 - v) * 100];
  }, f2.hwb.hcg = function(y) {
    var A = y[1] / 100, S = y[2] / 100, v = 1 - S, T = v - A, C = 0;
    return T < 1 && (C = (v - T) / (1 - T)), [y[0], T * 100, C * 100];
  }, f2.apple.rgb = function(y) {
    return [y[0] / 65535 * 255, y[1] / 65535 * 255, y[2] / 65535 * 255];
  }, f2.rgb.apple = function(y) {
    return [y[0] / 255 * 65535, y[1] / 255 * 65535, y[2] / 255 * 65535];
  }, f2.gray.rgb = function(y) {
    return [y[0] / 100 * 255, y[0] / 100 * 255, y[0] / 100 * 255];
  }, f2.gray.hsl = f2.gray.hsv = function(y) {
    return [0, 0, y[0]];
  }, f2.gray.hwb = function(y) {
    return [0, 100, y[0]];
  }, f2.gray.cmyk = function(y) {
    return [0, 0, 0, y[0]];
  }, f2.gray.lab = function(y) {
    return [y[0], 0, 0];
  }, f2.gray.hex = function(y) {
    var A = Math.round(y[0] / 100 * 255) & 255, S = (A << 16) + (A << 8) + A, v = S.toString(16).toUpperCase();
    return "000000".substring(v.length) + v;
  }, f2.rgb.gray = function(y) {
    var A = (y[0] + y[1] + y[2]) / 3;
    return [A / 255 * 100];
  }, Zu.exports;
}
var tc;
var pd;
function LT() {
  if (pd)
    return tc;
  pd = 1;
  var s = Qy();
  function n() {
    for (var g = {}, P = Object.keys(s), x = P.length, y = 0; y < x; y++)
      g[P[y]] = {
        distance: -1,
        parent: null
      };
    return g;
  }
  function h(g) {
    var P = n(), x = [g];
    for (P[g].distance = 0; x.length; )
      for (var y = x.pop(), A = Object.keys(s[y]), S = A.length, v = 0; v < S; v++) {
        var T = A[v], C = P[T];
        C.distance === -1 && (C.distance = P[y].distance + 1, C.parent = y, x.unshift(T));
      }
    return P;
  }
  function f2(g, P) {
    return function(x) {
      return P(g(x));
    };
  }
  function p(g, P) {
    for (var x = [P[g].parent, g], y = s[P[g].parent][g], A = P[g].parent; P[A].parent; )
      x.unshift(P[A].parent), y = f2(s[P[A].parent][A], y), A = P[A].parent;
    return y.conversion = x, y;
  }
  return tc = function(g) {
    for (var P = h(g), x = {}, y = Object.keys(P), A = y.length, S = 0; S < A; S++) {
      var v = y[S], T = P[v];
      T.parent !== null && (x[v] = p(v, P));
    }
    return x;
  }, tc;
}
var rc;
var fd;
function MT() {
  if (fd)
    return rc;
  fd = 1;
  var s = Qy(), n = LT(), h = {}, f2 = Object.keys(s);
  function p(P) {
    var x = function(y) {
      return y == null ? y : (arguments.length > 1 && (y = Array.prototype.slice.call(arguments)), P(y));
    };
    return "conversion" in P && (x.conversion = P.conversion), x;
  }
  function g(P) {
    var x = function(y) {
      if (y == null)
        return y;
      arguments.length > 1 && (y = Array.prototype.slice.call(arguments));
      var A = P(y);
      if (typeof A == "object")
        for (var S = A.length, v = 0; v < S; v++)
          A[v] = Math.round(A[v]);
      return A;
    };
    return "conversion" in P && (x.conversion = P.conversion), x;
  }
  return f2.forEach(function(P) {
    h[P] = {}, Object.defineProperty(h[P], "channels", { value: s[P].channels }), Object.defineProperty(h[P], "labels", { value: s[P].labels });
    var x = n(P), y = Object.keys(x);
    y.forEach(function(A) {
      var S = x[A];
      h[P][A] = g(S), h[P][A].raw = p(S);
    });
  }), rc = h, rc;
}
var hd;
function BT() {
  return hd || (hd = 1, function(s) {
    const n = MT(), h = (P, x) => function() {
      return `\x1B[${P.apply(n, arguments) + x}m`;
    }, f2 = (P, x) => function() {
      const y = P.apply(n, arguments);
      return `\x1B[${38 + x};5;${y}m`;
    }, p = (P, x) => function() {
      const y = P.apply(n, arguments);
      return `\x1B[${38 + x};2;${y[0]};${y[1]};${y[2]}m`;
    };
    function g() {
      const P = /* @__PURE__ */ new Map(), x = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      x.color.grey = x.color.gray;
      for (const S of Object.keys(x)) {
        const v = x[S];
        for (const T of Object.keys(v)) {
          const C = v[T];
          x[T] = {
            open: `\x1B[${C[0]}m`,
            close: `\x1B[${C[1]}m`
          }, v[T] = x[T], P.set(C[0], C[1]);
        }
        Object.defineProperty(x, S, {
          value: v,
          enumerable: false
        }), Object.defineProperty(x, "codes", {
          value: P,
          enumerable: false
        });
      }
      const y = (S) => S, A = (S, v, T) => [S, v, T];
      x.color.close = "\x1B[39m", x.bgColor.close = "\x1B[49m", x.color.ansi = {
        ansi: h(y, 0)
      }, x.color.ansi256 = {
        ansi256: f2(y, 0)
      }, x.color.ansi16m = {
        rgb: p(A, 0)
      }, x.bgColor.ansi = {
        ansi: h(y, 10)
      }, x.bgColor.ansi256 = {
        ansi256: f2(y, 10)
      }, x.bgColor.ansi16m = {
        rgb: p(A, 10)
      };
      for (let S of Object.keys(n)) {
        if (typeof n[S] != "object")
          continue;
        const v = n[S];
        S === "ansi16" && (S = "ansi"), "ansi16" in v && (x.color.ansi[S] = h(v.ansi16, 0), x.bgColor.ansi[S] = h(v.ansi16, 10)), "ansi256" in v && (x.color.ansi256[S] = f2(v.ansi256, 0), x.bgColor.ansi256[S] = f2(v.ansi256, 10)), "rgb" in v && (x.color.ansi16m[S] = p(v.rgb, 0), x.bgColor.ansi16m[S] = p(v.rgb, 10));
      }
      return x;
    }
    Object.defineProperty(s, "exports", {
      enumerable: true,
      get: g
    });
  }(Qu)), Qu.exports;
}
var sc;
var dd;
function _T() {
  return dd || (dd = 1, sc = {
    stdout: false,
    stderr: false
  }), sc;
}
var ic;
var md;
function FT() {
  if (md)
    return ic;
  md = 1;
  const s = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, n = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, h = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, f2 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, p = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function g(A) {
    return A[0] === "u" && A.length === 5 || A[0] === "x" && A.length === 3 ? String.fromCharCode(parseInt(A.slice(1), 16)) : p.get(A) || A;
  }
  function P(A, S) {
    const v = [], T = S.trim().split(/\s*,\s*/g);
    let C;
    for (const I of T)
      if (!isNaN(I))
        v.push(Number(I));
      else if (C = I.match(h))
        v.push(C[2].replace(f2, (N, D, _) => D ? g(D) : _));
      else
        throw new Error(`Invalid Chalk template style argument: ${I} (in style '${A}')`);
    return v;
  }
  function x(A) {
    n.lastIndex = 0;
    const S = [];
    let v;
    for (; (v = n.exec(A)) !== null; ) {
      const T = v[1];
      if (v[2]) {
        const C = P(T, v[2]);
        S.push([T].concat(C));
      } else
        S.push([T]);
    }
    return S;
  }
  function y(A, S) {
    const v = {};
    for (const C of S)
      for (const I of C.styles)
        v[I[0]] = C.inverse ? null : I.slice(1);
    let T = A;
    for (const C of Object.keys(v))
      if (Array.isArray(v[C])) {
        if (!(C in T))
          throw new Error(`Unknown Chalk style: ${C}`);
        v[C].length > 0 ? T = T[C].apply(T, v[C]) : T = T[C];
      }
    return T;
  }
  return ic = (A, S) => {
    const v = [], T = [];
    let C = [];
    if (S.replace(s, (I, N, D, _, m, L) => {
      if (N)
        C.push(g(N));
      else if (_) {
        const R = C.join("");
        C = [], T.push(v.length === 0 ? R : y(A, v)(R)), v.push({ inverse: D, styles: x(_) });
      } else if (m) {
        if (v.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        T.push(y(A, v)(C.join(""))), C = [], v.pop();
      } else
        C.push(L);
    }), T.push(C.join("")), v.length > 0) {
      const I = `Chalk template literal is missing ${v.length} closing bracket${v.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(I);
    }
    return T.join("");
  }, ic;
}
var yd;
function jT() {
  return yd || (yd = 1, function(s) {
    const n = OT(), h = BT(), f2 = _T().stdout, p = FT(), g = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), P = ["ansi", "ansi", "ansi256", "ansi16m"], x = /* @__PURE__ */ new Set(["gray"]), y = /* @__PURE__ */ Object.create(null);
    function A(N, D) {
      D = D || {};
      const _ = f2 ? f2.level : 0;
      N.level = D.level === void 0 ? _ : D.level, N.enabled = "enabled" in D ? D.enabled : N.level > 0;
    }
    function S(N) {
      if (!this || !(this instanceof S) || this.template) {
        const D = {};
        return A(D, N), D.template = function() {
          const _ = [].slice.call(arguments);
          return I.apply(null, [D.template].concat(_));
        }, Object.setPrototypeOf(D, S.prototype), Object.setPrototypeOf(D.template, D), D.template.constructor = S, D.template;
      }
      A(this, N);
    }
    g && (h.blue.open = "\x1B[94m");
    for (const N of Object.keys(h))
      h[N].closeRe = new RegExp(n(h[N].close), "g"), y[N] = {
        get() {
          const D = h[N];
          return T.call(this, this._styles ? this._styles.concat(D) : [D], this._empty, N);
        }
      };
    y.visible = {
      get() {
        return T.call(this, this._styles || [], true, "visible");
      }
    }, h.color.closeRe = new RegExp(n(h.color.close), "g");
    for (const N of Object.keys(h.color.ansi))
      x.has(N) || (y[N] = {
        get() {
          const D = this.level;
          return function() {
            const m = {
              open: h.color[P[D]][N].apply(null, arguments),
              close: h.color.close,
              closeRe: h.color.closeRe
            };
            return T.call(this, this._styles ? this._styles.concat(m) : [m], this._empty, N);
          };
        }
      });
    h.bgColor.closeRe = new RegExp(n(h.bgColor.close), "g");
    for (const N of Object.keys(h.bgColor.ansi)) {
      if (x.has(N))
        continue;
      const D = "bg" + N[0].toUpperCase() + N.slice(1);
      y[D] = {
        get() {
          const _ = this.level;
          return function() {
            const L = {
              open: h.bgColor[P[_]][N].apply(null, arguments),
              close: h.bgColor.close,
              closeRe: h.bgColor.closeRe
            };
            return T.call(this, this._styles ? this._styles.concat(L) : [L], this._empty, N);
          };
        }
      };
    }
    const v = Object.defineProperties(() => {
    }, y);
    function T(N, D, _) {
      const m = function() {
        return C.apply(m, arguments);
      };
      m._styles = N, m._empty = D;
      const L = this;
      return Object.defineProperty(m, "level", {
        enumerable: true,
        get() {
          return L.level;
        },
        set(R) {
          L.level = R;
        }
      }), Object.defineProperty(m, "enabled", {
        enumerable: true,
        get() {
          return L.enabled;
        },
        set(R) {
          L.enabled = R;
        }
      }), m.hasGrey = this.hasGrey || _ === "gray" || _ === "grey", m.__proto__ = v, m;
    }
    function C() {
      const N = arguments, D = N.length;
      let _ = String(arguments[0]);
      if (D === 0)
        return "";
      if (D > 1)
        for (let L = 1; L < D; L++)
          _ += " " + N[L];
      if (!this.enabled || this.level <= 0 || !_)
        return this._empty ? "" : _;
      const m = h.dim.open;
      g && this.hasGrey && (h.dim.open = "");
      for (const L of this._styles.slice().reverse())
        _ = L.open + _.replace(L.closeRe, L.open) + L.close, _ = _.replace(/\r?\n/g, `${L.close}$&${L.open}`);
      return h.dim.open = m, _;
    }
    function I(N, D) {
      if (!Array.isArray(D))
        return [].slice.call(arguments, 1).join(" ");
      const _ = [].slice.call(arguments, 2), m = [D.raw[0]];
      for (let L = 1; L < D.length; L++)
        m.push(String(_[L - 1]).replace(/[{}\\]/g, "\\$&")), m.push(String(D.raw[L]));
      return p(N, m.join(""));
    }
    Object.defineProperties(S.prototype, y), s.exports = S(), s.exports.supportsColor = f2, s.exports.default = s.exports;
  }(Ju)), Ju.exports;
}
var bd;
function RT() {
  if (bd)
    return Nn;
  bd = 1, Object.defineProperty(Nn, "__esModule", {
    value: true
  }), Nn.default = v, Nn.getChalk = S, Nn.shouldHighlight = A;
  var s = kT(), n = Ba(), h = jT();
  const f2 = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
  function p(T) {
    return {
      keyword: T.cyan,
      capitalized: T.yellow,
      jsxIdentifier: T.yellow,
      punctuator: T.yellow,
      number: T.magenta,
      string: T.green,
      regex: T.magenta,
      comment: T.grey,
      invalid: T.white.bgRed.bold
    };
  }
  const g = /\r\n|[\n\r\u2028\u2029]/, P = /^[()[\]{}]$/;
  let x;
  {
    const T = /^[a-z][\w-]*$/i, C = function(I, N, D) {
      if (I.type === "name") {
        if ((0, n.isKeyword)(I.value) || (0, n.isStrictReservedWord)(I.value, true) || f2.has(I.value))
          return "keyword";
        if (T.test(I.value) && (D[N - 1] === "<" || D.slice(N - 2, N) == "</"))
          return "jsxIdentifier";
        if (I.value[0] !== I.value[0].toLowerCase())
          return "capitalized";
      }
      return I.type === "punctuator" && P.test(I.value) ? "bracket" : I.type === "invalid" && (I.value === "@" || I.value === "#") ? "punctuator" : I.type;
    };
    x = function* (I) {
      let N;
      for (; N = s.default.exec(I); ) {
        const D = s.matchToToken(N);
        yield {
          type: C(D, N.index, I),
          value: D.value
        };
      }
    };
  }
  function y(T, C) {
    let I = "";
    for (const {
      type: N,
      value: D
    } of x(C)) {
      const _ = T[N];
      _ ? I += D.split(g).map((m) => _(m)).join(`
`) : I += D;
    }
    return I;
  }
  function A(T) {
    return !!h.supportsColor || T.forceColor;
  }
  function S(T) {
    return T.forceColor ? new h.constructor({
      enabled: true,
      level: 1
    }) : h;
  }
  function v(T, C = {}) {
    if (T !== "" && A(C)) {
      const I = S(C), N = p(I);
      return y(N, T);
    } else
      return T;
  }
  return Nn;
}
var gd;
function Bl() {
  if (gd)
    return da;
  gd = 1, Object.defineProperty(da, "__esModule", {
    value: true
  }), da.codeFrameColumns = g, da.default = P;
  var s = RT();
  let n = false;
  function h(x) {
    return {
      gutter: x.grey,
      marker: x.red.bold,
      message: x.red.bold
    };
  }
  const f2 = /\r\n|[\n\r\u2028\u2029]/;
  function p(x, y, A) {
    const S = Object.assign({
      column: 0,
      line: -1
    }, x.start), v = Object.assign({}, S, x.end), {
      linesAbove: T = 2,
      linesBelow: C = 3
    } = A || {}, I = S.line, N = S.column, D = v.line, _ = v.column;
    let m = Math.max(I - (T + 1), 0), L = Math.min(y.length, D + C);
    I === -1 && (m = 0), D === -1 && (L = y.length);
    const R = D - I, O = {};
    if (R)
      for (let B = 0; B <= R; B++) {
        const M = B + I;
        if (!N)
          O[M] = true;
        else if (B === 0) {
          const j = y[M - 1].length;
          O[M] = [N, j - N + 1];
        } else if (B === R)
          O[M] = [0, _];
        else {
          const j = y[M - B].length;
          O[M] = [0, j];
        }
      }
    else
      N === _ ? N ? O[I] = [N, 0] : O[I] = true : O[I] = [N, _ - N];
    return {
      start: m,
      end: L,
      markerLines: O
    };
  }
  function g(x, y, A = {}) {
    const S = (A.highlightCode || A.forceColor) && (0, s.shouldHighlight)(A), v = (0, s.getChalk)(A), T = h(v), C = (B, M) => S ? B(M) : M, I = x.split(f2), {
      start: N,
      end: D,
      markerLines: _
    } = p(y, I, A), m = y.start && typeof y.start.column == "number", L = String(D).length;
    let O = (S ? (0, s.default)(x, A) : x).split(f2, D).slice(N, D).map((B, M) => {
      const j = N + 1 + M, k = ` ${` ${j}`.slice(-L)} |`, ne = _[j], Q = !_[j + 1];
      if (ne) {
        let q = "";
        if (Array.isArray(ne)) {
          const ee = B.slice(0, Math.max(ne[0] - 1, 0)).replace(/[^\t]/g, " "), K = ne[1] || 1;
          q = [`
 `, C(T.gutter, k.replace(/\d/g, " ")), " ", ee, C(T.marker, "^").repeat(K)].join(""), Q && A.message && (q += " " + C(T.message, A.message));
        }
        return [C(T.marker, ">"), C(T.gutter, k), B.length > 0 ? ` ${B}` : "", q].join("");
      } else
        return ` ${C(T.gutter, k)}${B.length > 0 ? ` ${B}` : ""}`;
    }).join(`
`);
    return A.message && !m && (O = `${" ".repeat(L + 1)}${A.message}
${O}`), S ? v.reset(O) : O;
  }
  function P(x, y, A, S = {}) {
    if (!n) {
      n = true;
      const T = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(T, "DeprecationWarning");
      else {
        const C = new Error(T);
        C.name = "DeprecationWarning", console.warn(new Error(T));
      }
    }
    return A = Math.max(A, 0), g(x, {
      start: {
        column: A,
        line: y
      }
    }, S);
  }
  return da;
}
var kn = {};
var Td;
function UT() {
  if (Td)
    return kn;
  Td = 1, Object.defineProperty(kn, "__esModule", { value: true });
  function s(a, e) {
    if (a == null)
      return {};
    var t = {}, r = Object.keys(a), i, o;
    for (o = 0; o < r.length; o++)
      i = r[o], !(e.indexOf(i) >= 0) && (t[i] = a[i]);
    return t;
  }
  class n {
    constructor(e, t, r) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = t, this.index = r;
    }
  }
  class h {
    constructor(e, t) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = t;
    }
  }
  function f2(a, e) {
    const {
      line: t,
      column: r,
      index: i
    } = a;
    return new n(t, r + e, i + e);
  }
  const p = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
  }), g = (a, e = a.length - 1) => ({
    get() {
      return a.reduce((t, r) => t[r], this);
    },
    set(t) {
      a.reduce((r, i, o) => o === e ? r[i] = t : r[i], this);
    }
  }), P = (a, e, t) => Object.keys(t).map((r) => [r, t[r]]).filter(([, r]) => !!r).map(([r, i]) => [r, typeof i == "function" ? {
    value: i,
    enumerable: false
  } : typeof i.reflect == "string" ? Object.assign({}, i, g(i.reflect.split("."))) : i]).reduce((r, [i, o]) => Object.defineProperty(r, i, Object.assign({
    configurable: true
  }, o)), Object.assign(new a(), e));
  var x = (a) => ({
    ImportMetaOutsideModule: a(`import.meta may appear only with 'sourceType: "module"'`, {
      code: p.SourceTypeModuleError
    }),
    ImportOutsideModule: a(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
      code: p.SourceTypeModuleError
    })
  });
  const y = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, A = ({
    type: a,
    prefix: e
  }) => a === "UpdateExpression" ? y.UpdateExpression[String(e)] : y[a];
  var S = (a) => ({
    AccessorIsGenerator: a(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`),
    ArgumentsInClass: a("'arguments' is only allowed in functions and class methods."),
    AsyncFunctionInSingleStatementContext: a("Async functions can only be declared at the top level or inside a block."),
    AwaitBindingIdentifier: a("Can not use 'await' as identifier inside an async function."),
    AwaitBindingIdentifierInStaticBlock: a("Can not use 'await' as identifier inside a static block."),
    AwaitExpressionFormalParameter: a("'await' is not allowed in async function parameters."),
    AwaitNotInAsyncContext: a("'await' is only allowed within async functions and at the top levels of modules."),
    AwaitNotInAsyncFunction: a("'await' is only allowed within async functions."),
    BadGetterArity: a("A 'get' accesor must not have any formal parameters."),
    BadSetterArity: a("A 'set' accesor must have exactly one formal parameter."),
    BadSetterRestParameter: a("A 'set' accesor function argument must not be a rest parameter."),
    ConstructorClassField: a("Classes may not have a field named 'constructor'."),
    ConstructorClassPrivateField: a("Classes may not have a private field named '#constructor'."),
    ConstructorIsAccessor: a("Class constructor may not be an accessor."),
    ConstructorIsAsync: a("Constructor can't be an async function."),
    ConstructorIsGenerator: a("Constructor can't be a generator."),
    DeclarationMissingInitializer: a(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`),
    DecoratorBeforeExport: a("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."),
    DecoratorConstructor: a("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
    DecoratorExportClass: a("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."),
    DecoratorSemicolon: a("Decorators must not be followed by a semicolon."),
    DecoratorStaticBlock: a("Decorators can't be used with a static block."),
    DeletePrivateField: a("Deleting a private field is not allowed."),
    DestructureNamedImport: a("ES2015 named imports do not destructure. Use another statement for destructuring after the import."),
    DuplicateConstructor: a("Duplicate constructor in the same class."),
    DuplicateDefaultExport: a("Only one default export allowed per module."),
    DuplicateExport: a(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`),
    DuplicateProto: a("Redefinition of __proto__ property."),
    DuplicateRegExpFlags: a("Duplicate regular expression flag."),
    ElementAfterRest: a("Rest element must be last element."),
    EscapedCharNotAnIdentifier: a("Invalid Unicode escape."),
    ExportBindingIsString: a(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`),
    ExportDefaultFromAsIdentifier: a("'from' is not allowed as an identifier after 'export default'."),
    ForInOfLoopInitializer: a(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`),
    ForOfAsync: a("The left-hand side of a for-of loop may not be 'async'."),
    ForOfLet: a("The left-hand side of a for-of loop may not start with 'let'."),
    GeneratorInSingleStatementContext: a("Generators can only be declared at the top level or inside a block."),
    IllegalBreakContinue: a(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`),
    IllegalLanguageModeDirective: a("Illegal 'use strict' directive in function with non-simple parameter list."),
    IllegalReturn: a("'return' outside of function."),
    ImportBindingIsString: a(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`),
    ImportCallArgumentTrailingComma: a("Trailing comma is disallowed inside import(...) arguments."),
    ImportCallArity: a(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`),
    ImportCallNotNewExpression: a("Cannot use new with import(...)."),
    ImportCallSpreadArgument: a("`...` is not allowed in `import()`."),
    ImportJSONBindingNotDefault: a("A JSON module can only be imported with `default`."),
    IncompatibleRegExpUVFlags: a("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
    InvalidBigIntLiteral: a("Invalid BigIntLiteral."),
    InvalidCodePoint: a("Code point out of bounds."),
    InvalidCoverInitializedName: a("Invalid shorthand property initializer."),
    InvalidDecimal: a("Invalid decimal."),
    InvalidDigit: a(({
      radix: e
    }) => `Expected number in radix ${e}.`),
    InvalidEscapeSequence: a("Bad character escape sequence."),
    InvalidEscapeSequenceTemplate: a("Invalid escape sequence in template."),
    InvalidEscapedReservedWord: a(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`),
    InvalidIdentifier: a(({
      identifierName: e
    }) => `Invalid identifier ${e}.`),
    InvalidLhs: a(({
      ancestor: e
    }) => `Invalid left-hand side in ${A(e)}.`),
    InvalidLhsBinding: a(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${A(e)}.`),
    InvalidNumber: a("Invalid number."),
    InvalidOrMissingExponent: a("Floating-point numbers require a valid exponent after the 'e'."),
    InvalidOrUnexpectedToken: a(({
      unexpected: e
    }) => `Unexpected character '${e}'.`),
    InvalidParenthesizedAssignment: a("Invalid parenthesized assignment pattern."),
    InvalidPrivateFieldResolution: a(({
      identifierName: e
    }) => `Private name #${e} is not defined.`),
    InvalidPropertyBindingPattern: a("Binding member expression."),
    InvalidRecordProperty: a("Only properties and spread elements are allowed in record definitions."),
    InvalidRestAssignmentPattern: a("Invalid rest operator's argument."),
    LabelRedeclaration: a(({
      labelName: e
    }) => `Label '${e}' is already declared.`),
    LetInLexicalBinding: a("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
    LineTerminatorBeforeArrow: a("No line break is allowed before '=>'."),
    MalformedRegExpFlags: a("Invalid regular expression flag."),
    MissingClassName: a("A class name is required."),
    MissingEqInAssignment: a("Only '=' operator can be used for specifying default value."),
    MissingSemicolon: a("Missing semicolon."),
    MissingPlugin: a(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`),
    MissingOneOfPlugins: a(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`),
    MissingUnicodeEscape: a("Expecting Unicode escape sequence \\uXXXX."),
    MixingCoalesceWithLogical: a("Nullish coalescing operator(??) requires parens when mixing with logical operators."),
    ModuleAttributeDifferentFromType: a("The only accepted module attribute is `type`."),
    ModuleAttributeInvalidValue: a("Only string literals are allowed as module attribute values."),
    ModuleAttributesWithDuplicateKeys: a(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`),
    ModuleExportNameHasLoneSurrogate: a(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`),
    ModuleExportUndefined: a(({
      localName: e
    }) => `Export '${e}' is not defined.`),
    MultipleDefaultsInSwitch: a("Multiple default clauses."),
    NewlineAfterThrow: a("Illegal newline after throw."),
    NoCatchOrFinally: a("Missing catch or finally clause."),
    NumberIdentifier: a("Identifier directly after number."),
    NumericSeparatorInEscapeSequence: a("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."),
    ObsoleteAwaitStar: a("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
    OptionalChainingNoNew: a("Constructors in/after an Optional Chain are not allowed."),
    OptionalChainingNoTemplate: a("Tagged Template Literals are not allowed in optionalChain."),
    OverrideOnConstructor: a("'override' modifier cannot appear on a constructor declaration."),
    ParamDupe: a("Argument name clash."),
    PatternHasAccessor: a("Object pattern can't contain getter or setter."),
    PatternHasMethod: a("Object pattern can't contain methods."),
    PrivateInExpectedIn: a(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`),
    PrivateNameRedeclaration: a(({
      identifierName: e
    }) => `Duplicate private name #${e}.`),
    RecordExpressionBarIncorrectEndSyntaxType: a("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    RecordExpressionBarIncorrectStartSyntaxType: a("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    RecordExpressionHashIncorrectStartSyntaxType: a("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
    RecordNoProto: a("'__proto__' is not allowed in Record expressions."),
    RestTrailingComma: a("Unexpected trailing comma after rest element."),
    SloppyFunction: a("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."),
    StaticPrototype: a("Classes may not have static property named prototype."),
    SuperNotAllowed: a("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"),
    SuperPrivateField: a("Private fields can't be accessed on super."),
    TrailingDecorator: a("Decorators must be attached to a class element."),
    TupleExpressionBarIncorrectEndSyntaxType: a("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    TupleExpressionBarIncorrectStartSyntaxType: a("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    TupleExpressionHashIncorrectStartSyntaxType: a("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
    UnexpectedArgumentPlaceholder: a("Unexpected argument placeholder."),
    UnexpectedAwaitAfterPipelineBody: a('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'),
    UnexpectedDigitAfterHash: a("Unexpected digit after hash token."),
    UnexpectedImportExport: a("'import' and 'export' may only appear at the top level."),
    UnexpectedKeyword: a(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`),
    UnexpectedLeadingDecorator: a("Leading decorators must be attached to a class declaration."),
    UnexpectedLexicalDeclaration: a("Lexical declaration cannot appear in a single-statement context."),
    UnexpectedNewTarget: a("`new.target` can only be used in functions or class properties."),
    UnexpectedNumericSeparator: a("A numeric separator is only allowed between two digits."),
    UnexpectedPrivateField: a("Unexpected private name."),
    UnexpectedReservedWord: a(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`),
    UnexpectedSuper: a("'super' is only allowed in object methods and classes."),
    UnexpectedToken: a(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`),
    UnexpectedTokenUnaryExponentiation: a("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."),
    UnsupportedBind: a("Binding should be performed on object property."),
    UnsupportedDecoratorExport: a("A decorated export must export a class declaration."),
    UnsupportedDefaultExport: a("Only expressions, functions or classes are allowed as the `default` export."),
    UnsupportedImport: a("`import` can only be used in `import()` or `import.meta`."),
    UnsupportedMetaProperty: a(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`),
    UnsupportedParameterDecorator: a("Decorators cannot be used to decorate parameters."),
    UnsupportedPropertyDecorator: a("Decorators cannot be used to decorate object literal properties."),
    UnsupportedSuper: a("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."),
    UnterminatedComment: a("Unterminated comment."),
    UnterminatedRegExp: a("Unterminated regular expression."),
    UnterminatedString: a("Unterminated string constant."),
    UnterminatedTemplate: a("Unterminated template."),
    VarRedeclaration: a(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`),
    YieldBindingIdentifier: a("Can not use 'yield' as identifier inside a generator."),
    YieldInParameter: a("Yield expression is not allowed in formal parameters."),
    ZeroDigitNumericSeparator: a("Numeric separator can not be used after leading 0.")
  }), v = (a) => ({
    StrictDelete: a("Deleting local variable in strict mode."),
    StrictEvalArguments: a(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`),
    StrictEvalArgumentsBinding: a(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`),
    StrictFunction: a("In strict mode code, functions can only be declared at top level or inside a block."),
    StrictNumericEscape: a("The only valid numeric escape in strict mode is '\\0'."),
    StrictOctalLiteral: a("Legacy octal literals are not allowed in strict mode."),
    StrictWith: a("'with' in strict mode.")
  });
  const T = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var C = (a) => ({
    PipeBodyIsTighter: a("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."),
    PipeTopicRequiresHackPipes: a('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'),
    PipeTopicUnbound: a("Topic reference is unbound; it must be inside a pipe body."),
    PipeTopicUnconfiguredToken: a(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`),
    PipeTopicUnused: a("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."),
    PipeUnparenthesizedBody: a(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${A({
      type: e
    })}; please wrap it in parentheses.`),
    PipelineBodyNoArrow: a('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'),
    PipelineBodySequenceExpression: a("Pipeline body may not be a comma-separated sequence expression."),
    PipelineHeadSequenceExpression: a("Pipeline head should not be a comma-separated sequence expression."),
    PipelineTopicUnused: a("Pipeline is in topic style but does not use topic reference."),
    PrimaryTopicNotAllowed: a("Topic reference was used in a lexical context without topic binding."),
    PrimaryTopicRequiresSmartPipeline: a('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.')
  });
  const I = ["toMessage"];
  function N(a) {
    let {
      toMessage: e
    } = a, t = s(a, I);
    return function r({
      loc: i,
      details: o
    }) {
      return P(SyntaxError, Object.assign({}, t, {
        loc: i
      }), {
        clone(d = {}) {
          const u = d.loc || {};
          return r({
            loc: new n("line" in u ? u.line : this.loc.line, "column" in u ? u.column : this.loc.column, "index" in u ? u.index : this.loc.index),
            details: Object.assign({}, this.details, d.details)
          });
        },
        details: {
          value: o,
          enumerable: false
        },
        message: {
          get() {
            return `${e(this.details)} (${this.loc.line}:${this.loc.column})`;
          },
          set(d) {
            Object.defineProperty(this, "message", {
              value: d
            });
          }
        },
        pos: {
          reflect: "loc.index",
          enumerable: true
        },
        missingPlugin: "missingPlugin" in o && {
          reflect: "details.missingPlugin",
          enumerable: true
        }
      });
    };
  }
  function D(a, e) {
    return Object.assign({
      toMessage: typeof a == "string" ? () => a : a
    }, e);
  }
  function _(a, e) {
    if (Array.isArray(a))
      return (i) => _(i, a[0]);
    const t = a(D), r = {};
    for (const i of Object.keys(t))
      r[i] = N(Object.assign({
        code: p.SyntaxError,
        reasonCode: i
      }, e ? {
        syntaxPlugin: e
      } : {}, t[i]));
    return r;
  }
  const m = Object.assign({}, _(x), _(S), _(v), _`pipelineOperator`(C)), {
    defineProperty: L
  } = Object, R = (a, e) => L(a, e, {
    enumerable: false,
    value: a[e]
  });
  function O(a) {
    return a.loc.start && R(a.loc.start, "index"), a.loc.end && R(a.loc.end, "index"), a;
  }
  var B = (a) => class extends a {
    parse() {
      const e = O(super.parse());
      return this.options.tokens && (e.tokens = e.tokens.map(O)), e;
    }
    parseRegExpLiteral({
      pattern: e,
      flags: t
    }) {
      let r = null;
      try {
        r = new RegExp(e, t);
      } catch {
      }
      const i = this.estreeParseLiteral(r);
      return i.regex = {
        pattern: e,
        flags: t
      }, i;
    }
    parseBigIntLiteral(e) {
      let t;
      try {
        t = BigInt(e);
      } catch {
        t = null;
      }
      const r = this.estreeParseLiteral(t);
      return r.bigint = String(r.value || e), r;
    }
    parseDecimalLiteral(e) {
      const r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || e), r;
    }
    estreeParseLiteral(e) {
      return this.parseLiteral(e, "Literal");
    }
    parseStringLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNumericLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    directiveToStmt(e) {
      const t = e.value, r = this.startNodeAt(e.start, e.loc.start), i = this.startNodeAt(t.start, t.loc.start);
      return i.value = t.extra.expressionValue, i.raw = t.extra.raw, r.expression = this.finishNodeAt(i, "Literal", t.loc.end), r.directive = t.extra.raw.slice(1, -1), this.finishNodeAt(r, "ExpressionStatement", e.loc.end);
    }
    initFunction(e, t) {
      super.initFunction(e, t), e.expression = false;
    }
    checkDeclaration(e) {
      e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
    }
    getObjectOrClassMethodParams(e) {
      return e.value.params;
    }
    isValidDirective(e) {
      var t;
      return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((t = e.expression.extra) != null && t.parenthesized);
    }
    parseBlockBody(e, ...t) {
      super.parseBlockBody(e, ...t);
      const r = e.directives.map((i) => this.directiveToStmt(i));
      e.body = r.concat(e.body), delete e.directives;
    }
    pushClassMethod(e, t, r, i, o, d) {
      this.parseMethod(t, r, i, o, d, "ClassMethod", true), t.typeParameters && (t.value.typeParameters = t.typeParameters, delete t.typeParameters), e.body.push(t);
    }
    parsePrivateName() {
      const e = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
    }
    convertPrivateNameToPrivateIdentifier(e) {
      const t = super.getPrivateNameSV(e);
      return e = e, delete e.id, e.name = t, e.type = "PrivateIdentifier", e;
    }
    isPrivateName(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
    }
    getPrivateNameSV(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
    }
    parseLiteral(e, t) {
      const r = super.parseLiteral(e, t);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(e, t, r = false) {
      super.parseFunctionBody(e, t, r), e.expression = e.body.type !== "BlockStatement";
    }
    parseMethod(e, t, r, i, o, d, u = false) {
      let E = this.startNode();
      return E.kind = e.kind, E = super.parseMethod(E, t, r, i, o, d, u), E.type = "FunctionExpression", delete E.kind, e.value = E, d === "ClassPrivateMethod" && (e.computed = false), d = "MethodDefinition", this.finishNode(e, d);
    }
    parseClassProperty(...e) {
      const t = super.parseClassProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition"), t;
    }
    parseClassPrivateProperty(...e) {
      const t = super.parseClassPrivateProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition", t.computed = false), t;
    }
    parseObjectMethod(e, t, r, i, o) {
      const d = super.parseObjectMethod(e, t, r, i, o);
      return d && (d.type = "Property", d.kind === "method" && (d.kind = "init"), d.shorthand = false), d;
    }
    parseObjectProperty(e, t, r, i, o) {
      const d = super.parseObjectProperty(e, t, r, i, o);
      return d && (d.kind = "init", d.type = "Property"), d;
    }
    isValidLVal(e, ...t) {
      return e === "Property" ? "value" : super.isValidLVal(e, ...t);
    }
    isAssignable(e, t) {
      return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
    }
    toAssignable(e, t = false) {
      if (e != null && this.isObjectProperty(e)) {
        const {
          key: r,
          value: i
        } = e;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(i, t);
      } else
        super.toAssignable(e, t);
    }
    toAssignableObjectExpressionProp(e) {
      e.kind === "get" || e.kind === "set" ? this.raise(m.PatternHasAccessor, {
        at: e.key
      }) : e.method ? this.raise(m.PatternHasMethod, {
        at: e.key
      }) : super.toAssignableObjectExpressionProp(...arguments);
    }
    finishCallExpression(e, t) {
      if (super.finishCallExpression(e, t), e.callee.type === "Import") {
        if (e.type = "ImportExpression", e.source = e.arguments[0], this.hasPlugin("importAssertions")) {
          var r;
          e.attributes = (r = e.arguments[1]) != null ? r : null;
        }
        delete e.arguments, delete e.callee;
      }
      return e;
    }
    toReferencedArguments(e) {
      e.type !== "ImportExpression" && super.toReferencedArguments(e);
    }
    parseExport(e) {
      switch (super.parseExport(e), e.type) {
        case "ExportAllDeclaration":
          e.exported = null;
          break;
        case "ExportNamedDeclaration":
          e.specifiers.length === 1 && e.specifiers[0].type === "ExportNamespaceSpecifier" && (e.type = "ExportAllDeclaration", e.exported = e.specifiers[0].exported, delete e.specifiers);
          break;
      }
      return e;
    }
    parseSubscript(e, t, r, i, o) {
      const d = super.parseSubscript(e, t, r, i, o);
      if (o.optionalChainMember) {
        if ((d.type === "OptionalMemberExpression" || d.type === "OptionalCallExpression") && (d.type = d.type.substring(8)), o.stop) {
          const u = this.startNodeAtNode(d);
          return u.expression = d, this.finishNode(u, "ChainExpression");
        }
      } else
        (d.type === "MemberExpression" || d.type === "CallExpression") && (d.optional = false);
      return d;
    }
    hasPropertyAsPrivateName(e) {
      return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
    }
    isOptionalChain(e) {
      return e.type === "ChainExpression";
    }
    isObjectProperty(e) {
      return e.type === "Property" && e.kind === "init" && !e.method;
    }
    isObjectMethod(e) {
      return e.method || e.kind === "get" || e.kind === "set";
    }
    finishNodeAt(e, t, r) {
      return O(super.finishNodeAt(e, t, r));
    }
    resetStartLocation(e, t, r) {
      super.resetStartLocation(e, t, r), O(e);
    }
    resetEndLocation(e, t = this.state.lastTokEndLoc) {
      super.resetEndLocation(e, t), O(e);
    }
  };
  class M {
    constructor(e, t) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!t;
    }
  }
  const j = {
    brace: new M("{"),
    j_oTag: new M("<tag"),
    j_cTag: new M("</tag"),
    j_expr: new M("<tag>...</tag>", true)
  };
  j.template = new M("`", true);
  const $ = true, k = true, ne = true, Q = true, q = true, ee = true;
  class K {
    constructor(e, t = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.rightAssociative = !!t.rightAssociative, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop != null ? t.binop : null, this.updateContext = null;
    }
  }
  const G = /* @__PURE__ */ new Map();
  function V(a, e = {}) {
    e.keyword = a;
    const t = H(a, e);
    return G.set(a, t), t;
  }
  function F(a, e) {
    return H(a, {
      beforeExpr: $,
      binop: e
    });
  }
  let le = -1;
  const oe = [], fe = [], he = [], de = [], Pe = [], we = [];
  function H(a, e = {}) {
    var t, r, i, o;
    return ++le, fe.push(a), he.push((t = e.binop) != null ? t : -1), de.push((r = e.beforeExpr) != null ? r : false), Pe.push((i = e.startsExpr) != null ? i : false), we.push((o = e.prefix) != null ? o : false), oe.push(new K(a, e)), le;
  }
  function te(a, e = {}) {
    var t, r, i, o;
    return ++le, G.set(a, le), fe.push(a), he.push((t = e.binop) != null ? t : -1), de.push((r = e.beforeExpr) != null ? r : false), Pe.push((i = e.startsExpr) != null ? i : false), we.push((o = e.prefix) != null ? o : false), oe.push(new K("name", e)), le;
  }
  const Ie = {
    bracketL: H("[", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketHashL: H("#[", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketBarL: H("[|", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketR: H("]"),
    bracketBarR: H("|]"),
    braceL: H("{", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceBarL: H("{|", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceHashL: H("#{", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceR: H("}"),
    braceBarR: H("|}"),
    parenL: H("(", {
      beforeExpr: $,
      startsExpr: k
    }),
    parenR: H(")"),
    comma: H(",", {
      beforeExpr: $
    }),
    semi: H(";", {
      beforeExpr: $
    }),
    colon: H(":", {
      beforeExpr: $
    }),
    doubleColon: H("::", {
      beforeExpr: $
    }),
    dot: H("."),
    question: H("?", {
      beforeExpr: $
    }),
    questionDot: H("?."),
    arrow: H("=>", {
      beforeExpr: $
    }),
    template: H("template"),
    ellipsis: H("...", {
      beforeExpr: $
    }),
    backQuote: H("`", {
      startsExpr: k
    }),
    dollarBraceL: H("${", {
      beforeExpr: $,
      startsExpr: k
    }),
    templateTail: H("...`", {
      startsExpr: k
    }),
    templateNonTail: H("...${", {
      beforeExpr: $,
      startsExpr: k
    }),
    at: H("@"),
    hash: H("#", {
      startsExpr: k
    }),
    interpreterDirective: H("#!..."),
    eq: H("=", {
      beforeExpr: $,
      isAssign: Q
    }),
    assign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    slashAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    xorAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    moduloAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    incDec: H("++/--", {
      prefix: q,
      postfix: ee,
      startsExpr: k
    }),
    bang: H("!", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    tilde: H("~", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    doubleCaret: H("^^", {
      startsExpr: k
    }),
    doubleAt: H("@@", {
      startsExpr: k
    }),
    pipeline: F("|>", 0),
    nullishCoalescing: F("??", 1),
    logicalOR: F("||", 1),
    logicalAND: F("&&", 2),
    bitwiseOR: F("|", 3),
    bitwiseXOR: F("^", 4),
    bitwiseAND: F("&", 5),
    equality: F("==/!=/===/!==", 6),
    lt: F("</>/<=/>=", 7),
    gt: F("</>/<=/>=", 7),
    relational: F("</>/<=/>=", 7),
    bitShift: F("<</>>/>>>", 8),
    bitShiftL: F("<</>>/>>>", 8),
    bitShiftR: F("<</>>/>>>", 8),
    plusMin: H("+/-", {
      beforeExpr: $,
      binop: 9,
      prefix: q,
      startsExpr: k
    }),
    modulo: H("%", {
      binop: 10,
      startsExpr: k
    }),
    star: H("*", {
      binop: 10
    }),
    slash: F("/", 10),
    exponent: H("**", {
      beforeExpr: $,
      binop: 11,
      rightAssociative: true
    }),
    _in: V("in", {
      beforeExpr: $,
      binop: 7
    }),
    _instanceof: V("instanceof", {
      beforeExpr: $,
      binop: 7
    }),
    _break: V("break"),
    _case: V("case", {
      beforeExpr: $
    }),
    _catch: V("catch"),
    _continue: V("continue"),
    _debugger: V("debugger"),
    _default: V("default", {
      beforeExpr: $
    }),
    _else: V("else", {
      beforeExpr: $
    }),
    _finally: V("finally"),
    _function: V("function", {
      startsExpr: k
    }),
    _if: V("if"),
    _return: V("return", {
      beforeExpr: $
    }),
    _switch: V("switch"),
    _throw: V("throw", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _try: V("try"),
    _var: V("var"),
    _const: V("const"),
    _with: V("with"),
    _new: V("new", {
      beforeExpr: $,
      startsExpr: k
    }),
    _this: V("this", {
      startsExpr: k
    }),
    _super: V("super", {
      startsExpr: k
    }),
    _class: V("class", {
      startsExpr: k
    }),
    _extends: V("extends", {
      beforeExpr: $
    }),
    _export: V("export"),
    _import: V("import", {
      startsExpr: k
    }),
    _null: V("null", {
      startsExpr: k
    }),
    _true: V("true", {
      startsExpr: k
    }),
    _false: V("false", {
      startsExpr: k
    }),
    _typeof: V("typeof", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _void: V("void", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _delete: V("delete", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _do: V("do", {
      isLoop: ne,
      beforeExpr: $
    }),
    _for: V("for", {
      isLoop: ne
    }),
    _while: V("while", {
      isLoop: ne
    }),
    _as: te("as", {
      startsExpr: k
    }),
    _assert: te("assert", {
      startsExpr: k
    }),
    _async: te("async", {
      startsExpr: k
    }),
    _await: te("await", {
      startsExpr: k
    }),
    _from: te("from", {
      startsExpr: k
    }),
    _get: te("get", {
      startsExpr: k
    }),
    _let: te("let", {
      startsExpr: k
    }),
    _meta: te("meta", {
      startsExpr: k
    }),
    _of: te("of", {
      startsExpr: k
    }),
    _sent: te("sent", {
      startsExpr: k
    }),
    _set: te("set", {
      startsExpr: k
    }),
    _static: te("static", {
      startsExpr: k
    }),
    _yield: te("yield", {
      startsExpr: k
    }),
    _asserts: te("asserts", {
      startsExpr: k
    }),
    _checks: te("checks", {
      startsExpr: k
    }),
    _exports: te("exports", {
      startsExpr: k
    }),
    _global: te("global", {
      startsExpr: k
    }),
    _implements: te("implements", {
      startsExpr: k
    }),
    _intrinsic: te("intrinsic", {
      startsExpr: k
    }),
    _infer: te("infer", {
      startsExpr: k
    }),
    _is: te("is", {
      startsExpr: k
    }),
    _mixins: te("mixins", {
      startsExpr: k
    }),
    _proto: te("proto", {
      startsExpr: k
    }),
    _require: te("require", {
      startsExpr: k
    }),
    _keyof: te("keyof", {
      startsExpr: k
    }),
    _readonly: te("readonly", {
      startsExpr: k
    }),
    _unique: te("unique", {
      startsExpr: k
    }),
    _abstract: te("abstract", {
      startsExpr: k
    }),
    _declare: te("declare", {
      startsExpr: k
    }),
    _enum: te("enum", {
      startsExpr: k
    }),
    _module: te("module", {
      startsExpr: k
    }),
    _namespace: te("namespace", {
      startsExpr: k
    }),
    _interface: te("interface", {
      startsExpr: k
    }),
    _type: te("type", {
      startsExpr: k
    }),
    _opaque: te("opaque", {
      startsExpr: k
    }),
    name: H("name", {
      startsExpr: k
    }),
    string: H("string", {
      startsExpr: k
    }),
    num: H("num", {
      startsExpr: k
    }),
    bigint: H("bigint", {
      startsExpr: k
    }),
    decimal: H("decimal", {
      startsExpr: k
    }),
    regexp: H("regexp", {
      startsExpr: k
    }),
    privateName: H("#name", {
      startsExpr: k
    }),
    eof: H("eof"),
    jsxName: H("jsxName"),
    jsxText: H("jsxText", {
      beforeExpr: true
    }),
    jsxTagStart: H("jsxTagStart", {
      startsExpr: true
    }),
    jsxTagEnd: H("jsxTagEnd"),
    placeholder: H("%%", {
      startsExpr: true
    })
  };
  function Te(a) {
    return a >= 93 && a <= 128;
  }
  function pe(a) {
    return a <= 92;
  }
  function z(a) {
    return a >= 58 && a <= 128;
  }
  function W(a) {
    return a >= 58 && a <= 132;
  }
  function ae(a) {
    return de[a];
  }
  function ce(a) {
    return Pe[a];
  }
  function xe(a) {
    return a >= 29 && a <= 33;
  }
  function Se(a) {
    return a >= 125 && a <= 127;
  }
  function Le(a) {
    return a >= 90 && a <= 92;
  }
  function Ee(a) {
    return a >= 58 && a <= 92;
  }
  function J(a) {
    return a >= 39 && a <= 59;
  }
  function me(a) {
    return a === 34;
  }
  function ke(a) {
    return we[a];
  }
  function _e(a) {
    return a >= 117 && a <= 119;
  }
  function Re(a) {
    return a >= 120 && a <= 126;
  }
  function $e(a) {
    return fe[a];
  }
  function Ge(a) {
    return he[a];
  }
  function lt(a) {
    return a === 57;
  }
  function Ze(a) {
    return a >= 24 && a <= 25;
  }
  function Xe(a) {
    return oe[a];
  }
  oe[8].updateContext = (a) => {
    a.pop();
  }, oe[5].updateContext = oe[7].updateContext = oe[23].updateContext = (a) => {
    a.push(j.brace);
  }, oe[22].updateContext = (a) => {
    a[a.length - 1] === j.template ? a.pop() : a.push(j.template);
  }, oe[138].updateContext = (a) => {
    a.push(j.j_expr, j.j_oTag);
  };
  let et = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", st = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const re = new RegExp("[" + et + "]"), be = new RegExp("[" + et + st + "]");
  et = st = null;
  const ue = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Me = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Y(a, e) {
    let t = 65536;
    for (let r = 0, i = e.length; r < i; r += 2) {
      if (t += e[r], t > a)
        return false;
      if (t += e[r + 1], t >= a)
        return true;
    }
    return false;
  }
  function Ne(a) {
    return a < 65 ? a === 36 : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && re.test(String.fromCharCode(a)) : Y(a, ue);
  }
  function Be(a) {
    return a < 48 ? a === 36 : a < 58 ? true : a < 65 ? false : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && be.test(String.fromCharCode(a)) : Y(a, ue) || Y(a, Me);
  }
  const X = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, je = new Set(X.keyword), rt = new Set(X.strict), vt = new Set(X.strictBind);
  function gt(a, e) {
    return e && a === "await" || a === "enum";
  }
  function ut(a, e) {
    return gt(a, e) || rt.has(a);
  }
  function qe(a) {
    return vt.has(a);
  }
  function De(a, e) {
    return ut(a, e) || qe(a);
  }
  function Tt(a) {
    return je.has(a);
  }
  function sr(a, e, t) {
    return a === 64 && e === 64 && Ne(t);
  }
  const ar = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Nr(a) {
    return ar.has(a);
  }
  const At = 0, Dt = 1, Ye = 2, bt = 4, ct = 8, $t = 16, Mr = 32, xt = 64, or = 128, qt = 256, Vt = Dt | Ye | qt, it = 1, wt = 2, Br = 4, pt = 8, Kt = 16, _r = 64, Wt = 128, lr = 256, ur = 512, cr = 1024, pr = 2048, Fr = it | wt | pt | Wt, nt = it | 0 | pt | 0, Ht = it | 0 | Br | 0, jr = it | 0 | Kt | 0, Es = 0 | wt | 0 | Wt, vs = 0 | wt | 0 | 0, Rr = it | wt | pt | lr, Ur = 0 | cr, Pt = 0 | _r, As = it | 0 | 0 | _r, Cs = Rr | ur, ws = 0 | cr, Is = pr, zt = 4, fr = 2, hr = 1, dr = fr | hr, Ns = fr | zt, ks = hr | zt, Os = fr, Ds = hr, mr = 0;
  class Ls {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        const [t, r] = e;
        if (!this.hasPlugin(t))
          return false;
        const i = this.plugins.get(t);
        for (const o of Object.keys(r))
          if ((i == null ? void 0 : i[o]) !== r[o])
            return false;
        return true;
      }
    }
    getPluginOption(e, t) {
      var r;
      return (r = this.plugins.get(e)) == null ? void 0 : r[t];
    }
  }
  function $r(a, e) {
    a.trailingComments === void 0 ? a.trailingComments = e : a.trailingComments.unshift(...e);
  }
  function Ms(a, e) {
    a.leadingComments === void 0 ? a.leadingComments = e : a.leadingComments.unshift(...e);
  }
  function Bt(a, e) {
    a.innerComments === void 0 ? a.innerComments = e : a.innerComments.unshift(...e);
  }
  function _t(a, e, t) {
    let r = null, i = e.length;
    for (; r === null && i > 0; )
      r = e[--i];
    r === null || r.start > t.start ? Bt(a, t.comments) : $r(r, t.comments);
  }
  class Bs extends Ls {
    addComment(e) {
      this.filename && (e.loc.filename = this.filename), this.state.comments.push(e);
    }
    processComment(e) {
      const {
        commentStack: t
      } = this.state, r = t.length;
      if (r === 0)
        return;
      let i = r - 1;
      const o = t[i];
      o.start === e.end && (o.leadingNode = e, i--);
      const {
        start: d
      } = e;
      for (; i >= 0; i--) {
        const u = t[i], E = u.end;
        if (E > d)
          u.containingNode = e, this.finalizeComment(u), t.splice(i, 1);
        else {
          E === d && (u.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      const {
        comments: t
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && $r(e.leadingNode, t), e.trailingNode !== null && Ms(e.trailingNode, t);
      else {
        const {
          containingNode: r,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (r.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              _t(r, r.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              _t(r, r.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              _t(r, r.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              _t(r, r.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              _t(r, r.specifiers, e);
              break;
            default:
              Bt(r, t);
          }
        else
          Bt(r, t);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack: e
      } = this.state;
      for (let t = e.length - 1; t >= 0; t--)
        this.finalizeComment(e[t]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      const {
        commentStack: t
      } = this.state, {
        length: r
      } = t;
      if (r === 0)
        return;
      const i = t[r - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    takeSurroundingComments(e, t, r) {
      const {
        commentStack: i
      } = this.state, o = i.length;
      if (o === 0)
        return;
      let d = o - 1;
      for (; d >= 0; d--) {
        const u = i[d], E = u.end;
        if (u.start === r)
          u.leadingNode = e;
        else if (E === t)
          u.trailingNode = e;
        else if (E < t)
          break;
      }
    }
  }
  const yr = /\r\n?|[\n\u2028\u2029]/, Gt = new RegExp(yr.source, "g");
  function St(a) {
    switch (a) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const br = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, _s = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, qr = new RegExp("(?=(" + _s.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Fs(a) {
    switch (a) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class gr {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 135, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [j.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    init({
      strictMode: e,
      sourceType: t,
      startLine: r,
      startColumn: i
    }) {
      this.strict = e === false ? false : e === true ? true : t === "module", this.curLine = r, this.lineStart = -i, this.startLoc = this.endLoc = new n(r, i, 0);
    }
    curPosition() {
      return new n(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(e) {
      const t = new gr(), r = Object.keys(this);
      for (let i = 0, o = r.length; i < o; i++) {
        const d = r[i];
        let u = this[d];
        !e && Array.isArray(u) && (u = u.slice()), t[d] = u;
      }
      return t;
    }
  }
  const js = ["at"], Rs = ["at"];
  var Us = function(e) {
    return e >= 48 && e <= 57;
  };
  const $s = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Vr = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Xt = {
    bin: (a) => a === 48 || a === 49,
    oct: (a) => a >= 48 && a <= 55,
    dec: (a) => a >= 48 && a <= 57,
    hex: (a) => a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102
  };
  class ft {
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new h(e.startLoc, e.endLoc);
    }
  }
  class qs extends Bs {
    constructor(e, t) {
      super(), this.isLookahead = void 0, this.tokens = [], this.state = new gr(), this.state.init(e), this.input = t, this.length = t.length, this.isLookahead = false;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ft(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), true) : false;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      const e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t = this.state;
      return this.state = e, t;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return br.lastIndex = e, br.test(this.input) ? br.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(e) {
      let t = this.input.charCodeAt(e);
      if ((t & 64512) === 55296 && ++e < this.input.length) {
        const r = this.input.charCodeAt(e);
        (r & 64512) === 56320 && (t = 65536 + ((t & 1023) << 10) + (r & 1023));
      }
      return t;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([t, r]) => this.raise(t, {
        at: r
      })), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(135);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
      let e;
      this.isLookahead || (e = this.state.curPosition());
      const t = this.state.pos, r = this.input.indexOf("*/", t + 2);
      if (r === -1)
        throw this.raise(m.UnterminatedComment, {
          at: this.state.curPosition()
        });
      for (this.state.pos = r + 2, Gt.lastIndex = t + 2; Gt.test(this.input) && Gt.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = Gt.lastIndex;
      if (this.isLookahead)
        return;
      const i = {
        type: "CommentBlock",
        value: this.input.slice(t + 2, r),
        start: t,
        end: r + 2,
        loc: new h(e, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(i), i;
    }
    skipLineComment(e) {
      const t = this.state.pos;
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !St(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      const o = this.state.pos, d = this.input.slice(t + e, o), u = {
        type: "CommentLine",
        value: d,
        start: t,
        end: o,
        loc: new h(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(u), u;
    }
    skipSpace() {
      const e = this.state.pos, t = [];
      e:
        for (; this.state.pos < this.length; ) {
          const r = this.input.charCodeAt(this.state.pos);
          switch (r) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const i = this.skipBlockComment();
                  i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
                  break;
                }
                case 47: {
                  const i = this.skipLineComment(2);
                  i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Fs(r))
                ++this.state.pos;
              else if (r === 45 && !this.inModule) {
                const i = this.state.pos;
                if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                  const o = this.skipLineComment(3);
                  o !== void 0 && (this.addComment(o), this.options.attachComment && t.push(o));
                } else
                  break e;
              } else if (r === 60 && !this.inModule) {
                const i = this.state.pos;
                if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                  const o = this.skipLineComment(4);
                  o !== void 0 && (this.addComment(o), this.options.attachComment && t.push(o));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (t.length > 0) {
        const r = this.state.pos, i = {
          start: e,
          end: r,
          comments: t,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, t) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const r = this.state.type;
      this.state.type = e, this.state.value = t, this.isLookahead || this.updateContext(r);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const e = this.state.pos + 1, t = this.codePointAtPos(e);
      if (t >= 48 && t <= 57)
        throw this.raise(m.UnexpectedDigitAfterHash, {
          at: this.state.curPosition()
        });
      if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
          throw this.raise(t === 123 ? m.RecordExpressionHashIncorrectStartSyntaxType : m.TupleExpressionHashIncorrectStartSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, t === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        Ne(t) ? (++this.state.pos, this.finishToken(134, this.readWord1(t))) : t === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(true);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33)
        return false;
      const t = this.state.pos;
      for (this.state.pos += 1; !St(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      const r = this.input.slice(t + 2, this.state.pos);
      return this.finishToken(28, r), true;
    }
    readToken_mult_modulo(e) {
      let t = e === 42 ? 55 : 54, r = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (r++, i = this.input.charCodeAt(this.state.pos + 2), t = 57), i === 61 && !this.state.inType && (r++, t = e === 37 ? 33 : 30), this.finishOp(t, r);
    }
    readToken_pipe_amp(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (t === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && t === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(m.RecordExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && t === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(m.TupleExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (t === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e === 61 && !this.state.inType)
        this.finishOp(32, 2);
      else if (e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
          throw this.unexpected();
      } else
        this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === e) {
        this.finishOp(34, 2);
        return;
      }
      t === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: e
      } = this.state, t = this.input.charCodeAt(e + 1);
      if (t === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (t === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: e
      } = this.state, t = this.input.charCodeAt(e + 1);
      if (t === 62) {
        const r = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + r) === 61) {
          this.finishOp(30, r + 1);
          return;
        }
        this.finishOp(52, r);
        return;
      }
      if (t === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && t === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const e = this.input.charCodeAt(this.state.pos + 1), t = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? t === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(t >= 48 && t <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(m.TupleExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(m.RecordExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const t = this.input.charCodeAt(this.state.pos + 1);
          if (t === 120 || t === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (t === 111 || t === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (t === 98 || t === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ne(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(m.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, t) {
      const r = this.input.slice(this.state.pos, this.state.pos + t);
      this.state.pos += t, this.finishToken(e, r);
    }
    readRegexp() {
      const e = this.state.startLoc, t = this.state.start + 1;
      let r, i, {
        pos: o
      } = this.state;
      for (; ; ++o) {
        if (o >= this.length)
          throw this.raise(m.UnterminatedRegExp, {
            at: f2(e, 1)
          });
        const w = this.input.charCodeAt(o);
        if (St(w))
          throw this.raise(m.UnterminatedRegExp, {
            at: f2(e, 1)
          });
        if (r)
          r = false;
        else {
          if (w === 91)
            i = true;
          else if (w === 93 && i)
            i = false;
          else if (w === 47 && !i)
            break;
          r = w === 92;
        }
      }
      const d = this.input.slice(t, o);
      ++o;
      let u = "";
      const E = () => f2(e, o + 2 - t);
      for (; o < this.length; ) {
        const w = this.codePointAtPos(o), U = String.fromCharCode(w);
        if ($s.has(w))
          w === 118 ? (this.expectPlugin("regexpUnicodeSets", E()), u.includes("u") && this.raise(m.IncompatibleRegExpUVFlags, {
            at: E()
          })) : w === 117 && u.includes("v") && this.raise(m.IncompatibleRegExpUVFlags, {
            at: E()
          }), u.includes(U) && this.raise(m.DuplicateRegExpFlags, {
            at: E()
          });
        else if (Be(w) || w === 92)
          this.raise(m.MalformedRegExpFlags, {
            at: E()
          });
        else
          break;
        ++o, u += U;
      }
      this.state.pos = o, this.finishToken(133, {
        pattern: d,
        flags: u
      });
    }
    readInt(e, t, r, i = true) {
      const o = this.state.pos, d = e === 16 ? Vr.hex : Vr.decBinOct, u = e === 16 ? Xt.hex : e === 10 ? Xt.dec : e === 8 ? Xt.oct : Xt.bin;
      let E = false, w = 0;
      for (let U = 0, ge = t == null ? 1 / 0 : t; U < ge; ++U) {
        const ye = this.input.charCodeAt(this.state.pos);
        let Ae;
        if (ye === 95 && i !== "bail") {
          const Oe = this.input.charCodeAt(this.state.pos - 1), Ve = this.input.charCodeAt(this.state.pos + 1);
          i ? (Number.isNaN(Ve) || !u(Ve) || d.has(Oe) || d.has(Ve)) && this.raise(m.UnexpectedNumericSeparator, {
            at: this.state.curPosition()
          }) : this.raise(m.NumericSeparatorInEscapeSequence, {
            at: this.state.curPosition()
          }), ++this.state.pos;
          continue;
        }
        if (ye >= 97 ? Ae = ye - 97 + 10 : ye >= 65 ? Ae = ye - 65 + 10 : Us(ye) ? Ae = ye - 48 : Ae = 1 / 0, Ae >= e)
          if (this.options.errorRecovery && Ae <= 9)
            Ae = 0, this.raise(m.InvalidDigit, {
              at: this.state.curPosition(),
              radix: e
            });
          else if (r)
            Ae = 0, E = true;
          else
            break;
        ++this.state.pos, w = w * e + Ae;
      }
      return this.state.pos === o || t != null && this.state.pos - o !== t || E ? null : w;
    }
    readRadixNumber(e) {
      const t = this.state.curPosition();
      let r = false;
      this.state.pos += 2;
      const i = this.readInt(e);
      i == null && this.raise(m.InvalidDigit, {
        at: f2(t, 2),
        radix: e
      });
      const o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = true;
      else if (o === 109)
        throw this.raise(m.InvalidDecimal, {
          at: t
        });
      if (Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(m.NumberIdentifier, {
          at: this.state.curPosition()
        });
      if (r) {
        const d = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(131, d);
        return;
      }
      this.finishToken(130, i);
    }
    readNumber(e) {
      const t = this.state.pos, r = this.state.curPosition();
      let i = false, o = false, d = false, u = false, E = false;
      !e && this.readInt(10) === null && this.raise(m.InvalidNumber, {
        at: this.state.curPosition()
      });
      const w = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
      if (w) {
        const Ae = this.input.slice(t, this.state.pos);
        if (this.recordStrictModeErrors(m.StrictOctalLiteral, {
          at: r
        }), !this.state.strict) {
          const Oe = Ae.indexOf("_");
          Oe > 0 && this.raise(m.ZeroDigitNumericSeparator, {
            at: f2(r, Oe)
          });
        }
        E = w && !/[89]/.test(Ae);
      }
      let U = this.input.charCodeAt(this.state.pos);
      if (U === 46 && !E && (++this.state.pos, this.readInt(10), i = true, U = this.input.charCodeAt(this.state.pos)), (U === 69 || U === 101) && !E && (U = this.input.charCodeAt(++this.state.pos), (U === 43 || U === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(m.InvalidOrMissingExponent, {
        at: r
      }), i = true, u = true, U = this.input.charCodeAt(this.state.pos)), U === 110 && ((i || w) && this.raise(m.InvalidBigIntLiteral, {
        at: r
      }), ++this.state.pos, o = true), U === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (u || w) && this.raise(m.InvalidDecimal, {
        at: r
      }), ++this.state.pos, d = true), Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(m.NumberIdentifier, {
          at: this.state.curPosition()
        });
      const ge = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
      if (o) {
        this.finishToken(131, ge);
        return;
      }
      if (d) {
        this.finishToken(132, ge);
        return;
      }
      const ye = E ? parseInt(ge, 8) : parseFloat(ge);
      this.finishToken(130, ye);
    }
    readCodePoint(e) {
      const t = this.input.charCodeAt(this.state.pos);
      let r;
      if (t === 123) {
        if (++this.state.pos, r = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e), ++this.state.pos, r !== null && r > 1114111)
          if (e)
            this.raise(m.InvalidCodePoint, {
              at: this.state.curPosition()
            });
          else
            return null;
      } else
        r = this.readHexChar(4, false, e);
      return r;
    }
    readString(e) {
      let t = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedString, {
            at: this.state.startLoc
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === e)
          break;
        if (i === 92)
          t += this.input.slice(r, this.state.pos), t += this.readEscapedChar(false), r = this.state.pos;
        else if (i === 8232 || i === 8233)
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        else {
          if (St(i))
            throw this.raise(m.UnterminatedString, {
              at: this.state.startLoc
            });
          ++this.state.pos;
        }
      }
      t += this.input.slice(r, this.state.pos++), this.finishToken(129, t);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = "", t = this.state.pos, r = false;
      for (++this.state.pos; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedTemplate, {
            at: f2(this.state.startLoc, 1)
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === 96) {
          ++this.state.pos, e += this.input.slice(t, this.state.pos), this.finishToken(24, r ? null : e);
          return;
        }
        if (i === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          this.state.pos += 2, e += this.input.slice(t, this.state.pos), this.finishToken(25, r ? null : e);
          return;
        }
        if (i === 92) {
          e += this.input.slice(t, this.state.pos);
          const o = this.readEscapedChar(true);
          o === null ? r = true : e += o, t = this.state.pos;
        } else if (St(i)) {
          switch (e += this.input.slice(t, this.state.pos), ++this.state.pos, i) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
            case 10:
              e += `
`;
              break;
            default:
              e += String.fromCharCode(i);
              break;
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, t = this.state.pos;
        } else
          ++this.state.pos;
      }
    }
    recordStrictModeErrors(e, {
      at: t
    }) {
      const r = t.index;
      this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, {
        at: t
      }) : this.state.strictErrors.set(r, [e, t]);
    }
    readEscapedChar(e) {
      const t = !e, r = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, r) {
        case 110:
          return `
`;
        case 114:
          return "\r";
        case 120: {
          const i = this.readHexChar(2, false, t);
          return i === null ? null : String.fromCharCode(i);
        }
        case 117: {
          const i = this.readCodePoint(t);
          return i === null ? null : String.fromCodePoint(i);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
        case 10:
          this.state.lineStart = this.state.pos, ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (e)
            return null;
          this.recordStrictModeErrors(m.StrictNumericEscape, {
            at: f2(this.state.curPosition(), -1)
          });
        default:
          if (r >= 48 && r <= 55) {
            const i = f2(this.state.curPosition(), -1);
            let d = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0], u = parseInt(d, 8);
            u > 255 && (d = d.slice(0, -1), u = parseInt(d, 8)), this.state.pos += d.length - 1;
            const E = this.input.charCodeAt(this.state.pos);
            if (d !== "0" || E === 56 || E === 57) {
              if (e)
                return null;
              this.recordStrictModeErrors(m.StrictNumericEscape, {
                at: i
              });
            }
            return String.fromCharCode(u);
          }
          return String.fromCharCode(r);
      }
    }
    readHexChar(e, t, r) {
      const i = this.state.curPosition(), o = this.readInt(16, e, t, false);
      return o === null && (r ? this.raise(m.InvalidEscapeSequence, {
        at: i
      }) : this.state.pos = i.index - 1), o;
    }
    readWord1(e) {
      this.state.containsEsc = false;
      let t = "";
      const r = this.state.pos;
      let i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const o = this.codePointAtPos(this.state.pos);
        if (Be(o))
          this.state.pos += o <= 65535 ? 1 : 2;
        else if (o === 92) {
          this.state.containsEsc = true, t += this.input.slice(i, this.state.pos);
          const d = this.state.curPosition(), u = this.state.pos === r ? Ne : Be;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(m.MissingUnicodeEscape, {
              at: this.state.curPosition()
            }), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const E = this.readCodePoint(true);
          E !== null && (u(E) || this.raise(m.EscapedCharNotAnIdentifier, {
            at: d
          }), t += String.fromCodePoint(E)), i = this.state.pos;
        } else
          break;
      }
      return t + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      const t = this.readWord1(e), r = G.get(t);
      r !== void 0 ? this.finishToken(r, $e(r)) : this.finishToken(128, t);
    }
    checkKeywordEscapes() {
      const {
        type: e
      } = this.state;
      Ee(e) && this.state.containsEsc && this.raise(m.InvalidEscapedReservedWord, {
        at: this.state.startLoc,
        reservedWord: $e(e)
      });
    }
    raise(e, t) {
      const {
        at: r
      } = t, i = s(t, js), o = r instanceof n ? r : r.loc.start, d = e({
        loc: o,
        details: i
      });
      if (!this.options.errorRecovery)
        throw d;
      return this.isLookahead || this.state.errors.push(d), d;
    }
    raiseOverwrite(e, t) {
      const {
        at: r
      } = t, i = s(t, Rs), o = r instanceof n ? r : r.loc.start, d = o.index, u = this.state.errors;
      for (let E = u.length - 1; E >= 0; E--) {
        const w = u[E];
        if (w.loc.index === d)
          return u[E] = e({
            loc: o,
            details: i
          });
        if (w.loc.index < d)
          break;
      }
      return this.raise(e, t);
    }
    updateContext(e) {
    }
    unexpected(e, t) {
      throw this.raise(m.UnexpectedToken, {
        expected: t ? $e(t) : null,
        at: e != null ? e : this.state.startLoc
      });
    }
    expectPlugin(e, t) {
      if (this.hasPlugin(e))
        return true;
      throw this.raise(m.MissingPlugin, {
        at: t != null ? t : this.state.startLoc,
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((t) => this.hasPlugin(t)))
        throw this.raise(m.MissingOneOfPlugins, {
          at: this.state.startLoc,
          missingPlugin: e
        });
    }
  }
  class Tr {
    constructor(e) {
      this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = e;
    }
  }
  class xr {
    constructor(e, t) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e, this.inModule = t;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & Ye) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & $t) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & Mr) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & xt) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e = this.currentThisScopeFlags();
      return (e & xt) > 0 && (e & Ye) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & or)
          return true;
        if (t & (Vt | xt))
          return false;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & Ye) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Tr(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & (Ye | or) || !this.parser.inModule && e.flags & Dt);
    }
    declareName(e, t, r) {
      let i = this.currentScope();
      if (t & pt || t & Kt)
        this.checkRedeclarationInScope(i, e, t, r), t & Kt ? i.functions.add(e) : i.lexical.add(e), t & pt && this.maybeExportDefined(i, e);
      else if (t & Br)
        for (let o = this.scopeStack.length - 1; o >= 0 && (i = this.scopeStack[o], this.checkRedeclarationInScope(i, e, t, r), i.var.add(e), this.maybeExportDefined(i, e), !(i.flags & Vt)); --o)
          ;
      this.parser.inModule && i.flags & Dt && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, t) {
      this.parser.inModule && e.flags & Dt && this.undefinedExports.delete(t);
    }
    checkRedeclarationInScope(e, t, r, i) {
      this.isRedeclaredInScope(e, t, r) && this.parser.raise(m.VarRedeclaration, {
        at: i,
        identifierName: t
      });
    }
    isRedeclaredInScope(e, t, r) {
      return r & it ? r & pt ? e.lexical.has(t) || e.functions.has(t) || e.var.has(t) : r & Kt ? e.lexical.has(t) || !this.treatFunctionsAsVarInScope(e) && e.var.has(t) : e.lexical.has(t) && !(e.flags & ct && e.lexical.values().next().value === t) || !this.treatFunctionsAsVarInScope(e) && e.functions.has(t) : false;
    }
    checkLocalExport(e) {
      const {
        name: t
      } = e, r = this.scopeStack[0];
      !r.lexical.has(t) && !r.var.has(t) && !r.functions.has(t) && this.undefinedExports.set(t, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & Vt)
          return t;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & (Vt | xt) && !(t & bt))
          return t;
      }
    }
  }
  class Vs extends Tr {
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class Ks extends xr {
    createScope(e) {
      return new Vs(e);
    }
    declareName(e, t, r) {
      const i = this.currentScope();
      if (t & pr) {
        this.checkRedeclarationInScope(i, e, t, r), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(...arguments);
    }
    isRedeclaredInScope(e, t, r) {
      return super.isRedeclaredInScope(...arguments) ? true : r & pr ? !e.declareFunctions.has(t) && (e.lexical.has(t) || e.functions.has(t)) : false;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }
  class Ws {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class Hs {
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Ws());
    }
    exit() {
      const e = this.stack.pop(), t = this.current();
      for (const [r, i] of Array.from(e.undefinedPrivateNames))
        t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, i) : this.parser.raise(m.InvalidPrivateFieldResolution, {
          at: i,
          identifierName: r
        });
    }
    declarePrivateName(e, t, r) {
      const {
        privateNames: i,
        loneAccessors: o,
        undefinedPrivateNames: d
      } = this.current();
      let u = i.has(e);
      if (t & dr) {
        const E = u && o.get(e);
        if (E) {
          const w = E & zt, U = t & zt, ge = E & dr, ye = t & dr;
          u = ge === ye || w !== U, u || o.delete(e);
        } else
          u || o.set(e, t);
      }
      u && this.parser.raise(m.PrivateNameRedeclaration, {
        at: r,
        identifierName: e
      }), i.add(e), d.delete(e);
    }
    usePrivateName(e, t) {
      let r;
      for (r of this.stack)
        if (r.privateNames.has(e))
          return;
      r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(m.InvalidPrivateFieldResolution, {
        at: t,
        identifierName: e
      });
    }
  }
  const zs = 0, Kr = 1, Pr = 2, Wr = 3;
  class Jt {
    constructor(e = zs) {
      this.type = void 0, this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === Pr || this.type === Kr;
    }
    isCertainlyParameterDeclaration() {
      return this.type === Wr;
    }
  }
  class Hr extends Jt {
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, {
      at: t
    }) {
      const r = t.index;
      this.declarationErrors.set(r, [e, t]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }
  class Gs {
    constructor(e) {
      this.parser = void 0, this.stack = [new Jt()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, {
      at: t
    }) {
      const r = {
        at: t.loc.start
      }, {
        stack: i
      } = this;
      let o = i.length - 1, d = i[o];
      for (; !d.isCertainlyParameterDeclaration(); ) {
        if (d.canBeArrowParameterDeclaration())
          d.recordDeclarationError(e, r);
        else
          return;
        d = i[--o];
      }
      this.parser.raise(e, r);
    }
    recordArrowParemeterBindingError(e, {
      at: t
    }) {
      const {
        stack: r
      } = this, i = r[r.length - 1], o = {
        at: t.loc.start
      };
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, o);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, o);
      else
        return;
    }
    recordAsyncArrowParametersError({
      at: e
    }) {
      const {
        stack: t
      } = this;
      let r = t.length - 1, i = t[r];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === Pr && i.recordDeclarationError(m.AwaitBindingIdentifier, {
          at: e
        }), i = t[--r];
    }
    validateAsPattern() {
      const {
        stack: e
      } = this, t = e[e.length - 1];
      !t.canBeArrowParameterDeclaration() || t.iterateErrors(([r, i]) => {
        this.parser.raise(r, {
          at: i
        });
        let o = e.length - 2, d = e[o];
        for (; d.canBeArrowParameterDeclaration(); )
          d.clearDeclarationError(i.index), d = e[--o];
      });
    }
  }
  function Xs() {
    return new Jt(Wr);
  }
  function Js() {
    return new Hr(Kr);
  }
  function Ys() {
    return new Hr(Pr);
  }
  function zr() {
    return new Jt();
  }
  const It = 0, Gr = 1, Yt = 2, Xr = 4, Nt = 8;
  class Qs {
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & Yt) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & Gr) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & Xr) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & Nt) > 0;
    }
  }
  function Qt(a, e) {
    return (a ? Yt : 0) | (e ? Gr : 0);
  }
  class Zs extends qs {
    addExtra(e, t, r, i = true) {
      if (!e)
        return;
      const o = e.extra = e.extra || {};
      i ? o[t] = r : Object.defineProperty(o, t, {
        enumerable: i,
        value: r
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, t) {
      const r = e + t.length;
      if (this.input.slice(e, r) === t) {
        const i = this.input.charCodeAt(r);
        return !(Be(i) || (i & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(e) {
      const t = this.nextTokenStart();
      return this.isUnparsedContextual(t, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), true) : false;
    }
    expectContextual(e, t) {
      if (!this.eatContextual(e))
        throw t != null ? this.raise(t, {
          at: this.state.startLoc
        }) : this.unexpected(null, e);
    }
    canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return yr.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return qr.lastIndex = this.state.end, qr.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = true) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(m.MissingSemicolon, {
        at: this.state.lastTokEndLoc
      });
    }
    expect(e, t) {
      this.eat(e) || this.unexpected(t, e);
    }
    tryParse(e, t = this.state.clone()) {
      const r = {
        node: null
      };
      try {
        const i = e((o = null) => {
          throw r.node = o, r;
        });
        if (this.state.errors.length > t.errors.length) {
          const o = this.state;
          return this.state = t, this.state.tokensLength = o.tokensLength, {
            node: i,
            error: o.errors[t.errors.length],
            thrown: false,
            aborted: false,
            failState: o
          };
        }
        return {
          node: i,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (i) {
        const o = this.state;
        if (this.state = t, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: true,
            aborted: false,
            failState: o
          };
        if (i === r)
          return {
            node: r.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: o
          };
        throw i;
      }
    }
    checkExpressionErrors(e, t) {
      if (!e)
        return false;
      const {
        shorthandAssignLoc: r,
        doubleProtoLoc: i,
        privateKeyLoc: o,
        optionalParametersLoc: d
      } = e, u = !!r || !!i || !!d || !!o;
      if (!t)
        return u;
      r != null && this.raise(m.InvalidCoverInitializedName, {
        at: r
      }), i != null && this.raise(m.DuplicateProto, {
        at: i
      }), o != null && this.raise(m.UnexpectedPrivateField, {
        at: o
      }), d != null && this.unexpected(d);
    }
    isLiteralPropertyName() {
      return W(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isOptionalChain(e) {
      return e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression";
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      const t = this.state.labels;
      this.state.labels = [];
      const r = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const i = this.inModule;
      this.inModule = e;
      const o = this.scope, d = this.getScopeHandler();
      this.scope = new d(this, e);
      const u = this.prodParam;
      this.prodParam = new Qs();
      const E = this.classScope;
      this.classScope = new Hs(this);
      const w = this.expressionScope;
      return this.expressionScope = new Gs(this), () => {
        this.state.labels = t, this.exportedIdentifiers = r, this.inModule = i, this.scope = o, this.prodParam = u, this.classScope = E, this.expressionScope = w;
      };
    }
    enterInitialScopes() {
      let e = It;
      this.inModule && (e |= Yt), this.scope.enter(Dt), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      const {
        privateKeyLoc: t
      } = e;
      t !== null && this.expectPlugin("destructuringPrivate", t);
    }
  }
  class Zt {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class er {
    constructor(e, t, r) {
      this.type = "", this.start = t, this.end = 0, this.loc = new h(r), e != null && e.options.ranges && (this.range = [t, 0]), e != null && e.filename && (this.loc.filename = e.filename);
    }
  }
  const Sr = er.prototype;
  Sr.__clone = function() {
    const a = new er(), e = Object.keys(this);
    for (let t = 0, r = e.length; t < r; t++) {
      const i = e[t];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (a[i] = this[i]);
    }
    return a;
  };
  function ei(a) {
    return at(a);
  }
  function at(a) {
    const {
      type: e,
      start: t,
      end: r,
      loc: i,
      range: o,
      extra: d,
      name: u
    } = a, E = Object.create(Sr);
    return E.type = e, E.start = t, E.end = r, E.loc = i, E.range = o, E.extra = d, E.name = u, e === "Placeholder" && (E.expectedNode = a.expectedNode), E;
  }
  function ti(a) {
    const {
      type: e,
      start: t,
      end: r,
      loc: i,
      range: o,
      extra: d
    } = a;
    if (e === "Placeholder")
      return ei(a);
    const u = Object.create(Sr);
    return u.type = e, u.start = t, u.end = r, u.loc = i, u.range = o, a.raw !== void 0 ? u.raw = a.raw : u.extra = d, u.value = a.value, u;
  }
  class ri extends Zs {
    startNode() {
      return new er(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(e, t) {
      return new er(this, e, t);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.start, e.loc.start);
    }
    finishNode(e, t) {
      return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, t, r) {
      return e.type = t, e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index), this.options.attachComment && this.processComment(e), e;
    }
    resetStartLocation(e, t, r) {
      e.start = t, e.loc.start = r, this.options.ranges && (e.range[0] = t);
    }
    resetEndLocation(e, t = this.state.lastTokEndLoc) {
      e.end = t.index, e.loc.end = t, this.options.ranges && (e.range[1] = t.index);
    }
    resetStartLocationFromNode(e, t) {
      this.resetStartLocation(e, t.start, t.loc.start);
    }
  }
  const si = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Ce = _`flow`((a) => ({
    AmbiguousConditionalArrow: a("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."),
    AmbiguousDeclareModuleKind: a("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."),
    AssignReservedType: a(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`),
    DeclareClassElement: a("The `declare` modifier can only appear on class fields."),
    DeclareClassFieldInitializer: a("Initializers are not allowed in fields with the `declare` modifier."),
    DuplicateDeclareModuleExports: a("Duplicate `declare module.exports` statement."),
    EnumBooleanMemberNotInitialized: a(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`),
    EnumDuplicateMemberName: a(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`),
    EnumInconsistentMemberValues: a(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`),
    EnumInvalidExplicitType: a(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`),
    EnumInvalidExplicitTypeUnknownSupplied: a(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`),
    EnumInvalidMemberInitializerPrimaryType: a(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`),
    EnumInvalidMemberInitializerSymbolType: a(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`),
    EnumInvalidMemberInitializerUnknownType: a(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`),
    EnumInvalidMemberName: a(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`),
    EnumNumberMemberNotInitialized: a(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`),
    EnumStringMemberInconsistentlyInitailized: a(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`),
    GetterMayNotHaveThisParam: a("A getter cannot have a `this` parameter."),
    ImportTypeShorthandOnlyInPureImport: a("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."),
    InexactInsideExact: a("Explicit inexact syntax cannot appear inside an explicit exact object type."),
    InexactInsideNonObject: a("Explicit inexact syntax cannot appear in class or interface definitions."),
    InexactVariance: a("Explicit inexact syntax cannot have variance."),
    InvalidNonTypeImportInDeclareModule: a("Imports within a `declare module` body must always be `import type` or `import typeof`."),
    MissingTypeParamDefault: a("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),
    NestedDeclareModule: a("`declare module` cannot be used inside another `declare module`."),
    NestedFlowComment: a("Cannot have a flow comment inside another flow comment."),
    PatternIsOptional: a("A binding pattern parameter cannot be optional in an implementation signature.", {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: a("A setter cannot have a `this` parameter."),
    SpreadVariance: a("Spread properties cannot have variance."),
    ThisParamAnnotationRequired: a("A type annotation is required for the `this` parameter."),
    ThisParamBannedInConstructor: a("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."),
    ThisParamMayNotBeOptional: a("The `this` parameter cannot be optional."),
    ThisParamMustBeFirst: a("The `this` parameter must be the first function parameter."),
    ThisParamNoDefault: a("The `this` parameter may not have a default value."),
    TypeBeforeInitializer: a("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
    TypeCastInPattern: a("The type cast expression is expected to be wrapped with parenthesis."),
    UnexpectedExplicitInexactInObject: a("Explicit inexact syntax must appear at the end of an inexact object."),
    UnexpectedReservedType: a(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`),
    UnexpectedReservedUnderscore: a("`_` is only allowed as a type argument to call or new."),
    UnexpectedSpaceBetweenModuloChecks: a("Spaces between `%` and `checks` are not allowed here."),
    UnexpectedSpreadType: a("Spread operator cannot appear in class or interface definitions."),
    UnexpectedSubtractionOperand: a('Unexpected token, expected "number" or "bigint".'),
    UnexpectedTokenAfterTypeParameter: a("Expected an arrow function after this type parameter declaration."),
    UnexpectedTypeParameterBeforeAsyncArrowFunction: a("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."),
    UnsupportedDeclareExportKind: a(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`),
    UnsupportedStatementInDeclareModule: a("Only declares and type imports are allowed inside declare module."),
    UnterminatedFlowComment: a("Unterminated flow-comment.")
  }));
  function ii(a) {
    return a.type === "DeclareExportAllDeclaration" || a.type === "DeclareExportDeclaration" && (!a.declaration || a.declaration.type !== "TypeAlias" && a.declaration.type !== "InterfaceDeclaration");
  }
  function Er(a) {
    return a.importKind === "type" || a.importKind === "typeof";
  }
  function Jr(a) {
    return z(a) && a !== 97;
  }
  const ni = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function ai(a, e) {
    const t = [], r = [];
    for (let i = 0; i < a.length; i++)
      (e(a[i], i, a) ? t : r).push(a[i]);
    return [t, r];
  }
  const oi = /\*?\s*@((?:no)?flow)\b/;
  var li = (a) => class extends a {
    constructor(...e) {
      super(...e), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Ks;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e, t) {
      return e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, t);
    }
    addComment(e) {
      if (this.flowPragma === void 0) {
        const t = oi.exec(e.value);
        if (t)
          if (t[1] === "flow")
            this.flowPragma = "flow";
          else if (t[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      return super.addComment(e);
    }
    flowParseTypeInitialiser(e) {
      const t = this.state.inType;
      this.state.inType = true, this.expect(e || 14);
      const r = this.flowParseType();
      return this.state.inType = t, r;
    }
    flowParsePredicate() {
      const e = this.startNode(), t = this.state.startLoc;
      return this.next(), this.expectContextual(107), this.state.lastTokStart > t.index + 1 && this.raise(Ce.UnexpectedSpaceBetweenModuloChecks, {
        at: t
      }), this.eat(10) ? (e.value = this.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e = this.state.inType;
      this.state.inType = true, this.expect(14);
      let t = null, r = null;
      return this.match(54) ? (this.state.inType = e, r = this.flowParsePredicate()) : (t = this.flowParseType(), this.state.inType = e, this.match(54) && (r = this.flowParsePredicate())), [t, r];
    }
    flowParseDeclareClass(e) {
      return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
    }
    flowParseDeclareFunction(e) {
      this.next();
      const t = e.id = this.parseIdentifier(), r = this.startNode(), i = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      const o = this.flowParseFunctionTypeParams();
      return r.params = o.params, r.rest = o.rest, r.this = o._this, this.expect(11), [r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), t.typeAnnotation = this.finishNode(i, "TypeAnnotation"), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, Is, e.id.loc.start), this.finishNode(e, "DeclareFunction");
    }
    flowParseDeclare(e, t) {
      if (this.match(80))
        return this.flowParseDeclareClass(e);
      if (this.match(68))
        return this.flowParseDeclareFunction(e);
      if (this.match(74))
        return this.flowParseDeclareVariable(e);
      if (this.eatContextual(123))
        return this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(Ce.NestedDeclareModule, {
          at: this.state.lastTokStartLoc
        }), this.flowParseDeclareModule(e));
      if (this.isContextual(126))
        return this.flowParseDeclareTypeAlias(e);
      if (this.isContextual(127))
        return this.flowParseDeclareOpaqueType(e);
      if (this.isContextual(125))
        return this.flowParseDeclareInterface(e);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(e, t);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e) {
      return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, Ht, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
    }
    flowParseDeclareModule(e) {
      this.scope.enter(At), this.match(129) ? e.id = this.parseExprAtom() : e.id = this.parseIdentifier();
      const t = e.body = this.startNode(), r = t.body = [];
      for (this.expect(5); !this.match(8); ) {
        let d = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(126) && !this.match(87) && this.raise(Ce.InvalidNonTypeImportInDeclareModule, {
          at: this.state.lastTokStartLoc
        }), this.parseImport(d)) : (this.expectContextual(121, Ce.UnsupportedStatementInDeclareModule), d = this.flowParseDeclare(d, true)), r.push(d);
      }
      this.scope.exit(), this.expect(8), this.finishNode(t, "BlockStatement");
      let i = null, o = false;
      return r.forEach((d) => {
        ii(d) ? (i === "CommonJS" && this.raise(Ce.AmbiguousDeclareModuleKind, {
          at: d
        }), i = "ES") : d.type === "DeclareModuleExports" && (o && this.raise(Ce.DuplicateDeclareModuleExports, {
          at: d
        }), i === "ES" && this.raise(Ce.AmbiguousDeclareModuleKind, {
          at: d
        }), i = "CommonJS", o = true);
      }), e.kind = i || "CommonJS", this.finishNode(e, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e, t) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !t) {
        const r = this.state.value;
        throw this.raise(Ce.UnsupportedDeclareExportKind, {
          at: this.state.startLoc,
          unsupportedExportKind: r,
          suggestion: ni[r]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
        return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127))
        return e = this.parseExport(e), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e) {
      return this.next(), this.expectContextual(108), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e) {
      return this.next(), this.flowParseTypeAlias(e), e.type = "DeclareTypeAlias", e;
    }
    flowParseDeclareOpaqueType(e) {
      return this.next(), this.flowParseOpaqueType(e, true), e.type = "DeclareOpaqueType", e;
    }
    flowParseDeclareInterface(e) {
      return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, "DeclareInterface");
    }
    flowParseInterfaceish(e, t = false) {
      if (e.id = this.flowParseRestrictedIdentifier(!t, true), this.scope.declareName(e.id.name, t ? jr : nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (!t && this.eat(12));
      if (this.isContextual(114)) {
        this.next();
        do
          e.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      if (this.isContextual(110)) {
        this.next();
        do
          e.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      e.body = this.flowParseObjectType({
        allowStatic: t,
        allowExact: false,
        allowSpread: false,
        allowProto: t,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const e = this.startNode();
      return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
    }
    flowParseInterface(e) {
      return this.flowParseInterfaceish(e), this.finishNode(e, "InterfaceDeclaration");
    }
    checkNotUnderscore(e) {
      e === "_" && this.raise(Ce.UnexpectedReservedUnderscore, {
        at: this.state.startLoc
      });
    }
    checkReservedType(e, t, r) {
      !si.has(e) || this.raise(r ? Ce.AssignReservedType : Ce.UnexpectedReservedType, {
        at: t,
        reservedType: e
      });
    }
    flowParseRestrictedIdentifier(e, t) {
      return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
    }
    flowParseTypeAlias(e) {
      return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
    }
    flowParseOpaqueType(e, t) {
      return this.expectContextual(126), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
    }
    flowParseTypeParameter(e = false) {
      const t = this.state.startLoc, r = this.startNode(), i = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return r.name = o.name, r.variance = i, r.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) : e && this.raise(Ce.MissingTypeParamDefault, {
        at: t
      }), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e = this.state.inType, t = this.startNode();
      t.params = [], this.state.inType = true, this.match(47) || this.match(138) ? this.next() : this.unexpected();
      let r = false;
      do {
        const i = this.flowParseTypeParameter(r);
        t.params.push(i), i.default && (r = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e, this.finishNode(t, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e = this.startNode(), t = this.state.inType;
      e.params = [], this.state.inType = true, this.expect(47);
      const r = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); )
        e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = r, this.expect(48), this.state.inType = t, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e = this.startNode(), t = this.state.inType;
      for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
        e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = t, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e = this.startNode();
      if (this.expectContextual(125), e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return e.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      }), this.finishNode(e, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e, t, r) {
      return e.static = t, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = r, this.finishNode(e, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e, t) {
      return e.static = t, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e) {
      for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e, t) {
      const r = this.startNode();
      return e.static = t, e.value = this.flowParseObjectTypeMethodish(r), this.finishNode(e, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: e,
      allowExact: t,
      allowSpread: r,
      allowProto: i,
      allowInexact: o
    }) {
      const d = this.state.inType;
      this.state.inType = true;
      const u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let E, w, U = false;
      for (t && this.match(6) ? (this.expect(6), E = 9, w = true) : (this.expect(5), E = 8, w = false), u.exact = w; !this.match(E); ) {
        let ye = false, Ae = null, Oe = null;
        const Ve = this.startNode();
        if (i && this.isContextual(115)) {
          const He = this.lookahead();
          He.type !== 14 && He.type !== 17 && (this.next(), Ae = this.state.startLoc, e = false);
        }
        if (e && this.isContextual(104)) {
          const He = this.lookahead();
          He.type !== 14 && He.type !== 17 && (this.next(), ye = true);
        }
        const Ke = this.flowParseVariance();
        if (this.eat(0))
          Ae != null && this.unexpected(Ae), this.eat(0) ? (Ke && this.unexpected(Ke.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(Ve, ye))) : u.indexers.push(this.flowParseObjectTypeIndexer(Ve, ye, Ke));
        else if (this.match(10) || this.match(47))
          Ae != null && this.unexpected(Ae), Ke && this.unexpected(Ke.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(Ve, ye));
        else {
          let He = "init";
          if (this.isContextual(98) || this.isContextual(103)) {
            const zi = this.lookahead();
            W(zi.type) && (He = this.state.value, this.next());
          }
          const bs = this.flowParseObjectTypeProperty(Ve, ye, Ae, Ke, He, r, o != null ? o : !w);
          bs === null ? (U = true, Oe = this.state.lastTokStartLoc) : u.properties.push(bs);
        }
        this.flowObjectTypeSemicolon(), Oe && !this.match(8) && !this.match(9) && this.raise(Ce.UnexpectedExplicitInexactInObject, {
          at: Oe
        });
      }
      this.expect(E), r && (u.inexact = U);
      const ge = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = d, ge;
    }
    flowParseObjectTypeProperty(e, t, r, i, o, d, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (d ? u || this.raise(Ce.InexactInsideExact, {
          at: this.state.lastTokStartLoc
        }) : this.raise(Ce.InexactInsideNonObject, {
          at: this.state.lastTokStartLoc
        }), i && this.raise(Ce.InexactVariance, {
          at: i
        }), null) : (d || this.raise(Ce.UnexpectedSpreadType, {
          at: this.state.lastTokStartLoc
        }), r != null && this.unexpected(r), i && this.raise(Ce.SpreadVariance, {
          at: i
        }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
      {
        e.key = this.flowParseObjectPropertyKey(), e.static = t, e.proto = r != null, e.kind = o;
        let E = false;
        return this.match(47) || this.match(10) ? (e.method = true, r != null && this.unexpected(r), i && this.unexpected(i.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(e), !d && e.key.name === "constructor" && e.value.this && this.raise(Ce.ThisParamBannedInConstructor, {
          at: e.value.this
        })) : (o !== "init" && this.unexpected(), e.method = false, this.eat(17) && (E = true), e.value = this.flowParseTypeInitialiser(), e.variance = i), e.optional = E, this.finishNode(e, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e) {
      const t = e.kind === "get" ? 0 : 1, r = e.value.params.length + (e.value.rest ? 1 : 0);
      e.value.this && this.raise(e.kind === "get" ? Ce.GetterMayNotHaveThisParam : Ce.SetterMayNotHaveThisParam, {
        at: e.value.this
      }), r !== t && this.raise(e.kind === "get" ? m.BadGetterArity : m.BadSetterArity, {
        at: e
      }), e.kind === "set" && e.value.rest && this.raise(m.BadSetterRestParameter, {
        at: e
      });
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e, t, r) {
      e = e || this.state.start, t = t || this.state.startLoc;
      let i = r || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        const o = this.startNodeAt(e, t);
        o.qualification = i, o.id = this.flowParseRestrictedIdentifier(true), i = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return i;
    }
    flowParseGenericType(e, t, r) {
      const i = this.startNodeAt(e, t);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, t, r), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e = this.startNode();
      return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e = this.startNode();
      for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e) {
      let t = null, r = false, i = null;
      const o = this.startNode(), d = this.lookahead(), u = this.state.type === 78;
      return d.type === 14 || d.type === 17 ? (u && !e && this.raise(Ce.ThisParamMustBeFirst, {
        at: o
      }), t = this.parseIdentifier(u), this.eat(17) && (r = true, u && this.raise(Ce.ThisParamMayNotBeOptional, {
        at: o
      })), i = this.flowParseTypeInitialiser()) : i = this.flowParseType(), o.name = t, o.optional = r, o.typeAnnotation = i, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e) {
      const t = this.startNodeAt(e.start, e.loc.start);
      return t.name = null, t.optional = false, t.typeAnnotation = e, this.finishNode(t, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e = []) {
      let t = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(true), r.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (t = this.flowParseFunctionTypeParam(false)), {
        params: e,
        rest: t,
        _this: r
      };
    }
    flowIdentToTypeAnnotation(e, t, r, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(r, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(r, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(r, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(r, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(r, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(r, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(r, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, t, i);
      }
    }
    flowParsePrimaryType() {
      const e = this.state.start, t = this.state.startLoc, r = this.startNode();
      let i, o, d = false;
      const u = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case 0:
          return this.state.noAnonFunctionType = false, o = this.flowParseTupleType(), this.state.noAnonFunctionType = u, o;
        case 47:
          return r.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), this.finishNode(r, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (Te(this.state.type) || this.match(78)) {
              const E = this.lookahead().type;
              d = E !== 17 && E !== 14;
            } else
              d = true;
          if (d) {
            if (this.state.noAnonFunctionType = false, o = this.flowParseType(), this.state.noAnonFunctionType = u, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), o;
            this.eat(12);
          }
          return o ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(o)]) : i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation");
        case 129:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return r.value = this.match(85), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(130))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r);
            if (this.match(131))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r);
            throw this.raise(Ce.UnexpectedSubtractionOperand, {
              at: this.state.startLoc
            });
          }
          throw this.unexpected();
        case 130:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 131:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(r, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(r, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ee(this.state.type)) {
            const E = $e(this.state.type);
            return this.next(), super.createIdentifier(r, E);
          } else if (Te(this.state.type))
            return this.isContextual(125) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, t, r, this.parseIdentifier());
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const e = this.state.start, t = this.state.startLoc;
      let r = this.flowParsePrimaryType(), i = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const o = this.startNodeAt(e, t), d = this.eat(18);
        i = i || d, this.expect(0), !d && this.match(3) ? (o.elementType = r, this.next(), r = this.finishNode(o, "ArrayTypeAnnotation")) : (o.objectType = r, o.indexType = this.flowParseType(), this.expect(3), i ? (o.optional = d, r = this.finishNode(o, "OptionalIndexedAccessType")) : r = this.finishNode(o, "IndexedAccessType"));
      }
      return r;
    }
    flowParsePrefixType() {
      const e = this.startNode();
      return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const t = this.startNodeAt(e.start, e.loc.start);
        return t.params = [this.reinterpretTypeAsFunctionTypeParam(e)], t.rest = null, t.this = null, t.returnType = this.flowParseType(), t.typeParameters = null, this.finishNode(t, "FunctionTypeAnnotation");
      }
      return e;
    }
    flowParseIntersectionType() {
      const e = this.startNode();
      this.eat(45);
      const t = this.flowParseAnonFunctionWithoutParens();
      for (e.types = [t]; this.eat(45); )
        e.types.push(this.flowParseAnonFunctionWithoutParens());
      return e.types.length === 1 ? t : this.finishNode(e, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e = this.startNode();
      this.eat(43);
      const t = this.flowParseIntersectionType();
      for (e.types = [t]; this.eat(43); )
        e.types.push(this.flowParseIntersectionType());
      return e.types.length === 1 ? t : this.finishNode(e, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e = this.state.inType;
      this.state.inType = true;
      const t = this.flowParseUnionType();
      return this.state.inType = e, t;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 128 && this.state.value === "_") {
        const e = this.state.start, t = this.state.startLoc, r = this.parseIdentifier();
        return this.flowParseGenericType(e, t, r);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e = this.startNode();
      return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e) {
      const t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t)), t;
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    flowParseVariance() {
      let e = null;
      return this.match(53) && (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")), e;
    }
    parseFunctionBody(e, t, r = false) {
      return t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, r)) : super.parseFunctionBody(e, false, r);
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      if (this.match(14)) {
        const i = this.startNode();
        [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = i.typeAnnotation ? this.finishNode(i, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e, t, r);
    }
    parseStatement(e, t) {
      if (this.state.strict && this.isContextual(125)) {
        const i = this.lookahead();
        if (z(i.type)) {
          const o = this.startNode();
          return this.next(), this.flowParseInterface(o);
        }
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        const i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      const r = super.parseStatement(e, t);
      return this.flowPragma === void 0 && !this.isValidDirective(r) && (this.flowPragma = null), r;
    }
    parseExpressionStatement(e, t) {
      if (t.type === "Identifier") {
        if (t.name === "declare") {
          if (this.match(80) || Te(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(e);
        } else if (Te(this.state.type)) {
          if (t.name === "interface")
            return this.flowParseInterface(e);
          if (t.name === "type")
            return this.flowParseTypeAlias(e);
          if (t.name === "opaque")
            return this.flowParseOpaqueType(e, false);
        }
      }
      return super.parseExpressionStatement(e, t);
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      return Se(e) || this.shouldParseEnums() && e === 122 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      return Se(e) || this.shouldParseEnums() && e === 122 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(122)) {
        const e = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e, t, r, i) {
      if (!this.match(17))
        return e;
      if (this.state.maybeInArrowParameters) {
        const ye = this.lookaheadCharCode();
        if (ye === 44 || ye === 61 || ye === 58 || ye === 41)
          return this.setOptionalParametersError(i), e;
      }
      this.expect(17);
      const o = this.state.clone(), d = this.state.noArrowAt, u = this.startNodeAt(t, r);
      let {
        consequent: E,
        failed: w
      } = this.tryParseConditionalConsequent(), [U, ge] = this.getArrowLikeExpressions(E);
      if (w || ge.length > 0) {
        const ye = [...d];
        if (ge.length > 0) {
          this.state = o, this.state.noArrowAt = ye;
          for (let Ae = 0; Ae < ge.length; Ae++)
            ye.push(ge[Ae].start);
          ({
            consequent: E,
            failed: w
          } = this.tryParseConditionalConsequent()), [U, ge] = this.getArrowLikeExpressions(E);
        }
        w && U.length > 1 && this.raise(Ce.AmbiguousConditionalArrow, {
          at: o.startLoc
        }), w && U.length === 1 && (this.state = o, ye.push(U[0].start), this.state.noArrowAt = ye, {
          consequent: E,
          failed: w
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(E, true), this.state.noArrowAt = d, this.expect(14), u.test = e, u.consequent = E, u.alternate = this.forwardNoArrowParamsConversionAt(u, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(u, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e = this.parseMaybeAssignAllowIn(), t = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: e,
        failed: t
      };
    }
    getArrowLikeExpressions(e, t) {
      const r = [e], i = [];
      for (; r.length !== 0; ) {
        const o = r.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : i.push(o), r.push(o.body)) : o.type === "ConditionalExpression" && (r.push(o.consequent), r.push(o.alternate));
      }
      return t ? (i.forEach((o) => this.finishArrowValidation(o)), [i, []]) : ai(i, (o) => o.params.every((d) => this.isAssignable(d, true)));
    }
    finishArrowValidation(e) {
      var t;
      this.toAssignableList(e.params, (t = e.extra) == null ? void 0 : t.trailingCommaLoc, false), this.scope.enter(Ye | bt), super.checkParams(e, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e, t) {
      let r;
      return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), r = t(), this.state.noArrowParamsConversionAt.pop()) : r = t(), r;
    }
    parseParenItem(e, t, r) {
      if (e = super.parseParenItem(e, t, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        const i = this.startNodeAt(t, r);
        return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
      }
      return e;
    }
    assertModuleNodeAllowed(e) {
      e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
    }
    parseExport(e) {
      const t = super.parseExport(e);
      return (t.type === "ExportNamedDeclaration" || t.type === "ExportAllDeclaration") && (t.exportKind = t.exportKind || "value"), t;
    }
    parseExportDeclaration(e) {
      if (this.isContextual(126)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
      } else if (this.isContextual(127)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.flowParseOpaqueType(t, false);
      } else if (this.isContextual(125)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.flowParseInterface(t);
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        e.exportKind = "value";
        const t = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t);
      } else
        return super.parseExportDeclaration(e);
    }
    eatExportStar(e) {
      return super.eatExportStar(...arguments) ? true : this.isContextual(126) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      const {
        startLoc: t
      } = this.state, r = super.maybeParseExportNamespaceSpecifier(e);
      return r && e.exportKind === "type" && this.unexpected(t), r;
    }
    parseClassId(e, t, r) {
      super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e, t, r) {
      const {
        startLoc: i
      } = this.state;
      if (this.isContextual(121)) {
        if (this.parseClassMemberFromModifier(e, t))
          return;
        t.declare = true;
      }
      super.parseClassMember(e, t, r), t.declare && (t.type !== "ClassProperty" && t.type !== "ClassPrivateProperty" && t.type !== "PropertyDefinition" ? this.raise(Ce.DeclareClassElement, {
        at: i
      }) : t.value && this.raise(Ce.DeclareClassFieldInitializer, {
        at: t.value
      }));
    }
    isIterator(e) {
      return e === "iterator" || e === "asyncIterator";
    }
    readIterator() {
      const e = super.readWord1(), t = "@@" + e;
      (!this.isIterator(e) || !this.state.inType) && this.raise(m.InvalidIdentifier, {
        at: this.state.curPosition(),
        identifierName: t
      }), this.finishToken(128, t);
    }
    getTokenFromCode(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      return e === 123 && t === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? t === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : sr(e, t, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
    }
    isAssignable(e, t) {
      return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
    }
    toAssignable(e, t = false) {
      !t && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(...arguments);
    }
    toAssignableList(e, t, r) {
      for (let i = 0; i < e.length; i++) {
        const o = e[i];
        (o == null ? void 0 : o.type) === "TypeCastExpression" && (e[i] = this.typeCastToParameter(o));
      }
      super.toAssignableList(e, t, r);
    }
    toReferencedList(e, t) {
      for (let i = 0; i < e.length; i++) {
        var r;
        const o = e[i];
        o && o.type === "TypeCastExpression" && !((r = o.extra) != null && r.parenthesized) && (e.length > 1 || !t) && this.raise(Ce.TypeCastInPattern, {
          at: o.typeAnnotation
        });
      }
      return e;
    }
    parseArrayLike(e, t, r, i) {
      const o = super.parseArrayLike(e, t, r, i);
      return t && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(e, ...t) {
      return e === "TypeCastExpression" || super.isValidLVal(e, ...t);
    }
    parseClassProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e) {
      return !this.match(14) && super.isNonstaticConstructor(e);
    }
    pushClassMethod(e, t, r, i, o, d) {
      if (t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, i, o, d), t.params && o) {
        const u = t.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ce.ThisParamBannedInConstructor, {
          at: t
        });
      } else if (t.type === "MethodDefinition" && o && t.value.params) {
        const u = t.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ce.ThisParamBannedInConstructor, {
          at: t
        });
      }
    }
    pushClassPrivateMethod(e, t, r, i) {
      t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, i);
    }
    parseClassSuper(e) {
      if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(110)) {
        this.next();
        const t = e.implements = [];
        do {
          const r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, t.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e) {
      super.checkGetterSetterParams(e);
      const t = this.getObjectOrClassMethodParams(e);
      if (t.length > 0) {
        const r = t[0];
        this.isThisParam(r) && e.kind === "get" ? this.raise(Ce.GetterMayNotHaveThisParam, {
          at: r
        }) : this.isThisParam(r) && this.raise(Ce.SetterMayNotHaveThisParam, {
          at: r
        });
      }
    }
    parsePropertyNamePrefixOperator(e) {
      e.variance = this.flowParseVariance();
    }
    parseObjPropValue(e, t, r, i, o, d, u, E) {
      e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
      let w;
      this.match(47) && !u && (w = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(e, t, r, i, o, d, u, E), w && ((e.value || e).typeParameters = w);
    }
    parseAssignableListItemTypes(e) {
      return this.eat(17) && (e.type !== "Identifier" && this.raise(Ce.PatternIsOptional, {
        at: e
      }), this.isThisParam(e) && this.raise(Ce.ThisParamMayNotBeOptional, {
        at: e
      }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(Ce.ThisParamAnnotationRequired, {
        at: e
      }), this.match(29) && this.isThisParam(e) && this.raise(Ce.ThisParamNoDefault, {
        at: e
      }), this.resetEndLocation(e), e;
    }
    parseMaybeDefault(e, t, r) {
      const i = super.parseMaybeDefault(e, t, r);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Ce.TypeBeforeInitializer, {
        at: i.typeAnnotation
      }), i;
    }
    shouldParseDefaultImport(e) {
      return Er(e) ? Jr(this.state.type) : super.shouldParseDefaultImport(e);
    }
    parseImportSpecifierLocal(e, t, r) {
      t.local = Er(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, r));
    }
    maybeParseDefaultImportSpecifier(e) {
      e.importKind = "value";
      let t = null;
      if (this.match(87) ? t = "typeof" : this.isContextual(126) && (t = "type"), t) {
        const r = this.lookahead(), {
          type: i
        } = r;
        t === "type" && i === 55 && this.unexpected(null, r.type), (Jr(i) || i === 5 || i === 55) && (this.next(), e.importKind = t);
      }
      return super.maybeParseDefaultImportSpecifier(e);
    }
    parseImportSpecifier(e, t, r, i) {
      const o = e.imported;
      let d = null;
      o.type === "Identifier" && (o.name === "type" ? d = "type" : o.name === "typeof" && (d = "typeof"));
      let u = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const w = this.parseIdentifier(true);
        d !== null && !z(this.state.type) ? (e.imported = w, e.importKind = d, e.local = at(w)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
      } else {
        if (d !== null && z(this.state.type))
          e.imported = this.parseIdentifier(true), e.importKind = d;
        else {
          if (t)
            throw this.raise(m.ImportBindingIsString, {
              at: e,
              importName: o.value
            });
          e.imported = o, e.importKind = null;
        }
        this.eatContextual(93) ? e.local = this.parseIdentifier() : (u = true, e.local = at(e.imported));
      }
      const E = Er(e);
      return r && E && this.raise(Ce.ImportTypeShorthandOnlyInPureImport, {
        at: e
      }), (r || E) && this.checkReservedType(e.local.name, e.local.loc.start, true), u && !r && !E && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e, t) {
      const r = e.kind;
      r !== "get" && r !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
    }
    parseVarId(e, t) {
      super.parseVarId(e, t), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, t) {
      if (this.match(14)) {
        const r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(e, t);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e, t) {
      var r;
      let i = null, o;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (i = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(e, t), i), !o.error)
          return o.node;
        const {
          context: E
        } = this.state, w = E[E.length - 1];
        (w === j.j_oTag || w === j.j_expr) && E.pop();
      }
      if ((r = o) != null && r.error || this.match(47)) {
        var d, u;
        i = i || this.state.clone();
        let E;
        const w = this.tryParse((ge) => {
          var ye;
          E = this.flowParseTypeParameterDeclaration();
          const Ae = this.forwardNoArrowParamsConversionAt(E, () => {
            const Ve = super.parseMaybeAssign(e, t);
            return this.resetStartLocationFromNode(Ve, E), Ve;
          });
          (ye = Ae.extra) != null && ye.parenthesized && ge();
          const Oe = this.maybeUnwrapTypeCastExpression(Ae);
          return Oe.type !== "ArrowFunctionExpression" && ge(), Oe.typeParameters = E, this.resetStartLocationFromNode(Oe, E), Ae;
        }, i);
        let U = null;
        if (w.node && this.maybeUnwrapTypeCastExpression(w.node).type === "ArrowFunctionExpression") {
          if (!w.error && !w.aborted)
            return w.node.async && this.raise(Ce.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
              at: E
            }), w.node;
          U = w.node;
        }
        if ((d = o) != null && d.node)
          return this.state = o.failState, o.node;
        if (U)
          return this.state = w.failState, U;
        throw (u = o) != null && u.thrown ? o.error : w.thrown ? w.error : this.raise(Ce.UnexpectedTokenAfterTypeParameter, {
          at: E
        });
      }
      return super.parseMaybeAssign(e, t);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const t = this.tryParse(() => {
          const r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const i = this.startNode();
          return [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), i;
        });
        if (t.thrown)
          return null;
        t.error && (this.state = t.failState), e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e);
    }
    shouldParseArrow(e) {
      return this.match(14) || super.shouldParseArrow(e);
    }
    setArrowFunctionParameters(e, t) {
      this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = t : super.setArrowFunctionParameters(e, t);
    }
    checkParams(e, t, r) {
      if (!(r && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
        for (let i = 0; i < e.params.length; i++)
          this.isThisParam(e.params[i]) && i > 0 && this.raise(Ce.ThisParamMustBeFirst, {
            at: e.params[i]
          });
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e) {
      return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e, t, r, i) {
      if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(t) !== -1) {
        this.next();
        const o = this.startNodeAt(t, r);
        o.callee = e, o.arguments = this.parseCallExpressionArguments(11, false), e = this.finishNode(o, "CallExpression");
      } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
        const o = this.state.clone(), d = this.tryParse((E) => this.parseAsyncArrowWithTypeParameters(t, r) || E(), o);
        if (!d.error && !d.aborted)
          return d.node;
        const u = this.tryParse(() => super.parseSubscripts(e, t, r, i), o);
        if (u.node && !u.error)
          return u.node;
        if (d.node)
          return this.state = d.failState, d.node;
        if (u.node)
          return this.state = u.failState, u.node;
        throw d.error || u.error;
      }
      return super.parseSubscripts(e, t, r, i);
    }
    parseSubscript(e, t, r, i, o) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (o.optionalChainMember = true, i)
          return o.stop = true, e;
        this.next();
        const d = this.startNodeAt(t, r);
        return d.callee = e, d.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), d.arguments = this.parseCallExpressionArguments(11, false), d.optional = true, this.finishCallExpression(d, true);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        const d = this.startNodeAt(t, r);
        d.callee = e;
        const u = this.tryParse(() => (d.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), d.arguments = this.parseCallExpressionArguments(11, false), o.optionalChainMember && (d.optional = false), this.finishCallExpression(d, o.optionalChainMember)));
        if (u.node)
          return u.error && (this.state = u.failState), u.node;
      }
      return super.parseSubscript(e, t, r, i, o);
    }
    parseNewCallee(e) {
      super.parseNewCallee(e);
      let t = null;
      this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = t;
    }
    parseAsyncArrowWithTypeParameters(e, t) {
      const r = this.startNodeAt(e, t);
      if (this.parseFunctionParams(r), !!this.parseArrow(r))
        return this.parseArrowExpression(r, void 0, true);
    }
    readToken_mult_modulo(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (e === 42 && t === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(e);
    }
    readToken_pipe_amp(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (e === 124 && t === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(e);
    }
    parseTopLevel(e, t) {
      const r = super.parseTopLevel(e, t);
      return this.state.hasFlowComment && this.raise(Ce.UnterminatedFlowComment, {
        at: this.state.curPosition()
      }), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ce.NestedFlowComment, {
            at: this.state.startLoc
          });
        this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), this.state.hasFlowComment = true;
        return;
      }
      if (this.state.hasFlowComment) {
        const e = this.input.indexOf("*-/", this.state.pos + 2);
        if (e === -1)
          throw this.raise(m.UnterminatedComment, {
            at: this.state.curPosition()
          });
        this.state.pos = e + 2 + 3;
        return;
      }
      return super.skipBlockComment();
    }
    skipFlowComment() {
      const {
        pos: e
      } = this.state;
      let t = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e + t)); )
        t++;
      const r = this.input.charCodeAt(t + e), i = this.input.charCodeAt(t + e + 1);
      return r === 58 && i === 58 ? t + 2 : this.input.slice(t + e, t + e + 12) === "flow-include" ? t + 12 : r === 58 && i !== 58 ? t : false;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(m.UnterminatedComment, {
          at: this.state.curPosition()
        });
    }
    flowEnumErrorBooleanMemberNotInitialized(e, {
      enumName: t,
      memberName: r
    }) {
      this.raise(Ce.EnumBooleanMemberNotInitialized, {
        at: e,
        memberName: r,
        enumName: t
      });
    }
    flowEnumErrorInvalidMemberInitializer(e, t) {
      return this.raise(t.explicitType ? t.explicitType === "symbol" ? Ce.EnumInvalidMemberInitializerSymbolType : Ce.EnumInvalidMemberInitializerPrimaryType : Ce.EnumInvalidMemberInitializerUnknownType, Object.assign({
        at: e
      }, t));
    }
    flowEnumErrorNumberMemberNotInitialized(e, {
      enumName: t,
      memberName: r
    }) {
      this.raise(Ce.EnumNumberMemberNotInitialized, {
        at: e,
        enumName: t,
        memberName: r
      });
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e, {
      enumName: t
    }) {
      this.raise(Ce.EnumStringMemberInconsistentlyInitailized, {
        at: e,
        enumName: t
      });
    }
    flowEnumMemberInit() {
      const e = this.state.startLoc, t = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 130: {
          const r = this.parseNumericLiteral(this.state.value);
          return t() ? {
            type: "number",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 129: {
          const r = this.parseStringLiteral(this.state.value);
          return t() ? {
            type: "string",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 85:
        case 86: {
          const r = this.parseBooleanLiteral(this.match(85));
          return t() ? {
            type: "boolean",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        default:
          return {
            type: "invalid",
            loc: e
          };
      }
    }
    flowEnumMemberRaw() {
      const e = this.state.startLoc, t = this.parseIdentifier(true), r = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: e
      };
      return {
        id: t,
        init: r
      };
    }
    flowEnumCheckExplicitTypeMismatch(e, t, r) {
      const {
        explicitType: i
      } = t;
      i !== null && i !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
    }
    flowEnumMembers({
      enumName: e,
      explicitType: t
    }) {
      const r = /* @__PURE__ */ new Set(), i = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let o = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = true;
          break;
        }
        const d = this.startNode(), {
          id: u,
          init: E
        } = this.flowEnumMemberRaw(), w = u.name;
        if (w === "")
          continue;
        /^[a-z]/.test(w) && this.raise(Ce.EnumInvalidMemberName, {
          at: u,
          memberName: w,
          suggestion: w[0].toUpperCase() + w.slice(1),
          enumName: e
        }), r.has(w) && this.raise(Ce.EnumDuplicateMemberName, {
          at: u,
          memberName: w,
          enumName: e
        }), r.add(w);
        const U = {
          enumName: e,
          explicitType: t,
          memberName: w
        };
        switch (d.id = u, E.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "boolean"), d.init = E.value, i.booleanMembers.push(this.finishNode(d, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "number"), d.init = E.value, i.numberMembers.push(this.finishNode(d, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "string"), d.init = E.value, i.stringMembers.push(this.finishNode(d, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(E.loc, U);
          case "none":
            switch (t) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(E.loc, U);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(E.loc, U);
                break;
              default:
                i.defaultedMembers.push(this.finishNode(d, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: i,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(e, t, {
      enumName: r
    }) {
      if (e.length === 0)
        return t;
      if (t.length === 0)
        return e;
      if (t.length > e.length) {
        for (const i of e)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(i, {
            enumName: r
          });
        return t;
      } else {
        for (const i of t)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(i, {
            enumName: r
          });
        return e;
      }
    }
    flowEnumParseExplicitType({
      enumName: e
    }) {
      if (!this.eatContextual(101))
        return null;
      if (!Te(this.state.type))
        throw this.raise(Ce.EnumInvalidExplicitTypeUnknownSupplied, {
          at: this.state.startLoc,
          enumName: e
        });
      const {
        value: t
      } = this.state;
      return this.next(), t !== "boolean" && t !== "number" && t !== "string" && t !== "symbol" && this.raise(Ce.EnumInvalidExplicitType, {
        at: this.state.startLoc,
        enumName: e,
        invalidEnumType: t
      }), t;
    }
    flowEnumBody(e, t) {
      const r = t.name, i = t.loc.start, o = this.flowEnumParseExplicitType({
        enumName: r
      });
      this.expect(5);
      const {
        members: d,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: r,
        explicitType: o
      });
      switch (e.hasUnknownMembers = u, o) {
        case "boolean":
          return e.explicitType = true, e.members = d.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        case "number":
          return e.explicitType = true, e.members = d.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        case "string":
          return e.explicitType = true, e.members = this.flowEnumStringMembers(d.stringMembers, d.defaultedMembers, {
            enumName: r
          }), this.expect(8), this.finishNode(e, "EnumStringBody");
        case "symbol":
          return e.members = d.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
        default: {
          const E = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
          e.explicitType = false;
          const w = d.booleanMembers.length, U = d.numberMembers.length, ge = d.stringMembers.length, ye = d.defaultedMembers.length;
          if (!w && !U && !ge && !ye)
            return E();
          if (!w && !U)
            return e.members = this.flowEnumStringMembers(d.stringMembers, d.defaultedMembers, {
              enumName: r
            }), this.expect(8), this.finishNode(e, "EnumStringBody");
          if (!U && !ge && w >= ye) {
            for (const Ae of d.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(Ae.loc.start, {
                enumName: r,
                memberName: Ae.id.name
              });
            return e.members = d.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
          } else if (!w && !ge && U >= ye) {
            for (const Ae of d.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(Ae.loc.start, {
                enumName: r,
                memberName: Ae.id.name
              });
            return e.members = d.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
          } else
            return this.raise(Ce.EnumInconsistentMemberValues, {
              at: i,
              enumName: r
            }), E();
        }
      }
    }
    flowParseEnumDeclaration(e) {
      const t = this.parseIdentifier();
      return e.id = t, e.body = this.flowEnumBody(this.startNode(), t), this.finishNode(e, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e = this.nextTokenStart();
      if (this.input.charCodeAt(e) === 60) {
        const t = this.input.charCodeAt(e + 1);
        return t !== 60 && t !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e) {
      return e.type === "TypeCastExpression" ? e.expression : e;
    }
  };
  const ui = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }, Et = _`jsx`((a) => ({
    AttributeIsEmpty: a("JSX attributes must only be assigned a non-empty expression."),
    MissingClosingTagElement: a(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`),
    MissingClosingTagFragment: a("Expected corresponding JSX closing tag for <>."),
    UnexpectedSequenceExpression: a("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"),
    UnexpectedToken: a(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`),
    UnsupportedJsxValue: a("JSX value should be either an expression or a quoted JSX text."),
    UnterminatedJsxContent: a("Unterminated JSX contents."),
    UnwrappedAdjacentJSXElements: a("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?")
  }));
  function ht(a) {
    return a ? a.type === "JSXOpeningFragment" || a.type === "JSXClosingFragment" : false;
  }
  function kt(a) {
    if (a.type === "JSXIdentifier")
      return a.name;
    if (a.type === "JSXNamespacedName")
      return a.namespace.name + ":" + a.name.name;
    if (a.type === "JSXMemberExpression")
      return kt(a.object) + "." + kt(a.property);
    throw new Error("Node had unexpected type: " + a.type);
  }
  var ci = (a) => class extends a {
    jsxReadToken() {
      let e = "", t = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Et.UnterminatedJsxContent, {
            at: this.state.startLoc
          });
        const r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(r) : (e += this.input.slice(t, this.state.pos), this.finishToken(137, e));
          case 38:
            e += this.input.slice(t, this.state.pos), e += this.jsxReadEntity(), t = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            St(r) ? (e += this.input.slice(t, this.state.pos), e += this.jsxReadNewLine(true), t = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e) {
      const t = this.input.charCodeAt(this.state.pos);
      let r;
      return ++this.state.pos, t === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = e ? `
` : `\r
`) : r = String.fromCharCode(t), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(e) {
      let t = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedString, {
            at: this.state.startLoc
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === e)
          break;
        i === 38 ? (t += this.input.slice(r, this.state.pos), t += this.jsxReadEntity(), r = this.state.pos) : St(i) ? (t += this.input.slice(r, this.state.pos), t += this.jsxReadNewLine(false), r = this.state.pos) : ++this.state.pos;
      }
      return t += this.input.slice(r, this.state.pos++), this.finishToken(129, t);
    }
    jsxReadEntity() {
      const e = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let t = 10;
        this.codePointAtPos(this.state.pos) === 120 && (t = 16, ++this.state.pos);
        const r = this.readInt(t, void 0, false, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let t = 0, r = false;
        for (; t++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (r) {
          const i = this.input.slice(e, this.state.pos), o = ui[i];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = e, "&";
    }
    jsxReadWord() {
      let e;
      const t = this.state.pos;
      do
        e = this.input.charCodeAt(++this.state.pos);
      while (Be(e) || e === 45);
      return this.finishToken(136, this.input.slice(t, this.state.pos));
    }
    jsxParseIdentifier() {
      const e = this.startNode();
      return this.match(136) ? e.name = this.state.value : Ee(this.state.type) ? e.name = $e(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e = this.state.start, t = this.state.startLoc, r = this.jsxParseIdentifier();
      if (!this.eat(14))
        return r;
      const i = this.startNodeAt(e, t);
      return i.namespace = r, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e = this.state.start, t = this.state.startLoc;
      let r = this.jsxParseNamespacedName();
      if (r.type === "JSXNamespacedName")
        return r;
      for (; this.eat(16); ) {
        const i = this.startNodeAt(e, t);
        i.object = r, i.property = this.jsxParseIdentifier(), r = this.finishNode(i, "JSXMemberExpression");
      }
      return r;
    }
    jsxParseAttributeValue() {
      let e;
      switch (this.state.type) {
        case 5:
          return e = this.startNode(), this.setContext(j.brace), this.next(), e = this.jsxParseExpressionContainer(e, j.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Et.AttributeIsEmpty, {
            at: e
          }), e;
        case 138:
        case 129:
          return this.parseExprAtom();
        default:
          throw this.raise(Et.UnsupportedJsxValue, {
            at: this.state.startLoc
          });
      }
    }
    jsxParseEmptyExpression() {
      const e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
      return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e) {
      return this.next(), e.expression = this.parseExpression(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e, t) {
      if (this.match(8))
        e.expression = this.jsxParseEmptyExpression();
      else {
        const r = this.parseExpression();
        e.expression = r;
      }
      return this.setContext(t), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e = this.startNode();
      return this.match(5) ? (this.setContext(j.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e, t) {
      const r = this.startNodeAt(e, t);
      return this.eat(139) ? this.finishNode(r, "JSXOpeningFragment") : (r.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r));
    }
    jsxParseOpeningElementAfterName(e) {
      const t = [];
      for (; !this.match(56) && !this.match(139); )
        t.push(this.jsxParseAttribute());
      return e.attributes = t, e.selfClosing = this.eat(56), this.expect(139), this.finishNode(e, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e, t) {
      const r = this.startNodeAt(e, t);
      return this.eat(139) ? this.finishNode(r, "JSXClosingFragment") : (r.name = this.jsxParseElementName(), this.expect(139), this.finishNode(r, "JSXClosingElement"));
    }
    jsxParseElementAt(e, t) {
      const r = this.startNodeAt(e, t), i = [], o = this.jsxParseOpeningElementAt(e, t);
      let d = null;
      if (!o.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 138:
                if (e = this.state.start, t = this.state.startLoc, this.next(), this.eat(56)) {
                  d = this.jsxParseClosingElementAt(e, t);
                  break e;
                }
                i.push(this.jsxParseElementAt(e, t));
                break;
              case 137:
                i.push(this.parseExprAtom());
                break;
              case 5: {
                const u = this.startNode();
                this.setContext(j.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(u)) : i.push(this.jsxParseExpressionContainer(u, j.j_expr));
                break;
              }
              default:
                throw this.unexpected();
            }
        ht(o) && !ht(d) && d !== null ? this.raise(Et.MissingClosingTagFragment, {
          at: d
        }) : !ht(o) && ht(d) ? this.raise(Et.MissingClosingTagElement, {
          at: d,
          openingTagName: kt(o.name)
        }) : !ht(o) && !ht(d) && kt(d.name) !== kt(o.name) && this.raise(Et.MissingClosingTagElement, {
          at: d,
          openingTagName: kt(o.name)
        });
      }
      if (ht(o) ? (r.openingFragment = o, r.closingFragment = d) : (r.openingElement = o, r.closingElement = d), r.children = i, this.match(47))
        throw this.raise(Et.UnwrappedAdjacentJSXElements, {
          at: this.state.startLoc
        });
      return ht(o) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
    }
    jsxParseElement() {
      const e = this.state.start, t = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e, t);
    }
    setContext(e) {
      const {
        context: t
      } = this.state;
      t[t.length - 1] = e;
    }
    parseExprAtom(e) {
      return this.match(137) ? this.parseLiteral(this.state.value, "JSXText") : this.match(138) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(138), this.jsxParseElement()) : super.parseExprAtom(e);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e) {
      const t = this.curContext();
      if (t === j.j_expr)
        return this.jsxReadToken();
      if (t === j.j_oTag || t === j.j_cTag) {
        if (Ne(e))
          return this.jsxReadWord();
        if (e === 62)
          return ++this.state.pos, this.finishToken(139);
        if ((e === 34 || e === 39) && t === j.j_oTag)
          return this.jsxReadString(e);
      }
      return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(e);
    }
    updateContext(e) {
      const {
        context: t,
        type: r
      } = this.state;
      if (r === 56 && e === 138)
        t.splice(-2, 2, j.j_cTag), this.state.canStartJSXElement = false;
      else if (r === 138)
        t.push(j.j_oTag);
      else if (r === 139) {
        const i = t[t.length - 1];
        i === j.j_oTag && e === 56 || i === j.j_cTag ? (t.pop(), this.state.canStartJSXElement = t[t.length - 1] === j.j_expr) : (this.setContext(j.j_expr), this.state.canStartJSXElement = true);
      } else
        this.state.canStartJSXElement = ae(r);
    }
  };
  class pi extends Tr {
    constructor(...e) {
      super(...e), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
    }
  }
  class fi extends xr {
    createScope(e) {
      return new pi(e);
    }
    declareName(e, t, r) {
      const i = this.currentScope();
      if (t & cr) {
        this.maybeExportDefined(i, e), i.exportOnlyBindings.add(e);
        return;
      }
      super.declareName(...arguments), t & wt && (t & it || (this.checkRedeclarationInScope(i, e, t, r), this.maybeExportDefined(i, e)), i.types.add(e)), t & lr && i.enums.add(e), t & ur && i.constEnums.add(e), t & Wt && i.classes.add(e);
    }
    isRedeclaredInScope(e, t, r) {
      if (e.enums.has(t)) {
        if (r & lr) {
          const i = !!(r & ur), o = e.constEnums.has(t);
          return i !== o;
        }
        return true;
      }
      return r & Wt && e.classes.has(t) ? e.lexical.has(t) ? !!(r & it) : false : r & wt && e.types.has(t) ? true : super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(e) {
      const t = this.scopeStack[0], {
        name: r
      } = e;
      !t.types.has(r) && !t.exportOnlyBindings.has(r) && super.checkLocalExport(e);
    }
  }
  const hi = (a, e) => Object.hasOwnProperty.call(a, e) && a[e];
  function di(a) {
    if (a == null)
      throw new Error(`Unexpected ${a} value.`);
    return a;
  }
  function Yr(a) {
    if (!a)
      throw new Error("Assert fail");
  }
  const ve = _`typescript`((a) => ({
    AbstractMethodHasImplementation: a(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`),
    AbstractPropertyHasInitializer: a(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`),
    AccesorCannotDeclareThisParameter: a("'get' and 'set' accessors cannot declare 'this' parameters."),
    AccesorCannotHaveTypeParameters: a("An accessor cannot have type parameters."),
    CannotFindName: a(({
      name: e
    }) => `Cannot find name '${e}'.`),
    ClassMethodHasDeclare: a("Class methods cannot have the 'declare' modifier."),
    ClassMethodHasReadonly: a("Class methods cannot have the 'readonly' modifier."),
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: a("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
    ConstructorHasTypeParameters: a("Type parameters cannot appear on a constructor declaration."),
    DeclareAccessor: a(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`),
    DeclareClassFieldHasInitializer: a("Initializers are not allowed in ambient contexts."),
    DeclareFunctionHasImplementation: a("An implementation cannot be declared in ambient contexts."),
    DuplicateAccessibilityModifier: a(({
      modifier: e
    }) => "Accessibility modifier already seen."),
    DuplicateModifier: a(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`),
    EmptyHeritageClauseType: a(({
      token: e
    }) => `'${e}' list cannot be empty.`),
    EmptyTypeArguments: a("Type argument list cannot be empty."),
    EmptyTypeParameters: a("Type parameter list cannot be empty."),
    ExpectedAmbientAfterExportDeclare: a("'export declare' must be followed by an ambient declaration."),
    ImportAliasHasImportType: a("An import alias can not use 'import type'."),
    IncompatibleModifiers: a(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`),
    IndexSignatureHasAbstract: a("Index signatures cannot have the 'abstract' modifier."),
    IndexSignatureHasAccessibility: a(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`),
    IndexSignatureHasDeclare: a("Index signatures cannot have the 'declare' modifier."),
    IndexSignatureHasOverride: a("'override' modifier cannot appear on an index signature."),
    IndexSignatureHasStatic: a("Index signatures cannot have the 'static' modifier."),
    InitializerNotAllowedInAmbientContext: a("Initializers are not allowed in ambient contexts."),
    InvalidModifierOnTypeMember: a(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`),
    InvalidModifierOnTypeParameter: a(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`),
    InvalidModifierOnTypeParameterPositions: a(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`),
    InvalidModifiersOrder: a(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`),
    InvalidPropertyAccessAfterInstantiationExpression: a("Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments."),
    InvalidTupleMemberLabel: a("Tuple members must be labeled with a simple identifier."),
    MissingInterfaceName: a("'interface' declarations must be followed by an identifier."),
    MixedLabeledAndUnlabeledElements: a("Tuple members must all have names or all not have names."),
    NonAbstractClassHasAbstractMethod: a("Abstract methods can only appear within an abstract class."),
    NonClassMethodPropertyHasAbstractModifer: a("'abstract' modifier can only appear on a class, method, or property declaration."),
    OptionalTypeBeforeRequired: a("A required element cannot follow an optional element."),
    OverrideNotInSubClass: a("This member cannot have an 'override' modifier because its containing class does not extend another class."),
    PatternIsOptional: a("A binding pattern parameter cannot be optional in an implementation signature."),
    PrivateElementHasAbstract: a("Private elements cannot have the 'abstract' modifier."),
    PrivateElementHasAccessibility: a(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`),
    ReadonlyForMethodSignature: a("'readonly' modifier can only appear on a property declaration or index signature."),
    ReservedArrowTypeParam: a("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."),
    ReservedTypeAssertion: a("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
    SetAccesorCannotHaveOptionalParameter: a("A 'set' accessor cannot have an optional parameter."),
    SetAccesorCannotHaveRestParameter: a("A 'set' accessor cannot have rest parameter."),
    SetAccesorCannotHaveReturnType: a("A 'set' accessor cannot have a return type annotation."),
    SingleTypeParameterWithoutTrailingComma: a(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`),
    StaticBlockCannotHaveModifier: a("Static class blocks cannot have any modifier."),
    TypeAnnotationAfterAssign: a("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
    TypeImportCannotSpecifyDefaultAndNamed: a("A type-only import can specify a default import or named bindings, but not both."),
    TypeModifierIsUsedInTypeExports: a("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
    TypeModifierIsUsedInTypeImports: a("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
    UnexpectedParameterModifier: a("A parameter property is only allowed in a constructor implementation."),
    UnexpectedReadonly: a("'readonly' type modifier is only permitted on array and tuple literal types."),
    UnexpectedTypeAnnotation: a("Did not expect a type annotation here."),
    UnexpectedTypeCastInParameter: a("Unexpected type cast in parameter position."),
    UnsupportedImportTypeArgument: a("Argument in a type import must be a string literal."),
    UnsupportedParameterPropertyKind: a("A parameter property may not be declared using a binding pattern."),
    UnsupportedSignatureParameterKind: a(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`)
  }));
  function mi(a) {
    switch (a) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Qr(a) {
    return a === "private" || a === "public" || a === "protected";
  }
  function yi(a) {
    return a === "in" || a === "out";
  }
  var bi = (a) => class extends a {
    getScopeHandler() {
      return fi;
    }
    tsIsIdentifier() {
      return Te(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e, t) {
      if (!Te(this.state.type) && this.state.type !== 58)
        return;
      const r = this.state.value;
      if (e.indexOf(r) !== -1) {
        if (t && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers({
      modified: e,
      allowedModifiers: t,
      disallowedModifiers: r,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: o = ve.InvalidModifierOnTypeMember
    }) {
      const d = (E, w, U, ge) => {
        w === U && e[ge] && this.raise(ve.InvalidModifiersOrder, {
          at: E,
          orderedModifiers: [U, ge]
        });
      }, u = (E, w, U, ge) => {
        (e[U] && w === ge || e[ge] && w === U) && this.raise(ve.IncompatibleModifiers, {
          at: E,
          modifiers: [U, ge]
        });
      };
      for (; ; ) {
        const {
          startLoc: E
        } = this.state, w = this.tsParseModifier(t.concat(r != null ? r : []), i);
        if (!w)
          break;
        Qr(w) ? e.accessibility ? this.raise(ve.DuplicateAccessibilityModifier, {
          at: E,
          modifier: w
        }) : (d(E, w, w, "override"), d(E, w, w, "static"), d(E, w, w, "readonly"), e.accessibility = w) : yi(w) ? (e[w] && this.raise(ve.DuplicateModifier, {
          at: E,
          modifier: w
        }), e[w] = true, d(E, w, "in", "out")) : (Object.hasOwnProperty.call(e, w) ? this.raise(ve.DuplicateModifier, {
          at: E,
          modifier: w
        }) : (d(E, w, "static", "readonly"), d(E, w, "static", "override"), d(E, w, "override", "readonly"), d(E, w, "abstract", "override"), u(E, w, "declare", "override"), u(E, w, "static", "abstract")), e[w] = true), r != null && r.includes(w) && this.raise(o, {
          at: E,
          modifier: w
        });
      }
    }
    tsIsListTerminator(e) {
      switch (e) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
      throw new Error("Unreachable");
    }
    tsParseList(e, t) {
      const r = [];
      for (; !this.tsIsListTerminator(e); )
        r.push(t());
      return r;
    }
    tsParseDelimitedList(e, t, r) {
      return di(this.tsParseDelimitedListWorker(e, t, true, r));
    }
    tsParseDelimitedListWorker(e, t, r, i) {
      const o = [];
      let d = -1;
      for (; !this.tsIsListTerminator(e); ) {
        d = -1;
        const u = t();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          d = this.state.lastTokStart;
          continue;
        }
        if (this.tsIsListTerminator(e))
          break;
        r && this.expect(12);
        return;
      }
      return i && (i.value = d), o;
    }
    tsParseBracketedList(e, t, r, i, o) {
      i || (r ? this.expect(0) : this.expect(47));
      const d = this.tsParseDelimitedList(e, t, o);
      return r ? this.expect(3) : this.expect(48), d;
    }
    tsParseImportType() {
      const e = this.startNode();
      return this.expect(83), this.expect(10), this.match(129) || this.raise(ve.UnsupportedImportTypeArgument, {
        at: this.state.startLoc
      }), e.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
    }
    tsParseEntityName(e = true) {
      let t = this.parseIdentifier(e);
      for (; this.eat(16); ) {
        const r = this.startNodeAtNode(t);
        r.left = t, r.right = this.parseIdentifier(e), t = this.finishNode(r, "TSQualifiedName");
      }
      return t;
    }
    tsParseTypeReference() {
      const e = this.startNode();
      return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
    }
    tsParseThisTypePredicate(e) {
      this.next();
      const t = this.startNodeAtNode(e);
      return t.parameterName = e, t.typeAnnotation = this.tsParseTypeAnnotation(false), t.asserts = false, this.finishNode(t, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "TSThisType");
    }
    tsParseTypeQuery() {
      const e = this.startNode();
      return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
    }
    tsParseInOutModifiers(e) {
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ve.InvalidModifierOnTypeParameter
      });
    }
    tsParseNoneModifiers(e) {
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: [],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ve.InvalidModifierOnTypeParameterPositions
      });
    }
    tsParseTypeParameter(e = this.tsParseNoneModifiers.bind(this)) {
      const t = this.startNode();
      return e(t), t.name = this.tsParseTypeParameterName(), t.constraint = this.tsEatThenParseType(81), t.default = this.tsEatThenParseType(29), this.finishNode(t, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e) {
      if (this.match(47))
        return this.tsParseTypeParameters(e);
    }
    tsParseTypeParameters(e) {
      const t = this.startNode();
      this.match(47) || this.match(138) ? this.next() : this.unexpected();
      const r = {
        value: -1
      };
      return t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, r), t.params.length === 0 && this.raise(ve.EmptyTypeParameters, {
        at: t
      }), r.value !== -1 && this.addExtra(t, "trailingComma", r.value), this.finishNode(t, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type !== 75)
        return null;
      this.next();
      const e = this.tsParseTypeReference();
      return e.typeParameters && this.raise(ve.CannotFindName, {
        at: e.typeName,
        name: "const"
      }), e;
    }
    tsFillSignature(e, t) {
      const r = e === 19, i = "parameters", o = "typeAnnotation";
      t.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), t[i] = this.tsParseBindingListForSignature(), r ? t[o] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (t[o] = this.tsParseTypeOrTypePredicateAnnotation(e));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(11, 41).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(ve.UnsupportedSignatureParameterKind, {
        at: e,
        type: e.type
      }), e));
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(e, t) {
      return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Te(this.state.type) ? (this.next(), this.match(14)) : false;
    }
    tsTryParseIndexSignature(e) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const t = this.parseIdentifier();
      t.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t), this.expect(3), e.parameters = [t];
      const r = this.tsTryParseTypeAnnotation();
      return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e, t) {
      this.eat(17) && (e.optional = true);
      const r = e;
      if (this.match(10) || this.match(47)) {
        t && this.raise(ve.ReadonlyForMethodSignature, {
          at: e
        });
        const i = r;
        i.kind && this.match(47) && this.raise(ve.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        }), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
        const o = "parameters", d = "typeAnnotation";
        if (i.kind === "get")
          i[o].length > 0 && (this.raise(m.BadGetterArity, {
            at: this.state.curPosition()
          }), this.isThisParam(i[o][0]) && this.raise(ve.AccesorCannotDeclareThisParameter, {
            at: this.state.curPosition()
          }));
        else if (i.kind === "set") {
          if (i[o].length !== 1)
            this.raise(m.BadSetterArity, {
              at: this.state.curPosition()
            });
          else {
            const u = i[o][0];
            this.isThisParam(u) && this.raise(ve.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            }), u.type === "Identifier" && u.optional && this.raise(ve.SetAccesorCannotHaveOptionalParameter, {
              at: this.state.curPosition()
            }), u.type === "RestElement" && this.raise(ve.SetAccesorCannotHaveRestParameter, {
              at: this.state.curPosition()
            });
          }
          i[d] && this.raise(ve.SetAccesorCannotHaveReturnType, {
            at: i[d]
          });
        } else
          i.kind = "method";
        return this.finishNode(i, "TSMethodSignature");
      } else {
        const i = r;
        t && (i.readonly = true);
        const o = this.tsTryParseTypeAnnotation();
        return o && (i.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
      if (this.match(77)) {
        const r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(e, false));
      }
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      });
      const t = this.tsTryParseIndexSignature(e);
      return t || (this.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, this.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
    }
    tsParseTypeLiteral() {
      const e = this.startNode();
      return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(118) : (this.isContextual(118) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      const e = this.startNode();
      return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e = this.startNode();
      return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(118)) : this.eatContextual(118) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
    }
    tsParseTupleType() {
      const e = this.startNode();
      e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t = false, r = null;
      return e.elementTypes.forEach((i) => {
        var o;
        let {
          type: d
        } = i;
        t && d !== "TSRestType" && d !== "TSOptionalType" && !(d === "TSNamedTupleMember" && i.optional) && this.raise(ve.OptionalTypeBeforeRequired, {
          at: i
        }), t = t || d === "TSNamedTupleMember" && i.optional || d === "TSOptionalType", d === "TSRestType" && (i = i.typeAnnotation, d = i.type);
        const u = d === "TSNamedTupleMember";
        r = (o = r) != null ? o : u, r !== u && this.raise(ve.MixedLabeledAndUnlabeledElements, {
          at: i
        });
      }), this.finishNode(e, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        start: e,
        startLoc: t
      } = this.state, r = this.eat(21);
      let i = this.tsParseType();
      const o = this.eat(17);
      if (this.eat(14)) {
        const u = this.startNodeAtNode(i);
        u.optional = o, i.type === "TSTypeReference" && !i.typeParameters && i.typeName.type === "Identifier" ? u.label = i.typeName : (this.raise(ve.InvalidTupleMemberLabel, {
          at: i
        }), u.label = i), u.elementType = this.tsParseType(), i = this.finishNode(u, "TSNamedTupleMember");
      } else if (o) {
        const u = this.startNodeAtNode(i);
        u.typeAnnotation = i, i = this.finishNode(u, "TSOptionalType");
      }
      if (r) {
        const u = this.startNodeAt(e, t);
        u.typeAnnotation = i, i = this.finishNode(u, "TSRestType");
      }
      return i;
    }
    tsParseParenthesizedType() {
      const e = this.startNode();
      return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e, t) {
      const r = this.startNode();
      return e === "TSConstructorType" && (r.abstract = !!t, t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
    }
    tsParseLiteralTypeNode() {
      const e = this.startNode();
      return e.literal = (() => {
        switch (this.state.type) {
          case 130:
          case 131:
          case 129:
          case 85:
          case 86:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e = this.startNode();
      return e.literal = this.parseTemplate(false), this.finishNode(e, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e = this.tsParseThisTypeNode();
      return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 129:
        case 130:
        case 131:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const e = this.startNode(), t = this.lookahead();
            if (t.type !== 130 && t.type !== 131)
              throw this.unexpected();
            return e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: e
          } = this.state;
          if (Te(e) || e === 88 || e === 84) {
            const t = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : mi(this.state.value);
            if (t !== void 0 && this.lookaheadCharCode() !== 46) {
              const r = this.startNode();
              return this.next(), this.finishNode(r, t);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const t = this.startNodeAtNode(e);
          t.elementType = e, this.expect(3), e = this.finishNode(t, "TSArrayType");
        } else {
          const t = this.startNodeAtNode(e);
          t.objectType = e, t.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(t, "TSIndexedAccessType");
        }
      return e;
    }
    tsParseTypeOperator() {
      const e = this.startNode(), t = this.state.value;
      return this.next(), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), t === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e) {
      switch (e.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ve.UnexpectedReadonly, {
            at: e
          });
      }
    }
    tsParseInferType() {
      const e = this.startNode();
      this.expectContextual(112);
      const t = this.startNode();
      return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(t, "TSTypeParameter"), this.finishNode(e, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return e;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return _e(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e, t, r) {
      const i = this.startNode(), o = this.eat(r), d = [];
      do
        d.push(t());
      while (this.eat(r));
      return d.length === 1 && !o ? d[0] : (i.types = d, this.finishNode(i, e));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Te(this.state.type) || this.match(78))
        return this.next(), true;
      if (this.match(5)) {
        const {
          errors: e
        } = this.state, t = e.length;
        try {
          return this.parseObjectLike(8, true), e.length === t;
        } catch {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: e
        } = this.state, t = e.length;
        try {
          return this.parseBindingList(3, 93, true), e.length === t;
        } catch {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(e) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(e);
        const r = this.startNode(), i = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (i && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (r.parameterName = u, r.asserts = true, r.typeAnnotation = null, u = this.finishNode(r, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, r), u.asserts = true), t.typeAnnotation = u, this.finishNode(t, "TSTypeAnnotation");
        }
        const o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return i ? (r.parameterName = this.parseIdentifier(), r.asserts = i, r.typeAnnotation = null, t.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t);
        const d = this.tsParseTypeAnnotation(false);
        return r.parameterName = o, r.typeAnnotation = d, r.asserts = i, t.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const e = this.parseIdentifier();
      if (this.isContextual(113) && !this.hasPrecedingLineBreak())
        return this.next(), e;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 106)
        return false;
      const e = this.state.containsEsc;
      return this.next(), !Te(this.state.type) && !this.match(78) ? false : (e && this.raise(m.InvalidEscapedReservedWord, {
        at: this.state.lastTokStartLoc,
        reservedWord: "asserts"
      }), true);
    }
    tsParseTypeAnnotation(e = true, t = this.startNode()) {
      return this.tsInType(() => {
        e && this.expect(14), t.typeAnnotation = this.tsParseType();
      }), this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      Yr(this.state.inType);
      const e = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return e;
      const t = this.startNodeAtNode(e);
      return t.checkType = e, t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(120) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ve.ReservedTypeAssertion, {
        at: this.state.startLoc
      });
      const e = this.startNode(), t = this.tsTryNextParseConstantContext();
      return e.typeAnnotation = t || this.tsNextThenParseType(), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
    }
    tsParseHeritageClause(e) {
      const t = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const i = this.startNode();
        return i.expression = this.tsParseEntityName(), this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSExpressionWithTypeArguments");
      });
      return r.length || this.raise(ve.EmptyHeritageClauseType, {
        at: t,
        token: e
      }), r;
    }
    tsParseInterfaceDeclaration(e, t = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(125), t.declare && (e.declare = true), Te(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Es)) : (e.id = null, this.raise(ve.MissingInterfaceName, {
        at: this.state.startLoc
      })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
      const r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e) {
      return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, vs), e.typeAnnotation = this.tsInType(() => {
        if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(111) && this.lookahead().type !== 16) {
          const t = this.startNode();
          return this.next(), this.finishNode(t, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e) {
      const t = this.state.context;
      this.state.context = [t[0]];
      try {
        return e();
      } finally {
        this.state.context = t;
      }
    }
    tsInType(e) {
      const t = this.state.inType;
      this.state.inType = true;
      try {
        return e();
      } finally {
        this.state.inType = t;
      }
    }
    tsInDisallowConditionalTypesContext(e) {
      const t = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = t;
      }
    }
    tsInAllowConditionalTypesContext(e) {
      const t = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = t;
      }
    }
    tsEatThenParseType(e) {
      return this.match(e) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e) {
      return this.tsDoThenParseType(() => this.expect(e));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e) {
      return this.tsInType(() => (e(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e = this.startNode();
      return e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
    }
    tsParseEnumDeclaration(e, t = {}) {
      return t.const && (e.const = true), t.declare && (e.declare = true), this.expectContextual(122), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? Cs : Rr), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e = this.startNode();
      return this.scope.enter(At), this.expect(5), this.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e, t = false) {
      if (e.id = this.parseIdentifier(), t || this.checkIdentifier(e.id, ws), this.eat(16)) {
        const r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, true), e.body = r;
      } else
        this.scope.enter(qt), this.prodParam.enter(It), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e) {
      return this.isContextual(109) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(129) ? e.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(qt), this.prodParam.enter(It), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e, t) {
      e.isExport = t || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, nt), this.expect(29);
      const r = this.tsParseModuleReference();
      return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(ve.ImportAliasHasImportType, {
        at: r
      }), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(116) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e = this.startNode();
      if (this.expectContextual(116), this.expect(10), !this.match(129))
        throw this.unexpected();
      return e.expression = this.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
    }
    tsLookAhead(e) {
      const t = this.state.clone(), r = e();
      return this.state = t, r;
    }
    tsTryParseAndCatch(e) {
      const t = this.tryParse((r) => e() || r());
      if (!(t.aborted || !t.node))
        return t.error && (this.state = t.failState), t.node;
    }
    tsTryParse(e) {
      const t = this.state.clone(), r = e();
      if (r !== void 0 && r !== false)
        return r;
      this.state = t;
    }
    tsTryParseDeclare(e) {
      if (this.isLineTerminator())
        return;
      let t = this.state.type, r;
      return this.isContextual(99) && (t = 74, r = "let"), this.tsInAmbientContext(() => {
        if (t === 68)
          return e.declare = true, this.parseFunctionStatement(e, false, true);
        if (t === 80)
          return e.declare = true, this.parseClass(e, true, false);
        if (t === 122)
          return this.tsParseEnumDeclaration(e, {
            declare: true
          });
        if (t === 109)
          return this.tsParseAmbientExternalModuleDeclaration(e);
        if (t === 75 || t === 74)
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, r || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, {
            const: true,
            declare: true
          }));
        if (t === 125) {
          const i = this.tsParseInterfaceDeclaration(e, {
            declare: true
          });
          if (i)
            return i;
        }
        if (Te(t))
          return this.tsParseDeclaration(e, this.state.value, true);
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e, t) {
      switch (t.name) {
        case "declare": {
          const r = this.tsTryParseDeclare(e);
          if (r)
            return r.declare = true, r;
          break;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(qt), this.prodParam.enter(It);
            const r = e;
            return r.global = true, r.id = t, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e, t.name, false);
      }
    }
    tsParseDeclaration(e, t, r) {
      switch (t) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || Te(this.state.type)))
            return this.tsParseAbstractDeclaration(e);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(129))
              return this.tsParseAmbientExternalModuleDeclaration(e);
            if (Te(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(e);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && Te(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(e);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && Te(this.state.type))
            return this.tsParseTypeAliasDeclaration(e);
          break;
      }
    }
    tsCheckLineTerminator(e) {
      return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e, t) {
      if (!this.match(47))
        return;
      const r = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const i = this.tsTryParseAndCatch(() => {
        const o = this.startNodeAt(e, t);
        return o.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(o), o.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), o;
      });
      if (this.state.maybeInArrowParameters = r, !!i)
        return this.parseArrowExpression(i, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const e = this.startNode();
      return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(ve.EmptyTypeArguments, {
        at: e
      }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Re(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      let o, d = false, u = false;
      if (e !== void 0) {
        const U = {};
        this.tsParseModifiers({
          modified: U,
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }), o = U.accessibility, u = U.override, d = U.readonly, e === false && (o || d || u) && this.raise(ve.UnexpectedParameterModifier, {
          at: i
        });
      }
      const E = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(E);
      const w = this.parseMaybeDefault(E.start, E.loc.start, E);
      if (o || d || u) {
        const U = this.startNodeAt(r, i);
        return t.length && (U.decorators = t), o && (U.accessibility = o), d && (U.readonly = d), u && (U.override = u), w.type !== "Identifier" && w.type !== "AssignmentPattern" && this.raise(ve.UnsupportedParameterPropertyKind, {
          at: U
        }), U.parameter = w, this.finishNode(U, "TSParameterProperty");
      }
      return t.length && (E.decorators = t), w;
    }
    isSimpleParameter(e) {
      return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const i = t === "FunctionDeclaration" ? "TSDeclareFunction" : t === "ClassMethod" || t === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      if (i && !this.match(5) && this.isLineTerminator()) {
        this.finishNode(e, i);
        return;
      }
      if (i === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ve.DeclareFunctionHasImplementation, {
        at: e
      }), e.declare)) {
        super.parseFunctionBodyAndFinish(e, i, r);
        return;
      }
      super.parseFunctionBodyAndFinish(e, t, r);
    }
    registerFunctionStatementId(e) {
      !e.body && e.id ? this.checkIdentifier(e.id, Ur) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e) {
      e.forEach((t) => {
        (t == null ? void 0 : t.type) === "TSTypeCastExpression" && this.raise(ve.UnexpectedTypeAnnotation, {
          at: t.typeAnnotation
        });
      });
    }
    toReferencedList(e, t) {
      return this.tsCheckForInvalidTypeCasts(e), e;
    }
    parseArrayLike(...e) {
      const t = super.parseArrayLike(...e);
      return t.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t.elements), t;
    }
    parseSubscript(e, t, r, i, o) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        const u = this.startNodeAt(t, r);
        return u.expression = e, this.finishNode(u, "TSNonNullExpression");
      }
      let d = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return o.stop = true, e;
        o.optionalChainMember = d = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let u;
        const E = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(e)) {
            const ye = this.tsTryParseGenericAsyncArrowFunction(t, r);
            if (ye)
              return ye;
          }
          const w = this.tsParseTypeArgumentsInExpression();
          if (!w)
            return;
          if (d && !this.match(10)) {
            u = this.state.curPosition();
            return;
          }
          if (Ze(this.state.type)) {
            const ye = this.parseTaggedTemplateExpression(e, t, r, o);
            return ye.typeParameters = w, ye;
          }
          if (!i && this.eat(10)) {
            const ye = this.startNodeAt(t, r);
            return ye.callee = e, ye.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(ye.arguments), ye.typeParameters = w, o.optionalChainMember && (ye.optional = d), this.finishCallExpression(ye, o.optionalChainMember);
          }
          const U = this.state.type;
          if (U === 48 || U !== 10 && ce(U) && !this.hasPrecedingLineBreak())
            return;
          const ge = this.startNodeAt(t, r);
          return ge.expression = e, ge.typeParameters = w, this.finishNode(ge, "TSInstantiationExpression");
        });
        if (u && this.unexpected(u, 10), E)
          return E.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ve.InvalidPropertyAccessAfterInstantiationExpression, {
            at: this.state.startLoc
          }), E;
      }
      return super.parseSubscript(e, t, r, i, o);
    }
    parseNewCallee(e) {
      var t;
      super.parseNewCallee(e);
      const {
        callee: r
      } = e;
      r.type === "TSInstantiationExpression" && !((t = r.extra) != null && t.parenthesized) && (e.typeParameters = r.typeParameters, e.callee = r.expression);
    }
    parseExprOp(e, t, r, i) {
      if (Ge(58) > i && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
        const o = this.startNodeAt(t, r);
        o.expression = e;
        const d = this.tsTryNextParseConstantContext();
        return d ? o.typeAnnotation = d : o.typeAnnotation = this.tsNextThenParseType(), this.finishNode(o, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(o, t, r, i);
      }
      return super.parseExprOp(e, t, r, i);
    }
    checkReservedWord(e, t, r, i) {
      this.state.isAmbientContext || super.checkReservedWord(e, t, r, i);
    }
    checkDuplicateExports() {
    }
    parseImport(e) {
      if (e.importKind = "value", Te(this.state.type) || this.match(55) || this.match(5)) {
        let r = this.lookahead();
        if (this.isContextual(126) && r.type !== 12 && r.type !== 97 && r.type !== 29 && (e.importKind = "type", this.next(), r = this.lookahead()), Te(this.state.type) && r.type === 29)
          return this.tsParseImportEqualsDeclaration(e);
      }
      const t = super.parseImport(e);
      return t.importKind === "type" && t.specifiers.length > 1 && t.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ve.TypeImportCannotSpecifyDefaultAndNamed, {
        at: t
      }), t;
    }
    parseExport(e) {
      if (this.match(83))
        return this.next(), this.isContextual(126) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
      if (this.eat(29)) {
        const t = e;
        return t.expression = this.parseExpression(), this.semicolon(), this.finishNode(t, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const t = e;
        return this.expectContextual(124), t.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
      } else
        return this.isContextual(126) && this.lookahead().type === 5 ? (this.next(), e.exportKind = "type") : e.exportKind = "value", super.parseExport(e);
    }
    isAbstractClass() {
      return this.isContextual(120) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e = this.startNode();
        return this.next(), e.abstract = true, this.parseClass(e, true, true), e;
      }
      if (this.match(125)) {
        const e = this.tsParseInterfaceDeclaration(this.startNode());
        if (e)
          return e;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e, t, r = false) {
      const {
        isAmbientContext: i
      } = this.state, o = super.parseVarStatement(e, t, r || i);
      if (!i)
        return o;
      for (const {
        id: d,
        init: u
      } of o.declarations)
        !u || (t !== "const" || !!d.typeAnnotation ? this.raise(ve.InitializerNotAllowedInAmbientContext, {
          at: u
        }) : u.type !== "StringLiteral" && u.type !== "BooleanLiteral" && u.type !== "NumericLiteral" && u.type !== "BigIntLiteral" && (u.type !== "TemplateLiteral" || u.expressions.length > 0) && !gi(u) && this.raise(ve.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
          at: u
        }));
      return o;
    }
    parseStatementContent(e, t) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, {
          const: true
        });
      }
      if (this.isContextual(122))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(125)) {
        const r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r)
          return r;
      }
      return super.parseStatementContent(e, t);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e, t) {
      return t.some((r) => Qr(r) ? e.accessibility === r : !!e[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e, t, r) {
      const i = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        modified: t,
        allowedModifiers: i,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: ve.InvalidModifierOnTypeParameterPositions
      });
      const o = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, i) && this.raise(ve.StaticBlockCannotHaveModifier, {
          at: this.state.curPosition()
        }), this.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
      };
      t.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(e, t, r, i) {
      const o = this.tsTryParseIndexSignature(t);
      if (o) {
        e.body.push(o), t.abstract && this.raise(ve.IndexSignatureHasAbstract, {
          at: t
        }), t.accessibility && this.raise(ve.IndexSignatureHasAccessibility, {
          at: t,
          modifier: t.accessibility
        }), t.declare && this.raise(ve.IndexSignatureHasDeclare, {
          at: t
        }), t.override && this.raise(ve.IndexSignatureHasOverride, {
          at: t
        });
        return;
      }
      !this.state.inAbstractClass && t.abstract && this.raise(ve.NonAbstractClassHasAbstractMethod, {
        at: t
      }), t.override && (r.hadSuperClass || this.raise(ve.OverrideNotInSubClass, {
        at: t
      })), super.parseClassMemberWithIsStatic(e, t, r, i);
    }
    parsePostMemberNameModifiers(e) {
      this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(ve.ClassMethodHasReadonly, {
        at: e
      }), e.declare && this.match(10) && this.raise(ve.ClassMethodHasDeclare, {
        at: e
      });
    }
    parseExpressionStatement(e, t) {
      return (t.type === "Identifier" ? this.tsParseExpressionStatement(e, t) : void 0) || super.parseExpressionStatement(e, t);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
    }
    parseConditional(e, t, r, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(e, t, r, i);
      const o = this.tryParse(() => super.parseConditional(e, t, r));
      return o.node ? (o.error && (this.state = o.failState), o.node) : (o.error && super.setOptionalParametersError(i, o.error), e);
    }
    parseParenItem(e, t, r) {
      if (e = super.parseParenItem(e, t, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        const i = this.startNodeAt(t, r);
        return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
      }
      return e;
    }
    parseExportDeclaration(e) {
      if (!this.state.isAmbientContext && this.isContextual(121))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
      const t = this.state.start, r = this.state.startLoc, i = this.eatContextual(121);
      if (i && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
        throw this.raise(ve.ExpectedAmbientAfterExportDeclare, {
          at: this.state.startLoc
        });
      const d = Te(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
      return d ? ((d.type === "TSInterfaceDeclaration" || d.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(d, t, r), d.declare = true), d) : null;
    }
    parseClassId(e, t, r) {
      if ((!t || r) && this.isContextual(110))
        return;
      super.parseClassId(e, t, r, e.declare ? Ur : Fr);
      const i = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
      i && (e.typeParameters = i);
    }
    parseClassPropertyAnnotation(e) {
      !e.optional && this.eat(35) && (e.definite = true);
      const t = this.tsTryParseTypeAnnotation();
      t && (e.typeAnnotation = t);
    }
    parseClassProperty(e) {
      if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && this.match(29) && this.raise(ve.DeclareClassFieldHasInitializer, {
        at: this.state.startLoc
      }), e.abstract && this.match(29)) {
        const {
          key: t
        } = e;
        this.raise(ve.AbstractPropertyHasInitializer, {
          at: this.state.startLoc,
          propertyName: t.type === "Identifier" && !e.computed ? t.name : `[${this.input.slice(t.start, t.end)}]`
        });
      }
      return super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return e.abstract && this.raise(ve.PrivateElementHasAbstract, {
        at: e
      }), e.accessibility && this.raise(ve.PrivateElementHasAccessibility, {
        at: e,
        modifier: e.accessibility
      }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
    }
    pushClassMethod(e, t, r, i, o, d) {
      const u = this.tsTryParseTypeParameters();
      u && o && this.raise(ve.ConstructorHasTypeParameters, {
        at: u
      });
      const {
        declare: E = false,
        kind: w
      } = t;
      E && (w === "get" || w === "set") && this.raise(ve.DeclareAccessor, {
        at: t,
        kind: w
      }), u && (t.typeParameters = u), super.pushClassMethod(e, t, r, i, o, d);
    }
    pushClassPrivateMethod(e, t, r, i) {
      const o = this.tsTryParseTypeParameters();
      o && (t.typeParameters = o), super.pushClassPrivateMethod(e, t, r, i);
    }
    declareClassPrivateMethodInScope(e, t) {
      e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, t));
    }
    parseClassSuper(e) {
      super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(110) && (e.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e, ...t) {
      const r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseObjPropValue(e, ...t);
    }
    parseFunctionParams(e, t) {
      const r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseFunctionParams(e, t);
    }
    parseVarId(e, t) {
      super.parseVarId(e, t), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
      const r = this.tsTryParseTypeAnnotation();
      r && (e.id.typeAnnotation = r, this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, t) {
      return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
    }
    parseMaybeAssign(...e) {
      var t, r, i, o, d, u, E;
      let w, U, ge;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (w = this.state.clone(), U = this.tryParse(() => super.parseMaybeAssign(...e), w), !U.error)
          return U.node;
        const {
          context: Oe
        } = this.state, Ve = Oe[Oe.length - 1];
        (Ve === j.j_oTag || Ve === j.j_expr) && Oe.pop();
      }
      if (!((t = U) != null && t.error) && !this.match(47))
        return super.parseMaybeAssign(...e);
      (!w || w === this.state) && (w = this.state.clone());
      let ye;
      const Ae = this.tryParse((Oe) => {
        var Ve, Ke;
        ye = this.tsParseTypeParameters();
        const He = super.parseMaybeAssign(...e);
        return (He.type !== "ArrowFunctionExpression" || (Ve = He.extra) != null && Ve.parenthesized) && Oe(), ((Ke = ye) == null ? void 0 : Ke.params.length) !== 0 && this.resetStartLocationFromNode(He, ye), He.typeParameters = ye, He;
      }, w);
      if (!Ae.error && !Ae.aborted)
        return ye && this.reportReservedArrowTypeParam(ye), Ae.node;
      if (!U && (Yr(!this.hasPlugin("jsx")), ge = this.tryParse(() => super.parseMaybeAssign(...e), w), !ge.error))
        return ge.node;
      if ((r = U) != null && r.node)
        return this.state = U.failState, U.node;
      if (Ae.node)
        return this.state = Ae.failState, ye && this.reportReservedArrowTypeParam(ye), Ae.node;
      if ((i = ge) != null && i.node)
        return this.state = ge.failState, ge.node;
      throw (o = U) != null && o.thrown ? U.error : Ae.thrown ? Ae.error : (d = ge) != null && d.thrown ? ge.error : ((u = U) == null ? void 0 : u.error) || Ae.error || ((E = ge) == null ? void 0 : E.error);
    }
    reportReservedArrowTypeParam(e) {
      var t;
      e.params.length === 1 && !((t = e.extra) != null && t.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ve.ReservedArrowTypeParam, {
        at: e
      });
    }
    parseMaybeUnary(e) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const t = this.tryParse((r) => {
          const i = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), i;
        });
        if (t.aborted)
          return;
        t.thrown || (t.error && (this.state = t.failState), e.returnType = t.node);
      }
      return super.parseArrow(e);
    }
    parseAssignableListItemTypes(e) {
      this.eat(17) && (e.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(ve.PatternIsOptional, {
        at: e
      }), e.optional = true);
      const t = this.tsTryParseTypeAnnotation();
      return t && (e.typeAnnotation = t), this.resetEndLocation(e), e;
    }
    isAssignable(e, t) {
      switch (e.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e.expression, t);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e, t);
      }
    }
    toAssignable(e, t = false) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e, t);
          break;
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          t ? this.expressionScope.recordArrowParemeterBindingError(ve.UnexpectedTypeCastInParameter, {
            at: e
          }) : this.raise(ve.UnexpectedTypeCastInParameter, {
            at: e
          }), this.toAssignable(e.expression, t);
          break;
        case "AssignmentExpression":
          !t && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
        default:
          super.toAssignable(e, t);
      }
    }
    toAssignableParenthesizedExpression(e, t) {
      switch (e.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, t);
          break;
        default:
          super.toAssignable(e, t);
      }
    }
    checkToRestConversion(e, t) {
      switch (e.type) {
        case "TSAsExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e.expression, false);
          break;
        default:
          super.checkToRestConversion(e, t);
      }
    }
    isValidLVal(e, t, r) {
      return hi({
        TSTypeCastExpression: true,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (r !== Pt || !t) && ["expression", true],
        TSTypeAssertion: (r !== Pt || !t) && ["expression", true]
      }, e) || super.isValidLVal(e, t, r);
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e) {
      if (this.match(47) || this.match(51)) {
        const t = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const r = super.parseMaybeDecoratorArguments(e);
          return r.typeParameters = t, r;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e);
    }
    checkCommaAfterRest(e) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(...e) {
      const t = super.parseMaybeDefault(...e);
      return t.type === "AssignmentPattern" && t.typeAnnotation && t.right.start < t.typeAnnotation.start && this.raise(ve.TypeAnnotationAfterAssign, {
        at: t.typeAnnotation
      }), t;
    }
    getTokenFromCode(e) {
      if (this.state.inType) {
        if (e === 62)
          return this.finishOp(48, 1);
        if (e === 60)
          return this.finishOp(47, 1);
      }
      return super.getTokenFromCode(e);
    }
    reScan_lt_gt() {
      const {
        type: e
      } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: e
      } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    toAssignableList(e) {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        (r == null ? void 0 : r.type) === "TSTypeCastExpression" && (e[t] = this.typeCastToParameter(r));
      }
      super.toAssignableList(...arguments);
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    shouldParseArrow(e) {
      return this.match(14) ? e.every((t) => this.isAssignable(t, true)) : super.shouldParseArrow(e);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e) {
      if (this.match(47) || this.match(51)) {
        const t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        t && (e.typeParameters = t);
      }
      return super.jsxParseOpeningElementAfterName(e);
    }
    getGetterSetterExpectedParamCount(e) {
      const t = super.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e)[0];
      return i && this.isThisParam(i) ? t + 1 : t;
    }
    parseCatchClauseParam() {
      const e = super.parseCatchClauseParam(), t = this.tsTryParseTypeAnnotation();
      return t && (e.typeAnnotation = t, this.resetEndLocation(e)), e;
    }
    tsInAmbientContext(e) {
      const t = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e();
      } finally {
        this.state.isAmbientContext = t;
      }
    }
    parseClass(e, ...t) {
      const r = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e.abstract;
      try {
        return super.parseClass(e, ...t);
      } finally {
        this.state.inAbstractClass = r;
      }
    }
    tsParseAbstractDeclaration(e) {
      if (this.match(80))
        return e.abstract = true, this.parseClass(e, true, false);
      if (this.isContextual(125)) {
        if (!this.hasFollowingLineBreak())
          return e.abstract = true, this.raise(ve.NonClassMethodPropertyHasAbstractModifer, {
            at: e
          }), this.tsParseInterfaceDeclaration(e);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(...e) {
      const t = super.parseMethod(...e);
      if (t.abstract && (this.hasPlugin("estree") ? !!t.value.body : !!t.body)) {
        const {
          key: i
        } = t;
        this.raise(ve.AbstractMethodHasImplementation, {
          at: t,
          methodName: i.type === "Identifier" && !t.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
        });
      }
      return t;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e, t, r, i) {
      return !t && i ? (this.parseTypeOnlyImportExportSpecifier(e, false, r), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, t, r, i));
    }
    parseImportSpecifier(e, t, r, i) {
      return !t && i ? (this.parseTypeOnlyImportExportSpecifier(e, true, r), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, t, r, i));
    }
    parseTypeOnlyImportExportSpecifier(e, t, r) {
      const i = t ? "imported" : "local", o = t ? "local" : "exported";
      let d = e[i], u, E = false, w = true;
      const U = d.loc.start;
      if (this.isContextual(93)) {
        const ye = this.parseIdentifier();
        if (this.isContextual(93)) {
          const Ae = this.parseIdentifier();
          z(this.state.type) ? (E = true, d = ye, u = t ? this.parseIdentifier() : this.parseModuleExportName(), w = false) : (u = Ae, w = false);
        } else
          z(this.state.type) ? (w = false, u = t ? this.parseIdentifier() : this.parseModuleExportName()) : (E = true, d = ye);
      } else
        z(this.state.type) && (E = true, t ? (d = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(d.name, d.loc.start, true, true)) : d = this.parseModuleExportName());
      E && r && this.raise(t ? ve.TypeModifierIsUsedInTypeImports : ve.TypeModifierIsUsedInTypeExports, {
        at: U
      }), e[i] = d, e[o] = u;
      const ge = t ? "importKind" : "exportKind";
      e[ge] = E ? "type" : "value", w && this.eatContextual(93) && (e[o] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[o] || (e[o] = at(e[i])), t && this.checkIdentifier(e[o], nt);
    }
  };
  function gi(a) {
    if (a.type !== "MemberExpression")
      return false;
    const {
      computed: e,
      property: t
    } = a;
    return e && t.type !== "StringLiteral" && (t.type !== "TemplateLiteral" || t.expressions.length > 0) ? false : Zr(a.object);
  }
  function Zr(a) {
    return a.type === "Identifier" ? true : a.type !== "MemberExpression" || a.computed ? false : Zr(a.object);
  }
  const es = _`placeholders`((a) => ({
    ClassNameIsRequired: a("A class name is required."),
    UnexpectedSpace: a("Unexpected space in placeholder.")
  }));
  var Ti = (a) => class extends a {
    parsePlaceholder(e) {
      if (this.match(140)) {
        const t = this.startNode();
        return this.next(), this.assertNoSpace(), t.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(140), this.finishPlaceholder(t, e);
      }
    }
    finishPlaceholder(e, t) {
      const r = !!(e.expectedNode && e.type === "Placeholder");
      return e.expectedNode = t, r ? e : this.finishNode(e, "Placeholder");
    }
    getTokenFromCode(e) {
      return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(140, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e) {
      e !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    isValidLVal(e, ...t) {
      return e === "Placeholder" || super.isValidLVal(e, ...t);
    }
    toAssignable(e) {
      e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(...arguments);
    }
    isLet(e) {
      return super.isLet(e) ? true : !this.isContextual(99) || e ? false : this.lookahead().type === 140;
    }
    verifyBreakContinue(e) {
      e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e, t) {
      if (t.type !== "Placeholder" || t.extra && t.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(14)) {
        const r = e;
        return r.label = this.finishPlaceholder(t, "Identifier"), this.next(), r.body = this.parseStatement("label"), this.finishNode(r, "LabeledStatement");
      }
      return this.semicolon(), e.name = t.name, this.finishPlaceholder(e, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e, t, r) {
      const i = t ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e);
      const o = this.state.strict, d = this.parsePlaceholder("Identifier");
      if (d)
        if (this.match(81) || this.match(140) || this.match(5))
          e.id = d;
        else {
          if (r || !t)
            return e.id = null, e.body = this.finishPlaceholder(d, "ClassBody"), this.finishNode(e, i);
          throw this.raise(es.ClassNameIsRequired, {
            at: this.state.startLoc
          });
        }
      else
        this.parseClassId(e, t, r);
      return this.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e.superClass, o), this.finishNode(e, i);
    }
    parseExport(e) {
      const t = this.parsePlaceholder("Identifier");
      if (!t)
        return super.parseExport(...arguments);
      if (!this.isContextual(97) && !this.match(12))
        return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(t, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const r = this.startNode();
      return r.exported = t, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], super.parseExport(e);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const e = this.nextTokenStart();
        if (this.isUnparsedContextual(e, "from") && this.input.startsWith($e(140), this.nextTokenStartSince(e + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e) {
      return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e) {
      const {
        specifiers: t
      } = e;
      t != null && t.length && (e.specifiers = t.filter((r) => r.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = t;
    }
    parseImport(e) {
      const t = this.parsePlaceholder("Identifier");
      if (!t)
        return super.parseImport(...arguments);
      if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
        return e.source = this.finishPlaceholder(t, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
      const r = this.startNodeAtNode(t);
      return r.local = t, this.finishNode(r, "ImportDefaultSpecifier"), e.specifiers.push(r), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(es.UnexpectedSpace, {
        at: this.state.lastTokEndLoc
      });
    }
  }, xi = (a) => class extends a {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const e = this.state.startLoc, t = this.startNode();
        if (this.next(), Te(this.state.type)) {
          const r = this.parseIdentifierName(this.state.start), i = this.createIdentifier(t, r);
          if (i.type = "V8IntrinsicIdentifier", this.match(10))
            return i;
        }
        this.unexpected(e);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  };
  function ze(a, e) {
    const [t, r] = typeof e == "string" ? [e, {}] : e, i = Object.keys(r), o = i.length === 0;
    return a.some((d) => {
      if (typeof d == "string")
        return o && d === t;
      {
        const [u, E] = d;
        if (u !== t)
          return false;
        for (const w of i)
          if (E[w] !== r[w])
            return false;
        return true;
      }
    });
  }
  function Ft(a, e, t) {
    const r = a.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return r && Array.isArray(r) ? r[1][t] : null;
  }
  const ts = ["minimal", "fsharp", "hack", "smart"], rs = ["^^", "@@", "^", "%", "#"], ss = ["hash", "bar"];
  function Pi(a) {
    if (ze(a, "decorators")) {
      if (ze(a, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const e = Ft(a, "decorators", "decoratorsBeforeExport");
      if (e == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (ze(a, "flow") && ze(a, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (ze(a, "placeholders") && ze(a, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (ze(a, "pipelineOperator")) {
      const e = Ft(a, "pipelineOperator", "proposal");
      if (!ts.includes(e)) {
        const r = ts.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`);
      }
      const t = ze(a, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (e === "hack") {
        if (ze(a, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (ze(a, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const r = Ft(a, "pipelineOperator", "topicToken");
        if (!rs.includes(r)) {
          const i = rs.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
        }
        if (r === "#" && t)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (e === "smart" && t)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (ze(a, "moduleAttributes")) {
      if (ze(a, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Ft(a, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (ze(a, "recordAndTuple") && !ss.includes(Ft(a, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + ss.map((e) => `'${e}'`).join(", "));
    if (ze(a, "asyncDoExpressions") && !ze(a, "doExpressions")) {
      const e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
  }
  const is = {
    estree: B,
    jsx: ci,
    flow: li,
    typescript: bi,
    v8intrinsic: xi,
    placeholders: Ti
  }, Si = Object.keys(is), ns = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true
  };
  function Ei(a) {
    const e = {};
    for (const t of Object.keys(ns))
      e[t] = a && a[t] != null ? a[t] : ns[t];
    return e;
  }
  const vi = (a, e) => Object.hasOwnProperty.call(a, e) && a[e], as = (a) => a.type === "ParenthesizedExpression" ? as(a.expression) : a;
  class Ai extends ri {
    toAssignable(e, t = false) {
      var r, i;
      let o;
      switch ((e.type === "ParenthesizedExpression" || (r = e.extra) != null && r.parenthesized) && (o = as(e), t ? o.type === "Identifier" ? this.expressionScope.recordArrowParemeterBindingError(m.InvalidParenthesizedAssignment, {
        at: e
      }) : o.type !== "MemberExpression" && this.raise(m.InvalidParenthesizedAssignment, {
        at: e
      }) : this.raise(m.InvalidParenthesizedAssignment, {
        at: e
      })), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let u = 0, E = e.properties.length, w = E - 1; u < E; u++) {
            var d;
            const U = e.properties[u], ge = u === w;
            this.toAssignableObjectExpressionProp(U, ge, t), ge && U.type === "RestElement" && (d = e.extra) != null && d.trailingCommaLoc && this.raise(m.RestTrailingComma, {
              at: e.extra.trailingCommaLoc
            });
          }
          break;
        case "ObjectProperty": {
          const {
            key: u,
            value: E
          } = e;
          this.isPrivateName(u) && this.classScope.usePrivateName(this.getPrivateNameSV(u), u.loc.start), this.toAssignable(E, t);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, t);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(m.MissingEqInAssignment, {
            at: e.left.loc.end
          }), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(o, t);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, t, r) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? m.PatternHasAccessor : m.PatternHasMethod, {
          at: e.key
        });
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        const i = e.argument;
        this.checkToRestConversion(i, false), this.toAssignable(i, r), t || this.raise(m.RestTrailingComma, {
          at: e
        });
      } else
        this.toAssignable(e, r);
    }
    toAssignableList(e, t, r) {
      const i = e.length - 1;
      for (let o = 0; o <= i; o++) {
        const d = e[o];
        if (!!d) {
          if (d.type === "SpreadElement") {
            d.type = "RestElement";
            const u = d.argument;
            this.checkToRestConversion(u, true), this.toAssignable(u, r);
          } else
            this.toAssignable(d, r);
          d.type === "RestElement" && (o < i ? this.raise(m.RestTrailingComma, {
            at: d
          }) : t && this.raise(m.RestTrailingComma, {
            at: t
          }));
        }
      }
    }
    isAssignable(e, t) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const r = e.properties.length - 1;
          return e.properties.every((i, o) => i.type !== "ObjectMethod" && (o === r || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((r) => r === null || this.isAssignable(r));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t;
        default:
          return false;
      }
    }
    toReferencedList(e, t) {
      return e;
    }
    toReferencedListDeep(e, t) {
      this.toReferencedList(e, t);
      for (const r of e)
        (r == null ? void 0 : r.type) === "ArrayExpression" && this.toReferencedListDeep(r.elements);
    }
    parseSpread(e, t) {
      const r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0, t), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      const e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, true), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, t, r, i) {
      const o = [];
      let d = true;
      for (; !this.eat(e); )
        if (d ? d = false : this.expect(12), r && this.match(12))
          o.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (o.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(t)) {
              this.expect(e);
              break;
            }
          } else {
            const u = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(m.UnsupportedParameterDecorator, {
              at: this.state.startLoc
            }); this.match(26); )
              u.push(this.parseDecorator());
            o.push(this.parseAssignableListItem(i, u));
          }
        }
      return o;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      const e = this.startNode(), {
        type: t,
        start: r,
        startLoc: i
      } = this.state;
      return t === 21 ? this.parseBindingRestProperty(e) : (t === 134 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(this.state.value, i), e.key = this.parsePrivateName()) : this.parsePropertyName(e), e.method = false, this.parseObjPropValue(e, r, i, false, false, true, false), e);
    }
    parseAssignableListItem(e, t) {
      const r = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(r);
      const i = this.parseMaybeDefault(r.start, r.loc.start, r);
      return t.length && (r.decorators = t), i;
    }
    parseAssignableListItemTypes(e) {
      return e;
    }
    parseMaybeDefault(e, t, r) {
      var i, o, d;
      if (t = (i = t) != null ? i : this.state.startLoc, e = (o = e) != null ? o : this.state.start, r = (d = r) != null ? d : this.parseBindingAtom(), !this.eat(29))
        return r;
      const u = this.startNodeAt(e, t);
      return u.left = r, u.right = this.parseMaybeAssignAllowIn(), this.finishNode(u, "AssignmentPattern");
    }
    isValidLVal(e, t, r) {
      return vi({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    checkLVal(e, {
      in: t,
      binding: r = Pt,
      checkClashes: i = false,
      strictModeChanged: o = false,
      allowingSloppyLetBinding: d = !(r & pt),
      hasParenthesizedAncestor: u = false
    }) {
      var E;
      const w = e.type;
      if (this.isObjectMethod(e))
        return;
      if (w === "MemberExpression") {
        r !== Pt && this.raise(m.InvalidPropertyBindingPattern, {
          at: e
        });
        return;
      }
      if (e.type === "Identifier") {
        this.checkIdentifier(e, r, o, d);
        const {
          name: Oe
        } = e;
        i && (i.has(Oe) ? this.raise(m.ParamDupe, {
          at: e
        }) : i.add(Oe));
        return;
      }
      const U = this.isValidLVal(e.type, !(u || (E = e.extra) != null && E.parenthesized) && t.type === "AssignmentExpression", r);
      if (U === true)
        return;
      if (U === false) {
        const Oe = r === Pt ? m.InvalidLhs : m.InvalidLhsBinding;
        this.raise(Oe, {
          at: e,
          ancestor: t.type === "UpdateExpression" ? {
            type: "UpdateExpression",
            prefix: t.prefix
          } : {
            type: t.type
          }
        });
        return;
      }
      const [ge, ye] = Array.isArray(U) ? U : [U, w === "ParenthesizedExpression"], Ae = e.type === "ArrayPattern" || e.type === "ObjectPattern" || e.type === "ParenthesizedExpression" ? e : t;
      for (const Oe of [].concat(e[ge]))
        Oe && this.checkLVal(Oe, {
          in: Ae,
          binding: r,
          checkClashes: i,
          allowingSloppyLetBinding: d,
          strictModeChanged: o,
          hasParenthesizedAncestor: ye
        });
    }
    checkIdentifier(e, t, r = false, i = !(t & pt)) {
      this.state.strict && (r ? De(e.name, this.inModule) : qe(e.name)) && (t === Pt ? this.raise(m.StrictEvalArguments, {
        at: e,
        referenceName: e.name
      }) : this.raise(m.StrictEvalArgumentsBinding, {
        at: e,
        bindingName: e.name
      })), !i && e.name === "let" && this.raise(m.LetInLexicalBinding, {
        at: e
      }), t & Pt || this.declareNameFromIdentifier(e, t);
    }
    declareNameFromIdentifier(e, t) {
      this.scope.declareName(e.name, t, e.loc.start);
    }
    checkToRestConversion(e, t) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, t);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (t)
            break;
        default:
          this.raise(m.InvalidRestAssignmentPattern, {
            at: e
          });
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? m.RestTrailingComma : m.ElementAfterRest, {
        at: this.state.startLoc
      }), true) : false;
    }
  }
  class Ci extends Ai {
    checkProto(e, t, r, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      const o = e.key;
      if ((o.type === "Identifier" ? o.name : o.value) === "__proto__") {
        if (t) {
          this.raise(m.RecordNoProto, {
            at: o
          });
          return;
        }
        r.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = o.loc.start) : this.raise(m.DuplicateProto, {
          at: o
        })), r.used = true;
      }
    }
    shouldExitDescending(e, t) {
      return e.type === "ArrowFunctionExpression" && e.start === t;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e = this.parseExpression();
      return this.match(135) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.state.comments, e.errors = this.state.errors, this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, t) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
    }
    parseExpressionBase(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        const o = this.startNodeAt(t, r);
        for (o.expressions = [i]; this.eat(12); )
          o.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(o.expressions), this.finishNode(o, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, t) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
    }
    parseMaybeAssignAllowIn(e, t) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, t));
    }
    setOptionalParametersError(e, t) {
      var r;
      e.optionalParametersLoc = (r = t == null ? void 0 : t.loc) != null ? r : this.state.startLoc;
    }
    parseMaybeAssign(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      if (this.isContextual(105) && this.prodParam.hasYield) {
        let E = this.parseYield();
        return t && (E = t.call(this, E, r, i)), E;
      }
      let o;
      e ? o = false : (e = new Zt(), o = true);
      const {
        type: d
      } = this.state;
      (d === 10 || Te(d)) && (this.state.potentialArrowAt = this.state.start);
      let u = this.parseMaybeConditional(e);
      if (t && (u = t.call(this, u, r, i)), xe(this.state.type)) {
        const E = this.startNodeAt(r, i), w = this.state.value;
        return E.operator = w, this.match(29) ? (this.toAssignable(u, true), E.left = u, e.doubleProtoLoc != null && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), e.privateKeyLoc = null)) : E.left = u, this.next(), E.right = this.parseMaybeAssign(), this.checkLVal(u, {
          in: this.finishNode(E, "AssignmentExpression")
        }), E;
      } else
        o && this.checkExpressionErrors(e, true);
      return u;
    }
    parseMaybeConditional(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseExprOps(e);
      return this.shouldExitDescending(o, i) ? o : this.parseConditional(o, t, r, e);
    }
    parseConditional(e, t, r, i) {
      if (this.eat(17)) {
        const o = this.startNodeAt(t, r);
        return o.test = e, o.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), o.alternate = this.parseMaybeAssign(), this.finishNode(o, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(o, i) ? o : this.parseExprOp(o, t, r, -1);
    }
    parseExprOp(e, t, r, i) {
      if (this.isPrivateName(e)) {
        const d = this.getPrivateNameSV(e);
        (i >= Ge(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(m.PrivateInExpectedIn, {
          at: e,
          identifierName: d
        }), this.classScope.usePrivateName(d, e.loc.start);
      }
      const o = this.state.type;
      if (J(o) && (this.prodParam.hasIn || !this.match(58))) {
        let d = Ge(o);
        if (d > i) {
          if (o === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          const u = this.startNodeAt(t, r);
          u.left = e, u.operator = this.state.value;
          const E = o === 41 || o === 42, w = o === 40;
          if (w && (d = Ge(42)), this.next(), o === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(m.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc
            });
          u.right = this.parseExprOpRightExpr(o, d), this.finishNode(u, E || w ? "LogicalExpression" : "BinaryExpression");
          const U = this.state.type;
          if (w && (U === 41 || U === 42) || E && U === 40)
            throw this.raise(m.MixingCoalesceWithLogical, {
              at: this.state.startLoc
            });
          return this.parseExprOp(u, t, r, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(105))
                  throw this.raise(m.PipeBodyIsTighter, {
                    at: this.state.startLoc
                  });
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r, i);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, t);
      }
    }
    parseExprOpBaseRightExpr(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, i, lt(e) ? t - 1 : t);
    }
    parseHackPipeBody() {
      var e;
      const {
        startLoc: t
      } = this.state, r = this.parseMaybeAssign();
      return T.has(r.type) && !((e = r.extra) != null && e.parenthesized) && this.raise(m.PipeUnparenthesizedBody, {
        at: t,
        type: r.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(m.PipeTopicUnused, {
        at: t
      }), r;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(m.UnexpectedTokenUnaryExponentiation, {
        at: e.argument
      });
    }
    parseMaybeUnary(e, t) {
      const r = this.state.start, i = this.state.startLoc, o = this.isContextual(96);
      if (o && this.isAwaitAllowed()) {
        this.next();
        const w = this.parseAwait(r, i);
        return t || this.checkExponentialAfterUnary(w), w;
      }
      const d = this.match(34), u = this.startNode();
      if (ke(this.state.type)) {
        u.operator = this.state.value, u.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        const w = this.match(89);
        if (this.next(), u.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e, true), this.state.strict && w) {
          const U = u.argument;
          U.type === "Identifier" ? this.raise(m.StrictDelete, {
            at: u
          }) : this.hasPropertyAsPrivateName(U) && this.raise(m.DeletePrivateField, {
            at: u
          });
        }
        if (!d)
          return t || this.checkExponentialAfterUnary(u), this.finishNode(u, "UnaryExpression");
      }
      const E = this.parseUpdate(u, d, e);
      if (o) {
        const {
          type: w
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ce(w) : ce(w) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(m.AwaitNotInAsyncContext, {
            at: i
          }), this.parseAwait(r, i);
      }
      return E;
    }
    parseUpdate(e, t, r) {
      if (t)
        return this.checkLVal(e.argument, {
          in: this.finishNode(e, "UpdateExpression")
        }), e;
      const i = this.state.start, o = this.state.startLoc;
      let d = this.parseExprSubscripts(r);
      if (this.checkExpressionErrors(r, false))
        return d;
      for (; me(this.state.type) && !this.canInsertSemicolon(); ) {
        const u = this.startNodeAt(i, o);
        u.operator = this.state.value, u.prefix = false, u.argument = d, this.next(), this.checkLVal(d, {
          in: d = this.finishNode(u, "UpdateExpression")
        });
      }
      return d;
    }
    parseExprSubscripts(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseExprAtom(e);
      return this.shouldExitDescending(o, i) ? o : this.parseSubscripts(o, t, r);
    }
    parseSubscripts(e, t, r, i) {
      const o = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: false
      };
      do
        e = this.parseSubscript(e, t, r, i, o), o.maybeAsyncArrow = false;
      while (!o.stop);
      return e;
    }
    parseSubscript(e, t, r, i, o) {
      const {
        type: d
      } = this.state;
      if (!i && d === 15)
        return this.parseBind(e, t, r, i, o);
      if (Ze(d))
        return this.parseTaggedTemplateExpression(e, t, r, o);
      let u = false;
      if (d === 18) {
        if (i && this.lookaheadCharCode() === 40)
          return o.stop = true, e;
        o.optionalChainMember = u = true, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, t, r, o, u);
      {
        const E = this.eat(0);
        return E || u || this.eat(16) ? this.parseMember(e, t, r, o, E, u) : (o.stop = true, e);
      }
    }
    parseMember(e, t, r, i, o, d) {
      const u = this.startNodeAt(t, r);
      return u.object = e, u.computed = o, o ? (u.property = this.parseExpression(), this.expect(3)) : this.match(134) ? (e.type === "Super" && this.raise(m.SuperPrivateField, {
        at: r
      }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), u.property = this.parsePrivateName()) : u.property = this.parseIdentifier(true), i.optionalChainMember ? (u.optional = d, this.finishNode(u, "OptionalMemberExpression")) : this.finishNode(u, "MemberExpression");
    }
    parseBind(e, t, r, i, o) {
      const d = this.startNodeAt(t, r);
      return d.object = e, this.next(), d.callee = this.parseNoCallExpr(), o.stop = true, this.parseSubscripts(this.finishNode(d, "BindExpression"), t, r, i);
    }
    parseCoverCallAndAsyncArrowHead(e, t, r, i, o) {
      const d = this.state.maybeInArrowParameters;
      let u = null;
      this.state.maybeInArrowParameters = true, this.next();
      let E = this.startNodeAt(t, r);
      E.callee = e;
      const {
        maybeAsyncArrow: w,
        optionalChainMember: U
      } = i;
      return w && (this.expressionScope.enter(Ys()), u = new Zt()), U && (E.optional = o), o ? E.arguments = this.parseCallExpressionArguments(11) : E.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", E, u), this.finishCallExpression(E, U), w && this.shouldParseAsyncArrow() && !o ? (i.stop = true, this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), E = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t, r), E)) : (w && (this.checkExpressionErrors(u, true), this.expressionScope.exit()), this.toReferencedArguments(E)), this.state.maybeInArrowParameters = d, E;
    }
    toReferencedArguments(e, t) {
      this.toReferencedListDeep(e.arguments, t);
    }
    parseTaggedTemplateExpression(e, t, r, i) {
      const o = this.startNodeAt(t, r);
      return o.tag = e, o.quasi = this.parseTemplate(true), i.optionalChainMember && this.raise(m.OptionalChainingNoTemplate, {
        at: r
      }), this.finishNode(o, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    finishCallExpression(e, t) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(m.ImportCallArity, {
            at: e,
            maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        else
          for (const r of e.arguments)
            r.type === "SpreadElement" && this.raise(m.ImportCallSpreadArgument, {
              at: r
            });
      return this.finishNode(e, t ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, t, r, i, o) {
      const d = [];
      let u = true;
      const E = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e); ) {
        if (u)
          u = false;
        else if (this.expect(12), this.match(e)) {
          t && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(m.ImportCallArgumentTrailingComma, {
            at: this.state.lastTokStartLoc
          }), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        d.push(this.parseExprListItem(false, o, r));
      }
      return this.state.inFSharpPipelineDirectBody = E, d;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, t) {
      var r;
      return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, true, (r = t.extra) == null ? void 0 : r.trailingCommaLoc), t.innerComments && Bt(e, t.innerComments), t.callee.trailingComments && Bt(e, t.callee.trailingComments), e;
    }
    parseNoCallExpr() {
      const e = this.state.start, t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, t, true);
    }
    parseExprAtom(e) {
      let t;
      const {
        type: r
      } = this.state;
      switch (r) {
        case 79:
          return this.parseSuper();
        case 83:
          return t = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : (this.match(10) || this.raise(m.UnsupportedImport, {
            at: this.state.lastTokStartLoc
          }), this.finishNode(t, "Import"));
        case 78:
          return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 130:
          return this.parseNumericLiteral(this.state.value);
        case 131:
          return this.parseBigIntLiteral(this.state.value);
        case 132:
          return this.parseDecimalLiteral(this.state.value);
        case 129:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const i = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(i);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          this.parseDecorators();
        case 80:
          return t = this.startNode(), this.takeDecorators(t), this.parseClass(t, false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          t = this.startNode(), this.next(), t.object = null;
          const i = t.callee = this.parseNoCallExpr();
          if (i.type === "MemberExpression")
            return this.finishNode(t, "BindExpression");
          throw this.raise(m.UnsupportedBind, {
            at: i
          });
        }
        case 134:
          return this.raise(m.PrivateInExpectedIn, {
            at: this.state.startLoc,
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const i = this.getPluginOption("pipelineOperator", "proposal");
          if (i)
            return this.parseTopicReference(i);
          throw this.unexpected();
        }
        case 47: {
          const i = this.input.codePointAt(this.nextTokenStart());
          if (Ne(i) || i === 62) {
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
            break;
          } else
            throw this.unexpected();
        }
        default:
          if (Te(r)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression();
            const i = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, d = this.parseIdentifier();
            if (!o && d.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(d), this.next(), this.parseFunction(this.startNodeAtNode(d), void 0, true);
              if (Te(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(d)) : d;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(d), this.parseDo(this.startNodeAtNode(d), true);
            }
            return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(d), [d], false)) : d;
          } else
            throw this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, t) {
      const r = this.getPluginOption("pipelineOperator", "proposal");
      if (r)
        return this.state.type = e, this.state.value = t, this.state.pos--, this.state.end--, this.state.endLoc = f2(this.state.endLoc, -1), this.parseTopicReference(r);
      throw this.unexpected();
    }
    parseTopicReference(e) {
      const t = this.startNode(), r = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(t, r, e, i);
    }
    finishTopicReference(e, t, r, i) {
      if (this.testTopicReferenceConfiguration(r, t, i)) {
        const o = r === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(r === "smart" ? m.PrimaryTopicNotAllowed : m.PipeTopicUnbound, {
          at: t
        }), this.registerTopicReference(), this.finishNode(e, o);
      } else
        throw this.raise(m.PipeTopicUnconfiguredToken, {
          at: t,
          token: $e(i)
        });
    }
    testTopicReferenceConfiguration(e, t, r) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: $e(r)
          }]);
        case "smart":
          return r === 27;
        default:
          throw this.raise(m.PipeTopicRequiresHackPipes, {
            at: t
          });
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Qt(true, this.prodParam.hasYield));
      const t = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(m.LineTerminatorBeforeArrow, {
        at: this.state.curPosition()
      }), this.expect(19), this.parseArrowExpression(e, t, true), e;
    }
    parseDo(e, t) {
      this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), e.async = t, this.next();
      const r = this.state.labels;
      return this.state.labels = [], t ? (this.prodParam.enter(Yt), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(), this.state.labels = r, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      const e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(m.SuperNotAllowed, {
        at: e
      }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(m.UnexpectedSuper, {
        at: e
      }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(m.UnsupportedSuper, {
        at: e
      }), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      const e = this.startNode(), t = this.startNodeAt(this.state.start + 1, new n(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), r = this.state.value;
      return this.next(), e.id = this.createIdentifier(t, r), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const t = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e, t, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, t, r) {
      e.meta = t;
      const i = this.state.containsEsc;
      return e.property = this.parseIdentifier(true), (e.property.name !== r || i) && this.raise(m.UnsupportedMetaProperty, {
        at: e.property,
        target: t.name,
        onlyValidPropertyName: r
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "import");
      return this.next(), this.isContextual(100) && (this.inModule || this.raise(m.ImportMetaOutsideModule, {
        at: t
      }), this.sawUnambiguousESM = true), this.parseMetaProperty(e, t, "meta");
    }
    parseLiteralAtNode(e, t, r) {
      return this.addExtra(r, "rawValue", e), this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), r.value = e, this.next(), this.finishNode(r, t);
    }
    parseLiteral(e, t) {
      const r = this.startNode();
      return this.parseLiteralAtNode(e, t, r);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      const t = this.parseLiteral(e.value, "RegExpLiteral");
      return t.pattern = e.pattern, t.flags = e.flags, t;
    }
    parseBooleanLiteral(e) {
      const t = this.startNode();
      return t.value = e, this.next(), this.finishNode(t, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      const t = this.state.start, r = this.state.startLoc;
      let i;
      this.next(), this.expressionScope.enter(Js());
      const o = this.state.maybeInArrowParameters, d = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const u = this.state.start, E = this.state.startLoc, w = [], U = new Zt();
      let ge = true, ye, Ae;
      for (; !this.match(11); ) {
        if (ge)
          ge = false;
        else if (this.expect(12, U.optionalParametersLoc === null ? null : U.optionalParametersLoc), this.match(11)) {
          Ae = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const Ke = this.state.start, He = this.state.startLoc;
          if (ye = this.state.startLoc, w.push(this.parseParenItem(this.parseRestBinding(), Ke, He)), !this.checkCommaAfterRest(41))
            break;
        } else
          w.push(this.parseMaybeAssignAllowIn(U, this.parseParenItem));
      }
      const Oe = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = o, this.state.inFSharpPipelineDirectBody = d;
      let Ve = this.startNodeAt(t, r);
      return e && this.shouldParseArrow(w) && (Ve = this.parseArrow(Ve)) ? (this.checkDestructuringPrivate(U), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(Ve, w, false), Ve) : (this.expressionScope.exit(), w.length || this.unexpected(this.state.lastTokStartLoc), Ae && this.unexpected(Ae), ye && this.unexpected(ye), this.checkExpressionErrors(U, true), this.toReferencedListDeep(w, true), w.length > 1 ? (i = this.startNodeAt(u, E), i.expressions = w, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, Oe)) : i = w[0], this.wrapParenthesis(t, r, i));
    }
    wrapParenthesis(e, t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", true), this.addExtra(r, "parenStart", e), this.takeSurroundingComments(r, e, this.state.lastTokEndLoc.index), r;
      const i = this.startNodeAt(e, t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression"), i;
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, t, r) {
      return e;
    }
    parseNewOrNewTarget() {
      const e = this.startNode();
      if (this.next(), this.match(16)) {
        const t = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        const r = this.parseMetaProperty(e, t, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(m.UnexpectedNewTarget, {
          at: r
        }), r;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        const t = this.parseExprList(11);
        this.toReferencedList(t), e.arguments = t;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      e.callee = this.parseNoCallExpr(), e.callee.type === "Import" ? this.raise(m.ImportCallNotNewExpression, {
        at: e.callee
      }) : this.isOptionalChain(e.callee) ? this.raise(m.OptionalChainingNoNew, {
        at: this.state.lastTokEndLoc
      }) : this.eat(18) && this.raise(m.OptionalChainingNoNew, {
        at: this.state.startLoc
      });
    }
    parseTemplateElement(e) {
      const {
        start: t,
        startLoc: r,
        end: i,
        value: o
      } = this.state, d = t + 1, u = this.startNodeAt(d, f2(r, 1));
      o === null && (e || this.raise(m.InvalidEscapeSequenceTemplate, {
        at: f2(r, 2)
      }));
      const E = this.match(24), w = E ? -1 : -2, U = i + w;
      return u.value = {
        raw: this.input.slice(d, U).replace(/\r\n?/g, `
`),
        cooked: o === null ? null : o.slice(1, w)
      }, u.tail = E, this.next(), this.finishNode(u, "TemplateElement"), this.resetEndLocation(u, f2(this.state.lastTokEndLoc, w)), u;
    }
    parseTemplate(e) {
      const t = this.startNode();
      t.expressions = [];
      let r = this.parseTemplateElement(e);
      for (t.quasis = [r]; !r.tail; )
        t.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t.quasis.push(r = this.parseTemplateElement(e));
      return this.finishNode(t, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const d = /* @__PURE__ */ Object.create(null);
      let u = true;
      const E = this.startNode();
      for (E.properties = [], this.next(); !this.match(e); ) {
        if (u)
          u = false;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(E);
          break;
        }
        let U;
        t ? U = this.parseBindingProperty() : (U = this.parsePropertyDefinition(i), this.checkProto(U, r, d, i)), r && !this.isObjectProperty(U) && U.type !== "SpreadElement" && this.raise(m.InvalidRecordProperty, {
          at: U
        }), U.shorthand && this.addExtra(U, "shorthand", true), E.properties.push(U);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = o;
      let w = "ObjectExpression";
      return t ? w = "ObjectPattern" : r && (w = "RecordExpression"), this.finishNode(E, w);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStart), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let t = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(m.UnsupportedPropertyDecorator, {
          at: this.state.startLoc
        }); this.match(26); )
          t.push(this.parseDecorator());
      const r = this.startNode();
      let i = false, o = false, d, u;
      if (this.match(21))
        return t.length && this.unexpected(), this.parseSpread();
      t.length && (r.decorators = t, t = []), r.method = false, e && (d = this.state.start, u = this.state.startLoc);
      let E = this.eat(55);
      this.parsePropertyNamePrefixOperator(r);
      const w = this.state.containsEsc, U = this.parsePropertyName(r, e);
      if (!E && !w && this.maybeAsyncOrAccessorProp(r)) {
        const ge = U.name;
        ge === "async" && !this.hasPrecedingLineBreak() && (i = true, this.resetPreviousNodeTrailingComments(U), E = this.eat(55), this.parsePropertyName(r)), (ge === "get" || ge === "set") && (o = true, this.resetPreviousNodeTrailingComments(U), r.kind = ge, this.match(55) && (E = true, this.raise(m.AccessorIsGenerator, {
          at: this.state.curPosition(),
          kind: ge
        }), this.next()), this.parsePropertyName(r));
      }
      return this.parseObjPropValue(r, d, u, E, i, false, o, e), r;
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var t;
      const r = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== r && this.raise(e.kind === "get" ? m.BadGetterArity : m.BadSetterArity, {
        at: e
      }), e.kind === "set" && ((t = i[i.length - 1]) == null ? void 0 : t.type) === "RestElement" && this.raise(m.BadSetterRestParameter, {
        at: e
      });
    }
    parseObjectMethod(e, t, r, i, o) {
      if (o)
        return this.parseMethod(e, t, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e), e;
      if (r || t || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = true, this.parseMethod(e, t, r, false, false, "ObjectMethod");
    }
    parseObjectProperty(e, t, r, i, o) {
      if (e.shorthand = false, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(o), this.finishNode(e, "ObjectProperty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, true, false), i)
          e.value = this.parseMaybeDefault(t, r, at(e.key));
        else if (this.match(29)) {
          const d = this.state.startLoc;
          o != null ? o.shorthandAssignLoc === null && (o.shorthandAssignLoc = d) : this.raise(m.InvalidCoverInitializedName, {
            at: d
          }), e.value = this.parseMaybeDefault(t, r, at(e.key));
        } else
          e.value = at(e.key);
        return e.shorthand = true, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, t, r, i, o, d, u, E) {
      const w = this.parseObjectMethod(e, i, o, d, u) || this.parseObjectProperty(e, t, r, d, E);
      return w || this.unexpected(), w;
    }
    parsePropertyName(e, t) {
      if (this.eat(0))
        e.computed = true, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: r,
          value: i
        } = this.state;
        let o;
        if (z(r))
          o = this.parseIdentifier(true);
        else
          switch (r) {
            case 130:
              o = this.parseNumericLiteral(i);
              break;
            case 129:
              o = this.parseStringLiteral(i);
              break;
            case 131:
              o = this.parseBigIntLiteral(i);
              break;
            case 132:
              o = this.parseDecimalLiteral(i);
              break;
            case 134: {
              const d = this.state.startLoc;
              t != null ? t.privateKeyLoc === null && (t.privateKeyLoc = d) : this.raise(m.UnexpectedPrivateField, {
                at: d
              }), o = this.parsePrivateName();
              break;
            }
            default:
              throw this.unexpected();
          }
        e.key = o, r !== 134 && (e.computed = false);
      }
      return e.key;
    }
    initFunction(e, t) {
      e.id = null, e.generator = false, e.async = !!t;
    }
    parseMethod(e, t, r, i, o, d, u = false) {
      this.initFunction(e, r), e.generator = !!t;
      const E = i;
      return this.scope.enter(Ye | $t | (u ? xt : 0) | (o ? Mr : 0)), this.prodParam.enter(Qt(r, e.generator)), this.parseFunctionParams(e, E), this.parseFunctionBodyAndFinish(e, d, true), this.prodParam.exit(), this.scope.exit(), e;
    }
    parseArrayLike(e, t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const d = this.startNode();
      return this.next(), d.elements = this.parseExprList(e, !r, i, d), this.state.inFSharpPipelineDirectBody = o, this.finishNode(d, r ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, t, r, i) {
      this.scope.enter(Ye | bt);
      let o = Qt(r, false);
      !this.match(5) && this.prodParam.hasIn && (o |= Nt), this.prodParam.enter(o), this.initFunction(e, r);
      const d = this.state.maybeInArrowParameters;
      return t && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e, t, i)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = d, this.finishNode(e, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e, t, r) {
      this.toAssignableList(t, r, false), e.params = t;
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      this.parseFunctionBody(e, false, r), this.finishNode(e, t);
    }
    parseFunctionBody(e, t, r = false) {
      const i = t && !this.match(5);
      if (this.expressionScope.enter(zr()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, false, t, false);
      else {
        const o = this.state.strict, d = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Xr), e.body = this.parseBlock(true, false, (u) => {
          const E = !this.isSimpleParamList(e.params);
          u && E && this.raise(m.IllegalLanguageModeDirective, {
            at: (e.kind === "method" || e.kind === "constructor") && !!e.key ? e.key.loc.end : e
          });
          const w = !o && this.state.strict;
          this.checkParams(e, !this.state.strict && !t && !r && !E, t, w), this.state.strict && e.id && this.checkIdentifier(e.id, As, w);
        }), this.prodParam.exit(), this.state.labels = d;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let t = 0, r = e.length; t < r; t++)
        if (!this.isSimpleParameter(e[t]))
          return false;
      return true;
    }
    checkParams(e, t, r, i = true) {
      const o = !t && /* @__PURE__ */ new Set(), d = {
        type: "FormalParameters"
      };
      for (const u of e.params)
        this.checkLVal(u, {
          in: d,
          binding: Ht,
          checkClashes: o,
          strictModeChanged: i
        });
    }
    parseExprList(e, t, r, i) {
      const o = [];
      let d = true;
      for (; !this.eat(e); ) {
        if (d)
          d = false;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(t, r));
      }
      return o;
    }
    parseExprListItem(e, t, r) {
      let i;
      if (this.match(12))
        e || this.raise(m.UnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        const o = this.state.start, d = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(t), o, d);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), r || this.raise(m.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc
        });
        const o = this.startNode();
        this.next(), i = this.finishNode(o, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      const t = this.startNode(), r = this.parseIdentifierName(t.start, e);
      return this.createIdentifier(t, r);
    }
    createIdentifier(e, t) {
      return e.name = t, e.loc.identifierName = t, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e, t) {
      let r;
      const {
        startLoc: i,
        type: o
      } = this.state;
      if (z(o))
        r = this.state.value;
      else
        throw this.unexpected();
      const d = pe(o);
      return t ? d && this.replaceToken(128) : this.checkReservedWord(r, i, d, false), this.next(), r;
    }
    checkReservedWord(e, t, r, i) {
      if (e.length > 10 || !Nr(e))
        return;
      if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(m.YieldBindingIdentifier, {
            at: t
          });
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(m.AwaitBindingIdentifier, {
            at: t
          });
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(m.AwaitBindingIdentifierInStaticBlock, {
            at: t
          });
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError({
          at: t
        });
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(m.ArgumentsInClass, {
          at: t
        });
        return;
      }
      if (r && Tt(e)) {
        this.raise(m.UnexpectedKeyword, {
          at: t,
          keyword: e
        });
        return;
      }
      (this.state.strict ? i ? De : ut : gt)(e, this.inModule) && this.raise(m.UnexpectedReservedWord, {
        at: t,
        reservedWord: e
      });
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e, t) {
      const r = this.startNodeAt(e, t);
      return this.expressionScope.recordParameterInitializerError(m.AwaitExpressionFormalParameter, {
        at: r
      }), this.eat(55) && this.raise(m.ObsoleteAwaitStar, {
        at: r
      }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, true)), this.finishNode(r, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      const {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Ze(e) || e === 133 || e === 56 || this.hasPlugin("v8intrinsic") && e === 54;
    }
    parseYield() {
      const e = this.startNode();
      this.expressionScope.recordParameterInitializerError(m.YieldInParameter, {
        at: e
      }), this.next();
      let t = false, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (t = this.eat(55), this.state.type) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!t)
              break;
          default:
            r = this.parseMaybeAssign();
        }
      return e.delegate = t, e.argument = r, this.finishNode(e, "YieldExpression");
    }
    checkPipelineAtInfixOperator(e, t) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(m.PipelineHeadSequenceExpression, {
        at: t
      });
    }
    parseSmartPipelineBodyInStyle(e, t, r) {
      const i = this.startNodeAt(t, r);
      return this.isSimpleReference(e) ? (i.callee = e, this.finishNode(i, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = e, this.finishNode(i, "PipelineTopicExpression"));
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(m.PipelineBodyNoArrow, {
          at: this.state.startLoc
        });
      this.topicReferenceWasUsedInCurrentContext() || this.raise(m.PipelineTopicUnused, {
        at: e
      });
    }
    withTopicBindingContext(e) {
      const t = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = t;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const t = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = t;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      const t = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e();
      } finally {
        this.state.soloAwait = t;
      }
    }
    allowInAnd(e) {
      const t = this.prodParam.currentFlags();
      if (Nt & ~t) {
        this.prodParam.enter(t | Nt);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      const t = this.prodParam.currentFlags();
      if (Nt & t) {
        this.prodParam.enter(t & ~Nt);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      const t = this.state.start, r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const o = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, r, e);
      return this.state.inFSharpPipelineDirectBody = i, o;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e = this.startNode();
      this.next(), this.eat(5);
      const t = this.initializeScopes(true);
      this.enterInitialScopes();
      const r = this.startNode();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        t();
      }
      return this.eat(8), this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }
  const vr = {
    kind: "loop"
  }, wi = {
    kind: "switch"
  }, Ii = 0, Ar = 1, os = 2, ls = 4, Ni = /[\uD800-\uDFFF]/u, Cr = /in(?:stanceof)?/y;
  function ki(a, e) {
    for (let t = 0; t < a.length; t++) {
      const r = a[t], {
        type: i
      } = r;
      if (typeof i == "number") {
        {
          if (i === 134) {
            const {
              loc: o,
              start: d,
              value: u,
              end: E
            } = r, w = d + 1, U = f2(o.start, 1);
            a.splice(t, 1, new ft({
              type: Xe(27),
              value: "#",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            }), new ft({
              type: Xe(128),
              value: u,
              start: w,
              end: E,
              startLoc: U,
              endLoc: o.end
            })), t++;
            continue;
          }
          if (Ze(i)) {
            const {
              loc: o,
              start: d,
              value: u,
              end: E
            } = r, w = d + 1, U = f2(o.start, 1);
            let ge;
            e.charCodeAt(d) === 96 ? ge = new ft({
              type: Xe(22),
              value: "`",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            }) : ge = new ft({
              type: Xe(8),
              value: "}",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            });
            let ye, Ae, Oe, Ve;
            i === 24 ? (Ae = E - 1, Oe = f2(o.end, -1), ye = u === null ? null : u.slice(1, -1), Ve = new ft({
              type: Xe(22),
              value: "`",
              start: Ae,
              end: E,
              startLoc: Oe,
              endLoc: o.end
            })) : (Ae = E - 2, Oe = f2(o.end, -2), ye = u === null ? null : u.slice(1, -2), Ve = new ft({
              type: Xe(23),
              value: "${",
              start: Ae,
              end: E,
              startLoc: Oe,
              endLoc: o.end
            })), a.splice(t, 1, ge, new ft({
              type: Xe(20),
              value: ye,
              start: w,
              end: Ae,
              startLoc: U,
              endLoc: Oe
            }), Ve), t += 2;
            continue;
          }
        }
        r.type = Xe(i);
      }
    }
    return a;
  }
  class Oi extends Ci {
    parseTopLevel(e, t) {
      return e.program = this.parseProgram(t), e.comments = this.state.comments, this.options.tokens && (e.tokens = ki(this.tokens, this.input)), this.finishNode(e, "File");
    }
    parseProgram(e, t = 135, r = this.options.sourceType) {
      if (e.sourceType = r, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, true, true, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (const [i, o] of Array.from(this.scope.undefinedExports))
          this.raise(m.ModuleExportUndefined, {
            at: o,
            localName: i
          });
      return this.finishNode(e, "Program");
    }
    stmtToDirective(e) {
      const t = e;
      t.type = "Directive", t.value = t.expression, delete t.expression;
      const r = t.value, i = r.value, o = this.input.slice(r.start, r.end), d = r.value = o.slice(1, -1);
      return this.addExtra(r, "raw", o), this.addExtra(r, "rawValue", d), this.addExtra(r, "expressionValue", i), r.type = "DirectiveLiteral", t;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet(e) {
      return this.isContextual(99) ? this.isLetKeyword(e) : false;
    }
    isLetKeyword(e) {
      const t = this.nextTokenStart(), r = this.codePointAtPos(t);
      if (r === 92 || r === 91)
        return true;
      if (e)
        return false;
      if (r === 123)
        return true;
      if (Ne(r)) {
        if (Cr.lastIndex = t, Cr.test(this.input)) {
          const i = this.codePointAtPos(Cr.lastIndex);
          if (!Be(i) && i !== 92)
            return false;
        }
        return true;
      }
      return false;
    }
    parseStatement(e, t) {
      return this.match(26) && this.parseDecorators(true), this.parseStatementContent(e, t);
    }
    parseStatementContent(e, t) {
      let r = this.state.type;
      const i = this.startNode();
      let o;
      switch (this.isLet(e) && (r = 74, o = "let"), r) {
        case 60:
          return this.parseBreakContinueStatement(i, true);
        case 63:
          return this.parseBreakContinueStatement(i, false);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return e && (this.state.strict ? this.raise(m.StrictFunction, {
            at: this.state.startLoc
          }) : e !== "if" && e !== "label" && this.raise(m.SloppyFunction, {
            at: this.state.startLoc
          })), this.parseFunctionStatement(i, false, !e);
        case 80:
          return e && this.unexpected(), this.parseClass(i, true);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 75:
        case 74:
          return o = o || this.state.value, e && o !== "var" && this.raise(m.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          }), this.parseVarStatement(i, o);
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          const E = this.lookaheadCharCode();
          if (E === 40 || E === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !t && this.raise(m.UnexpectedImportExport, {
            at: this.state.startLoc
          }), this.next();
          let E;
          return r === 83 ? (E = this.parseImport(i), E.type === "ImportDeclaration" && (!E.importKind || E.importKind === "value") && (this.sawUnambiguousESM = true)) : (E = this.parseExport(i), (E.type === "ExportNamedDeclaration" && (!E.exportKind || E.exportKind === "value") || E.type === "ExportAllDeclaration" && (!E.exportKind || E.exportKind === "value") || E.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(i), E;
        }
        default:
          if (this.isAsyncFunction())
            return e && this.raise(m.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc
            }), this.next(), this.parseFunctionStatement(i, true, !e);
      }
      const d = this.state.value, u = this.parseExpression();
      return Te(r) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, d, u, e) : this.parseExpressionStatement(i, u);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(m.ImportOutsideModule, {
        at: e
      });
    }
    takeDecorators(e) {
      const t = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      t.length && (e.decorators = t, this.resetStartLocationFromNode(e, t[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      const t = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (; this.match(26); ) {
        const r = this.parseDecorator();
        t.push(r);
      }
      if (this.match(82))
        e || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(m.DecoratorExportClass, {
          at: this.state.startLoc
        });
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(m.UnexpectedLeadingDecorator, {
          at: this.state.startLoc
        });
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const t = this.state.start, r = this.state.startLoc;
        let i;
        if (this.match(10)) {
          const o = this.state.start, d = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(o, d, i);
        } else
          for (i = this.parseIdentifier(false); this.eat(16); ) {
            const o = this.startNodeAt(t, r);
            o.object = i, o.property = this.parseIdentifier(true), o.computed = false, i = this.finishNode(o, "MemberExpression");
          }
        e.expression = this.parseMaybeDecoratorArguments(i), this.state.decoratorStack.pop();
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        const t = this.startNodeAtNode(e);
        return t.callee = e, t.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, t) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, t) {
      let r;
      for (r = 0; r < this.state.labels.length; ++r) {
        const i = this.state.labels[r];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (t || i.kind === "loop") || e.label && t))
          break;
      }
      if (r === this.state.labels.length) {
        const i = t ? "BreakStatement" : "ContinueStatement";
        this.raise(m.IllegalBreakContinue, {
          at: e,
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoStatement(e) {
      return this.next(), this.state.labels.push(vr), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(vr);
      let t = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(At), this.expect(10), this.match(13))
        return t !== null && this.unexpected(t), this.parseFor(e, null);
      const r = this.isContextual(99), i = r && this.isLetKeyword();
      if (this.match(74) || this.match(75) || i) {
        const w = this.startNode(), U = i ? "let" : this.state.value;
        return this.next(), this.parseVar(w, true, U), this.finishNode(w, "VariableDeclaration"), (this.match(58) || this.isContextual(101)) && w.declarations.length === 1 ? this.parseForIn(e, w, t) : (t !== null && this.unexpected(t), this.parseFor(e, w));
      }
      const o = this.isContextual(95), d = new Zt(), u = this.parseExpression(true, d), E = this.isContextual(101);
      if (E && (r && this.raise(m.ForOfLet, {
        at: u
      }), t === null && o && u.type === "Identifier" && this.raise(m.ForOfAsync, {
        at: u
      })), E || this.match(58)) {
        this.checkDestructuringPrivate(d), this.toAssignable(u, true);
        const w = E ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(u, {
          in: {
            type: w
          }
        }), this.parseForIn(e, u, t);
      } else
        this.checkExpressionErrors(d, true);
      return t !== null && this.unexpected(t), this.parseFor(e, u);
    }
    parseFunctionStatement(e, t, r) {
      return this.next(), this.parseFunction(e, Ar | (r ? 0 : os), t);
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(m.IllegalReturn, {
        at: this.state.startLoc
      }), this.next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      const t = e.cases = [];
      this.expect(5), this.state.labels.push(wi), this.scope.enter(At);
      let r;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const o = this.match(61);
          r && this.finishNode(r, "SwitchCase"), t.push(r = this.startNode()), r.consequent = [], this.next(), o ? r.test = this.parseExpression() : (i && this.raise(m.MultipleDefaultsInSwitch, {
            at: this.state.lastTokStartLoc
          }), i = true, r.test = null), this.expect(14);
        } else
          r ? r.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), r && this.finishNode(r, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchStatement");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(m.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc
      }), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e = this.parseBindingAtom(), t = e.type === "Identifier";
      return this.scope.enter(t ? ct : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: nt,
        allowingSloppyLetBinding: true
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        const t = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), t.param = this.parseCatchClauseParam(), this.expect(11)) : (t.param = null, this.scope.enter(At)), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e.handler = this.finishNode(t, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(m.NoCatchOrFinally, {
        at: e
      }), this.finishNode(e, "TryStatement");
    }
    parseVarStatement(e, t, r = false) {
      return this.next(), this.parseVar(e, false, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(vr), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(m.StrictWith, {
        at: this.state.startLoc
      }), this.next(), e.object = this.parseHeaderExpression(), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, t, r, i) {
      for (const d of this.state.labels)
        d.name === t && this.raise(m.LabelRedeclaration, {
          at: r,
          labelName: t
        });
      const o = Le(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
      for (let d = this.state.labels.length - 1; d >= 0; d--) {
        const u = this.state.labels[d];
        if (u.statementStart === e.start)
          u.statementStart = this.state.start, u.kind = o;
        else
          break;
      }
      return this.state.labels.push({
        name: t,
        kind: o,
        statementStart: this.state.start
      }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i + "label" : i : "label"), this.state.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, t) {
      return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = false, t = true, r) {
      const i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(At), this.parseBlockBody(i, e, false, 8, r), t && this.scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, t, r, i, o) {
      const d = e.body = [], u = e.directives = [];
      this.parseBlockOrModuleBlockBody(d, t ? u : void 0, r, i, o);
    }
    parseBlockOrModuleBlockBody(e, t, r, i, o) {
      const d = this.state.strict;
      let u = false, E = false;
      for (; !this.match(i); ) {
        const w = this.parseStatement(null, r);
        if (t && !E) {
          if (this.isValidDirective(w)) {
            const U = this.stmtToDirective(w);
            t.push(U), !u && U.value.value === "use strict" && (u = true, this.setStrict(true));
            continue;
          }
          E = true, this.state.strictErrors.clear();
        }
        e.push(w);
      }
      o && o.call(this, u), d || this.setStrict(false), this.next();
    }
    parseFor(e, t) {
      return e.init = t, this.semicolon(false), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, t, r) {
      const i = this.match(58);
      return this.next(), i ? r !== null && this.unexpected(r) : e.await = r !== null, t.type === "VariableDeclaration" && t.declarations[0].init != null && (!i || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(m.ForInOfLoopInitializer, {
        at: t,
        type: i ? "ForInStatement" : "ForOfStatement"
      }), t.type === "AssignmentPattern" && this.raise(m.InvalidLhs, {
        at: t,
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = t, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, t, r, i = false) {
      const o = e.declarations = [];
      for (e.kind = r; ; ) {
        const d = this.startNode();
        if (this.parseVarId(d, r), d.init = this.eat(29) ? t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, d.init === null && !i && (d.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(101))) ? this.raise(m.DeclarationMissingInitializer, {
          at: this.state.lastTokEndLoc,
          kind: "destructuring"
        }) : r === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(m.DeclarationMissingInitializer, {
          at: this.state.lastTokEndLoc,
          kind: "const"
        })), o.push(this.finishNode(d, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return e;
    }
    parseVarId(e, t) {
      e.id = this.parseBindingAtom(), this.checkLVal(e.id, {
        in: {
          type: "VariableDeclarator"
        },
        binding: t === "var" ? Ht : nt
      });
    }
    parseFunction(e, t = Ii, r = false) {
      const i = t & Ar, o = t & os, d = !!i && !(t & ls);
      this.initFunction(e, r), this.match(55) && o && this.raise(m.GeneratorInSingleStatementContext, {
        at: this.state.startLoc
      }), e.generator = this.eat(55), i && (e.id = this.parseFunctionId(d));
      const u = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(Ye), this.prodParam.enter(Qt(r, e.generator)), i || (e.id = this.parseFunctionId()), this.parseFunctionParams(e, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !o && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = u, e;
    }
    parseFunctionId(e) {
      return e || Te(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, t) {
      this.expect(10), this.expressionScope.enter(Xs()), e.params = this.parseBindingList(11, 41, false, t), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      !e.id || this.scope.declareName(e.id.name, this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ? Ht : nt : jr, e.id.loc.start);
    }
    parseClass(e, t, r) {
      this.next(), this.takeDecorators(e);
      const i = this.state.strict;
      return this.state.strict = true, this.parseClassId(e, t, r), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === "constructor" || e.key.value === "constructor");
    }
    parseClassBody(e, t) {
      this.classScope.enter();
      const r = {
        hadConstructor: false,
        hadSuperClass: e
      };
      let i = [];
      const o = this.startNode();
      if (o.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(m.DecoratorSemicolon, {
                at: this.state.lastTokEndLoc
              });
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          const d = this.startNode();
          i.length && (d.decorators = i, this.resetStartLocationFromNode(d, i[0]), i = []), this.parseClassMember(o, d, r), d.kind === "constructor" && d.decorators && d.decorators.length > 0 && this.raise(m.DecoratorConstructor, {
            at: d
          });
        }
      }), this.state.strict = t, this.next(), i.length)
        throw this.raise(m.TrailingDecorator, {
          at: this.state.startLoc
        });
      return this.classScope.exit(), this.finishNode(o, "ClassBody");
    }
    parseClassMemberFromModifier(e, t) {
      const r = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const i = t;
        return i.kind = "method", i.computed = false, i.key = r, i.static = false, this.pushClassMethod(e, i, false, false, false, false), true;
      } else if (this.isClassProperty()) {
        const i = t;
        return i.computed = false, i.key = r, i.static = false, e.body.push(this.parseClassProperty(i)), true;
      }
      return this.resetPreviousNodeTrailingComments(r), false;
    }
    parseClassMember(e, t, r) {
      const i = this.isContextual(104);
      if (i) {
        if (this.parseClassMemberFromModifier(e, t))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, t);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, t, r, i);
    }
    parseClassMemberWithIsStatic(e, t, r, i) {
      const o = t, d = t, u = t, E = t, w = t, U = o, ge = o;
      if (t.static = i, this.parsePropertyNamePrefixOperator(t), this.eat(55)) {
        U.kind = "method";
        const Ke = this.match(134);
        if (this.parseClassElementName(U), Ke) {
          this.pushClassPrivateMethod(e, d, true, false);
          return;
        }
        this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsGenerator, {
          at: o.key
        }), this.pushClassMethod(e, o, true, false, false, false);
        return;
      }
      const ye = Te(this.state.type) && !this.state.containsEsc, Ae = this.match(134), Oe = this.parseClassElementName(t), Ve = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(ge), this.isClassMethod()) {
        if (U.kind = "method", Ae) {
          this.pushClassPrivateMethod(e, d, false, false);
          return;
        }
        const Ke = this.isNonstaticConstructor(o);
        let He = false;
        Ke && (o.kind = "constructor", r.hadConstructor && !this.hasPlugin("typescript") && this.raise(m.DuplicateConstructor, {
          at: Oe
        }), Ke && this.hasPlugin("typescript") && t.override && this.raise(m.OverrideOnConstructor, {
          at: Oe
        }), r.hadConstructor = true, He = r.hadSuperClass), this.pushClassMethod(e, o, false, false, Ke, He);
      } else if (this.isClassProperty())
        Ae ? this.pushClassPrivateProperty(e, E) : this.pushClassProperty(e, u);
      else if (ye && Oe.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(Oe);
        const Ke = this.eat(55);
        ge.optional && this.unexpected(Ve), U.kind = "method";
        const He = this.match(134);
        this.parseClassElementName(U), this.parsePostMemberNameModifiers(ge), He ? this.pushClassPrivateMethod(e, d, Ke, true) : (this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsAsync, {
          at: o.key
        }), this.pushClassMethod(e, o, Ke, true, false, false));
      } else if (ye && (Oe.name === "get" || Oe.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(Oe), U.kind = Oe.name;
        const Ke = this.match(134);
        this.parseClassElementName(o), Ke ? this.pushClassPrivateMethod(e, d, false, false) : (this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsAccessor, {
          at: o.key
        }), this.pushClassMethod(e, o, false, false, false, false)), this.checkGetterSetterParams(o);
      } else if (ye && Oe.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(Oe);
        const Ke = this.match(134);
        this.parseClassElementName(u), this.pushClassAccessorProperty(e, w, Ke);
      } else
        this.isLineTerminator() ? Ae ? this.pushClassPrivateProperty(e, E) : this.pushClassProperty(e, u) : this.unexpected();
    }
    parseClassElementName(e) {
      const {
        type: t,
        value: r
      } = this.state;
      if ((t === 128 || t === 129) && e.static && r === "prototype" && this.raise(m.StaticPrototype, {
        at: this.state.startLoc
      }), t === 134) {
        r === "constructor" && this.raise(m.ConstructorClassPrivateField, {
          at: this.state.startLoc
        });
        const i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e);
    }
    parseClassStaticBlock(e, t) {
      var r;
      this.scope.enter(xt | or | $t);
      const i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(It);
      const o = t.body = [];
      this.parseBlockOrModuleBlockBody(o, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.finishNode(t, "StaticBlock")), (r = t.decorators) != null && r.length && this.raise(m.DecoratorStaticBlock, {
        at: t
      });
    }
    pushClassProperty(e, t) {
      !t.computed && (t.key.name === "constructor" || t.key.value === "constructor") && this.raise(m.ConstructorClassField, {
        at: t.key
      }), e.body.push(this.parseClassProperty(t));
    }
    pushClassPrivateProperty(e, t) {
      const r = this.parseClassPrivateProperty(t);
      e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), mr, r.key.loc.start);
    }
    pushClassAccessorProperty(e, t, r) {
      if (!r && !t.computed) {
        const o = t.key;
        (o.name === "constructor" || o.value === "constructor") && this.raise(m.ConstructorClassField, {
          at: o
        });
      }
      const i = this.parseClassAccessorProperty(t);
      e.body.push(i), r && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), mr, i.key.loc.start);
    }
    pushClassMethod(e, t, r, i, o, d) {
      e.body.push(this.parseMethod(t, r, i, o, d, "ClassMethod", true));
    }
    pushClassPrivateMethod(e, t, r, i) {
      const o = this.parseMethod(t, r, i, false, false, "ClassPrivateMethod", true);
      e.body.push(o);
      const d = o.kind === "get" ? o.static ? Ns : Os : o.kind === "set" ? o.static ? ks : Ds : mr;
      this.declareClassPrivateMethodInScope(o, d);
    }
    declareClassPrivateMethodInScope(e, t) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(xt | $t), this.expressionScope.enter(zr()), this.prodParam.enter(It), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, t, r, i = Fr) {
      if (Te(this.state.type))
        e.id = this.parseIdentifier(), t && this.declareNameFromIdentifier(e.id, i);
      else if (r || !t)
        e.id = null;
      else
        throw this.raise(m.MissingClassName, {
          at: this.state.startLoc
        });
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e) {
      const t = this.maybeParseExportDefaultSpecifier(e), r = !t || this.eat(12), i = r && this.eatExportStar(e), o = i && this.maybeParseExportNamespaceSpecifier(e), d = r && (!o || this.eat(12)), u = t || i;
      if (i && !o)
        return t && this.unexpected(), this.parseExportFrom(e, true), this.finishNode(e, "ExportAllDeclaration");
      const E = this.maybeParseExportNamedSpecifiers(e);
      if (t && r && !i && !E || o && d && !E)
        throw this.unexpected(null, 5);
      let w;
      if (u || E ? (w = false, this.parseExportFrom(e, u)) : w = this.maybeParseExportDeclaration(e), u || E || w)
        return this.checkExport(e, true, false, !!e.source), this.finishNode(e, "ExportNamedDeclaration");
      if (this.eat(65))
        return e.declaration = this.parseExportDefaultExpression(), this.checkExport(e, true, true), this.finishNode(e, "ExportDefaultDeclaration");
      throw this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const t = this.startNode();
        return t.exported = this.parseIdentifier(true), e.specifiers = [this.finishNode(t, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = []);
        const t = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), t.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = []);
        const t = e.exportKind === "type";
        return e.specifiers.push(...this.parseExportSpecifiers(t)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") && (e.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions = []), e.declaration = this.parseExportDeclaration(e), true) : false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      const e = this.nextTokenStart();
      return !yr.test(this.input.slice(this.state.pos, e)) && this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      const e = this.startNode(), t = this.isAsyncFunction();
      if (this.match(68) || t)
        return this.next(), t && this.next(), this.parseFunction(e, Ar | ls, t);
      if (this.match(80))
        return this.parseClass(e, true, true);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(m.DecoratorBeforeExport, {
          at: this.state.startLoc
        }), this.parseDecorators(false), this.parseClass(e, true, true);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(m.UnsupportedDefaultExport, {
          at: this.state.startLoc
        });
      const r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      if (Te(e)) {
        if (e === 95 && !this.state.containsEsc || e === 99)
          return false;
        if ((e === 126 || e === 125) && !this.state.containsEsc) {
          const {
            type: i
          } = this.lookahead();
          if (Te(i) && i !== 97 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65))
        return false;
      const t = this.nextTokenStart(), r = this.isUnparsedContextual(t, "from");
      if (this.input.charCodeAt(t) === 44 || Te(this.state.type) && r)
        return true;
      if (this.match(65) && r) {
        const i = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
        return i === 34 || i === 39;
      }
      return false;
    }
    parseExportFrom(e, t) {
      if (this.eatContextual(97)) {
        e.source = this.parseImportSource(), this.checkExport(e);
        const r = this.maybeParseImportAssertions();
        r && (e.assertions = r, this.checkJSONModuleImport(e));
      } else
        t && this.unexpected();
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      if (e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
          throw this.raise(m.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        return true;
      }
      return e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, t, r, i) {
      if (t) {
        if (r) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            const u = e.declaration;
            u.type === "Identifier" && u.name === "from" && u.end - u.start === 4 && !((o = u.extra) != null && o.parenthesized) && this.raise(m.ExportDefaultFromAsIdentifier, {
              at: u
            });
          }
        } else if (e.specifiers && e.specifiers.length)
          for (const u of e.specifiers) {
            const {
              exported: E
            } = u, w = E.type === "Identifier" ? E.name : E.value;
            if (this.checkDuplicateExports(u, w), !i && u.local) {
              const {
                local: U
              } = u;
              U.type !== "Identifier" ? this.raise(m.ExportBindingIsString, {
                at: u,
                localName: U.value,
                exportName: w
              }) : (this.checkReservedWord(U.name, U.loc.start, true, false), this.scope.checkLocalExport(U));
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === "FunctionDeclaration" || e.declaration.type === "ClassDeclaration") {
            const u = e.declaration.id;
            if (!u)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (e.declaration.type === "VariableDeclaration")
            for (const u of e.declaration.declarations)
              this.checkDeclaration(u.id);
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(m.UnsupportedDecoratorExport, {
          at: e
        });
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (const t of e.properties)
          this.checkDeclaration(t);
      else if (e.type === "ArrayPattern")
        for (const t of e.elements)
          t && this.checkDeclaration(t);
      else
        e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type === "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, t) {
      this.exportedIdentifiers.has(t) && (t === "default" ? this.raise(m.DuplicateDefaultExport, {
        at: e
      }) : this.raise(m.DuplicateExport, {
        at: e,
        exportName: t
      })), this.exportedIdentifiers.add(t);
    }
    parseExportSpecifiers(e) {
      const t = [];
      let r = true;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = false;
        else if (this.expect(12), this.eat(8))
          break;
        const i = this.isContextual(126), o = this.match(129), d = this.startNode();
        d.local = this.parseModuleExportName(), t.push(this.parseExportSpecifier(d, o, e, i));
      }
      return t;
    }
    parseExportSpecifier(e, t, r, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : t ? e.exported = ti(e.local) : e.exported || (e.exported = at(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(129)) {
        const e = this.parseStringLiteral(this.state.value), t = e.value.match(Ni);
        return t && this.raise(m.ModuleExportNameHasLoneSurrogate, {
          at: e,
          surrogateCharCode: t[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: t,
        value: r
      }) => r.value === "json" && (t.type === "Identifier" ? t.name === "type" : t.value === "type")) : false;
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        const {
          specifiers: t
        } = e;
        if (e.specifiers != null) {
          const r = t.find((i) => {
            let o;
            if (i.type === "ExportSpecifier" ? o = i.local : i.type === "ImportSpecifier" && (o = i.imported), o !== void 0)
              return o.type === "Identifier" ? o.name !== "default" : o.value !== "default";
          });
          r !== void 0 && this.raise(m.ImportJSONBindingNotDefault, {
            at: r.loc.start
          });
        }
      }
    }
    parseImport(e) {
      if (e.specifiers = [], !this.match(129)) {
        const i = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12), o = i && this.maybeParseStarImportSpecifier(e);
        i && !o && this.parseNamedImportSpecifiers(e), this.expectContextual(97);
      }
      e.source = this.parseImportSource();
      const t = this.maybeParseImportAssertions();
      if (t)
        e.assertions = t;
      else {
        const r = this.maybeParseModuleAttributes();
        r && (e.attributes = r);
      }
      return this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(129) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(e) {
      return Te(this.state.type);
    }
    parseImportSpecifierLocal(e, t, r) {
      t.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, r));
    }
    finishImportSpecifier(e, t) {
      return this.checkLVal(e.local, {
        in: e,
        binding: nt
      }), this.finishNode(e, t);
    }
    parseAssertEntries() {
      const e = [], t = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const r = this.startNode(), i = this.state.value;
        if (t.has(i) && this.raise(m.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc,
          key: i
        }), t.add(i), this.match(129) ? r.key = this.parseStringLiteral(i) : r.key = this.parseIdentifier(true), this.expect(14), !this.match(129))
          throw this.raise(m.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        r.value = this.parseStringLiteral(this.state.value), this.finishNode(r, "ImportAttribute"), e.push(r);
      } while (this.eat(12));
      return e;
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak())
        this.expectPlugin("moduleAttributes"), this.next();
      else
        return this.hasPlugin("moduleAttributes") ? [] : null;
      const e = [], t = /* @__PURE__ */ new Set();
      do {
        const r = this.startNode();
        if (r.key = this.parseIdentifier(true), r.key.name !== "type" && this.raise(m.ModuleAttributeDifferentFromType, {
          at: r.key
        }), t.has(r.key.name) && this.raise(m.ModuleAttributesWithDuplicateKeys, {
          at: r.key,
          key: r.key.name
        }), t.add(r.key.name), this.expect(14), !this.match(129))
          throw this.raise(m.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        r.value = this.parseStringLiteral(this.state.value), this.finishNode(r, "ImportAttribute"), e.push(r);
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.expectPlugin("importAssertions"), this.next();
      else
        return this.hasPlugin("importAssertions") ? [] : null;
      this.eat(5);
      const e = this.parseAssertEntries();
      return this.eat(8), e;
    }
    maybeParseDefaultImportSpecifier(e) {
      return this.shouldParseDefaultImport(e) ? (this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), true) : false;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        const t = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e) {
      let t = true;
      for (this.expect(5); !this.eat(8); ) {
        if (t)
          t = false;
        else {
          if (this.eat(14))
            throw this.raise(m.DestructureNamedImport, {
              at: this.state.startLoc
            });
          if (this.expect(12), this.eat(8))
            break;
        }
        const r = this.startNode(), i = this.match(129), o = this.isContextual(126);
        r.imported = this.parseModuleExportName();
        const d = this.parseImportSpecifier(r, i, e.importKind === "type" || e.importKind === "typeof", o);
        e.specifiers.push(d);
      }
    }
    parseImportSpecifier(e, t, r, i) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        const {
          imported: o
        } = e;
        if (t)
          throw this.raise(m.ImportBindingIsString, {
            at: e,
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, true, true), e.local || (e.local = at(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier");
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }
  class us extends Oi {
    constructor(e, t) {
      e = Ei(e), super(e, t), this.options = e, this.initializeScopes(), this.plugins = Di(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return xr;
    }
    parse() {
      this.enterInitialScopes();
      const e = this.startNode(), t = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, t), e.errors = this.state.errors, e;
    }
  }
  function Di(a) {
    const e = /* @__PURE__ */ new Map();
    for (const t of a) {
      const [r, i] = Array.isArray(t) ? t : [t, {}];
      e.has(r) || e.set(r, i || {});
    }
    return e;
  }
  function Li(a, e) {
    var t;
    if (((t = e) == null ? void 0 : t.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        const r = jt(e, a), i = r.parse();
        if (r.sawUnambiguousESM)
          return i;
        if (r.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", jt(e, a).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (r) {
        try {
          return e.sourceType = "script", jt(e, a).parse();
        } catch {
        }
        throw r;
      }
    } else
      return jt(e, a).parse();
  }
  function Mi(a, e) {
    const t = jt(e, a);
    return t.options.strictMode && (t.state.strict = true), t.getExpression();
  }
  function Bi(a) {
    const e = {};
    for (const t of Object.keys(a))
      e[t] = Xe(a[t]);
    return e;
  }
  const _i = Bi(Ie);
  function jt(a, e) {
    let t = us;
    return a != null && a.plugins && (Pi(a.plugins), t = Fi(a.plugins)), new t(a, e);
  }
  const cs = {};
  function Fi(a) {
    const e = Si.filter((i) => ze(a, i)), t = e.join("/");
    let r = cs[t];
    if (!r) {
      r = us;
      for (const i of e)
        r = is[i](r);
      cs[t] = r;
    }
    return r;
  }
  return kn.parse = Li, kn.parseExpression = Mi, kn.tokTypes = _i, kn;
}
var el = {};
var xd;
function $T() {
  if (xd)
    return el;
  xd = 1, Object.defineProperty(el, "__esModule", {
    value: true
  }), el.default = g;
  var s = Je();
  const {
    assignmentExpression: n,
    expressionStatement: h,
    identifier: f2
  } = s, p = {
    Scope(P, x) {
      x.kind === "let" && P.skip();
    },
    FunctionParent(P) {
      P.skip();
    },
    VariableDeclaration(P, x) {
      if (x.kind && P.node.kind !== x.kind)
        return;
      const y = [], A = P.get("declarations");
      let S;
      for (const v of A) {
        S = v.node.id, v.node.init && y.push(h(n("=", v.node.id, v.node.init)));
        for (const T of Object.keys(v.getBindingIdentifiers()))
          x.emit(f2(T), T, v.node.init !== null);
      }
      P.parentPath.isFor({
        left: P.node
      }) ? P.replaceWith(S) : P.replaceWithMultiple(y);
    }
  };
  function g(P, x, y = "var") {
    P.traverse(p, {
      kind: y,
      emit: x
    });
  }
  return el;
}
var Pd;
function qT() {
  if (Pd)
    return Ji;
  Pd = 1, Object.defineProperty(Ji, "__esModule", {
    value: true
  }), Ji._replaceWith = ee, Ji.replaceExpressionWithStatements = K, Ji.replaceInline = G, Ji.replaceWith = q, Ji.replaceWithMultiple = ne, Ji.replaceWithSourceString = Q;
  var s = Bl(), n = qi(), h = nn(), f2 = Wn(), p = UT(), g = Je(), P = $T();
  const {
    FUNCTION_TYPES: x,
    arrowFunctionExpression: y,
    assignmentExpression: A,
    awaitExpression: S,
    blockStatement: v,
    callExpression: T,
    cloneNode: C,
    expressionStatement: I,
    identifier: N,
    inheritLeadingComments: D,
    inheritTrailingComments: _,
    inheritsComments: m,
    isExpression: L,
    isProgram: R,
    isStatement: O,
    removeComments: B,
    returnStatement: M,
    toSequenceExpression: j,
    validate: $,
    yieldExpression: k
  } = g;
  function ne(V) {
    var F;
    this.resync(), V = this._verifyNodeList(V), D(V[0], this.node), _(V[V.length - 1], this.node), (F = f2.path.get(this.parent)) == null || F.delete(this.node), this.node = this.container[this.key] = null;
    const le = this.insertAfter(V);
    return this.node ? this.requeue() : this.remove(), le;
  }
  function Q(V) {
    this.resync();
    let F;
    try {
      V = `(${V})`, F = (0, p.parse)(V);
    } catch (oe) {
      const fe = oe.loc;
      throw fe && (oe.message += ` - make sure this is an expression.
` + (0, s.codeFrameColumns)(V, {
        start: {
          line: fe.line,
          column: fe.column + 1
        }
      }), oe.code = "BABEL_REPLACE_SOURCE_ERROR"), oe;
    }
    const le = F.program.body[0].expression;
    return n.default.removeProperties(le), this.replaceWith(le);
  }
  function q(V) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let F = V instanceof h.default ? V.node : V;
    if (!F)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === F)
      return [this];
    if (this.isProgram() && !R(F))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(F))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof F == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let le = "";
    if (this.isNodeType("Statement") && L(F) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(F) && !this.parentPath.isExportDefaultDeclaration() && (F = I(F), le = "expression"), this.isNodeType("Expression") && O(F) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(F))
      return this.replaceExpressionWithStatements([F]);
    const oe = this.node;
    return oe && (m(F, oe), B(oe)), this._replaceWith(F), this.type = F.type, this.setScope(), this.requeue(), [le ? this.get(le) : this];
  }
  function ee(V) {
    var F;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? $(this.parent, this.key, [V]) : $(this.parent, this.key, V), this.debug(`Replace with ${V == null ? void 0 : V.type}`), (F = f2.path.get(this.parent)) == null || F.set(V, this).delete(this.node), this.node = this.container[this.key] = V;
  }
  function K(V) {
    this.resync();
    const F = j(V, this.scope);
    if (F)
      return this.replaceWith(F)[0].get("expressions");
    const le = this.getFunctionParent(), oe = le == null ? void 0 : le.is("async"), fe = le == null ? void 0 : le.is("generator"), he = y([], v(V));
    this.replaceWith(T(he, []));
    const de = this.get("callee");
    (0, P.default)(de.get("body"), (Ie) => {
      this.scope.push({
        id: Ie
      });
    }, "var");
    const Pe = this.get("callee").getCompletionRecords();
    for (const Ie of Pe) {
      if (!Ie.isExpressionStatement())
        continue;
      const Te = Ie.findParent((pe) => pe.isLoop());
      if (Te) {
        let pe = Te.getData("expressionReplacementReturnUid");
        pe ? pe = N(pe.name) : (pe = de.scope.generateDeclaredUidIdentifier("ret"), de.get("body").pushContainer("body", M(C(pe))), Te.setData("expressionReplacementReturnUid", pe)), Ie.get("expression").replaceWith(A("=", C(pe), Ie.node.expression));
      } else
        Ie.replaceWith(M(Ie.node.expression));
    }
    de.arrowFunctionToExpression();
    const we = de, H = oe && n.default.hasType(this.get("callee.body").node, "AwaitExpression", x), te = fe && n.default.hasType(this.get("callee.body").node, "YieldExpression", x);
    return H && (we.set("async", true), te || this.replaceWith(S(this.node))), te && (we.set("generator", true), this.replaceWith(k(this.node, true))), we.get("body.body");
  }
  function G(V) {
    if (this.resync(), Array.isArray(V))
      if (Array.isArray(this.container)) {
        V = this._verifyNodeList(V);
        const F = this._containerInsertAfter(V);
        return this.remove(), F;
      } else
        return this.replaceWithMultiple(V);
    else
      return this.replaceWith(V);
  }
  return Ji;
}
var ya = {};
var Sd;
function VT() {
  if (Sd)
    return ya;
  Sd = 1, Object.defineProperty(ya, "__esModule", {
    value: true
  }), ya.evaluate = A, ya.evaluateTruthy = p;
  const s = ["String", "Number", "Math"], n = ["random"];
  function h(S) {
    return s.includes(S);
  }
  function f2(S) {
    return n.includes(S);
  }
  function p() {
    const S = this.evaluate();
    if (S.confident)
      return !!S.value;
  }
  function g(S, v) {
    !v.confident || (v.deoptPath = S, v.confident = false);
  }
  function P(S, v) {
    const {
      node: T
    } = S, {
      seen: C
    } = v;
    if (C.has(T)) {
      const I = C.get(T);
      if (I.resolved)
        return I.value;
      g(S, v);
      return;
    } else {
      const I = {
        resolved: false
      };
      C.set(T, I);
      const N = x(S, v);
      return v.confident && (I.resolved = true, I.value = N), N;
    }
  }
  function x(S, v) {
    if (!!v.confident) {
      if (S.isSequenceExpression()) {
        const T = S.get("expressions");
        return P(T[T.length - 1], v);
      }
      if (S.isStringLiteral() || S.isNumericLiteral() || S.isBooleanLiteral())
        return S.node.value;
      if (S.isNullLiteral())
        return null;
      if (S.isTemplateLiteral())
        return y(S, S.node.quasis, v);
      if (S.isTaggedTemplateExpression() && S.get("tag").isMemberExpression()) {
        const T = S.get("tag.object"), {
          node: {
            name: C
          }
        } = T, I = S.get("tag.property");
        if (T.isIdentifier() && C === "String" && !S.scope.getBinding(C) && I.isIdentifier() && I.node.name === "raw")
          return y(S, S.node.quasi.quasis, v, true);
      }
      if (S.isConditionalExpression()) {
        const T = P(S.get("test"), v);
        return v.confident ? P(T ? S.get("consequent") : S.get("alternate"), v) : void 0;
      }
      if (S.isExpressionWrapper())
        return P(S.get("expression"), v);
      if (S.isMemberExpression() && !S.parentPath.isCallExpression({
        callee: S.node
      })) {
        const T = S.get("property"), C = S.get("object");
        if (C.isLiteral() && T.isIdentifier()) {
          const I = C.node.value, N = typeof I;
          if (N === "number" || N === "string")
            return I[T.node.name];
        }
      }
      if (S.isReferencedIdentifier()) {
        const T = S.scope.getBinding(S.node.name);
        if (T && T.constantViolations.length > 0 || T && S.node.start < T.path.node.end)
          return g(T.path, v);
        if (T != null && T.hasValue)
          return T.value;
        {
          if (S.node.name === "undefined")
            return T ? g(T.path, v) : void 0;
          if (S.node.name === "Infinity")
            return T ? g(T.path, v) : 1 / 0;
          if (S.node.name === "NaN")
            return T ? g(T.path, v) : NaN;
          const C = S.resolve();
          return C === S ? g(S, v) : P(C, v);
        }
      }
      if (S.isUnaryExpression({
        prefix: true
      })) {
        if (S.node.operator === "void")
          return;
        const T = S.get("argument");
        if (S.node.operator === "typeof" && (T.isFunction() || T.isClass()))
          return "function";
        const C = P(T, v);
        if (!v.confident)
          return;
        switch (S.node.operator) {
          case "!":
            return !C;
          case "+":
            return +C;
          case "-":
            return -C;
          case "~":
            return ~C;
          case "typeof":
            return typeof C;
        }
      }
      if (S.isArrayExpression()) {
        const T = [], C = S.get("elements");
        for (const I of C) {
          const N = I.evaluate();
          if (N.confident)
            T.push(N.value);
          else
            return g(N.deopt, v);
        }
        return T;
      }
      if (S.isObjectExpression()) {
        const T = {}, C = S.get("properties");
        for (const I of C) {
          if (I.isObjectMethod() || I.isSpreadElement())
            return g(I, v);
          let D = I.get("key");
          if (I.node.computed) {
            if (D = D.evaluate(), !D.confident)
              return g(D.deopt, v);
            D = D.value;
          } else
            D.isIdentifier() ? D = D.node.name : D = D.node.value;
          let m = I.get("value").evaluate();
          if (!m.confident)
            return g(m.deopt, v);
          m = m.value, T[D] = m;
        }
        return T;
      }
      if (S.isLogicalExpression()) {
        const T = v.confident, C = P(S.get("left"), v), I = v.confident;
        v.confident = T;
        const N = P(S.get("right"), v), D = v.confident;
        switch (S.node.operator) {
          case "||":
            return v.confident = I && (!!C || D), v.confident ? C || N : void 0;
          case "&&":
            return v.confident = I && (!C || D), v.confident ? C && N : void 0;
        }
      }
      if (S.isBinaryExpression()) {
        const T = P(S.get("left"), v);
        if (!v.confident)
          return;
        const C = P(S.get("right"), v);
        if (!v.confident)
          return;
        switch (S.node.operator) {
          case "-":
            return T - C;
          case "+":
            return T + C;
          case "/":
            return T / C;
          case "*":
            return T * C;
          case "%":
            return T % C;
          case "**":
            return Math.pow(T, C);
          case "<":
            return T < C;
          case ">":
            return T > C;
          case "<=":
            return T <= C;
          case ">=":
            return T >= C;
          case "==":
            return T == C;
          case "!=":
            return T != C;
          case "===":
            return T === C;
          case "!==":
            return T !== C;
          case "|":
            return T | C;
          case "&":
            return T & C;
          case "^":
            return T ^ C;
          case "<<":
            return T << C;
          case ">>":
            return T >> C;
          case ">>>":
            return T >>> C;
        }
      }
      if (S.isCallExpression()) {
        const T = S.get("callee");
        let C, I;
        if (T.isIdentifier() && !S.scope.getBinding(T.node.name) && h(T.node.name) && (I = f[T.node.name]), T.isMemberExpression()) {
          const N = T.get("object"), D = T.get("property");
          if (N.isIdentifier() && D.isIdentifier() && h(N.node.name) && !f2(D.node.name) && (C = f[N.node.name], I = C[D.node.name]), N.isLiteral() && D.isIdentifier()) {
            const _ = typeof N.node.value;
            (_ === "string" || _ === "number") && (C = N.node.value, I = C[D.node.name]);
          }
        }
        if (I) {
          const N = S.get("arguments").map((D) => P(D, v));
          return v.confident ? I.apply(C, N) : void 0;
        }
      }
      g(S, v);
    }
  }
  function y(S, v, T, C = false) {
    let I = "", N = 0;
    const D = S.get("expressions");
    for (const _ of v) {
      if (!T.confident)
        break;
      I += C ? _.value.raw : _.value.cooked;
      const m = D[N++];
      m && (I += String(P(m, T)));
    }
    if (!!T.confident)
      return I;
  }
  function A() {
    const S = {
      confident: true,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    };
    let v = P(this, S);
    return S.confident || (v = void 0), {
      confident: S.confident,
      deopt: S.deoptPath,
      value: v
    };
  }
  return ya;
}
var un = {};
var ja = {};
var Dr = {};
var ds = {};
var Ed;
function KT() {
  if (Ed)
    return ds;
  Ed = 1, Object.defineProperty(ds, "__esModule", {
    value: true
  }), ds.statements = ds.statement = ds.smart = ds.program = ds.expression = void 0;
  var s = Je();
  const {
    assertExpressionStatement: n
  } = s;
  function h(y) {
    return {
      code: (A) => `/* @babel/template */;
${A}`,
      validate: () => {
      },
      unwrap: (A) => y(A.program.body.slice(1))
    };
  }
  const f2 = h((y) => y.length > 1 ? y : y[0]);
  ds.smart = f2;
  const p = h((y) => y);
  ds.statements = p;
  const g = h((y) => {
    if (y.length === 0)
      throw new Error("Found nothing to return.");
    if (y.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return y[0];
  });
  ds.statement = g;
  const P = {
    code: (y) => `(
${y}
)`,
    validate: (y) => {
      if (y.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (P.unwrap(y).start === 0)
        throw new Error("Parse result included parens.");
    },
    unwrap: ({
      program: y
    }) => {
      const [A] = y.body;
      return n(A), A.expression;
    }
  };
  ds.expression = P;
  const x = {
    code: (y) => y,
    validate: () => {
    },
    unwrap: (y) => y.program
  };
  return ds.program = x, ds;
}
var tl = {};
var On = {};
var vd;
function ep() {
  if (vd)
    return On;
  vd = 1, Object.defineProperty(On, "__esModule", {
    value: true
  }), On.merge = h, On.normalizeReplacements = p, On.validate = f2;
  const s = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function n(g, P) {
    if (g == null)
      return {};
    var x = {}, y = Object.keys(g), A, S;
    for (S = 0; S < y.length; S++)
      A = y[S], !(P.indexOf(A) >= 0) && (x[A] = g[A]);
    return x;
  }
  function h(g, P) {
    const {
      placeholderWhitelist: x = g.placeholderWhitelist,
      placeholderPattern: y = g.placeholderPattern,
      preserveComments: A = g.preserveComments,
      syntacticPlaceholders: S = g.syntacticPlaceholders
    } = P;
    return {
      parser: Object.assign({}, g.parser, P.parser),
      placeholderWhitelist: x,
      placeholderPattern: y,
      preserveComments: A,
      syntacticPlaceholders: S
    };
  }
  function f2(g) {
    if (g != null && typeof g != "object")
      throw new Error("Unknown template options.");
    const P = g || {}, {
      placeholderWhitelist: x,
      placeholderPattern: y,
      preserveComments: A,
      syntacticPlaceholders: S
    } = P, v = n(P, s);
    if (x != null && !(x instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (y != null && !(y instanceof RegExp) && y !== false)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (A != null && typeof A != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (S != null && typeof S != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (S === true && (x != null || y != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: v,
      placeholderWhitelist: x || void 0,
      placeholderPattern: y == null ? void 0 : y,
      preserveComments: A == null ? void 0 : A,
      syntacticPlaceholders: S == null ? void 0 : S
    };
  }
  function p(g) {
    if (Array.isArray(g))
      return g.reduce((P, x, y) => (P["$" + y] = x, P), {});
    if (typeof g == "object" || g == null)
      return g || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  return On;
}
var rl = {};
var sl = {};
var Dn = {};
var Ad;
function WT() {
  if (Ad)
    return Dn;
  Ad = 1, Object.defineProperty(Dn, "__esModule", { value: true });
  function s(a, e) {
    if (a == null)
      return {};
    var t = {}, r = Object.keys(a), i, o;
    for (o = 0; o < r.length; o++)
      i = r[o], !(e.indexOf(i) >= 0) && (t[i] = a[i]);
    return t;
  }
  class n {
    constructor(e, t, r) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = t, this.index = r;
    }
  }
  class h {
    constructor(e, t) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = t;
    }
  }
  function f2(a, e) {
    const {
      line: t,
      column: r,
      index: i
    } = a;
    return new n(t, r + e, i + e);
  }
  const p = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
  }), g = (a, e = a.length - 1) => ({
    get() {
      return a.reduce((t, r) => t[r], this);
    },
    set(t) {
      a.reduce((r, i, o) => o === e ? r[i] = t : r[i], this);
    }
  }), P = (a, e, t) => Object.keys(t).map((r) => [r, t[r]]).filter(([, r]) => !!r).map(([r, i]) => [r, typeof i == "function" ? {
    value: i,
    enumerable: false
  } : typeof i.reflect == "string" ? Object.assign({}, i, g(i.reflect.split("."))) : i]).reduce((r, [i, o]) => Object.defineProperty(r, i, Object.assign({
    configurable: true
  }, o)), Object.assign(new a(), e));
  var x = (a) => ({
    ImportMetaOutsideModule: a(`import.meta may appear only with 'sourceType: "module"'`, {
      code: p.SourceTypeModuleError
    }),
    ImportOutsideModule: a(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
      code: p.SourceTypeModuleError
    })
  });
  const y = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, A = ({
    type: a,
    prefix: e
  }) => a === "UpdateExpression" ? y.UpdateExpression[String(e)] : y[a];
  var S = (a) => ({
    AccessorIsGenerator: a(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`),
    ArgumentsInClass: a("'arguments' is only allowed in functions and class methods."),
    AsyncFunctionInSingleStatementContext: a("Async functions can only be declared at the top level or inside a block."),
    AwaitBindingIdentifier: a("Can not use 'await' as identifier inside an async function."),
    AwaitBindingIdentifierInStaticBlock: a("Can not use 'await' as identifier inside a static block."),
    AwaitExpressionFormalParameter: a("'await' is not allowed in async function parameters."),
    AwaitNotInAsyncContext: a("'await' is only allowed within async functions and at the top levels of modules."),
    AwaitNotInAsyncFunction: a("'await' is only allowed within async functions."),
    BadGetterArity: a("A 'get' accesor must not have any formal parameters."),
    BadSetterArity: a("A 'set' accesor must have exactly one formal parameter."),
    BadSetterRestParameter: a("A 'set' accesor function argument must not be a rest parameter."),
    ConstructorClassField: a("Classes may not have a field named 'constructor'."),
    ConstructorClassPrivateField: a("Classes may not have a private field named '#constructor'."),
    ConstructorIsAccessor: a("Class constructor may not be an accessor."),
    ConstructorIsAsync: a("Constructor can't be an async function."),
    ConstructorIsGenerator: a("Constructor can't be a generator."),
    DeclarationMissingInitializer: a(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`),
    DecoratorBeforeExport: a("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."),
    DecoratorConstructor: a("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
    DecoratorExportClass: a("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."),
    DecoratorSemicolon: a("Decorators must not be followed by a semicolon."),
    DecoratorStaticBlock: a("Decorators can't be used with a static block."),
    DeletePrivateField: a("Deleting a private field is not allowed."),
    DestructureNamedImport: a("ES2015 named imports do not destructure. Use another statement for destructuring after the import."),
    DuplicateConstructor: a("Duplicate constructor in the same class."),
    DuplicateDefaultExport: a("Only one default export allowed per module."),
    DuplicateExport: a(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`),
    DuplicateProto: a("Redefinition of __proto__ property."),
    DuplicateRegExpFlags: a("Duplicate regular expression flag."),
    ElementAfterRest: a("Rest element must be last element."),
    EscapedCharNotAnIdentifier: a("Invalid Unicode escape."),
    ExportBindingIsString: a(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`),
    ExportDefaultFromAsIdentifier: a("'from' is not allowed as an identifier after 'export default'."),
    ForInOfLoopInitializer: a(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`),
    ForOfAsync: a("The left-hand side of a for-of loop may not be 'async'."),
    ForOfLet: a("The left-hand side of a for-of loop may not start with 'let'."),
    GeneratorInSingleStatementContext: a("Generators can only be declared at the top level or inside a block."),
    IllegalBreakContinue: a(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`),
    IllegalLanguageModeDirective: a("Illegal 'use strict' directive in function with non-simple parameter list."),
    IllegalReturn: a("'return' outside of function."),
    ImportBindingIsString: a(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`),
    ImportCallArgumentTrailingComma: a("Trailing comma is disallowed inside import(...) arguments."),
    ImportCallArity: a(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`),
    ImportCallNotNewExpression: a("Cannot use new with import(...)."),
    ImportCallSpreadArgument: a("`...` is not allowed in `import()`."),
    ImportJSONBindingNotDefault: a("A JSON module can only be imported with `default`."),
    IncompatibleRegExpUVFlags: a("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
    InvalidBigIntLiteral: a("Invalid BigIntLiteral."),
    InvalidCodePoint: a("Code point out of bounds."),
    InvalidCoverInitializedName: a("Invalid shorthand property initializer."),
    InvalidDecimal: a("Invalid decimal."),
    InvalidDigit: a(({
      radix: e
    }) => `Expected number in radix ${e}.`),
    InvalidEscapeSequence: a("Bad character escape sequence."),
    InvalidEscapeSequenceTemplate: a("Invalid escape sequence in template."),
    InvalidEscapedReservedWord: a(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`),
    InvalidIdentifier: a(({
      identifierName: e
    }) => `Invalid identifier ${e}.`),
    InvalidLhs: a(({
      ancestor: e
    }) => `Invalid left-hand side in ${A(e)}.`),
    InvalidLhsBinding: a(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${A(e)}.`),
    InvalidNumber: a("Invalid number."),
    InvalidOrMissingExponent: a("Floating-point numbers require a valid exponent after the 'e'."),
    InvalidOrUnexpectedToken: a(({
      unexpected: e
    }) => `Unexpected character '${e}'.`),
    InvalidParenthesizedAssignment: a("Invalid parenthesized assignment pattern."),
    InvalidPrivateFieldResolution: a(({
      identifierName: e
    }) => `Private name #${e} is not defined.`),
    InvalidPropertyBindingPattern: a("Binding member expression."),
    InvalidRecordProperty: a("Only properties and spread elements are allowed in record definitions."),
    InvalidRestAssignmentPattern: a("Invalid rest operator's argument."),
    LabelRedeclaration: a(({
      labelName: e
    }) => `Label '${e}' is already declared.`),
    LetInLexicalBinding: a("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
    LineTerminatorBeforeArrow: a("No line break is allowed before '=>'."),
    MalformedRegExpFlags: a("Invalid regular expression flag."),
    MissingClassName: a("A class name is required."),
    MissingEqInAssignment: a("Only '=' operator can be used for specifying default value."),
    MissingSemicolon: a("Missing semicolon."),
    MissingPlugin: a(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`),
    MissingOneOfPlugins: a(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`),
    MissingUnicodeEscape: a("Expecting Unicode escape sequence \\uXXXX."),
    MixingCoalesceWithLogical: a("Nullish coalescing operator(??) requires parens when mixing with logical operators."),
    ModuleAttributeDifferentFromType: a("The only accepted module attribute is `type`."),
    ModuleAttributeInvalidValue: a("Only string literals are allowed as module attribute values."),
    ModuleAttributesWithDuplicateKeys: a(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`),
    ModuleExportNameHasLoneSurrogate: a(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`),
    ModuleExportUndefined: a(({
      localName: e
    }) => `Export '${e}' is not defined.`),
    MultipleDefaultsInSwitch: a("Multiple default clauses."),
    NewlineAfterThrow: a("Illegal newline after throw."),
    NoCatchOrFinally: a("Missing catch or finally clause."),
    NumberIdentifier: a("Identifier directly after number."),
    NumericSeparatorInEscapeSequence: a("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."),
    ObsoleteAwaitStar: a("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
    OptionalChainingNoNew: a("Constructors in/after an Optional Chain are not allowed."),
    OptionalChainingNoTemplate: a("Tagged Template Literals are not allowed in optionalChain."),
    OverrideOnConstructor: a("'override' modifier cannot appear on a constructor declaration."),
    ParamDupe: a("Argument name clash."),
    PatternHasAccessor: a("Object pattern can't contain getter or setter."),
    PatternHasMethod: a("Object pattern can't contain methods."),
    PrivateInExpectedIn: a(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`),
    PrivateNameRedeclaration: a(({
      identifierName: e
    }) => `Duplicate private name #${e}.`),
    RecordExpressionBarIncorrectEndSyntaxType: a("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    RecordExpressionBarIncorrectStartSyntaxType: a("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    RecordExpressionHashIncorrectStartSyntaxType: a("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
    RecordNoProto: a("'__proto__' is not allowed in Record expressions."),
    RestTrailingComma: a("Unexpected trailing comma after rest element."),
    SloppyFunction: a("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."),
    StaticPrototype: a("Classes may not have static property named prototype."),
    SuperNotAllowed: a("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"),
    SuperPrivateField: a("Private fields can't be accessed on super."),
    TrailingDecorator: a("Decorators must be attached to a class element."),
    TupleExpressionBarIncorrectEndSyntaxType: a("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    TupleExpressionBarIncorrectStartSyntaxType: a("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    TupleExpressionHashIncorrectStartSyntaxType: a("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
    UnexpectedArgumentPlaceholder: a("Unexpected argument placeholder."),
    UnexpectedAwaitAfterPipelineBody: a('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'),
    UnexpectedDigitAfterHash: a("Unexpected digit after hash token."),
    UnexpectedImportExport: a("'import' and 'export' may only appear at the top level."),
    UnexpectedKeyword: a(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`),
    UnexpectedLeadingDecorator: a("Leading decorators must be attached to a class declaration."),
    UnexpectedLexicalDeclaration: a("Lexical declaration cannot appear in a single-statement context."),
    UnexpectedNewTarget: a("`new.target` can only be used in functions or class properties."),
    UnexpectedNumericSeparator: a("A numeric separator is only allowed between two digits."),
    UnexpectedPrivateField: a("Unexpected private name."),
    UnexpectedReservedWord: a(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`),
    UnexpectedSuper: a("'super' is only allowed in object methods and classes."),
    UnexpectedToken: a(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`),
    UnexpectedTokenUnaryExponentiation: a("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."),
    UnsupportedBind: a("Binding should be performed on object property."),
    UnsupportedDecoratorExport: a("A decorated export must export a class declaration."),
    UnsupportedDefaultExport: a("Only expressions, functions or classes are allowed as the `default` export."),
    UnsupportedImport: a("`import` can only be used in `import()` or `import.meta`."),
    UnsupportedMetaProperty: a(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`),
    UnsupportedParameterDecorator: a("Decorators cannot be used to decorate parameters."),
    UnsupportedPropertyDecorator: a("Decorators cannot be used to decorate object literal properties."),
    UnsupportedSuper: a("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."),
    UnterminatedComment: a("Unterminated comment."),
    UnterminatedRegExp: a("Unterminated regular expression."),
    UnterminatedString: a("Unterminated string constant."),
    UnterminatedTemplate: a("Unterminated template."),
    VarRedeclaration: a(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`),
    YieldBindingIdentifier: a("Can not use 'yield' as identifier inside a generator."),
    YieldInParameter: a("Yield expression is not allowed in formal parameters."),
    ZeroDigitNumericSeparator: a("Numeric separator can not be used after leading 0.")
  }), v = (a) => ({
    StrictDelete: a("Deleting local variable in strict mode."),
    StrictEvalArguments: a(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`),
    StrictEvalArgumentsBinding: a(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`),
    StrictFunction: a("In strict mode code, functions can only be declared at top level or inside a block."),
    StrictNumericEscape: a("The only valid numeric escape in strict mode is '\\0'."),
    StrictOctalLiteral: a("Legacy octal literals are not allowed in strict mode."),
    StrictWith: a("'with' in strict mode.")
  });
  const T = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var C = (a) => ({
    PipeBodyIsTighter: a("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."),
    PipeTopicRequiresHackPipes: a('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'),
    PipeTopicUnbound: a("Topic reference is unbound; it must be inside a pipe body."),
    PipeTopicUnconfiguredToken: a(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`),
    PipeTopicUnused: a("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."),
    PipeUnparenthesizedBody: a(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${A({
      type: e
    })}; please wrap it in parentheses.`),
    PipelineBodyNoArrow: a('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'),
    PipelineBodySequenceExpression: a("Pipeline body may not be a comma-separated sequence expression."),
    PipelineHeadSequenceExpression: a("Pipeline head should not be a comma-separated sequence expression."),
    PipelineTopicUnused: a("Pipeline is in topic style but does not use topic reference."),
    PrimaryTopicNotAllowed: a("Topic reference was used in a lexical context without topic binding."),
    PrimaryTopicRequiresSmartPipeline: a('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.')
  });
  const I = ["toMessage"];
  function N(a) {
    let {
      toMessage: e
    } = a, t = s(a, I);
    return function r({
      loc: i,
      details: o
    }) {
      return P(SyntaxError, Object.assign({}, t, {
        loc: i
      }), {
        clone(d = {}) {
          const u = d.loc || {};
          return r({
            loc: new n("line" in u ? u.line : this.loc.line, "column" in u ? u.column : this.loc.column, "index" in u ? u.index : this.loc.index),
            details: Object.assign({}, this.details, d.details)
          });
        },
        details: {
          value: o,
          enumerable: false
        },
        message: {
          get() {
            return `${e(this.details)} (${this.loc.line}:${this.loc.column})`;
          },
          set(d) {
            Object.defineProperty(this, "message", {
              value: d
            });
          }
        },
        pos: {
          reflect: "loc.index",
          enumerable: true
        },
        missingPlugin: "missingPlugin" in o && {
          reflect: "details.missingPlugin",
          enumerable: true
        }
      });
    };
  }
  function D(a, e) {
    return Object.assign({
      toMessage: typeof a == "string" ? () => a : a
    }, e);
  }
  function _(a, e) {
    if (Array.isArray(a))
      return (i) => _(i, a[0]);
    const t = a(D), r = {};
    for (const i of Object.keys(t))
      r[i] = N(Object.assign({
        code: p.SyntaxError,
        reasonCode: i
      }, e ? {
        syntaxPlugin: e
      } : {}, t[i]));
    return r;
  }
  const m = Object.assign({}, _(x), _(S), _(v), _`pipelineOperator`(C)), {
    defineProperty: L
  } = Object, R = (a, e) => L(a, e, {
    enumerable: false,
    value: a[e]
  });
  function O(a) {
    return a.loc.start && R(a.loc.start, "index"), a.loc.end && R(a.loc.end, "index"), a;
  }
  var B = (a) => class extends a {
    parse() {
      const e = O(super.parse());
      return this.options.tokens && (e.tokens = e.tokens.map(O)), e;
    }
    parseRegExpLiteral({
      pattern: e,
      flags: t
    }) {
      let r = null;
      try {
        r = new RegExp(e, t);
      } catch {
      }
      const i = this.estreeParseLiteral(r);
      return i.regex = {
        pattern: e,
        flags: t
      }, i;
    }
    parseBigIntLiteral(e) {
      let t;
      try {
        t = BigInt(e);
      } catch {
        t = null;
      }
      const r = this.estreeParseLiteral(t);
      return r.bigint = String(r.value || e), r;
    }
    parseDecimalLiteral(e) {
      const r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || e), r;
    }
    estreeParseLiteral(e) {
      return this.parseLiteral(e, "Literal");
    }
    parseStringLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNumericLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    directiveToStmt(e) {
      const t = e.value, r = this.startNodeAt(e.start, e.loc.start), i = this.startNodeAt(t.start, t.loc.start);
      return i.value = t.extra.expressionValue, i.raw = t.extra.raw, r.expression = this.finishNodeAt(i, "Literal", t.loc.end), r.directive = t.extra.raw.slice(1, -1), this.finishNodeAt(r, "ExpressionStatement", e.loc.end);
    }
    initFunction(e, t) {
      super.initFunction(e, t), e.expression = false;
    }
    checkDeclaration(e) {
      e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
    }
    getObjectOrClassMethodParams(e) {
      return e.value.params;
    }
    isValidDirective(e) {
      var t;
      return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((t = e.expression.extra) != null && t.parenthesized);
    }
    parseBlockBody(e, ...t) {
      super.parseBlockBody(e, ...t);
      const r = e.directives.map((i) => this.directiveToStmt(i));
      e.body = r.concat(e.body), delete e.directives;
    }
    pushClassMethod(e, t, r, i, o, d) {
      this.parseMethod(t, r, i, o, d, "ClassMethod", true), t.typeParameters && (t.value.typeParameters = t.typeParameters, delete t.typeParameters), e.body.push(t);
    }
    parsePrivateName() {
      const e = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
    }
    convertPrivateNameToPrivateIdentifier(e) {
      const t = super.getPrivateNameSV(e);
      return e = e, delete e.id, e.name = t, e.type = "PrivateIdentifier", e;
    }
    isPrivateName(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
    }
    getPrivateNameSV(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
    }
    parseLiteral(e, t) {
      const r = super.parseLiteral(e, t);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(e, t, r = false) {
      super.parseFunctionBody(e, t, r), e.expression = e.body.type !== "BlockStatement";
    }
    parseMethod(e, t, r, i, o, d, u = false) {
      let E = this.startNode();
      return E.kind = e.kind, E = super.parseMethod(E, t, r, i, o, d, u), E.type = "FunctionExpression", delete E.kind, e.value = E, d === "ClassPrivateMethod" && (e.computed = false), d = "MethodDefinition", this.finishNode(e, d);
    }
    parseClassProperty(...e) {
      const t = super.parseClassProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition"), t;
    }
    parseClassPrivateProperty(...e) {
      const t = super.parseClassPrivateProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition", t.computed = false), t;
    }
    parseObjectMethod(e, t, r, i, o) {
      const d = super.parseObjectMethod(e, t, r, i, o);
      return d && (d.type = "Property", d.kind === "method" && (d.kind = "init"), d.shorthand = false), d;
    }
    parseObjectProperty(e, t, r, i, o) {
      const d = super.parseObjectProperty(e, t, r, i, o);
      return d && (d.kind = "init", d.type = "Property"), d;
    }
    isValidLVal(e, ...t) {
      return e === "Property" ? "value" : super.isValidLVal(e, ...t);
    }
    isAssignable(e, t) {
      return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
    }
    toAssignable(e, t = false) {
      if (e != null && this.isObjectProperty(e)) {
        const {
          key: r,
          value: i
        } = e;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(i, t);
      } else
        super.toAssignable(e, t);
    }
    toAssignableObjectExpressionProp(e) {
      e.kind === "get" || e.kind === "set" ? this.raise(m.PatternHasAccessor, {
        at: e.key
      }) : e.method ? this.raise(m.PatternHasMethod, {
        at: e.key
      }) : super.toAssignableObjectExpressionProp(...arguments);
    }
    finishCallExpression(e, t) {
      if (super.finishCallExpression(e, t), e.callee.type === "Import") {
        if (e.type = "ImportExpression", e.source = e.arguments[0], this.hasPlugin("importAssertions")) {
          var r;
          e.attributes = (r = e.arguments[1]) != null ? r : null;
        }
        delete e.arguments, delete e.callee;
      }
      return e;
    }
    toReferencedArguments(e) {
      e.type !== "ImportExpression" && super.toReferencedArguments(e);
    }
    parseExport(e) {
      switch (super.parseExport(e), e.type) {
        case "ExportAllDeclaration":
          e.exported = null;
          break;
        case "ExportNamedDeclaration":
          e.specifiers.length === 1 && e.specifiers[0].type === "ExportNamespaceSpecifier" && (e.type = "ExportAllDeclaration", e.exported = e.specifiers[0].exported, delete e.specifiers);
          break;
      }
      return e;
    }
    parseSubscript(e, t, r, i, o) {
      const d = super.parseSubscript(e, t, r, i, o);
      if (o.optionalChainMember) {
        if ((d.type === "OptionalMemberExpression" || d.type === "OptionalCallExpression") && (d.type = d.type.substring(8)), o.stop) {
          const u = this.startNodeAtNode(d);
          return u.expression = d, this.finishNode(u, "ChainExpression");
        }
      } else
        (d.type === "MemberExpression" || d.type === "CallExpression") && (d.optional = false);
      return d;
    }
    hasPropertyAsPrivateName(e) {
      return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
    }
    isOptionalChain(e) {
      return e.type === "ChainExpression";
    }
    isObjectProperty(e) {
      return e.type === "Property" && e.kind === "init" && !e.method;
    }
    isObjectMethod(e) {
      return e.method || e.kind === "get" || e.kind === "set";
    }
    finishNodeAt(e, t, r) {
      return O(super.finishNodeAt(e, t, r));
    }
    resetStartLocation(e, t, r) {
      super.resetStartLocation(e, t, r), O(e);
    }
    resetEndLocation(e, t = this.state.lastTokEndLoc) {
      super.resetEndLocation(e, t), O(e);
    }
  };
  class M {
    constructor(e, t) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!t;
    }
  }
  const j = {
    brace: new M("{"),
    j_oTag: new M("<tag"),
    j_cTag: new M("</tag"),
    j_expr: new M("<tag>...</tag>", true)
  };
  j.template = new M("`", true);
  const $ = true, k = true, ne = true, Q = true, q = true, ee = true;
  class K {
    constructor(e, t = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.rightAssociative = !!t.rightAssociative, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop != null ? t.binop : null, this.updateContext = null;
    }
  }
  const G = /* @__PURE__ */ new Map();
  function V(a, e = {}) {
    e.keyword = a;
    const t = H(a, e);
    return G.set(a, t), t;
  }
  function F(a, e) {
    return H(a, {
      beforeExpr: $,
      binop: e
    });
  }
  let le = -1;
  const oe = [], fe = [], he = [], de = [], Pe = [], we = [];
  function H(a, e = {}) {
    var t, r, i, o;
    return ++le, fe.push(a), he.push((t = e.binop) != null ? t : -1), de.push((r = e.beforeExpr) != null ? r : false), Pe.push((i = e.startsExpr) != null ? i : false), we.push((o = e.prefix) != null ? o : false), oe.push(new K(a, e)), le;
  }
  function te(a, e = {}) {
    var t, r, i, o;
    return ++le, G.set(a, le), fe.push(a), he.push((t = e.binop) != null ? t : -1), de.push((r = e.beforeExpr) != null ? r : false), Pe.push((i = e.startsExpr) != null ? i : false), we.push((o = e.prefix) != null ? o : false), oe.push(new K("name", e)), le;
  }
  const Ie = {
    bracketL: H("[", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketHashL: H("#[", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketBarL: H("[|", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketR: H("]"),
    bracketBarR: H("|]"),
    braceL: H("{", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceBarL: H("{|", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceHashL: H("#{", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceR: H("}"),
    braceBarR: H("|}"),
    parenL: H("(", {
      beforeExpr: $,
      startsExpr: k
    }),
    parenR: H(")"),
    comma: H(",", {
      beforeExpr: $
    }),
    semi: H(";", {
      beforeExpr: $
    }),
    colon: H(":", {
      beforeExpr: $
    }),
    doubleColon: H("::", {
      beforeExpr: $
    }),
    dot: H("."),
    question: H("?", {
      beforeExpr: $
    }),
    questionDot: H("?."),
    arrow: H("=>", {
      beforeExpr: $
    }),
    template: H("template"),
    ellipsis: H("...", {
      beforeExpr: $
    }),
    backQuote: H("`", {
      startsExpr: k
    }),
    dollarBraceL: H("${", {
      beforeExpr: $,
      startsExpr: k
    }),
    templateTail: H("...`", {
      startsExpr: k
    }),
    templateNonTail: H("...${", {
      beforeExpr: $,
      startsExpr: k
    }),
    at: H("@"),
    hash: H("#", {
      startsExpr: k
    }),
    interpreterDirective: H("#!..."),
    eq: H("=", {
      beforeExpr: $,
      isAssign: Q
    }),
    assign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    slashAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    xorAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    moduloAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    incDec: H("++/--", {
      prefix: q,
      postfix: ee,
      startsExpr: k
    }),
    bang: H("!", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    tilde: H("~", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    doubleCaret: H("^^", {
      startsExpr: k
    }),
    doubleAt: H("@@", {
      startsExpr: k
    }),
    pipeline: F("|>", 0),
    nullishCoalescing: F("??", 1),
    logicalOR: F("||", 1),
    logicalAND: F("&&", 2),
    bitwiseOR: F("|", 3),
    bitwiseXOR: F("^", 4),
    bitwiseAND: F("&", 5),
    equality: F("==/!=/===/!==", 6),
    lt: F("</>/<=/>=", 7),
    gt: F("</>/<=/>=", 7),
    relational: F("</>/<=/>=", 7),
    bitShift: F("<</>>/>>>", 8),
    bitShiftL: F("<</>>/>>>", 8),
    bitShiftR: F("<</>>/>>>", 8),
    plusMin: H("+/-", {
      beforeExpr: $,
      binop: 9,
      prefix: q,
      startsExpr: k
    }),
    modulo: H("%", {
      binop: 10,
      startsExpr: k
    }),
    star: H("*", {
      binop: 10
    }),
    slash: F("/", 10),
    exponent: H("**", {
      beforeExpr: $,
      binop: 11,
      rightAssociative: true
    }),
    _in: V("in", {
      beforeExpr: $,
      binop: 7
    }),
    _instanceof: V("instanceof", {
      beforeExpr: $,
      binop: 7
    }),
    _break: V("break"),
    _case: V("case", {
      beforeExpr: $
    }),
    _catch: V("catch"),
    _continue: V("continue"),
    _debugger: V("debugger"),
    _default: V("default", {
      beforeExpr: $
    }),
    _else: V("else", {
      beforeExpr: $
    }),
    _finally: V("finally"),
    _function: V("function", {
      startsExpr: k
    }),
    _if: V("if"),
    _return: V("return", {
      beforeExpr: $
    }),
    _switch: V("switch"),
    _throw: V("throw", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _try: V("try"),
    _var: V("var"),
    _const: V("const"),
    _with: V("with"),
    _new: V("new", {
      beforeExpr: $,
      startsExpr: k
    }),
    _this: V("this", {
      startsExpr: k
    }),
    _super: V("super", {
      startsExpr: k
    }),
    _class: V("class", {
      startsExpr: k
    }),
    _extends: V("extends", {
      beforeExpr: $
    }),
    _export: V("export"),
    _import: V("import", {
      startsExpr: k
    }),
    _null: V("null", {
      startsExpr: k
    }),
    _true: V("true", {
      startsExpr: k
    }),
    _false: V("false", {
      startsExpr: k
    }),
    _typeof: V("typeof", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _void: V("void", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _delete: V("delete", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _do: V("do", {
      isLoop: ne,
      beforeExpr: $
    }),
    _for: V("for", {
      isLoop: ne
    }),
    _while: V("while", {
      isLoop: ne
    }),
    _as: te("as", {
      startsExpr: k
    }),
    _assert: te("assert", {
      startsExpr: k
    }),
    _async: te("async", {
      startsExpr: k
    }),
    _await: te("await", {
      startsExpr: k
    }),
    _from: te("from", {
      startsExpr: k
    }),
    _get: te("get", {
      startsExpr: k
    }),
    _let: te("let", {
      startsExpr: k
    }),
    _meta: te("meta", {
      startsExpr: k
    }),
    _of: te("of", {
      startsExpr: k
    }),
    _sent: te("sent", {
      startsExpr: k
    }),
    _set: te("set", {
      startsExpr: k
    }),
    _static: te("static", {
      startsExpr: k
    }),
    _yield: te("yield", {
      startsExpr: k
    }),
    _asserts: te("asserts", {
      startsExpr: k
    }),
    _checks: te("checks", {
      startsExpr: k
    }),
    _exports: te("exports", {
      startsExpr: k
    }),
    _global: te("global", {
      startsExpr: k
    }),
    _implements: te("implements", {
      startsExpr: k
    }),
    _intrinsic: te("intrinsic", {
      startsExpr: k
    }),
    _infer: te("infer", {
      startsExpr: k
    }),
    _is: te("is", {
      startsExpr: k
    }),
    _mixins: te("mixins", {
      startsExpr: k
    }),
    _proto: te("proto", {
      startsExpr: k
    }),
    _require: te("require", {
      startsExpr: k
    }),
    _keyof: te("keyof", {
      startsExpr: k
    }),
    _readonly: te("readonly", {
      startsExpr: k
    }),
    _unique: te("unique", {
      startsExpr: k
    }),
    _abstract: te("abstract", {
      startsExpr: k
    }),
    _declare: te("declare", {
      startsExpr: k
    }),
    _enum: te("enum", {
      startsExpr: k
    }),
    _module: te("module", {
      startsExpr: k
    }),
    _namespace: te("namespace", {
      startsExpr: k
    }),
    _interface: te("interface", {
      startsExpr: k
    }),
    _type: te("type", {
      startsExpr: k
    }),
    _opaque: te("opaque", {
      startsExpr: k
    }),
    name: H("name", {
      startsExpr: k
    }),
    string: H("string", {
      startsExpr: k
    }),
    num: H("num", {
      startsExpr: k
    }),
    bigint: H("bigint", {
      startsExpr: k
    }),
    decimal: H("decimal", {
      startsExpr: k
    }),
    regexp: H("regexp", {
      startsExpr: k
    }),
    privateName: H("#name", {
      startsExpr: k
    }),
    eof: H("eof"),
    jsxName: H("jsxName"),
    jsxText: H("jsxText", {
      beforeExpr: true
    }),
    jsxTagStart: H("jsxTagStart", {
      startsExpr: true
    }),
    jsxTagEnd: H("jsxTagEnd"),
    placeholder: H("%%", {
      startsExpr: true
    })
  };
  function Te(a) {
    return a >= 93 && a <= 128;
  }
  function pe(a) {
    return a <= 92;
  }
  function z(a) {
    return a >= 58 && a <= 128;
  }
  function W(a) {
    return a >= 58 && a <= 132;
  }
  function ae(a) {
    return de[a];
  }
  function ce(a) {
    return Pe[a];
  }
  function xe(a) {
    return a >= 29 && a <= 33;
  }
  function Se(a) {
    return a >= 125 && a <= 127;
  }
  function Le(a) {
    return a >= 90 && a <= 92;
  }
  function Ee(a) {
    return a >= 58 && a <= 92;
  }
  function J(a) {
    return a >= 39 && a <= 59;
  }
  function me(a) {
    return a === 34;
  }
  function ke(a) {
    return we[a];
  }
  function _e(a) {
    return a >= 117 && a <= 119;
  }
  function Re(a) {
    return a >= 120 && a <= 126;
  }
  function $e(a) {
    return fe[a];
  }
  function Ge(a) {
    return he[a];
  }
  function lt(a) {
    return a === 57;
  }
  function Ze(a) {
    return a >= 24 && a <= 25;
  }
  function Xe(a) {
    return oe[a];
  }
  oe[8].updateContext = (a) => {
    a.pop();
  }, oe[5].updateContext = oe[7].updateContext = oe[23].updateContext = (a) => {
    a.push(j.brace);
  }, oe[22].updateContext = (a) => {
    a[a.length - 1] === j.template ? a.pop() : a.push(j.template);
  }, oe[138].updateContext = (a) => {
    a.push(j.j_expr, j.j_oTag);
  };
  let et = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", st = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const re = new RegExp("[" + et + "]"), be = new RegExp("[" + et + st + "]");
  et = st = null;
  const ue = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Me = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Y(a, e) {
    let t = 65536;
    for (let r = 0, i = e.length; r < i; r += 2) {
      if (t += e[r], t > a)
        return false;
      if (t += e[r + 1], t >= a)
        return true;
    }
    return false;
  }
  function Ne(a) {
    return a < 65 ? a === 36 : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && re.test(String.fromCharCode(a)) : Y(a, ue);
  }
  function Be(a) {
    return a < 48 ? a === 36 : a < 58 ? true : a < 65 ? false : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && be.test(String.fromCharCode(a)) : Y(a, ue) || Y(a, Me);
  }
  const X = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, je = new Set(X.keyword), rt = new Set(X.strict), vt = new Set(X.strictBind);
  function gt(a, e) {
    return e && a === "await" || a === "enum";
  }
  function ut(a, e) {
    return gt(a, e) || rt.has(a);
  }
  function qe(a) {
    return vt.has(a);
  }
  function De(a, e) {
    return ut(a, e) || qe(a);
  }
  function Tt(a) {
    return je.has(a);
  }
  function sr(a, e, t) {
    return a === 64 && e === 64 && Ne(t);
  }
  const ar = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Nr(a) {
    return ar.has(a);
  }
  const At = 0, Dt = 1, Ye = 2, bt = 4, ct = 8, $t = 16, Mr = 32, xt = 64, or = 128, qt = 256, Vt = Dt | Ye | qt, it = 1, wt = 2, Br = 4, pt = 8, Kt = 16, _r = 64, Wt = 128, lr = 256, ur = 512, cr = 1024, pr = 2048, Fr = it | wt | pt | Wt, nt = it | 0 | pt | 0, Ht = it | 0 | Br | 0, jr = it | 0 | Kt | 0, Es = 0 | wt | 0 | Wt, vs = 0 | wt | 0 | 0, Rr = it | wt | pt | lr, Ur = 0 | cr, Pt = 0 | _r, As = it | 0 | 0 | _r, Cs = Rr | ur, ws = 0 | cr, Is = pr, zt = 4, fr = 2, hr = 1, dr = fr | hr, Ns = fr | zt, ks = hr | zt, Os = fr, Ds = hr, mr = 0;
  class Ls {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        const [t, r] = e;
        if (!this.hasPlugin(t))
          return false;
        const i = this.plugins.get(t);
        for (const o of Object.keys(r))
          if ((i == null ? void 0 : i[o]) !== r[o])
            return false;
        return true;
      }
    }
    getPluginOption(e, t) {
      var r;
      return (r = this.plugins.get(e)) == null ? void 0 : r[t];
    }
  }
  function $r(a, e) {
    a.trailingComments === void 0 ? a.trailingComments = e : a.trailingComments.unshift(...e);
  }
  function Ms(a, e) {
    a.leadingComments === void 0 ? a.leadingComments = e : a.leadingComments.unshift(...e);
  }
  function Bt(a, e) {
    a.innerComments === void 0 ? a.innerComments = e : a.innerComments.unshift(...e);
  }
  function _t(a, e, t) {
    let r = null, i = e.length;
    for (; r === null && i > 0; )
      r = e[--i];
    r === null || r.start > t.start ? Bt(a, t.comments) : $r(r, t.comments);
  }
  class Bs extends Ls {
    addComment(e) {
      this.filename && (e.loc.filename = this.filename), this.state.comments.push(e);
    }
    processComment(e) {
      const {
        commentStack: t
      } = this.state, r = t.length;
      if (r === 0)
        return;
      let i = r - 1;
      const o = t[i];
      o.start === e.end && (o.leadingNode = e, i--);
      const {
        start: d
      } = e;
      for (; i >= 0; i--) {
        const u = t[i], E = u.end;
        if (E > d)
          u.containingNode = e, this.finalizeComment(u), t.splice(i, 1);
        else {
          E === d && (u.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      const {
        comments: t
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && $r(e.leadingNode, t), e.trailingNode !== null && Ms(e.trailingNode, t);
      else {
        const {
          containingNode: r,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (r.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              _t(r, r.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              _t(r, r.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              _t(r, r.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              _t(r, r.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              _t(r, r.specifiers, e);
              break;
            default:
              Bt(r, t);
          }
        else
          Bt(r, t);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack: e
      } = this.state;
      for (let t = e.length - 1; t >= 0; t--)
        this.finalizeComment(e[t]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      const {
        commentStack: t
      } = this.state, {
        length: r
      } = t;
      if (r === 0)
        return;
      const i = t[r - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    takeSurroundingComments(e, t, r) {
      const {
        commentStack: i
      } = this.state, o = i.length;
      if (o === 0)
        return;
      let d = o - 1;
      for (; d >= 0; d--) {
        const u = i[d], E = u.end;
        if (u.start === r)
          u.leadingNode = e;
        else if (E === t)
          u.trailingNode = e;
        else if (E < t)
          break;
      }
    }
  }
  const yr = /\r\n?|[\n\u2028\u2029]/, Gt = new RegExp(yr.source, "g");
  function St(a) {
    switch (a) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const br = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, _s = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, qr = new RegExp("(?=(" + _s.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Fs(a) {
    switch (a) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class gr {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 135, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [j.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    init({
      strictMode: e,
      sourceType: t,
      startLine: r,
      startColumn: i
    }) {
      this.strict = e === false ? false : e === true ? true : t === "module", this.curLine = r, this.lineStart = -i, this.startLoc = this.endLoc = new n(r, i, 0);
    }
    curPosition() {
      return new n(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(e) {
      const t = new gr(), r = Object.keys(this);
      for (let i = 0, o = r.length; i < o; i++) {
        const d = r[i];
        let u = this[d];
        !e && Array.isArray(u) && (u = u.slice()), t[d] = u;
      }
      return t;
    }
  }
  const js = ["at"], Rs = ["at"];
  var Us = function(e) {
    return e >= 48 && e <= 57;
  };
  const $s = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Vr = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Xt = {
    bin: (a) => a === 48 || a === 49,
    oct: (a) => a >= 48 && a <= 55,
    dec: (a) => a >= 48 && a <= 57,
    hex: (a) => a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102
  };
  class ft {
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new h(e.startLoc, e.endLoc);
    }
  }
  class qs extends Bs {
    constructor(e, t) {
      super(), this.isLookahead = void 0, this.tokens = [], this.state = new gr(), this.state.init(e), this.input = t, this.length = t.length, this.isLookahead = false;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ft(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), true) : false;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      const e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t = this.state;
      return this.state = e, t;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return br.lastIndex = e, br.test(this.input) ? br.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(e) {
      let t = this.input.charCodeAt(e);
      if ((t & 64512) === 55296 && ++e < this.input.length) {
        const r = this.input.charCodeAt(e);
        (r & 64512) === 56320 && (t = 65536 + ((t & 1023) << 10) + (r & 1023));
      }
      return t;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([t, r]) => this.raise(t, {
        at: r
      })), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(135);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
      let e;
      this.isLookahead || (e = this.state.curPosition());
      const t = this.state.pos, r = this.input.indexOf("*/", t + 2);
      if (r === -1)
        throw this.raise(m.UnterminatedComment, {
          at: this.state.curPosition()
        });
      for (this.state.pos = r + 2, Gt.lastIndex = t + 2; Gt.test(this.input) && Gt.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = Gt.lastIndex;
      if (this.isLookahead)
        return;
      const i = {
        type: "CommentBlock",
        value: this.input.slice(t + 2, r),
        start: t,
        end: r + 2,
        loc: new h(e, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(i), i;
    }
    skipLineComment(e) {
      const t = this.state.pos;
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !St(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      const o = this.state.pos, d = this.input.slice(t + e, o), u = {
        type: "CommentLine",
        value: d,
        start: t,
        end: o,
        loc: new h(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(u), u;
    }
    skipSpace() {
      const e = this.state.pos, t = [];
      e:
        for (; this.state.pos < this.length; ) {
          const r = this.input.charCodeAt(this.state.pos);
          switch (r) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const i = this.skipBlockComment();
                  i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
                  break;
                }
                case 47: {
                  const i = this.skipLineComment(2);
                  i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Fs(r))
                ++this.state.pos;
              else if (r === 45 && !this.inModule) {
                const i = this.state.pos;
                if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                  const o = this.skipLineComment(3);
                  o !== void 0 && (this.addComment(o), this.options.attachComment && t.push(o));
                } else
                  break e;
              } else if (r === 60 && !this.inModule) {
                const i = this.state.pos;
                if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                  const o = this.skipLineComment(4);
                  o !== void 0 && (this.addComment(o), this.options.attachComment && t.push(o));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (t.length > 0) {
        const r = this.state.pos, i = {
          start: e,
          end: r,
          comments: t,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, t) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const r = this.state.type;
      this.state.type = e, this.state.value = t, this.isLookahead || this.updateContext(r);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const e = this.state.pos + 1, t = this.codePointAtPos(e);
      if (t >= 48 && t <= 57)
        throw this.raise(m.UnexpectedDigitAfterHash, {
          at: this.state.curPosition()
        });
      if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
          throw this.raise(t === 123 ? m.RecordExpressionHashIncorrectStartSyntaxType : m.TupleExpressionHashIncorrectStartSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, t === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        Ne(t) ? (++this.state.pos, this.finishToken(134, this.readWord1(t))) : t === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(true);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33)
        return false;
      const t = this.state.pos;
      for (this.state.pos += 1; !St(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      const r = this.input.slice(t + 2, this.state.pos);
      return this.finishToken(28, r), true;
    }
    readToken_mult_modulo(e) {
      let t = e === 42 ? 55 : 54, r = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (r++, i = this.input.charCodeAt(this.state.pos + 2), t = 57), i === 61 && !this.state.inType && (r++, t = e === 37 ? 33 : 30), this.finishOp(t, r);
    }
    readToken_pipe_amp(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (t === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && t === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(m.RecordExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && t === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(m.TupleExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (t === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e === 61 && !this.state.inType)
        this.finishOp(32, 2);
      else if (e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
          throw this.unexpected();
      } else
        this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === e) {
        this.finishOp(34, 2);
        return;
      }
      t === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: e
      } = this.state, t = this.input.charCodeAt(e + 1);
      if (t === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (t === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: e
      } = this.state, t = this.input.charCodeAt(e + 1);
      if (t === 62) {
        const r = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + r) === 61) {
          this.finishOp(30, r + 1);
          return;
        }
        this.finishOp(52, r);
        return;
      }
      if (t === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && t === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const e = this.input.charCodeAt(this.state.pos + 1), t = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? t === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(t >= 48 && t <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(m.TupleExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(m.RecordExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const t = this.input.charCodeAt(this.state.pos + 1);
          if (t === 120 || t === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (t === 111 || t === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (t === 98 || t === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ne(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(m.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, t) {
      const r = this.input.slice(this.state.pos, this.state.pos + t);
      this.state.pos += t, this.finishToken(e, r);
    }
    readRegexp() {
      const e = this.state.startLoc, t = this.state.start + 1;
      let r, i, {
        pos: o
      } = this.state;
      for (; ; ++o) {
        if (o >= this.length)
          throw this.raise(m.UnterminatedRegExp, {
            at: f2(e, 1)
          });
        const w = this.input.charCodeAt(o);
        if (St(w))
          throw this.raise(m.UnterminatedRegExp, {
            at: f2(e, 1)
          });
        if (r)
          r = false;
        else {
          if (w === 91)
            i = true;
          else if (w === 93 && i)
            i = false;
          else if (w === 47 && !i)
            break;
          r = w === 92;
        }
      }
      const d = this.input.slice(t, o);
      ++o;
      let u = "";
      const E = () => f2(e, o + 2 - t);
      for (; o < this.length; ) {
        const w = this.codePointAtPos(o), U = String.fromCharCode(w);
        if ($s.has(w))
          w === 118 ? (this.expectPlugin("regexpUnicodeSets", E()), u.includes("u") && this.raise(m.IncompatibleRegExpUVFlags, {
            at: E()
          })) : w === 117 && u.includes("v") && this.raise(m.IncompatibleRegExpUVFlags, {
            at: E()
          }), u.includes(U) && this.raise(m.DuplicateRegExpFlags, {
            at: E()
          });
        else if (Be(w) || w === 92)
          this.raise(m.MalformedRegExpFlags, {
            at: E()
          });
        else
          break;
        ++o, u += U;
      }
      this.state.pos = o, this.finishToken(133, {
        pattern: d,
        flags: u
      });
    }
    readInt(e, t, r, i = true) {
      const o = this.state.pos, d = e === 16 ? Vr.hex : Vr.decBinOct, u = e === 16 ? Xt.hex : e === 10 ? Xt.dec : e === 8 ? Xt.oct : Xt.bin;
      let E = false, w = 0;
      for (let U = 0, ge = t == null ? 1 / 0 : t; U < ge; ++U) {
        const ye = this.input.charCodeAt(this.state.pos);
        let Ae;
        if (ye === 95 && i !== "bail") {
          const Oe = this.input.charCodeAt(this.state.pos - 1), Ve = this.input.charCodeAt(this.state.pos + 1);
          i ? (Number.isNaN(Ve) || !u(Ve) || d.has(Oe) || d.has(Ve)) && this.raise(m.UnexpectedNumericSeparator, {
            at: this.state.curPosition()
          }) : this.raise(m.NumericSeparatorInEscapeSequence, {
            at: this.state.curPosition()
          }), ++this.state.pos;
          continue;
        }
        if (ye >= 97 ? Ae = ye - 97 + 10 : ye >= 65 ? Ae = ye - 65 + 10 : Us(ye) ? Ae = ye - 48 : Ae = 1 / 0, Ae >= e)
          if (this.options.errorRecovery && Ae <= 9)
            Ae = 0, this.raise(m.InvalidDigit, {
              at: this.state.curPosition(),
              radix: e
            });
          else if (r)
            Ae = 0, E = true;
          else
            break;
        ++this.state.pos, w = w * e + Ae;
      }
      return this.state.pos === o || t != null && this.state.pos - o !== t || E ? null : w;
    }
    readRadixNumber(e) {
      const t = this.state.curPosition();
      let r = false;
      this.state.pos += 2;
      const i = this.readInt(e);
      i == null && this.raise(m.InvalidDigit, {
        at: f2(t, 2),
        radix: e
      });
      const o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = true;
      else if (o === 109)
        throw this.raise(m.InvalidDecimal, {
          at: t
        });
      if (Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(m.NumberIdentifier, {
          at: this.state.curPosition()
        });
      if (r) {
        const d = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(131, d);
        return;
      }
      this.finishToken(130, i);
    }
    readNumber(e) {
      const t = this.state.pos, r = this.state.curPosition();
      let i = false, o = false, d = false, u = false, E = false;
      !e && this.readInt(10) === null && this.raise(m.InvalidNumber, {
        at: this.state.curPosition()
      });
      const w = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
      if (w) {
        const Ae = this.input.slice(t, this.state.pos);
        if (this.recordStrictModeErrors(m.StrictOctalLiteral, {
          at: r
        }), !this.state.strict) {
          const Oe = Ae.indexOf("_");
          Oe > 0 && this.raise(m.ZeroDigitNumericSeparator, {
            at: f2(r, Oe)
          });
        }
        E = w && !/[89]/.test(Ae);
      }
      let U = this.input.charCodeAt(this.state.pos);
      if (U === 46 && !E && (++this.state.pos, this.readInt(10), i = true, U = this.input.charCodeAt(this.state.pos)), (U === 69 || U === 101) && !E && (U = this.input.charCodeAt(++this.state.pos), (U === 43 || U === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(m.InvalidOrMissingExponent, {
        at: r
      }), i = true, u = true, U = this.input.charCodeAt(this.state.pos)), U === 110 && ((i || w) && this.raise(m.InvalidBigIntLiteral, {
        at: r
      }), ++this.state.pos, o = true), U === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (u || w) && this.raise(m.InvalidDecimal, {
        at: r
      }), ++this.state.pos, d = true), Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(m.NumberIdentifier, {
          at: this.state.curPosition()
        });
      const ge = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
      if (o) {
        this.finishToken(131, ge);
        return;
      }
      if (d) {
        this.finishToken(132, ge);
        return;
      }
      const ye = E ? parseInt(ge, 8) : parseFloat(ge);
      this.finishToken(130, ye);
    }
    readCodePoint(e) {
      const t = this.input.charCodeAt(this.state.pos);
      let r;
      if (t === 123) {
        if (++this.state.pos, r = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e), ++this.state.pos, r !== null && r > 1114111)
          if (e)
            this.raise(m.InvalidCodePoint, {
              at: this.state.curPosition()
            });
          else
            return null;
      } else
        r = this.readHexChar(4, false, e);
      return r;
    }
    readString(e) {
      let t = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedString, {
            at: this.state.startLoc
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === e)
          break;
        if (i === 92)
          t += this.input.slice(r, this.state.pos), t += this.readEscapedChar(false), r = this.state.pos;
        else if (i === 8232 || i === 8233)
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        else {
          if (St(i))
            throw this.raise(m.UnterminatedString, {
              at: this.state.startLoc
            });
          ++this.state.pos;
        }
      }
      t += this.input.slice(r, this.state.pos++), this.finishToken(129, t);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = "", t = this.state.pos, r = false;
      for (++this.state.pos; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedTemplate, {
            at: f2(this.state.startLoc, 1)
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === 96) {
          ++this.state.pos, e += this.input.slice(t, this.state.pos), this.finishToken(24, r ? null : e);
          return;
        }
        if (i === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          this.state.pos += 2, e += this.input.slice(t, this.state.pos), this.finishToken(25, r ? null : e);
          return;
        }
        if (i === 92) {
          e += this.input.slice(t, this.state.pos);
          const o = this.readEscapedChar(true);
          o === null ? r = true : e += o, t = this.state.pos;
        } else if (St(i)) {
          switch (e += this.input.slice(t, this.state.pos), ++this.state.pos, i) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
            case 10:
              e += `
`;
              break;
            default:
              e += String.fromCharCode(i);
              break;
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, t = this.state.pos;
        } else
          ++this.state.pos;
      }
    }
    recordStrictModeErrors(e, {
      at: t
    }) {
      const r = t.index;
      this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, {
        at: t
      }) : this.state.strictErrors.set(r, [e, t]);
    }
    readEscapedChar(e) {
      const t = !e, r = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, r) {
        case 110:
          return `
`;
        case 114:
          return "\r";
        case 120: {
          const i = this.readHexChar(2, false, t);
          return i === null ? null : String.fromCharCode(i);
        }
        case 117: {
          const i = this.readCodePoint(t);
          return i === null ? null : String.fromCodePoint(i);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
        case 10:
          this.state.lineStart = this.state.pos, ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (e)
            return null;
          this.recordStrictModeErrors(m.StrictNumericEscape, {
            at: f2(this.state.curPosition(), -1)
          });
        default:
          if (r >= 48 && r <= 55) {
            const i = f2(this.state.curPosition(), -1);
            let d = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0], u = parseInt(d, 8);
            u > 255 && (d = d.slice(0, -1), u = parseInt(d, 8)), this.state.pos += d.length - 1;
            const E = this.input.charCodeAt(this.state.pos);
            if (d !== "0" || E === 56 || E === 57) {
              if (e)
                return null;
              this.recordStrictModeErrors(m.StrictNumericEscape, {
                at: i
              });
            }
            return String.fromCharCode(u);
          }
          return String.fromCharCode(r);
      }
    }
    readHexChar(e, t, r) {
      const i = this.state.curPosition(), o = this.readInt(16, e, t, false);
      return o === null && (r ? this.raise(m.InvalidEscapeSequence, {
        at: i
      }) : this.state.pos = i.index - 1), o;
    }
    readWord1(e) {
      this.state.containsEsc = false;
      let t = "";
      const r = this.state.pos;
      let i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const o = this.codePointAtPos(this.state.pos);
        if (Be(o))
          this.state.pos += o <= 65535 ? 1 : 2;
        else if (o === 92) {
          this.state.containsEsc = true, t += this.input.slice(i, this.state.pos);
          const d = this.state.curPosition(), u = this.state.pos === r ? Ne : Be;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(m.MissingUnicodeEscape, {
              at: this.state.curPosition()
            }), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const E = this.readCodePoint(true);
          E !== null && (u(E) || this.raise(m.EscapedCharNotAnIdentifier, {
            at: d
          }), t += String.fromCodePoint(E)), i = this.state.pos;
        } else
          break;
      }
      return t + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      const t = this.readWord1(e), r = G.get(t);
      r !== void 0 ? this.finishToken(r, $e(r)) : this.finishToken(128, t);
    }
    checkKeywordEscapes() {
      const {
        type: e
      } = this.state;
      Ee(e) && this.state.containsEsc && this.raise(m.InvalidEscapedReservedWord, {
        at: this.state.startLoc,
        reservedWord: $e(e)
      });
    }
    raise(e, t) {
      const {
        at: r
      } = t, i = s(t, js), o = r instanceof n ? r : r.loc.start, d = e({
        loc: o,
        details: i
      });
      if (!this.options.errorRecovery)
        throw d;
      return this.isLookahead || this.state.errors.push(d), d;
    }
    raiseOverwrite(e, t) {
      const {
        at: r
      } = t, i = s(t, Rs), o = r instanceof n ? r : r.loc.start, d = o.index, u = this.state.errors;
      for (let E = u.length - 1; E >= 0; E--) {
        const w = u[E];
        if (w.loc.index === d)
          return u[E] = e({
            loc: o,
            details: i
          });
        if (w.loc.index < d)
          break;
      }
      return this.raise(e, t);
    }
    updateContext(e) {
    }
    unexpected(e, t) {
      throw this.raise(m.UnexpectedToken, {
        expected: t ? $e(t) : null,
        at: e != null ? e : this.state.startLoc
      });
    }
    expectPlugin(e, t) {
      if (this.hasPlugin(e))
        return true;
      throw this.raise(m.MissingPlugin, {
        at: t != null ? t : this.state.startLoc,
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((t) => this.hasPlugin(t)))
        throw this.raise(m.MissingOneOfPlugins, {
          at: this.state.startLoc,
          missingPlugin: e
        });
    }
  }
  class Tr {
    constructor(e) {
      this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = e;
    }
  }
  class xr {
    constructor(e, t) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e, this.inModule = t;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & Ye) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & $t) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & Mr) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & xt) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e = this.currentThisScopeFlags();
      return (e & xt) > 0 && (e & Ye) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & or)
          return true;
        if (t & (Vt | xt))
          return false;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & Ye) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Tr(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & (Ye | or) || !this.parser.inModule && e.flags & Dt);
    }
    declareName(e, t, r) {
      let i = this.currentScope();
      if (t & pt || t & Kt)
        this.checkRedeclarationInScope(i, e, t, r), t & Kt ? i.functions.add(e) : i.lexical.add(e), t & pt && this.maybeExportDefined(i, e);
      else if (t & Br)
        for (let o = this.scopeStack.length - 1; o >= 0 && (i = this.scopeStack[o], this.checkRedeclarationInScope(i, e, t, r), i.var.add(e), this.maybeExportDefined(i, e), !(i.flags & Vt)); --o)
          ;
      this.parser.inModule && i.flags & Dt && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, t) {
      this.parser.inModule && e.flags & Dt && this.undefinedExports.delete(t);
    }
    checkRedeclarationInScope(e, t, r, i) {
      this.isRedeclaredInScope(e, t, r) && this.parser.raise(m.VarRedeclaration, {
        at: i,
        identifierName: t
      });
    }
    isRedeclaredInScope(e, t, r) {
      return r & it ? r & pt ? e.lexical.has(t) || e.functions.has(t) || e.var.has(t) : r & Kt ? e.lexical.has(t) || !this.treatFunctionsAsVarInScope(e) && e.var.has(t) : e.lexical.has(t) && !(e.flags & ct && e.lexical.values().next().value === t) || !this.treatFunctionsAsVarInScope(e) && e.functions.has(t) : false;
    }
    checkLocalExport(e) {
      const {
        name: t
      } = e, r = this.scopeStack[0];
      !r.lexical.has(t) && !r.var.has(t) && !r.functions.has(t) && this.undefinedExports.set(t, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & Vt)
          return t;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & (Vt | xt) && !(t & bt))
          return t;
      }
    }
  }
  class Vs extends Tr {
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class Ks extends xr {
    createScope(e) {
      return new Vs(e);
    }
    declareName(e, t, r) {
      const i = this.currentScope();
      if (t & pr) {
        this.checkRedeclarationInScope(i, e, t, r), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(...arguments);
    }
    isRedeclaredInScope(e, t, r) {
      return super.isRedeclaredInScope(...arguments) ? true : r & pr ? !e.declareFunctions.has(t) && (e.lexical.has(t) || e.functions.has(t)) : false;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }
  class Ws {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class Hs {
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Ws());
    }
    exit() {
      const e = this.stack.pop(), t = this.current();
      for (const [r, i] of Array.from(e.undefinedPrivateNames))
        t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, i) : this.parser.raise(m.InvalidPrivateFieldResolution, {
          at: i,
          identifierName: r
        });
    }
    declarePrivateName(e, t, r) {
      const {
        privateNames: i,
        loneAccessors: o,
        undefinedPrivateNames: d
      } = this.current();
      let u = i.has(e);
      if (t & dr) {
        const E = u && o.get(e);
        if (E) {
          const w = E & zt, U = t & zt, ge = E & dr, ye = t & dr;
          u = ge === ye || w !== U, u || o.delete(e);
        } else
          u || o.set(e, t);
      }
      u && this.parser.raise(m.PrivateNameRedeclaration, {
        at: r,
        identifierName: e
      }), i.add(e), d.delete(e);
    }
    usePrivateName(e, t) {
      let r;
      for (r of this.stack)
        if (r.privateNames.has(e))
          return;
      r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(m.InvalidPrivateFieldResolution, {
        at: t,
        identifierName: e
      });
    }
  }
  const zs = 0, Kr = 1, Pr = 2, Wr = 3;
  class Jt {
    constructor(e = zs) {
      this.type = void 0, this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === Pr || this.type === Kr;
    }
    isCertainlyParameterDeclaration() {
      return this.type === Wr;
    }
  }
  class Hr extends Jt {
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, {
      at: t
    }) {
      const r = t.index;
      this.declarationErrors.set(r, [e, t]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }
  class Gs {
    constructor(e) {
      this.parser = void 0, this.stack = [new Jt()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, {
      at: t
    }) {
      const r = {
        at: t.loc.start
      }, {
        stack: i
      } = this;
      let o = i.length - 1, d = i[o];
      for (; !d.isCertainlyParameterDeclaration(); ) {
        if (d.canBeArrowParameterDeclaration())
          d.recordDeclarationError(e, r);
        else
          return;
        d = i[--o];
      }
      this.parser.raise(e, r);
    }
    recordArrowParemeterBindingError(e, {
      at: t
    }) {
      const {
        stack: r
      } = this, i = r[r.length - 1], o = {
        at: t.loc.start
      };
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, o);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, o);
      else
        return;
    }
    recordAsyncArrowParametersError({
      at: e
    }) {
      const {
        stack: t
      } = this;
      let r = t.length - 1, i = t[r];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === Pr && i.recordDeclarationError(m.AwaitBindingIdentifier, {
          at: e
        }), i = t[--r];
    }
    validateAsPattern() {
      const {
        stack: e
      } = this, t = e[e.length - 1];
      !t.canBeArrowParameterDeclaration() || t.iterateErrors(([r, i]) => {
        this.parser.raise(r, {
          at: i
        });
        let o = e.length - 2, d = e[o];
        for (; d.canBeArrowParameterDeclaration(); )
          d.clearDeclarationError(i.index), d = e[--o];
      });
    }
  }
  function Xs() {
    return new Jt(Wr);
  }
  function Js() {
    return new Hr(Kr);
  }
  function Ys() {
    return new Hr(Pr);
  }
  function zr() {
    return new Jt();
  }
  const It = 0, Gr = 1, Yt = 2, Xr = 4, Nt = 8;
  class Qs {
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & Yt) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & Gr) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & Xr) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & Nt) > 0;
    }
  }
  function Qt(a, e) {
    return (a ? Yt : 0) | (e ? Gr : 0);
  }
  class Zs extends qs {
    addExtra(e, t, r, i = true) {
      if (!e)
        return;
      const o = e.extra = e.extra || {};
      i ? o[t] = r : Object.defineProperty(o, t, {
        enumerable: i,
        value: r
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, t) {
      const r = e + t.length;
      if (this.input.slice(e, r) === t) {
        const i = this.input.charCodeAt(r);
        return !(Be(i) || (i & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(e) {
      const t = this.nextTokenStart();
      return this.isUnparsedContextual(t, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), true) : false;
    }
    expectContextual(e, t) {
      if (!this.eatContextual(e))
        throw t != null ? this.raise(t, {
          at: this.state.startLoc
        }) : this.unexpected(null, e);
    }
    canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return yr.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return qr.lastIndex = this.state.end, qr.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = true) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(m.MissingSemicolon, {
        at: this.state.lastTokEndLoc
      });
    }
    expect(e, t) {
      this.eat(e) || this.unexpected(t, e);
    }
    tryParse(e, t = this.state.clone()) {
      const r = {
        node: null
      };
      try {
        const i = e((o = null) => {
          throw r.node = o, r;
        });
        if (this.state.errors.length > t.errors.length) {
          const o = this.state;
          return this.state = t, this.state.tokensLength = o.tokensLength, {
            node: i,
            error: o.errors[t.errors.length],
            thrown: false,
            aborted: false,
            failState: o
          };
        }
        return {
          node: i,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (i) {
        const o = this.state;
        if (this.state = t, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: true,
            aborted: false,
            failState: o
          };
        if (i === r)
          return {
            node: r.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: o
          };
        throw i;
      }
    }
    checkExpressionErrors(e, t) {
      if (!e)
        return false;
      const {
        shorthandAssignLoc: r,
        doubleProtoLoc: i,
        privateKeyLoc: o,
        optionalParametersLoc: d
      } = e, u = !!r || !!i || !!d || !!o;
      if (!t)
        return u;
      r != null && this.raise(m.InvalidCoverInitializedName, {
        at: r
      }), i != null && this.raise(m.DuplicateProto, {
        at: i
      }), o != null && this.raise(m.UnexpectedPrivateField, {
        at: o
      }), d != null && this.unexpected(d);
    }
    isLiteralPropertyName() {
      return W(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isOptionalChain(e) {
      return e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression";
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      const t = this.state.labels;
      this.state.labels = [];
      const r = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const i = this.inModule;
      this.inModule = e;
      const o = this.scope, d = this.getScopeHandler();
      this.scope = new d(this, e);
      const u = this.prodParam;
      this.prodParam = new Qs();
      const E = this.classScope;
      this.classScope = new Hs(this);
      const w = this.expressionScope;
      return this.expressionScope = new Gs(this), () => {
        this.state.labels = t, this.exportedIdentifiers = r, this.inModule = i, this.scope = o, this.prodParam = u, this.classScope = E, this.expressionScope = w;
      };
    }
    enterInitialScopes() {
      let e = It;
      this.inModule && (e |= Yt), this.scope.enter(Dt), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      const {
        privateKeyLoc: t
      } = e;
      t !== null && this.expectPlugin("destructuringPrivate", t);
    }
  }
  class Zt {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class er {
    constructor(e, t, r) {
      this.type = "", this.start = t, this.end = 0, this.loc = new h(r), e != null && e.options.ranges && (this.range = [t, 0]), e != null && e.filename && (this.loc.filename = e.filename);
    }
  }
  const Sr = er.prototype;
  Sr.__clone = function() {
    const a = new er(), e = Object.keys(this);
    for (let t = 0, r = e.length; t < r; t++) {
      const i = e[t];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (a[i] = this[i]);
    }
    return a;
  };
  function ei(a) {
    return at(a);
  }
  function at(a) {
    const {
      type: e,
      start: t,
      end: r,
      loc: i,
      range: o,
      extra: d,
      name: u
    } = a, E = Object.create(Sr);
    return E.type = e, E.start = t, E.end = r, E.loc = i, E.range = o, E.extra = d, E.name = u, e === "Placeholder" && (E.expectedNode = a.expectedNode), E;
  }
  function ti(a) {
    const {
      type: e,
      start: t,
      end: r,
      loc: i,
      range: o,
      extra: d
    } = a;
    if (e === "Placeholder")
      return ei(a);
    const u = Object.create(Sr);
    return u.type = e, u.start = t, u.end = r, u.loc = i, u.range = o, a.raw !== void 0 ? u.raw = a.raw : u.extra = d, u.value = a.value, u;
  }
  class ri extends Zs {
    startNode() {
      return new er(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(e, t) {
      return new er(this, e, t);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.start, e.loc.start);
    }
    finishNode(e, t) {
      return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, t, r) {
      return e.type = t, e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index), this.options.attachComment && this.processComment(e), e;
    }
    resetStartLocation(e, t, r) {
      e.start = t, e.loc.start = r, this.options.ranges && (e.range[0] = t);
    }
    resetEndLocation(e, t = this.state.lastTokEndLoc) {
      e.end = t.index, e.loc.end = t, this.options.ranges && (e.range[1] = t.index);
    }
    resetStartLocationFromNode(e, t) {
      this.resetStartLocation(e, t.start, t.loc.start);
    }
  }
  const si = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Ce = _`flow`((a) => ({
    AmbiguousConditionalArrow: a("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."),
    AmbiguousDeclareModuleKind: a("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."),
    AssignReservedType: a(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`),
    DeclareClassElement: a("The `declare` modifier can only appear on class fields."),
    DeclareClassFieldInitializer: a("Initializers are not allowed in fields with the `declare` modifier."),
    DuplicateDeclareModuleExports: a("Duplicate `declare module.exports` statement."),
    EnumBooleanMemberNotInitialized: a(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`),
    EnumDuplicateMemberName: a(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`),
    EnumInconsistentMemberValues: a(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`),
    EnumInvalidExplicitType: a(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`),
    EnumInvalidExplicitTypeUnknownSupplied: a(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`),
    EnumInvalidMemberInitializerPrimaryType: a(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`),
    EnumInvalidMemberInitializerSymbolType: a(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`),
    EnumInvalidMemberInitializerUnknownType: a(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`),
    EnumInvalidMemberName: a(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`),
    EnumNumberMemberNotInitialized: a(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`),
    EnumStringMemberInconsistentlyInitailized: a(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`),
    GetterMayNotHaveThisParam: a("A getter cannot have a `this` parameter."),
    ImportTypeShorthandOnlyInPureImport: a("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."),
    InexactInsideExact: a("Explicit inexact syntax cannot appear inside an explicit exact object type."),
    InexactInsideNonObject: a("Explicit inexact syntax cannot appear in class or interface definitions."),
    InexactVariance: a("Explicit inexact syntax cannot have variance."),
    InvalidNonTypeImportInDeclareModule: a("Imports within a `declare module` body must always be `import type` or `import typeof`."),
    MissingTypeParamDefault: a("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),
    NestedDeclareModule: a("`declare module` cannot be used inside another `declare module`."),
    NestedFlowComment: a("Cannot have a flow comment inside another flow comment."),
    PatternIsOptional: a("A binding pattern parameter cannot be optional in an implementation signature.", {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: a("A setter cannot have a `this` parameter."),
    SpreadVariance: a("Spread properties cannot have variance."),
    ThisParamAnnotationRequired: a("A type annotation is required for the `this` parameter."),
    ThisParamBannedInConstructor: a("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."),
    ThisParamMayNotBeOptional: a("The `this` parameter cannot be optional."),
    ThisParamMustBeFirst: a("The `this` parameter must be the first function parameter."),
    ThisParamNoDefault: a("The `this` parameter may not have a default value."),
    TypeBeforeInitializer: a("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
    TypeCastInPattern: a("The type cast expression is expected to be wrapped with parenthesis."),
    UnexpectedExplicitInexactInObject: a("Explicit inexact syntax must appear at the end of an inexact object."),
    UnexpectedReservedType: a(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`),
    UnexpectedReservedUnderscore: a("`_` is only allowed as a type argument to call or new."),
    UnexpectedSpaceBetweenModuloChecks: a("Spaces between `%` and `checks` are not allowed here."),
    UnexpectedSpreadType: a("Spread operator cannot appear in class or interface definitions."),
    UnexpectedSubtractionOperand: a('Unexpected token, expected "number" or "bigint".'),
    UnexpectedTokenAfterTypeParameter: a("Expected an arrow function after this type parameter declaration."),
    UnexpectedTypeParameterBeforeAsyncArrowFunction: a("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."),
    UnsupportedDeclareExportKind: a(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`),
    UnsupportedStatementInDeclareModule: a("Only declares and type imports are allowed inside declare module."),
    UnterminatedFlowComment: a("Unterminated flow-comment.")
  }));
  function ii(a) {
    return a.type === "DeclareExportAllDeclaration" || a.type === "DeclareExportDeclaration" && (!a.declaration || a.declaration.type !== "TypeAlias" && a.declaration.type !== "InterfaceDeclaration");
  }
  function Er(a) {
    return a.importKind === "type" || a.importKind === "typeof";
  }
  function Jr(a) {
    return z(a) && a !== 97;
  }
  const ni = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function ai(a, e) {
    const t = [], r = [];
    for (let i = 0; i < a.length; i++)
      (e(a[i], i, a) ? t : r).push(a[i]);
    return [t, r];
  }
  const oi = /\*?\s*@((?:no)?flow)\b/;
  var li = (a) => class extends a {
    constructor(...e) {
      super(...e), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Ks;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e, t) {
      return e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, t);
    }
    addComment(e) {
      if (this.flowPragma === void 0) {
        const t = oi.exec(e.value);
        if (t)
          if (t[1] === "flow")
            this.flowPragma = "flow";
          else if (t[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      return super.addComment(e);
    }
    flowParseTypeInitialiser(e) {
      const t = this.state.inType;
      this.state.inType = true, this.expect(e || 14);
      const r = this.flowParseType();
      return this.state.inType = t, r;
    }
    flowParsePredicate() {
      const e = this.startNode(), t = this.state.startLoc;
      return this.next(), this.expectContextual(107), this.state.lastTokStart > t.index + 1 && this.raise(Ce.UnexpectedSpaceBetweenModuloChecks, {
        at: t
      }), this.eat(10) ? (e.value = this.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e = this.state.inType;
      this.state.inType = true, this.expect(14);
      let t = null, r = null;
      return this.match(54) ? (this.state.inType = e, r = this.flowParsePredicate()) : (t = this.flowParseType(), this.state.inType = e, this.match(54) && (r = this.flowParsePredicate())), [t, r];
    }
    flowParseDeclareClass(e) {
      return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
    }
    flowParseDeclareFunction(e) {
      this.next();
      const t = e.id = this.parseIdentifier(), r = this.startNode(), i = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      const o = this.flowParseFunctionTypeParams();
      return r.params = o.params, r.rest = o.rest, r.this = o._this, this.expect(11), [r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), t.typeAnnotation = this.finishNode(i, "TypeAnnotation"), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, Is, e.id.loc.start), this.finishNode(e, "DeclareFunction");
    }
    flowParseDeclare(e, t) {
      if (this.match(80))
        return this.flowParseDeclareClass(e);
      if (this.match(68))
        return this.flowParseDeclareFunction(e);
      if (this.match(74))
        return this.flowParseDeclareVariable(e);
      if (this.eatContextual(123))
        return this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(Ce.NestedDeclareModule, {
          at: this.state.lastTokStartLoc
        }), this.flowParseDeclareModule(e));
      if (this.isContextual(126))
        return this.flowParseDeclareTypeAlias(e);
      if (this.isContextual(127))
        return this.flowParseDeclareOpaqueType(e);
      if (this.isContextual(125))
        return this.flowParseDeclareInterface(e);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(e, t);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e) {
      return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, Ht, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
    }
    flowParseDeclareModule(e) {
      this.scope.enter(At), this.match(129) ? e.id = this.parseExprAtom() : e.id = this.parseIdentifier();
      const t = e.body = this.startNode(), r = t.body = [];
      for (this.expect(5); !this.match(8); ) {
        let d = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(126) && !this.match(87) && this.raise(Ce.InvalidNonTypeImportInDeclareModule, {
          at: this.state.lastTokStartLoc
        }), this.parseImport(d)) : (this.expectContextual(121, Ce.UnsupportedStatementInDeclareModule), d = this.flowParseDeclare(d, true)), r.push(d);
      }
      this.scope.exit(), this.expect(8), this.finishNode(t, "BlockStatement");
      let i = null, o = false;
      return r.forEach((d) => {
        ii(d) ? (i === "CommonJS" && this.raise(Ce.AmbiguousDeclareModuleKind, {
          at: d
        }), i = "ES") : d.type === "DeclareModuleExports" && (o && this.raise(Ce.DuplicateDeclareModuleExports, {
          at: d
        }), i === "ES" && this.raise(Ce.AmbiguousDeclareModuleKind, {
          at: d
        }), i = "CommonJS", o = true);
      }), e.kind = i || "CommonJS", this.finishNode(e, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e, t) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !t) {
        const r = this.state.value;
        throw this.raise(Ce.UnsupportedDeclareExportKind, {
          at: this.state.startLoc,
          unsupportedExportKind: r,
          suggestion: ni[r]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
        return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127))
        return e = this.parseExport(e), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e) {
      return this.next(), this.expectContextual(108), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e) {
      return this.next(), this.flowParseTypeAlias(e), e.type = "DeclareTypeAlias", e;
    }
    flowParseDeclareOpaqueType(e) {
      return this.next(), this.flowParseOpaqueType(e, true), e.type = "DeclareOpaqueType", e;
    }
    flowParseDeclareInterface(e) {
      return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, "DeclareInterface");
    }
    flowParseInterfaceish(e, t = false) {
      if (e.id = this.flowParseRestrictedIdentifier(!t, true), this.scope.declareName(e.id.name, t ? jr : nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (!t && this.eat(12));
      if (this.isContextual(114)) {
        this.next();
        do
          e.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      if (this.isContextual(110)) {
        this.next();
        do
          e.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      e.body = this.flowParseObjectType({
        allowStatic: t,
        allowExact: false,
        allowSpread: false,
        allowProto: t,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const e = this.startNode();
      return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
    }
    flowParseInterface(e) {
      return this.flowParseInterfaceish(e), this.finishNode(e, "InterfaceDeclaration");
    }
    checkNotUnderscore(e) {
      e === "_" && this.raise(Ce.UnexpectedReservedUnderscore, {
        at: this.state.startLoc
      });
    }
    checkReservedType(e, t, r) {
      !si.has(e) || this.raise(r ? Ce.AssignReservedType : Ce.UnexpectedReservedType, {
        at: t,
        reservedType: e
      });
    }
    flowParseRestrictedIdentifier(e, t) {
      return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
    }
    flowParseTypeAlias(e) {
      return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
    }
    flowParseOpaqueType(e, t) {
      return this.expectContextual(126), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
    }
    flowParseTypeParameter(e = false) {
      const t = this.state.startLoc, r = this.startNode(), i = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return r.name = o.name, r.variance = i, r.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) : e && this.raise(Ce.MissingTypeParamDefault, {
        at: t
      }), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e = this.state.inType, t = this.startNode();
      t.params = [], this.state.inType = true, this.match(47) || this.match(138) ? this.next() : this.unexpected();
      let r = false;
      do {
        const i = this.flowParseTypeParameter(r);
        t.params.push(i), i.default && (r = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e, this.finishNode(t, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e = this.startNode(), t = this.state.inType;
      e.params = [], this.state.inType = true, this.expect(47);
      const r = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); )
        e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = r, this.expect(48), this.state.inType = t, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e = this.startNode(), t = this.state.inType;
      for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
        e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = t, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e = this.startNode();
      if (this.expectContextual(125), e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return e.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      }), this.finishNode(e, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e, t, r) {
      return e.static = t, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = r, this.finishNode(e, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e, t) {
      return e.static = t, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e) {
      for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e, t) {
      const r = this.startNode();
      return e.static = t, e.value = this.flowParseObjectTypeMethodish(r), this.finishNode(e, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: e,
      allowExact: t,
      allowSpread: r,
      allowProto: i,
      allowInexact: o
    }) {
      const d = this.state.inType;
      this.state.inType = true;
      const u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let E, w, U = false;
      for (t && this.match(6) ? (this.expect(6), E = 9, w = true) : (this.expect(5), E = 8, w = false), u.exact = w; !this.match(E); ) {
        let ye = false, Ae = null, Oe = null;
        const Ve = this.startNode();
        if (i && this.isContextual(115)) {
          const He = this.lookahead();
          He.type !== 14 && He.type !== 17 && (this.next(), Ae = this.state.startLoc, e = false);
        }
        if (e && this.isContextual(104)) {
          const He = this.lookahead();
          He.type !== 14 && He.type !== 17 && (this.next(), ye = true);
        }
        const Ke = this.flowParseVariance();
        if (this.eat(0))
          Ae != null && this.unexpected(Ae), this.eat(0) ? (Ke && this.unexpected(Ke.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(Ve, ye))) : u.indexers.push(this.flowParseObjectTypeIndexer(Ve, ye, Ke));
        else if (this.match(10) || this.match(47))
          Ae != null && this.unexpected(Ae), Ke && this.unexpected(Ke.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(Ve, ye));
        else {
          let He = "init";
          if (this.isContextual(98) || this.isContextual(103)) {
            const zi = this.lookahead();
            W(zi.type) && (He = this.state.value, this.next());
          }
          const bs = this.flowParseObjectTypeProperty(Ve, ye, Ae, Ke, He, r, o != null ? o : !w);
          bs === null ? (U = true, Oe = this.state.lastTokStartLoc) : u.properties.push(bs);
        }
        this.flowObjectTypeSemicolon(), Oe && !this.match(8) && !this.match(9) && this.raise(Ce.UnexpectedExplicitInexactInObject, {
          at: Oe
        });
      }
      this.expect(E), r && (u.inexact = U);
      const ge = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = d, ge;
    }
    flowParseObjectTypeProperty(e, t, r, i, o, d, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (d ? u || this.raise(Ce.InexactInsideExact, {
          at: this.state.lastTokStartLoc
        }) : this.raise(Ce.InexactInsideNonObject, {
          at: this.state.lastTokStartLoc
        }), i && this.raise(Ce.InexactVariance, {
          at: i
        }), null) : (d || this.raise(Ce.UnexpectedSpreadType, {
          at: this.state.lastTokStartLoc
        }), r != null && this.unexpected(r), i && this.raise(Ce.SpreadVariance, {
          at: i
        }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
      {
        e.key = this.flowParseObjectPropertyKey(), e.static = t, e.proto = r != null, e.kind = o;
        let E = false;
        return this.match(47) || this.match(10) ? (e.method = true, r != null && this.unexpected(r), i && this.unexpected(i.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(e), !d && e.key.name === "constructor" && e.value.this && this.raise(Ce.ThisParamBannedInConstructor, {
          at: e.value.this
        })) : (o !== "init" && this.unexpected(), e.method = false, this.eat(17) && (E = true), e.value = this.flowParseTypeInitialiser(), e.variance = i), e.optional = E, this.finishNode(e, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e) {
      const t = e.kind === "get" ? 0 : 1, r = e.value.params.length + (e.value.rest ? 1 : 0);
      e.value.this && this.raise(e.kind === "get" ? Ce.GetterMayNotHaveThisParam : Ce.SetterMayNotHaveThisParam, {
        at: e.value.this
      }), r !== t && this.raise(e.kind === "get" ? m.BadGetterArity : m.BadSetterArity, {
        at: e
      }), e.kind === "set" && e.value.rest && this.raise(m.BadSetterRestParameter, {
        at: e
      });
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e, t, r) {
      e = e || this.state.start, t = t || this.state.startLoc;
      let i = r || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        const o = this.startNodeAt(e, t);
        o.qualification = i, o.id = this.flowParseRestrictedIdentifier(true), i = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return i;
    }
    flowParseGenericType(e, t, r) {
      const i = this.startNodeAt(e, t);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, t, r), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e = this.startNode();
      return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e = this.startNode();
      for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e) {
      let t = null, r = false, i = null;
      const o = this.startNode(), d = this.lookahead(), u = this.state.type === 78;
      return d.type === 14 || d.type === 17 ? (u && !e && this.raise(Ce.ThisParamMustBeFirst, {
        at: o
      }), t = this.parseIdentifier(u), this.eat(17) && (r = true, u && this.raise(Ce.ThisParamMayNotBeOptional, {
        at: o
      })), i = this.flowParseTypeInitialiser()) : i = this.flowParseType(), o.name = t, o.optional = r, o.typeAnnotation = i, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e) {
      const t = this.startNodeAt(e.start, e.loc.start);
      return t.name = null, t.optional = false, t.typeAnnotation = e, this.finishNode(t, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e = []) {
      let t = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(true), r.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (t = this.flowParseFunctionTypeParam(false)), {
        params: e,
        rest: t,
        _this: r
      };
    }
    flowIdentToTypeAnnotation(e, t, r, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(r, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(r, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(r, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(r, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(r, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(r, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(r, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, t, i);
      }
    }
    flowParsePrimaryType() {
      const e = this.state.start, t = this.state.startLoc, r = this.startNode();
      let i, o, d = false;
      const u = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case 0:
          return this.state.noAnonFunctionType = false, o = this.flowParseTupleType(), this.state.noAnonFunctionType = u, o;
        case 47:
          return r.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), this.finishNode(r, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (Te(this.state.type) || this.match(78)) {
              const E = this.lookahead().type;
              d = E !== 17 && E !== 14;
            } else
              d = true;
          if (d) {
            if (this.state.noAnonFunctionType = false, o = this.flowParseType(), this.state.noAnonFunctionType = u, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), o;
            this.eat(12);
          }
          return o ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(o)]) : i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation");
        case 129:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return r.value = this.match(85), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(130))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r);
            if (this.match(131))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r);
            throw this.raise(Ce.UnexpectedSubtractionOperand, {
              at: this.state.startLoc
            });
          }
          throw this.unexpected();
        case 130:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 131:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(r, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(r, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ee(this.state.type)) {
            const E = $e(this.state.type);
            return this.next(), super.createIdentifier(r, E);
          } else if (Te(this.state.type))
            return this.isContextual(125) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, t, r, this.parseIdentifier());
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const e = this.state.start, t = this.state.startLoc;
      let r = this.flowParsePrimaryType(), i = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const o = this.startNodeAt(e, t), d = this.eat(18);
        i = i || d, this.expect(0), !d && this.match(3) ? (o.elementType = r, this.next(), r = this.finishNode(o, "ArrayTypeAnnotation")) : (o.objectType = r, o.indexType = this.flowParseType(), this.expect(3), i ? (o.optional = d, r = this.finishNode(o, "OptionalIndexedAccessType")) : r = this.finishNode(o, "IndexedAccessType"));
      }
      return r;
    }
    flowParsePrefixType() {
      const e = this.startNode();
      return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const t = this.startNodeAt(e.start, e.loc.start);
        return t.params = [this.reinterpretTypeAsFunctionTypeParam(e)], t.rest = null, t.this = null, t.returnType = this.flowParseType(), t.typeParameters = null, this.finishNode(t, "FunctionTypeAnnotation");
      }
      return e;
    }
    flowParseIntersectionType() {
      const e = this.startNode();
      this.eat(45);
      const t = this.flowParseAnonFunctionWithoutParens();
      for (e.types = [t]; this.eat(45); )
        e.types.push(this.flowParseAnonFunctionWithoutParens());
      return e.types.length === 1 ? t : this.finishNode(e, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e = this.startNode();
      this.eat(43);
      const t = this.flowParseIntersectionType();
      for (e.types = [t]; this.eat(43); )
        e.types.push(this.flowParseIntersectionType());
      return e.types.length === 1 ? t : this.finishNode(e, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e = this.state.inType;
      this.state.inType = true;
      const t = this.flowParseUnionType();
      return this.state.inType = e, t;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 128 && this.state.value === "_") {
        const e = this.state.start, t = this.state.startLoc, r = this.parseIdentifier();
        return this.flowParseGenericType(e, t, r);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e = this.startNode();
      return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e) {
      const t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t)), t;
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    flowParseVariance() {
      let e = null;
      return this.match(53) && (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")), e;
    }
    parseFunctionBody(e, t, r = false) {
      return t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, r)) : super.parseFunctionBody(e, false, r);
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      if (this.match(14)) {
        const i = this.startNode();
        [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = i.typeAnnotation ? this.finishNode(i, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e, t, r);
    }
    parseStatement(e, t) {
      if (this.state.strict && this.isContextual(125)) {
        const i = this.lookahead();
        if (z(i.type)) {
          const o = this.startNode();
          return this.next(), this.flowParseInterface(o);
        }
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        const i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      const r = super.parseStatement(e, t);
      return this.flowPragma === void 0 && !this.isValidDirective(r) && (this.flowPragma = null), r;
    }
    parseExpressionStatement(e, t) {
      if (t.type === "Identifier") {
        if (t.name === "declare") {
          if (this.match(80) || Te(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(e);
        } else if (Te(this.state.type)) {
          if (t.name === "interface")
            return this.flowParseInterface(e);
          if (t.name === "type")
            return this.flowParseTypeAlias(e);
          if (t.name === "opaque")
            return this.flowParseOpaqueType(e, false);
        }
      }
      return super.parseExpressionStatement(e, t);
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      return Se(e) || this.shouldParseEnums() && e === 122 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      return Se(e) || this.shouldParseEnums() && e === 122 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(122)) {
        const e = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e, t, r, i) {
      if (!this.match(17))
        return e;
      if (this.state.maybeInArrowParameters) {
        const ye = this.lookaheadCharCode();
        if (ye === 44 || ye === 61 || ye === 58 || ye === 41)
          return this.setOptionalParametersError(i), e;
      }
      this.expect(17);
      const o = this.state.clone(), d = this.state.noArrowAt, u = this.startNodeAt(t, r);
      let {
        consequent: E,
        failed: w
      } = this.tryParseConditionalConsequent(), [U, ge] = this.getArrowLikeExpressions(E);
      if (w || ge.length > 0) {
        const ye = [...d];
        if (ge.length > 0) {
          this.state = o, this.state.noArrowAt = ye;
          for (let Ae = 0; Ae < ge.length; Ae++)
            ye.push(ge[Ae].start);
          ({
            consequent: E,
            failed: w
          } = this.tryParseConditionalConsequent()), [U, ge] = this.getArrowLikeExpressions(E);
        }
        w && U.length > 1 && this.raise(Ce.AmbiguousConditionalArrow, {
          at: o.startLoc
        }), w && U.length === 1 && (this.state = o, ye.push(U[0].start), this.state.noArrowAt = ye, {
          consequent: E,
          failed: w
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(E, true), this.state.noArrowAt = d, this.expect(14), u.test = e, u.consequent = E, u.alternate = this.forwardNoArrowParamsConversionAt(u, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(u, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e = this.parseMaybeAssignAllowIn(), t = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: e,
        failed: t
      };
    }
    getArrowLikeExpressions(e, t) {
      const r = [e], i = [];
      for (; r.length !== 0; ) {
        const o = r.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : i.push(o), r.push(o.body)) : o.type === "ConditionalExpression" && (r.push(o.consequent), r.push(o.alternate));
      }
      return t ? (i.forEach((o) => this.finishArrowValidation(o)), [i, []]) : ai(i, (o) => o.params.every((d) => this.isAssignable(d, true)));
    }
    finishArrowValidation(e) {
      var t;
      this.toAssignableList(e.params, (t = e.extra) == null ? void 0 : t.trailingCommaLoc, false), this.scope.enter(Ye | bt), super.checkParams(e, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e, t) {
      let r;
      return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), r = t(), this.state.noArrowParamsConversionAt.pop()) : r = t(), r;
    }
    parseParenItem(e, t, r) {
      if (e = super.parseParenItem(e, t, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        const i = this.startNodeAt(t, r);
        return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
      }
      return e;
    }
    assertModuleNodeAllowed(e) {
      e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
    }
    parseExport(e) {
      const t = super.parseExport(e);
      return (t.type === "ExportNamedDeclaration" || t.type === "ExportAllDeclaration") && (t.exportKind = t.exportKind || "value"), t;
    }
    parseExportDeclaration(e) {
      if (this.isContextual(126)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
      } else if (this.isContextual(127)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.flowParseOpaqueType(t, false);
      } else if (this.isContextual(125)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.flowParseInterface(t);
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        e.exportKind = "value";
        const t = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t);
      } else
        return super.parseExportDeclaration(e);
    }
    eatExportStar(e) {
      return super.eatExportStar(...arguments) ? true : this.isContextual(126) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      const {
        startLoc: t
      } = this.state, r = super.maybeParseExportNamespaceSpecifier(e);
      return r && e.exportKind === "type" && this.unexpected(t), r;
    }
    parseClassId(e, t, r) {
      super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e, t, r) {
      const {
        startLoc: i
      } = this.state;
      if (this.isContextual(121)) {
        if (this.parseClassMemberFromModifier(e, t))
          return;
        t.declare = true;
      }
      super.parseClassMember(e, t, r), t.declare && (t.type !== "ClassProperty" && t.type !== "ClassPrivateProperty" && t.type !== "PropertyDefinition" ? this.raise(Ce.DeclareClassElement, {
        at: i
      }) : t.value && this.raise(Ce.DeclareClassFieldInitializer, {
        at: t.value
      }));
    }
    isIterator(e) {
      return e === "iterator" || e === "asyncIterator";
    }
    readIterator() {
      const e = super.readWord1(), t = "@@" + e;
      (!this.isIterator(e) || !this.state.inType) && this.raise(m.InvalidIdentifier, {
        at: this.state.curPosition(),
        identifierName: t
      }), this.finishToken(128, t);
    }
    getTokenFromCode(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      return e === 123 && t === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? t === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : sr(e, t, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
    }
    isAssignable(e, t) {
      return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
    }
    toAssignable(e, t = false) {
      !t && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(...arguments);
    }
    toAssignableList(e, t, r) {
      for (let i = 0; i < e.length; i++) {
        const o = e[i];
        (o == null ? void 0 : o.type) === "TypeCastExpression" && (e[i] = this.typeCastToParameter(o));
      }
      super.toAssignableList(e, t, r);
    }
    toReferencedList(e, t) {
      for (let i = 0; i < e.length; i++) {
        var r;
        const o = e[i];
        o && o.type === "TypeCastExpression" && !((r = o.extra) != null && r.parenthesized) && (e.length > 1 || !t) && this.raise(Ce.TypeCastInPattern, {
          at: o.typeAnnotation
        });
      }
      return e;
    }
    parseArrayLike(e, t, r, i) {
      const o = super.parseArrayLike(e, t, r, i);
      return t && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(e, ...t) {
      return e === "TypeCastExpression" || super.isValidLVal(e, ...t);
    }
    parseClassProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e) {
      return !this.match(14) && super.isNonstaticConstructor(e);
    }
    pushClassMethod(e, t, r, i, o, d) {
      if (t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, i, o, d), t.params && o) {
        const u = t.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ce.ThisParamBannedInConstructor, {
          at: t
        });
      } else if (t.type === "MethodDefinition" && o && t.value.params) {
        const u = t.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ce.ThisParamBannedInConstructor, {
          at: t
        });
      }
    }
    pushClassPrivateMethod(e, t, r, i) {
      t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, i);
    }
    parseClassSuper(e) {
      if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(110)) {
        this.next();
        const t = e.implements = [];
        do {
          const r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, t.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e) {
      super.checkGetterSetterParams(e);
      const t = this.getObjectOrClassMethodParams(e);
      if (t.length > 0) {
        const r = t[0];
        this.isThisParam(r) && e.kind === "get" ? this.raise(Ce.GetterMayNotHaveThisParam, {
          at: r
        }) : this.isThisParam(r) && this.raise(Ce.SetterMayNotHaveThisParam, {
          at: r
        });
      }
    }
    parsePropertyNamePrefixOperator(e) {
      e.variance = this.flowParseVariance();
    }
    parseObjPropValue(e, t, r, i, o, d, u, E) {
      e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
      let w;
      this.match(47) && !u && (w = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(e, t, r, i, o, d, u, E), w && ((e.value || e).typeParameters = w);
    }
    parseAssignableListItemTypes(e) {
      return this.eat(17) && (e.type !== "Identifier" && this.raise(Ce.PatternIsOptional, {
        at: e
      }), this.isThisParam(e) && this.raise(Ce.ThisParamMayNotBeOptional, {
        at: e
      }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(Ce.ThisParamAnnotationRequired, {
        at: e
      }), this.match(29) && this.isThisParam(e) && this.raise(Ce.ThisParamNoDefault, {
        at: e
      }), this.resetEndLocation(e), e;
    }
    parseMaybeDefault(e, t, r) {
      const i = super.parseMaybeDefault(e, t, r);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Ce.TypeBeforeInitializer, {
        at: i.typeAnnotation
      }), i;
    }
    shouldParseDefaultImport(e) {
      return Er(e) ? Jr(this.state.type) : super.shouldParseDefaultImport(e);
    }
    parseImportSpecifierLocal(e, t, r) {
      t.local = Er(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, r));
    }
    maybeParseDefaultImportSpecifier(e) {
      e.importKind = "value";
      let t = null;
      if (this.match(87) ? t = "typeof" : this.isContextual(126) && (t = "type"), t) {
        const r = this.lookahead(), {
          type: i
        } = r;
        t === "type" && i === 55 && this.unexpected(null, r.type), (Jr(i) || i === 5 || i === 55) && (this.next(), e.importKind = t);
      }
      return super.maybeParseDefaultImportSpecifier(e);
    }
    parseImportSpecifier(e, t, r, i) {
      const o = e.imported;
      let d = null;
      o.type === "Identifier" && (o.name === "type" ? d = "type" : o.name === "typeof" && (d = "typeof"));
      let u = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const w = this.parseIdentifier(true);
        d !== null && !z(this.state.type) ? (e.imported = w, e.importKind = d, e.local = at(w)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
      } else {
        if (d !== null && z(this.state.type))
          e.imported = this.parseIdentifier(true), e.importKind = d;
        else {
          if (t)
            throw this.raise(m.ImportBindingIsString, {
              at: e,
              importName: o.value
            });
          e.imported = o, e.importKind = null;
        }
        this.eatContextual(93) ? e.local = this.parseIdentifier() : (u = true, e.local = at(e.imported));
      }
      const E = Er(e);
      return r && E && this.raise(Ce.ImportTypeShorthandOnlyInPureImport, {
        at: e
      }), (r || E) && this.checkReservedType(e.local.name, e.local.loc.start, true), u && !r && !E && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e, t) {
      const r = e.kind;
      r !== "get" && r !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
    }
    parseVarId(e, t) {
      super.parseVarId(e, t), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, t) {
      if (this.match(14)) {
        const r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(e, t);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e, t) {
      var r;
      let i = null, o;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (i = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(e, t), i), !o.error)
          return o.node;
        const {
          context: E
        } = this.state, w = E[E.length - 1];
        (w === j.j_oTag || w === j.j_expr) && E.pop();
      }
      if ((r = o) != null && r.error || this.match(47)) {
        var d, u;
        i = i || this.state.clone();
        let E;
        const w = this.tryParse((ge) => {
          var ye;
          E = this.flowParseTypeParameterDeclaration();
          const Ae = this.forwardNoArrowParamsConversionAt(E, () => {
            const Ve = super.parseMaybeAssign(e, t);
            return this.resetStartLocationFromNode(Ve, E), Ve;
          });
          (ye = Ae.extra) != null && ye.parenthesized && ge();
          const Oe = this.maybeUnwrapTypeCastExpression(Ae);
          return Oe.type !== "ArrowFunctionExpression" && ge(), Oe.typeParameters = E, this.resetStartLocationFromNode(Oe, E), Ae;
        }, i);
        let U = null;
        if (w.node && this.maybeUnwrapTypeCastExpression(w.node).type === "ArrowFunctionExpression") {
          if (!w.error && !w.aborted)
            return w.node.async && this.raise(Ce.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
              at: E
            }), w.node;
          U = w.node;
        }
        if ((d = o) != null && d.node)
          return this.state = o.failState, o.node;
        if (U)
          return this.state = w.failState, U;
        throw (u = o) != null && u.thrown ? o.error : w.thrown ? w.error : this.raise(Ce.UnexpectedTokenAfterTypeParameter, {
          at: E
        });
      }
      return super.parseMaybeAssign(e, t);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const t = this.tryParse(() => {
          const r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const i = this.startNode();
          return [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), i;
        });
        if (t.thrown)
          return null;
        t.error && (this.state = t.failState), e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e);
    }
    shouldParseArrow(e) {
      return this.match(14) || super.shouldParseArrow(e);
    }
    setArrowFunctionParameters(e, t) {
      this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = t : super.setArrowFunctionParameters(e, t);
    }
    checkParams(e, t, r) {
      if (!(r && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
        for (let i = 0; i < e.params.length; i++)
          this.isThisParam(e.params[i]) && i > 0 && this.raise(Ce.ThisParamMustBeFirst, {
            at: e.params[i]
          });
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e) {
      return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e, t, r, i) {
      if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(t) !== -1) {
        this.next();
        const o = this.startNodeAt(t, r);
        o.callee = e, o.arguments = this.parseCallExpressionArguments(11, false), e = this.finishNode(o, "CallExpression");
      } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
        const o = this.state.clone(), d = this.tryParse((E) => this.parseAsyncArrowWithTypeParameters(t, r) || E(), o);
        if (!d.error && !d.aborted)
          return d.node;
        const u = this.tryParse(() => super.parseSubscripts(e, t, r, i), o);
        if (u.node && !u.error)
          return u.node;
        if (d.node)
          return this.state = d.failState, d.node;
        if (u.node)
          return this.state = u.failState, u.node;
        throw d.error || u.error;
      }
      return super.parseSubscripts(e, t, r, i);
    }
    parseSubscript(e, t, r, i, o) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (o.optionalChainMember = true, i)
          return o.stop = true, e;
        this.next();
        const d = this.startNodeAt(t, r);
        return d.callee = e, d.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), d.arguments = this.parseCallExpressionArguments(11, false), d.optional = true, this.finishCallExpression(d, true);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        const d = this.startNodeAt(t, r);
        d.callee = e;
        const u = this.tryParse(() => (d.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), d.arguments = this.parseCallExpressionArguments(11, false), o.optionalChainMember && (d.optional = false), this.finishCallExpression(d, o.optionalChainMember)));
        if (u.node)
          return u.error && (this.state = u.failState), u.node;
      }
      return super.parseSubscript(e, t, r, i, o);
    }
    parseNewCallee(e) {
      super.parseNewCallee(e);
      let t = null;
      this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = t;
    }
    parseAsyncArrowWithTypeParameters(e, t) {
      const r = this.startNodeAt(e, t);
      if (this.parseFunctionParams(r), !!this.parseArrow(r))
        return this.parseArrowExpression(r, void 0, true);
    }
    readToken_mult_modulo(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (e === 42 && t === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(e);
    }
    readToken_pipe_amp(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (e === 124 && t === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(e);
    }
    parseTopLevel(e, t) {
      const r = super.parseTopLevel(e, t);
      return this.state.hasFlowComment && this.raise(Ce.UnterminatedFlowComment, {
        at: this.state.curPosition()
      }), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ce.NestedFlowComment, {
            at: this.state.startLoc
          });
        this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), this.state.hasFlowComment = true;
        return;
      }
      if (this.state.hasFlowComment) {
        const e = this.input.indexOf("*-/", this.state.pos + 2);
        if (e === -1)
          throw this.raise(m.UnterminatedComment, {
            at: this.state.curPosition()
          });
        this.state.pos = e + 2 + 3;
        return;
      }
      return super.skipBlockComment();
    }
    skipFlowComment() {
      const {
        pos: e
      } = this.state;
      let t = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e + t)); )
        t++;
      const r = this.input.charCodeAt(t + e), i = this.input.charCodeAt(t + e + 1);
      return r === 58 && i === 58 ? t + 2 : this.input.slice(t + e, t + e + 12) === "flow-include" ? t + 12 : r === 58 && i !== 58 ? t : false;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(m.UnterminatedComment, {
          at: this.state.curPosition()
        });
    }
    flowEnumErrorBooleanMemberNotInitialized(e, {
      enumName: t,
      memberName: r
    }) {
      this.raise(Ce.EnumBooleanMemberNotInitialized, {
        at: e,
        memberName: r,
        enumName: t
      });
    }
    flowEnumErrorInvalidMemberInitializer(e, t) {
      return this.raise(t.explicitType ? t.explicitType === "symbol" ? Ce.EnumInvalidMemberInitializerSymbolType : Ce.EnumInvalidMemberInitializerPrimaryType : Ce.EnumInvalidMemberInitializerUnknownType, Object.assign({
        at: e
      }, t));
    }
    flowEnumErrorNumberMemberNotInitialized(e, {
      enumName: t,
      memberName: r
    }) {
      this.raise(Ce.EnumNumberMemberNotInitialized, {
        at: e,
        enumName: t,
        memberName: r
      });
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e, {
      enumName: t
    }) {
      this.raise(Ce.EnumStringMemberInconsistentlyInitailized, {
        at: e,
        enumName: t
      });
    }
    flowEnumMemberInit() {
      const e = this.state.startLoc, t = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 130: {
          const r = this.parseNumericLiteral(this.state.value);
          return t() ? {
            type: "number",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 129: {
          const r = this.parseStringLiteral(this.state.value);
          return t() ? {
            type: "string",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 85:
        case 86: {
          const r = this.parseBooleanLiteral(this.match(85));
          return t() ? {
            type: "boolean",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        default:
          return {
            type: "invalid",
            loc: e
          };
      }
    }
    flowEnumMemberRaw() {
      const e = this.state.startLoc, t = this.parseIdentifier(true), r = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: e
      };
      return {
        id: t,
        init: r
      };
    }
    flowEnumCheckExplicitTypeMismatch(e, t, r) {
      const {
        explicitType: i
      } = t;
      i !== null && i !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
    }
    flowEnumMembers({
      enumName: e,
      explicitType: t
    }) {
      const r = /* @__PURE__ */ new Set(), i = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let o = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = true;
          break;
        }
        const d = this.startNode(), {
          id: u,
          init: E
        } = this.flowEnumMemberRaw(), w = u.name;
        if (w === "")
          continue;
        /^[a-z]/.test(w) && this.raise(Ce.EnumInvalidMemberName, {
          at: u,
          memberName: w,
          suggestion: w[0].toUpperCase() + w.slice(1),
          enumName: e
        }), r.has(w) && this.raise(Ce.EnumDuplicateMemberName, {
          at: u,
          memberName: w,
          enumName: e
        }), r.add(w);
        const U = {
          enumName: e,
          explicitType: t,
          memberName: w
        };
        switch (d.id = u, E.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "boolean"), d.init = E.value, i.booleanMembers.push(this.finishNode(d, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "number"), d.init = E.value, i.numberMembers.push(this.finishNode(d, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "string"), d.init = E.value, i.stringMembers.push(this.finishNode(d, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(E.loc, U);
          case "none":
            switch (t) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(E.loc, U);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(E.loc, U);
                break;
              default:
                i.defaultedMembers.push(this.finishNode(d, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: i,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(e, t, {
      enumName: r
    }) {
      if (e.length === 0)
        return t;
      if (t.length === 0)
        return e;
      if (t.length > e.length) {
        for (const i of e)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(i, {
            enumName: r
          });
        return t;
      } else {
        for (const i of t)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(i, {
            enumName: r
          });
        return e;
      }
    }
    flowEnumParseExplicitType({
      enumName: e
    }) {
      if (!this.eatContextual(101))
        return null;
      if (!Te(this.state.type))
        throw this.raise(Ce.EnumInvalidExplicitTypeUnknownSupplied, {
          at: this.state.startLoc,
          enumName: e
        });
      const {
        value: t
      } = this.state;
      return this.next(), t !== "boolean" && t !== "number" && t !== "string" && t !== "symbol" && this.raise(Ce.EnumInvalidExplicitType, {
        at: this.state.startLoc,
        enumName: e,
        invalidEnumType: t
      }), t;
    }
    flowEnumBody(e, t) {
      const r = t.name, i = t.loc.start, o = this.flowEnumParseExplicitType({
        enumName: r
      });
      this.expect(5);
      const {
        members: d,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: r,
        explicitType: o
      });
      switch (e.hasUnknownMembers = u, o) {
        case "boolean":
          return e.explicitType = true, e.members = d.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        case "number":
          return e.explicitType = true, e.members = d.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        case "string":
          return e.explicitType = true, e.members = this.flowEnumStringMembers(d.stringMembers, d.defaultedMembers, {
            enumName: r
          }), this.expect(8), this.finishNode(e, "EnumStringBody");
        case "symbol":
          return e.members = d.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
        default: {
          const E = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
          e.explicitType = false;
          const w = d.booleanMembers.length, U = d.numberMembers.length, ge = d.stringMembers.length, ye = d.defaultedMembers.length;
          if (!w && !U && !ge && !ye)
            return E();
          if (!w && !U)
            return e.members = this.flowEnumStringMembers(d.stringMembers, d.defaultedMembers, {
              enumName: r
            }), this.expect(8), this.finishNode(e, "EnumStringBody");
          if (!U && !ge && w >= ye) {
            for (const Ae of d.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(Ae.loc.start, {
                enumName: r,
                memberName: Ae.id.name
              });
            return e.members = d.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
          } else if (!w && !ge && U >= ye) {
            for (const Ae of d.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(Ae.loc.start, {
                enumName: r,
                memberName: Ae.id.name
              });
            return e.members = d.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
          } else
            return this.raise(Ce.EnumInconsistentMemberValues, {
              at: i,
              enumName: r
            }), E();
        }
      }
    }
    flowParseEnumDeclaration(e) {
      const t = this.parseIdentifier();
      return e.id = t, e.body = this.flowEnumBody(this.startNode(), t), this.finishNode(e, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e = this.nextTokenStart();
      if (this.input.charCodeAt(e) === 60) {
        const t = this.input.charCodeAt(e + 1);
        return t !== 60 && t !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e) {
      return e.type === "TypeCastExpression" ? e.expression : e;
    }
  };
  const ui = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }, Et = _`jsx`((a) => ({
    AttributeIsEmpty: a("JSX attributes must only be assigned a non-empty expression."),
    MissingClosingTagElement: a(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`),
    MissingClosingTagFragment: a("Expected corresponding JSX closing tag for <>."),
    UnexpectedSequenceExpression: a("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"),
    UnexpectedToken: a(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`),
    UnsupportedJsxValue: a("JSX value should be either an expression or a quoted JSX text."),
    UnterminatedJsxContent: a("Unterminated JSX contents."),
    UnwrappedAdjacentJSXElements: a("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?")
  }));
  function ht(a) {
    return a ? a.type === "JSXOpeningFragment" || a.type === "JSXClosingFragment" : false;
  }
  function kt(a) {
    if (a.type === "JSXIdentifier")
      return a.name;
    if (a.type === "JSXNamespacedName")
      return a.namespace.name + ":" + a.name.name;
    if (a.type === "JSXMemberExpression")
      return kt(a.object) + "." + kt(a.property);
    throw new Error("Node had unexpected type: " + a.type);
  }
  var ci = (a) => class extends a {
    jsxReadToken() {
      let e = "", t = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Et.UnterminatedJsxContent, {
            at: this.state.startLoc
          });
        const r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(r) : (e += this.input.slice(t, this.state.pos), this.finishToken(137, e));
          case 38:
            e += this.input.slice(t, this.state.pos), e += this.jsxReadEntity(), t = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            St(r) ? (e += this.input.slice(t, this.state.pos), e += this.jsxReadNewLine(true), t = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e) {
      const t = this.input.charCodeAt(this.state.pos);
      let r;
      return ++this.state.pos, t === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = e ? `
` : `\r
`) : r = String.fromCharCode(t), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(e) {
      let t = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedString, {
            at: this.state.startLoc
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === e)
          break;
        i === 38 ? (t += this.input.slice(r, this.state.pos), t += this.jsxReadEntity(), r = this.state.pos) : St(i) ? (t += this.input.slice(r, this.state.pos), t += this.jsxReadNewLine(false), r = this.state.pos) : ++this.state.pos;
      }
      return t += this.input.slice(r, this.state.pos++), this.finishToken(129, t);
    }
    jsxReadEntity() {
      const e = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let t = 10;
        this.codePointAtPos(this.state.pos) === 120 && (t = 16, ++this.state.pos);
        const r = this.readInt(t, void 0, false, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let t = 0, r = false;
        for (; t++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (r) {
          const i = this.input.slice(e, this.state.pos), o = ui[i];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = e, "&";
    }
    jsxReadWord() {
      let e;
      const t = this.state.pos;
      do
        e = this.input.charCodeAt(++this.state.pos);
      while (Be(e) || e === 45);
      return this.finishToken(136, this.input.slice(t, this.state.pos));
    }
    jsxParseIdentifier() {
      const e = this.startNode();
      return this.match(136) ? e.name = this.state.value : Ee(this.state.type) ? e.name = $e(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e = this.state.start, t = this.state.startLoc, r = this.jsxParseIdentifier();
      if (!this.eat(14))
        return r;
      const i = this.startNodeAt(e, t);
      return i.namespace = r, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e = this.state.start, t = this.state.startLoc;
      let r = this.jsxParseNamespacedName();
      if (r.type === "JSXNamespacedName")
        return r;
      for (; this.eat(16); ) {
        const i = this.startNodeAt(e, t);
        i.object = r, i.property = this.jsxParseIdentifier(), r = this.finishNode(i, "JSXMemberExpression");
      }
      return r;
    }
    jsxParseAttributeValue() {
      let e;
      switch (this.state.type) {
        case 5:
          return e = this.startNode(), this.setContext(j.brace), this.next(), e = this.jsxParseExpressionContainer(e, j.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Et.AttributeIsEmpty, {
            at: e
          }), e;
        case 138:
        case 129:
          return this.parseExprAtom();
        default:
          throw this.raise(Et.UnsupportedJsxValue, {
            at: this.state.startLoc
          });
      }
    }
    jsxParseEmptyExpression() {
      const e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
      return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e) {
      return this.next(), e.expression = this.parseExpression(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e, t) {
      if (this.match(8))
        e.expression = this.jsxParseEmptyExpression();
      else {
        const r = this.parseExpression();
        e.expression = r;
      }
      return this.setContext(t), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e = this.startNode();
      return this.match(5) ? (this.setContext(j.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e, t) {
      const r = this.startNodeAt(e, t);
      return this.eat(139) ? this.finishNode(r, "JSXOpeningFragment") : (r.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r));
    }
    jsxParseOpeningElementAfterName(e) {
      const t = [];
      for (; !this.match(56) && !this.match(139); )
        t.push(this.jsxParseAttribute());
      return e.attributes = t, e.selfClosing = this.eat(56), this.expect(139), this.finishNode(e, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e, t) {
      const r = this.startNodeAt(e, t);
      return this.eat(139) ? this.finishNode(r, "JSXClosingFragment") : (r.name = this.jsxParseElementName(), this.expect(139), this.finishNode(r, "JSXClosingElement"));
    }
    jsxParseElementAt(e, t) {
      const r = this.startNodeAt(e, t), i = [], o = this.jsxParseOpeningElementAt(e, t);
      let d = null;
      if (!o.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 138:
                if (e = this.state.start, t = this.state.startLoc, this.next(), this.eat(56)) {
                  d = this.jsxParseClosingElementAt(e, t);
                  break e;
                }
                i.push(this.jsxParseElementAt(e, t));
                break;
              case 137:
                i.push(this.parseExprAtom());
                break;
              case 5: {
                const u = this.startNode();
                this.setContext(j.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(u)) : i.push(this.jsxParseExpressionContainer(u, j.j_expr));
                break;
              }
              default:
                throw this.unexpected();
            }
        ht(o) && !ht(d) && d !== null ? this.raise(Et.MissingClosingTagFragment, {
          at: d
        }) : !ht(o) && ht(d) ? this.raise(Et.MissingClosingTagElement, {
          at: d,
          openingTagName: kt(o.name)
        }) : !ht(o) && !ht(d) && kt(d.name) !== kt(o.name) && this.raise(Et.MissingClosingTagElement, {
          at: d,
          openingTagName: kt(o.name)
        });
      }
      if (ht(o) ? (r.openingFragment = o, r.closingFragment = d) : (r.openingElement = o, r.closingElement = d), r.children = i, this.match(47))
        throw this.raise(Et.UnwrappedAdjacentJSXElements, {
          at: this.state.startLoc
        });
      return ht(o) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
    }
    jsxParseElement() {
      const e = this.state.start, t = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e, t);
    }
    setContext(e) {
      const {
        context: t
      } = this.state;
      t[t.length - 1] = e;
    }
    parseExprAtom(e) {
      return this.match(137) ? this.parseLiteral(this.state.value, "JSXText") : this.match(138) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(138), this.jsxParseElement()) : super.parseExprAtom(e);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e) {
      const t = this.curContext();
      if (t === j.j_expr)
        return this.jsxReadToken();
      if (t === j.j_oTag || t === j.j_cTag) {
        if (Ne(e))
          return this.jsxReadWord();
        if (e === 62)
          return ++this.state.pos, this.finishToken(139);
        if ((e === 34 || e === 39) && t === j.j_oTag)
          return this.jsxReadString(e);
      }
      return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(e);
    }
    updateContext(e) {
      const {
        context: t,
        type: r
      } = this.state;
      if (r === 56 && e === 138)
        t.splice(-2, 2, j.j_cTag), this.state.canStartJSXElement = false;
      else if (r === 138)
        t.push(j.j_oTag);
      else if (r === 139) {
        const i = t[t.length - 1];
        i === j.j_oTag && e === 56 || i === j.j_cTag ? (t.pop(), this.state.canStartJSXElement = t[t.length - 1] === j.j_expr) : (this.setContext(j.j_expr), this.state.canStartJSXElement = true);
      } else
        this.state.canStartJSXElement = ae(r);
    }
  };
  class pi extends Tr {
    constructor(...e) {
      super(...e), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
    }
  }
  class fi extends xr {
    createScope(e) {
      return new pi(e);
    }
    declareName(e, t, r) {
      const i = this.currentScope();
      if (t & cr) {
        this.maybeExportDefined(i, e), i.exportOnlyBindings.add(e);
        return;
      }
      super.declareName(...arguments), t & wt && (t & it || (this.checkRedeclarationInScope(i, e, t, r), this.maybeExportDefined(i, e)), i.types.add(e)), t & lr && i.enums.add(e), t & ur && i.constEnums.add(e), t & Wt && i.classes.add(e);
    }
    isRedeclaredInScope(e, t, r) {
      if (e.enums.has(t)) {
        if (r & lr) {
          const i = !!(r & ur), o = e.constEnums.has(t);
          return i !== o;
        }
        return true;
      }
      return r & Wt && e.classes.has(t) ? e.lexical.has(t) ? !!(r & it) : false : r & wt && e.types.has(t) ? true : super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(e) {
      const t = this.scopeStack[0], {
        name: r
      } = e;
      !t.types.has(r) && !t.exportOnlyBindings.has(r) && super.checkLocalExport(e);
    }
  }
  const hi = (a, e) => Object.hasOwnProperty.call(a, e) && a[e];
  function di(a) {
    if (a == null)
      throw new Error(`Unexpected ${a} value.`);
    return a;
  }
  function Yr(a) {
    if (!a)
      throw new Error("Assert fail");
  }
  const ve = _`typescript`((a) => ({
    AbstractMethodHasImplementation: a(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`),
    AbstractPropertyHasInitializer: a(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`),
    AccesorCannotDeclareThisParameter: a("'get' and 'set' accessors cannot declare 'this' parameters."),
    AccesorCannotHaveTypeParameters: a("An accessor cannot have type parameters."),
    CannotFindName: a(({
      name: e
    }) => `Cannot find name '${e}'.`),
    ClassMethodHasDeclare: a("Class methods cannot have the 'declare' modifier."),
    ClassMethodHasReadonly: a("Class methods cannot have the 'readonly' modifier."),
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: a("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
    ConstructorHasTypeParameters: a("Type parameters cannot appear on a constructor declaration."),
    DeclareAccessor: a(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`),
    DeclareClassFieldHasInitializer: a("Initializers are not allowed in ambient contexts."),
    DeclareFunctionHasImplementation: a("An implementation cannot be declared in ambient contexts."),
    DuplicateAccessibilityModifier: a(({
      modifier: e
    }) => "Accessibility modifier already seen."),
    DuplicateModifier: a(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`),
    EmptyHeritageClauseType: a(({
      token: e
    }) => `'${e}' list cannot be empty.`),
    EmptyTypeArguments: a("Type argument list cannot be empty."),
    EmptyTypeParameters: a("Type parameter list cannot be empty."),
    ExpectedAmbientAfterExportDeclare: a("'export declare' must be followed by an ambient declaration."),
    ImportAliasHasImportType: a("An import alias can not use 'import type'."),
    IncompatibleModifiers: a(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`),
    IndexSignatureHasAbstract: a("Index signatures cannot have the 'abstract' modifier."),
    IndexSignatureHasAccessibility: a(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`),
    IndexSignatureHasDeclare: a("Index signatures cannot have the 'declare' modifier."),
    IndexSignatureHasOverride: a("'override' modifier cannot appear on an index signature."),
    IndexSignatureHasStatic: a("Index signatures cannot have the 'static' modifier."),
    InitializerNotAllowedInAmbientContext: a("Initializers are not allowed in ambient contexts."),
    InvalidModifierOnTypeMember: a(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`),
    InvalidModifierOnTypeParameter: a(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`),
    InvalidModifierOnTypeParameterPositions: a(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`),
    InvalidModifiersOrder: a(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`),
    InvalidPropertyAccessAfterInstantiationExpression: a("Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments."),
    InvalidTupleMemberLabel: a("Tuple members must be labeled with a simple identifier."),
    MissingInterfaceName: a("'interface' declarations must be followed by an identifier."),
    MixedLabeledAndUnlabeledElements: a("Tuple members must all have names or all not have names."),
    NonAbstractClassHasAbstractMethod: a("Abstract methods can only appear within an abstract class."),
    NonClassMethodPropertyHasAbstractModifer: a("'abstract' modifier can only appear on a class, method, or property declaration."),
    OptionalTypeBeforeRequired: a("A required element cannot follow an optional element."),
    OverrideNotInSubClass: a("This member cannot have an 'override' modifier because its containing class does not extend another class."),
    PatternIsOptional: a("A binding pattern parameter cannot be optional in an implementation signature."),
    PrivateElementHasAbstract: a("Private elements cannot have the 'abstract' modifier."),
    PrivateElementHasAccessibility: a(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`),
    ReadonlyForMethodSignature: a("'readonly' modifier can only appear on a property declaration or index signature."),
    ReservedArrowTypeParam: a("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."),
    ReservedTypeAssertion: a("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
    SetAccesorCannotHaveOptionalParameter: a("A 'set' accessor cannot have an optional parameter."),
    SetAccesorCannotHaveRestParameter: a("A 'set' accessor cannot have rest parameter."),
    SetAccesorCannotHaveReturnType: a("A 'set' accessor cannot have a return type annotation."),
    SingleTypeParameterWithoutTrailingComma: a(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`),
    StaticBlockCannotHaveModifier: a("Static class blocks cannot have any modifier."),
    TypeAnnotationAfterAssign: a("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
    TypeImportCannotSpecifyDefaultAndNamed: a("A type-only import can specify a default import or named bindings, but not both."),
    TypeModifierIsUsedInTypeExports: a("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
    TypeModifierIsUsedInTypeImports: a("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
    UnexpectedParameterModifier: a("A parameter property is only allowed in a constructor implementation."),
    UnexpectedReadonly: a("'readonly' type modifier is only permitted on array and tuple literal types."),
    UnexpectedTypeAnnotation: a("Did not expect a type annotation here."),
    UnexpectedTypeCastInParameter: a("Unexpected type cast in parameter position."),
    UnsupportedImportTypeArgument: a("Argument in a type import must be a string literal."),
    UnsupportedParameterPropertyKind: a("A parameter property may not be declared using a binding pattern."),
    UnsupportedSignatureParameterKind: a(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`)
  }));
  function mi(a) {
    switch (a) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Qr(a) {
    return a === "private" || a === "public" || a === "protected";
  }
  function yi(a) {
    return a === "in" || a === "out";
  }
  var bi = (a) => class extends a {
    getScopeHandler() {
      return fi;
    }
    tsIsIdentifier() {
      return Te(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e, t) {
      if (!Te(this.state.type) && this.state.type !== 58)
        return;
      const r = this.state.value;
      if (e.indexOf(r) !== -1) {
        if (t && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers({
      modified: e,
      allowedModifiers: t,
      disallowedModifiers: r,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: o = ve.InvalidModifierOnTypeMember
    }) {
      const d = (E, w, U, ge) => {
        w === U && e[ge] && this.raise(ve.InvalidModifiersOrder, {
          at: E,
          orderedModifiers: [U, ge]
        });
      }, u = (E, w, U, ge) => {
        (e[U] && w === ge || e[ge] && w === U) && this.raise(ve.IncompatibleModifiers, {
          at: E,
          modifiers: [U, ge]
        });
      };
      for (; ; ) {
        const {
          startLoc: E
        } = this.state, w = this.tsParseModifier(t.concat(r != null ? r : []), i);
        if (!w)
          break;
        Qr(w) ? e.accessibility ? this.raise(ve.DuplicateAccessibilityModifier, {
          at: E,
          modifier: w
        }) : (d(E, w, w, "override"), d(E, w, w, "static"), d(E, w, w, "readonly"), e.accessibility = w) : yi(w) ? (e[w] && this.raise(ve.DuplicateModifier, {
          at: E,
          modifier: w
        }), e[w] = true, d(E, w, "in", "out")) : (Object.hasOwnProperty.call(e, w) ? this.raise(ve.DuplicateModifier, {
          at: E,
          modifier: w
        }) : (d(E, w, "static", "readonly"), d(E, w, "static", "override"), d(E, w, "override", "readonly"), d(E, w, "abstract", "override"), u(E, w, "declare", "override"), u(E, w, "static", "abstract")), e[w] = true), r != null && r.includes(w) && this.raise(o, {
          at: E,
          modifier: w
        });
      }
    }
    tsIsListTerminator(e) {
      switch (e) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
      throw new Error("Unreachable");
    }
    tsParseList(e, t) {
      const r = [];
      for (; !this.tsIsListTerminator(e); )
        r.push(t());
      return r;
    }
    tsParseDelimitedList(e, t, r) {
      return di(this.tsParseDelimitedListWorker(e, t, true, r));
    }
    tsParseDelimitedListWorker(e, t, r, i) {
      const o = [];
      let d = -1;
      for (; !this.tsIsListTerminator(e); ) {
        d = -1;
        const u = t();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          d = this.state.lastTokStart;
          continue;
        }
        if (this.tsIsListTerminator(e))
          break;
        r && this.expect(12);
        return;
      }
      return i && (i.value = d), o;
    }
    tsParseBracketedList(e, t, r, i, o) {
      i || (r ? this.expect(0) : this.expect(47));
      const d = this.tsParseDelimitedList(e, t, o);
      return r ? this.expect(3) : this.expect(48), d;
    }
    tsParseImportType() {
      const e = this.startNode();
      return this.expect(83), this.expect(10), this.match(129) || this.raise(ve.UnsupportedImportTypeArgument, {
        at: this.state.startLoc
      }), e.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
    }
    tsParseEntityName(e = true) {
      let t = this.parseIdentifier(e);
      for (; this.eat(16); ) {
        const r = this.startNodeAtNode(t);
        r.left = t, r.right = this.parseIdentifier(e), t = this.finishNode(r, "TSQualifiedName");
      }
      return t;
    }
    tsParseTypeReference() {
      const e = this.startNode();
      return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
    }
    tsParseThisTypePredicate(e) {
      this.next();
      const t = this.startNodeAtNode(e);
      return t.parameterName = e, t.typeAnnotation = this.tsParseTypeAnnotation(false), t.asserts = false, this.finishNode(t, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "TSThisType");
    }
    tsParseTypeQuery() {
      const e = this.startNode();
      return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
    }
    tsParseInOutModifiers(e) {
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ve.InvalidModifierOnTypeParameter
      });
    }
    tsParseNoneModifiers(e) {
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: [],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ve.InvalidModifierOnTypeParameterPositions
      });
    }
    tsParseTypeParameter(e = this.tsParseNoneModifiers.bind(this)) {
      const t = this.startNode();
      return e(t), t.name = this.tsParseTypeParameterName(), t.constraint = this.tsEatThenParseType(81), t.default = this.tsEatThenParseType(29), this.finishNode(t, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e) {
      if (this.match(47))
        return this.tsParseTypeParameters(e);
    }
    tsParseTypeParameters(e) {
      const t = this.startNode();
      this.match(47) || this.match(138) ? this.next() : this.unexpected();
      const r = {
        value: -1
      };
      return t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, r), t.params.length === 0 && this.raise(ve.EmptyTypeParameters, {
        at: t
      }), r.value !== -1 && this.addExtra(t, "trailingComma", r.value), this.finishNode(t, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type !== 75)
        return null;
      this.next();
      const e = this.tsParseTypeReference();
      return e.typeParameters && this.raise(ve.CannotFindName, {
        at: e.typeName,
        name: "const"
      }), e;
    }
    tsFillSignature(e, t) {
      const r = e === 19, i = "parameters", o = "typeAnnotation";
      t.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), t[i] = this.tsParseBindingListForSignature(), r ? t[o] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (t[o] = this.tsParseTypeOrTypePredicateAnnotation(e));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(11, 41).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(ve.UnsupportedSignatureParameterKind, {
        at: e,
        type: e.type
      }), e));
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(e, t) {
      return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Te(this.state.type) ? (this.next(), this.match(14)) : false;
    }
    tsTryParseIndexSignature(e) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const t = this.parseIdentifier();
      t.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t), this.expect(3), e.parameters = [t];
      const r = this.tsTryParseTypeAnnotation();
      return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e, t) {
      this.eat(17) && (e.optional = true);
      const r = e;
      if (this.match(10) || this.match(47)) {
        t && this.raise(ve.ReadonlyForMethodSignature, {
          at: e
        });
        const i = r;
        i.kind && this.match(47) && this.raise(ve.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        }), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
        const o = "parameters", d = "typeAnnotation";
        if (i.kind === "get")
          i[o].length > 0 && (this.raise(m.BadGetterArity, {
            at: this.state.curPosition()
          }), this.isThisParam(i[o][0]) && this.raise(ve.AccesorCannotDeclareThisParameter, {
            at: this.state.curPosition()
          }));
        else if (i.kind === "set") {
          if (i[o].length !== 1)
            this.raise(m.BadSetterArity, {
              at: this.state.curPosition()
            });
          else {
            const u = i[o][0];
            this.isThisParam(u) && this.raise(ve.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            }), u.type === "Identifier" && u.optional && this.raise(ve.SetAccesorCannotHaveOptionalParameter, {
              at: this.state.curPosition()
            }), u.type === "RestElement" && this.raise(ve.SetAccesorCannotHaveRestParameter, {
              at: this.state.curPosition()
            });
          }
          i[d] && this.raise(ve.SetAccesorCannotHaveReturnType, {
            at: i[d]
          });
        } else
          i.kind = "method";
        return this.finishNode(i, "TSMethodSignature");
      } else {
        const i = r;
        t && (i.readonly = true);
        const o = this.tsTryParseTypeAnnotation();
        return o && (i.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
      if (this.match(77)) {
        const r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(e, false));
      }
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      });
      const t = this.tsTryParseIndexSignature(e);
      return t || (this.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, this.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
    }
    tsParseTypeLiteral() {
      const e = this.startNode();
      return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(118) : (this.isContextual(118) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      const e = this.startNode();
      return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e = this.startNode();
      return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(118)) : this.eatContextual(118) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
    }
    tsParseTupleType() {
      const e = this.startNode();
      e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t = false, r = null;
      return e.elementTypes.forEach((i) => {
        var o;
        let {
          type: d
        } = i;
        t && d !== "TSRestType" && d !== "TSOptionalType" && !(d === "TSNamedTupleMember" && i.optional) && this.raise(ve.OptionalTypeBeforeRequired, {
          at: i
        }), t = t || d === "TSNamedTupleMember" && i.optional || d === "TSOptionalType", d === "TSRestType" && (i = i.typeAnnotation, d = i.type);
        const u = d === "TSNamedTupleMember";
        r = (o = r) != null ? o : u, r !== u && this.raise(ve.MixedLabeledAndUnlabeledElements, {
          at: i
        });
      }), this.finishNode(e, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        start: e,
        startLoc: t
      } = this.state, r = this.eat(21);
      let i = this.tsParseType();
      const o = this.eat(17);
      if (this.eat(14)) {
        const u = this.startNodeAtNode(i);
        u.optional = o, i.type === "TSTypeReference" && !i.typeParameters && i.typeName.type === "Identifier" ? u.label = i.typeName : (this.raise(ve.InvalidTupleMemberLabel, {
          at: i
        }), u.label = i), u.elementType = this.tsParseType(), i = this.finishNode(u, "TSNamedTupleMember");
      } else if (o) {
        const u = this.startNodeAtNode(i);
        u.typeAnnotation = i, i = this.finishNode(u, "TSOptionalType");
      }
      if (r) {
        const u = this.startNodeAt(e, t);
        u.typeAnnotation = i, i = this.finishNode(u, "TSRestType");
      }
      return i;
    }
    tsParseParenthesizedType() {
      const e = this.startNode();
      return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e, t) {
      const r = this.startNode();
      return e === "TSConstructorType" && (r.abstract = !!t, t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
    }
    tsParseLiteralTypeNode() {
      const e = this.startNode();
      return e.literal = (() => {
        switch (this.state.type) {
          case 130:
          case 131:
          case 129:
          case 85:
          case 86:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e = this.startNode();
      return e.literal = this.parseTemplate(false), this.finishNode(e, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e = this.tsParseThisTypeNode();
      return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 129:
        case 130:
        case 131:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const e = this.startNode(), t = this.lookahead();
            if (t.type !== 130 && t.type !== 131)
              throw this.unexpected();
            return e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: e
          } = this.state;
          if (Te(e) || e === 88 || e === 84) {
            const t = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : mi(this.state.value);
            if (t !== void 0 && this.lookaheadCharCode() !== 46) {
              const r = this.startNode();
              return this.next(), this.finishNode(r, t);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const t = this.startNodeAtNode(e);
          t.elementType = e, this.expect(3), e = this.finishNode(t, "TSArrayType");
        } else {
          const t = this.startNodeAtNode(e);
          t.objectType = e, t.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(t, "TSIndexedAccessType");
        }
      return e;
    }
    tsParseTypeOperator() {
      const e = this.startNode(), t = this.state.value;
      return this.next(), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), t === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e) {
      switch (e.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ve.UnexpectedReadonly, {
            at: e
          });
      }
    }
    tsParseInferType() {
      const e = this.startNode();
      this.expectContextual(112);
      const t = this.startNode();
      return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(t, "TSTypeParameter"), this.finishNode(e, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return e;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return _e(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e, t, r) {
      const i = this.startNode(), o = this.eat(r), d = [];
      do
        d.push(t());
      while (this.eat(r));
      return d.length === 1 && !o ? d[0] : (i.types = d, this.finishNode(i, e));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Te(this.state.type) || this.match(78))
        return this.next(), true;
      if (this.match(5)) {
        const {
          errors: e
        } = this.state, t = e.length;
        try {
          return this.parseObjectLike(8, true), e.length === t;
        } catch {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: e
        } = this.state, t = e.length;
        try {
          return this.parseBindingList(3, 93, true), e.length === t;
        } catch {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(e) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(e);
        const r = this.startNode(), i = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (i && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (r.parameterName = u, r.asserts = true, r.typeAnnotation = null, u = this.finishNode(r, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, r), u.asserts = true), t.typeAnnotation = u, this.finishNode(t, "TSTypeAnnotation");
        }
        const o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return i ? (r.parameterName = this.parseIdentifier(), r.asserts = i, r.typeAnnotation = null, t.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t);
        const d = this.tsParseTypeAnnotation(false);
        return r.parameterName = o, r.typeAnnotation = d, r.asserts = i, t.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const e = this.parseIdentifier();
      if (this.isContextual(113) && !this.hasPrecedingLineBreak())
        return this.next(), e;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 106)
        return false;
      const e = this.state.containsEsc;
      return this.next(), !Te(this.state.type) && !this.match(78) ? false : (e && this.raise(m.InvalidEscapedReservedWord, {
        at: this.state.lastTokStartLoc,
        reservedWord: "asserts"
      }), true);
    }
    tsParseTypeAnnotation(e = true, t = this.startNode()) {
      return this.tsInType(() => {
        e && this.expect(14), t.typeAnnotation = this.tsParseType();
      }), this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      Yr(this.state.inType);
      const e = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return e;
      const t = this.startNodeAtNode(e);
      return t.checkType = e, t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(120) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ve.ReservedTypeAssertion, {
        at: this.state.startLoc
      });
      const e = this.startNode(), t = this.tsTryNextParseConstantContext();
      return e.typeAnnotation = t || this.tsNextThenParseType(), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
    }
    tsParseHeritageClause(e) {
      const t = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const i = this.startNode();
        return i.expression = this.tsParseEntityName(), this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSExpressionWithTypeArguments");
      });
      return r.length || this.raise(ve.EmptyHeritageClauseType, {
        at: t,
        token: e
      }), r;
    }
    tsParseInterfaceDeclaration(e, t = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(125), t.declare && (e.declare = true), Te(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Es)) : (e.id = null, this.raise(ve.MissingInterfaceName, {
        at: this.state.startLoc
      })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
      const r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e) {
      return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, vs), e.typeAnnotation = this.tsInType(() => {
        if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(111) && this.lookahead().type !== 16) {
          const t = this.startNode();
          return this.next(), this.finishNode(t, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e) {
      const t = this.state.context;
      this.state.context = [t[0]];
      try {
        return e();
      } finally {
        this.state.context = t;
      }
    }
    tsInType(e) {
      const t = this.state.inType;
      this.state.inType = true;
      try {
        return e();
      } finally {
        this.state.inType = t;
      }
    }
    tsInDisallowConditionalTypesContext(e) {
      const t = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = t;
      }
    }
    tsInAllowConditionalTypesContext(e) {
      const t = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = t;
      }
    }
    tsEatThenParseType(e) {
      return this.match(e) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e) {
      return this.tsDoThenParseType(() => this.expect(e));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e) {
      return this.tsInType(() => (e(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e = this.startNode();
      return e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
    }
    tsParseEnumDeclaration(e, t = {}) {
      return t.const && (e.const = true), t.declare && (e.declare = true), this.expectContextual(122), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? Cs : Rr), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e = this.startNode();
      return this.scope.enter(At), this.expect(5), this.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e, t = false) {
      if (e.id = this.parseIdentifier(), t || this.checkIdentifier(e.id, ws), this.eat(16)) {
        const r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, true), e.body = r;
      } else
        this.scope.enter(qt), this.prodParam.enter(It), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e) {
      return this.isContextual(109) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(129) ? e.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(qt), this.prodParam.enter(It), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e, t) {
      e.isExport = t || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, nt), this.expect(29);
      const r = this.tsParseModuleReference();
      return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(ve.ImportAliasHasImportType, {
        at: r
      }), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(116) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e = this.startNode();
      if (this.expectContextual(116), this.expect(10), !this.match(129))
        throw this.unexpected();
      return e.expression = this.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
    }
    tsLookAhead(e) {
      const t = this.state.clone(), r = e();
      return this.state = t, r;
    }
    tsTryParseAndCatch(e) {
      const t = this.tryParse((r) => e() || r());
      if (!(t.aborted || !t.node))
        return t.error && (this.state = t.failState), t.node;
    }
    tsTryParse(e) {
      const t = this.state.clone(), r = e();
      if (r !== void 0 && r !== false)
        return r;
      this.state = t;
    }
    tsTryParseDeclare(e) {
      if (this.isLineTerminator())
        return;
      let t = this.state.type, r;
      return this.isContextual(99) && (t = 74, r = "let"), this.tsInAmbientContext(() => {
        if (t === 68)
          return e.declare = true, this.parseFunctionStatement(e, false, true);
        if (t === 80)
          return e.declare = true, this.parseClass(e, true, false);
        if (t === 122)
          return this.tsParseEnumDeclaration(e, {
            declare: true
          });
        if (t === 109)
          return this.tsParseAmbientExternalModuleDeclaration(e);
        if (t === 75 || t === 74)
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, r || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, {
            const: true,
            declare: true
          }));
        if (t === 125) {
          const i = this.tsParseInterfaceDeclaration(e, {
            declare: true
          });
          if (i)
            return i;
        }
        if (Te(t))
          return this.tsParseDeclaration(e, this.state.value, true);
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e, t) {
      switch (t.name) {
        case "declare": {
          const r = this.tsTryParseDeclare(e);
          if (r)
            return r.declare = true, r;
          break;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(qt), this.prodParam.enter(It);
            const r = e;
            return r.global = true, r.id = t, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e, t.name, false);
      }
    }
    tsParseDeclaration(e, t, r) {
      switch (t) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || Te(this.state.type)))
            return this.tsParseAbstractDeclaration(e);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(129))
              return this.tsParseAmbientExternalModuleDeclaration(e);
            if (Te(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(e);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && Te(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(e);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && Te(this.state.type))
            return this.tsParseTypeAliasDeclaration(e);
          break;
      }
    }
    tsCheckLineTerminator(e) {
      return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e, t) {
      if (!this.match(47))
        return;
      const r = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const i = this.tsTryParseAndCatch(() => {
        const o = this.startNodeAt(e, t);
        return o.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(o), o.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), o;
      });
      if (this.state.maybeInArrowParameters = r, !!i)
        return this.parseArrowExpression(i, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const e = this.startNode();
      return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(ve.EmptyTypeArguments, {
        at: e
      }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Re(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      let o, d = false, u = false;
      if (e !== void 0) {
        const U = {};
        this.tsParseModifiers({
          modified: U,
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }), o = U.accessibility, u = U.override, d = U.readonly, e === false && (o || d || u) && this.raise(ve.UnexpectedParameterModifier, {
          at: i
        });
      }
      const E = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(E);
      const w = this.parseMaybeDefault(E.start, E.loc.start, E);
      if (o || d || u) {
        const U = this.startNodeAt(r, i);
        return t.length && (U.decorators = t), o && (U.accessibility = o), d && (U.readonly = d), u && (U.override = u), w.type !== "Identifier" && w.type !== "AssignmentPattern" && this.raise(ve.UnsupportedParameterPropertyKind, {
          at: U
        }), U.parameter = w, this.finishNode(U, "TSParameterProperty");
      }
      return t.length && (E.decorators = t), w;
    }
    isSimpleParameter(e) {
      return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const i = t === "FunctionDeclaration" ? "TSDeclareFunction" : t === "ClassMethod" || t === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      if (i && !this.match(5) && this.isLineTerminator()) {
        this.finishNode(e, i);
        return;
      }
      if (i === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ve.DeclareFunctionHasImplementation, {
        at: e
      }), e.declare)) {
        super.parseFunctionBodyAndFinish(e, i, r);
        return;
      }
      super.parseFunctionBodyAndFinish(e, t, r);
    }
    registerFunctionStatementId(e) {
      !e.body && e.id ? this.checkIdentifier(e.id, Ur) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e) {
      e.forEach((t) => {
        (t == null ? void 0 : t.type) === "TSTypeCastExpression" && this.raise(ve.UnexpectedTypeAnnotation, {
          at: t.typeAnnotation
        });
      });
    }
    toReferencedList(e, t) {
      return this.tsCheckForInvalidTypeCasts(e), e;
    }
    parseArrayLike(...e) {
      const t = super.parseArrayLike(...e);
      return t.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t.elements), t;
    }
    parseSubscript(e, t, r, i, o) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        const u = this.startNodeAt(t, r);
        return u.expression = e, this.finishNode(u, "TSNonNullExpression");
      }
      let d = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return o.stop = true, e;
        o.optionalChainMember = d = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let u;
        const E = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(e)) {
            const ye = this.tsTryParseGenericAsyncArrowFunction(t, r);
            if (ye)
              return ye;
          }
          const w = this.tsParseTypeArgumentsInExpression();
          if (!w)
            return;
          if (d && !this.match(10)) {
            u = this.state.curPosition();
            return;
          }
          if (Ze(this.state.type)) {
            const ye = this.parseTaggedTemplateExpression(e, t, r, o);
            return ye.typeParameters = w, ye;
          }
          if (!i && this.eat(10)) {
            const ye = this.startNodeAt(t, r);
            return ye.callee = e, ye.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(ye.arguments), ye.typeParameters = w, o.optionalChainMember && (ye.optional = d), this.finishCallExpression(ye, o.optionalChainMember);
          }
          const U = this.state.type;
          if (U === 48 || U !== 10 && ce(U) && !this.hasPrecedingLineBreak())
            return;
          const ge = this.startNodeAt(t, r);
          return ge.expression = e, ge.typeParameters = w, this.finishNode(ge, "TSInstantiationExpression");
        });
        if (u && this.unexpected(u, 10), E)
          return E.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ve.InvalidPropertyAccessAfterInstantiationExpression, {
            at: this.state.startLoc
          }), E;
      }
      return super.parseSubscript(e, t, r, i, o);
    }
    parseNewCallee(e) {
      var t;
      super.parseNewCallee(e);
      const {
        callee: r
      } = e;
      r.type === "TSInstantiationExpression" && !((t = r.extra) != null && t.parenthesized) && (e.typeParameters = r.typeParameters, e.callee = r.expression);
    }
    parseExprOp(e, t, r, i) {
      if (Ge(58) > i && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
        const o = this.startNodeAt(t, r);
        o.expression = e;
        const d = this.tsTryNextParseConstantContext();
        return d ? o.typeAnnotation = d : o.typeAnnotation = this.tsNextThenParseType(), this.finishNode(o, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(o, t, r, i);
      }
      return super.parseExprOp(e, t, r, i);
    }
    checkReservedWord(e, t, r, i) {
      this.state.isAmbientContext || super.checkReservedWord(e, t, r, i);
    }
    checkDuplicateExports() {
    }
    parseImport(e) {
      if (e.importKind = "value", Te(this.state.type) || this.match(55) || this.match(5)) {
        let r = this.lookahead();
        if (this.isContextual(126) && r.type !== 12 && r.type !== 97 && r.type !== 29 && (e.importKind = "type", this.next(), r = this.lookahead()), Te(this.state.type) && r.type === 29)
          return this.tsParseImportEqualsDeclaration(e);
      }
      const t = super.parseImport(e);
      return t.importKind === "type" && t.specifiers.length > 1 && t.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ve.TypeImportCannotSpecifyDefaultAndNamed, {
        at: t
      }), t;
    }
    parseExport(e) {
      if (this.match(83))
        return this.next(), this.isContextual(126) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
      if (this.eat(29)) {
        const t = e;
        return t.expression = this.parseExpression(), this.semicolon(), this.finishNode(t, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const t = e;
        return this.expectContextual(124), t.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
      } else
        return this.isContextual(126) && this.lookahead().type === 5 ? (this.next(), e.exportKind = "type") : e.exportKind = "value", super.parseExport(e);
    }
    isAbstractClass() {
      return this.isContextual(120) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e = this.startNode();
        return this.next(), e.abstract = true, this.parseClass(e, true, true), e;
      }
      if (this.match(125)) {
        const e = this.tsParseInterfaceDeclaration(this.startNode());
        if (e)
          return e;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e, t, r = false) {
      const {
        isAmbientContext: i
      } = this.state, o = super.parseVarStatement(e, t, r || i);
      if (!i)
        return o;
      for (const {
        id: d,
        init: u
      } of o.declarations)
        !u || (t !== "const" || !!d.typeAnnotation ? this.raise(ve.InitializerNotAllowedInAmbientContext, {
          at: u
        }) : u.type !== "StringLiteral" && u.type !== "BooleanLiteral" && u.type !== "NumericLiteral" && u.type !== "BigIntLiteral" && (u.type !== "TemplateLiteral" || u.expressions.length > 0) && !gi(u) && this.raise(ve.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
          at: u
        }));
      return o;
    }
    parseStatementContent(e, t) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, {
          const: true
        });
      }
      if (this.isContextual(122))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(125)) {
        const r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r)
          return r;
      }
      return super.parseStatementContent(e, t);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e, t) {
      return t.some((r) => Qr(r) ? e.accessibility === r : !!e[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e, t, r) {
      const i = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        modified: t,
        allowedModifiers: i,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: ve.InvalidModifierOnTypeParameterPositions
      });
      const o = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, i) && this.raise(ve.StaticBlockCannotHaveModifier, {
          at: this.state.curPosition()
        }), this.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
      };
      t.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(e, t, r, i) {
      const o = this.tsTryParseIndexSignature(t);
      if (o) {
        e.body.push(o), t.abstract && this.raise(ve.IndexSignatureHasAbstract, {
          at: t
        }), t.accessibility && this.raise(ve.IndexSignatureHasAccessibility, {
          at: t,
          modifier: t.accessibility
        }), t.declare && this.raise(ve.IndexSignatureHasDeclare, {
          at: t
        }), t.override && this.raise(ve.IndexSignatureHasOverride, {
          at: t
        });
        return;
      }
      !this.state.inAbstractClass && t.abstract && this.raise(ve.NonAbstractClassHasAbstractMethod, {
        at: t
      }), t.override && (r.hadSuperClass || this.raise(ve.OverrideNotInSubClass, {
        at: t
      })), super.parseClassMemberWithIsStatic(e, t, r, i);
    }
    parsePostMemberNameModifiers(e) {
      this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(ve.ClassMethodHasReadonly, {
        at: e
      }), e.declare && this.match(10) && this.raise(ve.ClassMethodHasDeclare, {
        at: e
      });
    }
    parseExpressionStatement(e, t) {
      return (t.type === "Identifier" ? this.tsParseExpressionStatement(e, t) : void 0) || super.parseExpressionStatement(e, t);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
    }
    parseConditional(e, t, r, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(e, t, r, i);
      const o = this.tryParse(() => super.parseConditional(e, t, r));
      return o.node ? (o.error && (this.state = o.failState), o.node) : (o.error && super.setOptionalParametersError(i, o.error), e);
    }
    parseParenItem(e, t, r) {
      if (e = super.parseParenItem(e, t, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        const i = this.startNodeAt(t, r);
        return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
      }
      return e;
    }
    parseExportDeclaration(e) {
      if (!this.state.isAmbientContext && this.isContextual(121))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
      const t = this.state.start, r = this.state.startLoc, i = this.eatContextual(121);
      if (i && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
        throw this.raise(ve.ExpectedAmbientAfterExportDeclare, {
          at: this.state.startLoc
        });
      const d = Te(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
      return d ? ((d.type === "TSInterfaceDeclaration" || d.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(d, t, r), d.declare = true), d) : null;
    }
    parseClassId(e, t, r) {
      if ((!t || r) && this.isContextual(110))
        return;
      super.parseClassId(e, t, r, e.declare ? Ur : Fr);
      const i = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
      i && (e.typeParameters = i);
    }
    parseClassPropertyAnnotation(e) {
      !e.optional && this.eat(35) && (e.definite = true);
      const t = this.tsTryParseTypeAnnotation();
      t && (e.typeAnnotation = t);
    }
    parseClassProperty(e) {
      if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && this.match(29) && this.raise(ve.DeclareClassFieldHasInitializer, {
        at: this.state.startLoc
      }), e.abstract && this.match(29)) {
        const {
          key: t
        } = e;
        this.raise(ve.AbstractPropertyHasInitializer, {
          at: this.state.startLoc,
          propertyName: t.type === "Identifier" && !e.computed ? t.name : `[${this.input.slice(t.start, t.end)}]`
        });
      }
      return super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return e.abstract && this.raise(ve.PrivateElementHasAbstract, {
        at: e
      }), e.accessibility && this.raise(ve.PrivateElementHasAccessibility, {
        at: e,
        modifier: e.accessibility
      }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
    }
    pushClassMethod(e, t, r, i, o, d) {
      const u = this.tsTryParseTypeParameters();
      u && o && this.raise(ve.ConstructorHasTypeParameters, {
        at: u
      });
      const {
        declare: E = false,
        kind: w
      } = t;
      E && (w === "get" || w === "set") && this.raise(ve.DeclareAccessor, {
        at: t,
        kind: w
      }), u && (t.typeParameters = u), super.pushClassMethod(e, t, r, i, o, d);
    }
    pushClassPrivateMethod(e, t, r, i) {
      const o = this.tsTryParseTypeParameters();
      o && (t.typeParameters = o), super.pushClassPrivateMethod(e, t, r, i);
    }
    declareClassPrivateMethodInScope(e, t) {
      e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, t));
    }
    parseClassSuper(e) {
      super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(110) && (e.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e, ...t) {
      const r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseObjPropValue(e, ...t);
    }
    parseFunctionParams(e, t) {
      const r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseFunctionParams(e, t);
    }
    parseVarId(e, t) {
      super.parseVarId(e, t), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
      const r = this.tsTryParseTypeAnnotation();
      r && (e.id.typeAnnotation = r, this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, t) {
      return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
    }
    parseMaybeAssign(...e) {
      var t, r, i, o, d, u, E;
      let w, U, ge;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (w = this.state.clone(), U = this.tryParse(() => super.parseMaybeAssign(...e), w), !U.error)
          return U.node;
        const {
          context: Oe
        } = this.state, Ve = Oe[Oe.length - 1];
        (Ve === j.j_oTag || Ve === j.j_expr) && Oe.pop();
      }
      if (!((t = U) != null && t.error) && !this.match(47))
        return super.parseMaybeAssign(...e);
      (!w || w === this.state) && (w = this.state.clone());
      let ye;
      const Ae = this.tryParse((Oe) => {
        var Ve, Ke;
        ye = this.tsParseTypeParameters();
        const He = super.parseMaybeAssign(...e);
        return (He.type !== "ArrowFunctionExpression" || (Ve = He.extra) != null && Ve.parenthesized) && Oe(), ((Ke = ye) == null ? void 0 : Ke.params.length) !== 0 && this.resetStartLocationFromNode(He, ye), He.typeParameters = ye, He;
      }, w);
      if (!Ae.error && !Ae.aborted)
        return ye && this.reportReservedArrowTypeParam(ye), Ae.node;
      if (!U && (Yr(!this.hasPlugin("jsx")), ge = this.tryParse(() => super.parseMaybeAssign(...e), w), !ge.error))
        return ge.node;
      if ((r = U) != null && r.node)
        return this.state = U.failState, U.node;
      if (Ae.node)
        return this.state = Ae.failState, ye && this.reportReservedArrowTypeParam(ye), Ae.node;
      if ((i = ge) != null && i.node)
        return this.state = ge.failState, ge.node;
      throw (o = U) != null && o.thrown ? U.error : Ae.thrown ? Ae.error : (d = ge) != null && d.thrown ? ge.error : ((u = U) == null ? void 0 : u.error) || Ae.error || ((E = ge) == null ? void 0 : E.error);
    }
    reportReservedArrowTypeParam(e) {
      var t;
      e.params.length === 1 && !((t = e.extra) != null && t.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ve.ReservedArrowTypeParam, {
        at: e
      });
    }
    parseMaybeUnary(e) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const t = this.tryParse((r) => {
          const i = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), i;
        });
        if (t.aborted)
          return;
        t.thrown || (t.error && (this.state = t.failState), e.returnType = t.node);
      }
      return super.parseArrow(e);
    }
    parseAssignableListItemTypes(e) {
      this.eat(17) && (e.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(ve.PatternIsOptional, {
        at: e
      }), e.optional = true);
      const t = this.tsTryParseTypeAnnotation();
      return t && (e.typeAnnotation = t), this.resetEndLocation(e), e;
    }
    isAssignable(e, t) {
      switch (e.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e.expression, t);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e, t);
      }
    }
    toAssignable(e, t = false) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e, t);
          break;
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          t ? this.expressionScope.recordArrowParemeterBindingError(ve.UnexpectedTypeCastInParameter, {
            at: e
          }) : this.raise(ve.UnexpectedTypeCastInParameter, {
            at: e
          }), this.toAssignable(e.expression, t);
          break;
        case "AssignmentExpression":
          !t && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
        default:
          super.toAssignable(e, t);
      }
    }
    toAssignableParenthesizedExpression(e, t) {
      switch (e.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, t);
          break;
        default:
          super.toAssignable(e, t);
      }
    }
    checkToRestConversion(e, t) {
      switch (e.type) {
        case "TSAsExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e.expression, false);
          break;
        default:
          super.checkToRestConversion(e, t);
      }
    }
    isValidLVal(e, t, r) {
      return hi({
        TSTypeCastExpression: true,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (r !== Pt || !t) && ["expression", true],
        TSTypeAssertion: (r !== Pt || !t) && ["expression", true]
      }, e) || super.isValidLVal(e, t, r);
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e) {
      if (this.match(47) || this.match(51)) {
        const t = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const r = super.parseMaybeDecoratorArguments(e);
          return r.typeParameters = t, r;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e);
    }
    checkCommaAfterRest(e) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(...e) {
      const t = super.parseMaybeDefault(...e);
      return t.type === "AssignmentPattern" && t.typeAnnotation && t.right.start < t.typeAnnotation.start && this.raise(ve.TypeAnnotationAfterAssign, {
        at: t.typeAnnotation
      }), t;
    }
    getTokenFromCode(e) {
      if (this.state.inType) {
        if (e === 62)
          return this.finishOp(48, 1);
        if (e === 60)
          return this.finishOp(47, 1);
      }
      return super.getTokenFromCode(e);
    }
    reScan_lt_gt() {
      const {
        type: e
      } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: e
      } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    toAssignableList(e) {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        (r == null ? void 0 : r.type) === "TSTypeCastExpression" && (e[t] = this.typeCastToParameter(r));
      }
      super.toAssignableList(...arguments);
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    shouldParseArrow(e) {
      return this.match(14) ? e.every((t) => this.isAssignable(t, true)) : super.shouldParseArrow(e);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e) {
      if (this.match(47) || this.match(51)) {
        const t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        t && (e.typeParameters = t);
      }
      return super.jsxParseOpeningElementAfterName(e);
    }
    getGetterSetterExpectedParamCount(e) {
      const t = super.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e)[0];
      return i && this.isThisParam(i) ? t + 1 : t;
    }
    parseCatchClauseParam() {
      const e = super.parseCatchClauseParam(), t = this.tsTryParseTypeAnnotation();
      return t && (e.typeAnnotation = t, this.resetEndLocation(e)), e;
    }
    tsInAmbientContext(e) {
      const t = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e();
      } finally {
        this.state.isAmbientContext = t;
      }
    }
    parseClass(e, ...t) {
      const r = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e.abstract;
      try {
        return super.parseClass(e, ...t);
      } finally {
        this.state.inAbstractClass = r;
      }
    }
    tsParseAbstractDeclaration(e) {
      if (this.match(80))
        return e.abstract = true, this.parseClass(e, true, false);
      if (this.isContextual(125)) {
        if (!this.hasFollowingLineBreak())
          return e.abstract = true, this.raise(ve.NonClassMethodPropertyHasAbstractModifer, {
            at: e
          }), this.tsParseInterfaceDeclaration(e);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(...e) {
      const t = super.parseMethod(...e);
      if (t.abstract && (this.hasPlugin("estree") ? !!t.value.body : !!t.body)) {
        const {
          key: i
        } = t;
        this.raise(ve.AbstractMethodHasImplementation, {
          at: t,
          methodName: i.type === "Identifier" && !t.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
        });
      }
      return t;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e, t, r, i) {
      return !t && i ? (this.parseTypeOnlyImportExportSpecifier(e, false, r), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, t, r, i));
    }
    parseImportSpecifier(e, t, r, i) {
      return !t && i ? (this.parseTypeOnlyImportExportSpecifier(e, true, r), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, t, r, i));
    }
    parseTypeOnlyImportExportSpecifier(e, t, r) {
      const i = t ? "imported" : "local", o = t ? "local" : "exported";
      let d = e[i], u, E = false, w = true;
      const U = d.loc.start;
      if (this.isContextual(93)) {
        const ye = this.parseIdentifier();
        if (this.isContextual(93)) {
          const Ae = this.parseIdentifier();
          z(this.state.type) ? (E = true, d = ye, u = t ? this.parseIdentifier() : this.parseModuleExportName(), w = false) : (u = Ae, w = false);
        } else
          z(this.state.type) ? (w = false, u = t ? this.parseIdentifier() : this.parseModuleExportName()) : (E = true, d = ye);
      } else
        z(this.state.type) && (E = true, t ? (d = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(d.name, d.loc.start, true, true)) : d = this.parseModuleExportName());
      E && r && this.raise(t ? ve.TypeModifierIsUsedInTypeImports : ve.TypeModifierIsUsedInTypeExports, {
        at: U
      }), e[i] = d, e[o] = u;
      const ge = t ? "importKind" : "exportKind";
      e[ge] = E ? "type" : "value", w && this.eatContextual(93) && (e[o] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[o] || (e[o] = at(e[i])), t && this.checkIdentifier(e[o], nt);
    }
  };
  function gi(a) {
    if (a.type !== "MemberExpression")
      return false;
    const {
      computed: e,
      property: t
    } = a;
    return e && t.type !== "StringLiteral" && (t.type !== "TemplateLiteral" || t.expressions.length > 0) ? false : Zr(a.object);
  }
  function Zr(a) {
    return a.type === "Identifier" ? true : a.type !== "MemberExpression" || a.computed ? false : Zr(a.object);
  }
  const es = _`placeholders`((a) => ({
    ClassNameIsRequired: a("A class name is required."),
    UnexpectedSpace: a("Unexpected space in placeholder.")
  }));
  var Ti = (a) => class extends a {
    parsePlaceholder(e) {
      if (this.match(140)) {
        const t = this.startNode();
        return this.next(), this.assertNoSpace(), t.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(140), this.finishPlaceholder(t, e);
      }
    }
    finishPlaceholder(e, t) {
      const r = !!(e.expectedNode && e.type === "Placeholder");
      return e.expectedNode = t, r ? e : this.finishNode(e, "Placeholder");
    }
    getTokenFromCode(e) {
      return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(140, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e) {
      e !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    isValidLVal(e, ...t) {
      return e === "Placeholder" || super.isValidLVal(e, ...t);
    }
    toAssignable(e) {
      e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(...arguments);
    }
    isLet(e) {
      return super.isLet(e) ? true : !this.isContextual(99) || e ? false : this.lookahead().type === 140;
    }
    verifyBreakContinue(e) {
      e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e, t) {
      if (t.type !== "Placeholder" || t.extra && t.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(14)) {
        const r = e;
        return r.label = this.finishPlaceholder(t, "Identifier"), this.next(), r.body = this.parseStatement("label"), this.finishNode(r, "LabeledStatement");
      }
      return this.semicolon(), e.name = t.name, this.finishPlaceholder(e, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e, t, r) {
      const i = t ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e);
      const o = this.state.strict, d = this.parsePlaceholder("Identifier");
      if (d)
        if (this.match(81) || this.match(140) || this.match(5))
          e.id = d;
        else {
          if (r || !t)
            return e.id = null, e.body = this.finishPlaceholder(d, "ClassBody"), this.finishNode(e, i);
          throw this.raise(es.ClassNameIsRequired, {
            at: this.state.startLoc
          });
        }
      else
        this.parseClassId(e, t, r);
      return this.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e.superClass, o), this.finishNode(e, i);
    }
    parseExport(e) {
      const t = this.parsePlaceholder("Identifier");
      if (!t)
        return super.parseExport(...arguments);
      if (!this.isContextual(97) && !this.match(12))
        return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(t, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const r = this.startNode();
      return r.exported = t, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], super.parseExport(e);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const e = this.nextTokenStart();
        if (this.isUnparsedContextual(e, "from") && this.input.startsWith($e(140), this.nextTokenStartSince(e + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e) {
      return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e) {
      const {
        specifiers: t
      } = e;
      t != null && t.length && (e.specifiers = t.filter((r) => r.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = t;
    }
    parseImport(e) {
      const t = this.parsePlaceholder("Identifier");
      if (!t)
        return super.parseImport(...arguments);
      if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
        return e.source = this.finishPlaceholder(t, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
      const r = this.startNodeAtNode(t);
      return r.local = t, this.finishNode(r, "ImportDefaultSpecifier"), e.specifiers.push(r), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(es.UnexpectedSpace, {
        at: this.state.lastTokEndLoc
      });
    }
  }, xi = (a) => class extends a {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const e = this.state.startLoc, t = this.startNode();
        if (this.next(), Te(this.state.type)) {
          const r = this.parseIdentifierName(this.state.start), i = this.createIdentifier(t, r);
          if (i.type = "V8IntrinsicIdentifier", this.match(10))
            return i;
        }
        this.unexpected(e);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  };
  function ze(a, e) {
    const [t, r] = typeof e == "string" ? [e, {}] : e, i = Object.keys(r), o = i.length === 0;
    return a.some((d) => {
      if (typeof d == "string")
        return o && d === t;
      {
        const [u, E] = d;
        if (u !== t)
          return false;
        for (const w of i)
          if (E[w] !== r[w])
            return false;
        return true;
      }
    });
  }
  function Ft(a, e, t) {
    const r = a.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return r && Array.isArray(r) ? r[1][t] : null;
  }
  const ts = ["minimal", "fsharp", "hack", "smart"], rs = ["^^", "@@", "^", "%", "#"], ss = ["hash", "bar"];
  function Pi(a) {
    if (ze(a, "decorators")) {
      if (ze(a, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const e = Ft(a, "decorators", "decoratorsBeforeExport");
      if (e == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (ze(a, "flow") && ze(a, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (ze(a, "placeholders") && ze(a, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (ze(a, "pipelineOperator")) {
      const e = Ft(a, "pipelineOperator", "proposal");
      if (!ts.includes(e)) {
        const r = ts.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`);
      }
      const t = ze(a, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (e === "hack") {
        if (ze(a, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (ze(a, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const r = Ft(a, "pipelineOperator", "topicToken");
        if (!rs.includes(r)) {
          const i = rs.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
        }
        if (r === "#" && t)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (e === "smart" && t)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (ze(a, "moduleAttributes")) {
      if (ze(a, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Ft(a, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (ze(a, "recordAndTuple") && !ss.includes(Ft(a, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + ss.map((e) => `'${e}'`).join(", "));
    if (ze(a, "asyncDoExpressions") && !ze(a, "doExpressions")) {
      const e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
  }
  const is = {
    estree: B,
    jsx: ci,
    flow: li,
    typescript: bi,
    v8intrinsic: xi,
    placeholders: Ti
  }, Si = Object.keys(is), ns = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true
  };
  function Ei(a) {
    const e = {};
    for (const t of Object.keys(ns))
      e[t] = a && a[t] != null ? a[t] : ns[t];
    return e;
  }
  const vi = (a, e) => Object.hasOwnProperty.call(a, e) && a[e], as = (a) => a.type === "ParenthesizedExpression" ? as(a.expression) : a;
  class Ai extends ri {
    toAssignable(e, t = false) {
      var r, i;
      let o;
      switch ((e.type === "ParenthesizedExpression" || (r = e.extra) != null && r.parenthesized) && (o = as(e), t ? o.type === "Identifier" ? this.expressionScope.recordArrowParemeterBindingError(m.InvalidParenthesizedAssignment, {
        at: e
      }) : o.type !== "MemberExpression" && this.raise(m.InvalidParenthesizedAssignment, {
        at: e
      }) : this.raise(m.InvalidParenthesizedAssignment, {
        at: e
      })), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let u = 0, E = e.properties.length, w = E - 1; u < E; u++) {
            var d;
            const U = e.properties[u], ge = u === w;
            this.toAssignableObjectExpressionProp(U, ge, t), ge && U.type === "RestElement" && (d = e.extra) != null && d.trailingCommaLoc && this.raise(m.RestTrailingComma, {
              at: e.extra.trailingCommaLoc
            });
          }
          break;
        case "ObjectProperty": {
          const {
            key: u,
            value: E
          } = e;
          this.isPrivateName(u) && this.classScope.usePrivateName(this.getPrivateNameSV(u), u.loc.start), this.toAssignable(E, t);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, t);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(m.MissingEqInAssignment, {
            at: e.left.loc.end
          }), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(o, t);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, t, r) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? m.PatternHasAccessor : m.PatternHasMethod, {
          at: e.key
        });
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        const i = e.argument;
        this.checkToRestConversion(i, false), this.toAssignable(i, r), t || this.raise(m.RestTrailingComma, {
          at: e
        });
      } else
        this.toAssignable(e, r);
    }
    toAssignableList(e, t, r) {
      const i = e.length - 1;
      for (let o = 0; o <= i; o++) {
        const d = e[o];
        if (!!d) {
          if (d.type === "SpreadElement") {
            d.type = "RestElement";
            const u = d.argument;
            this.checkToRestConversion(u, true), this.toAssignable(u, r);
          } else
            this.toAssignable(d, r);
          d.type === "RestElement" && (o < i ? this.raise(m.RestTrailingComma, {
            at: d
          }) : t && this.raise(m.RestTrailingComma, {
            at: t
          }));
        }
      }
    }
    isAssignable(e, t) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const r = e.properties.length - 1;
          return e.properties.every((i, o) => i.type !== "ObjectMethod" && (o === r || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((r) => r === null || this.isAssignable(r));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t;
        default:
          return false;
      }
    }
    toReferencedList(e, t) {
      return e;
    }
    toReferencedListDeep(e, t) {
      this.toReferencedList(e, t);
      for (const r of e)
        (r == null ? void 0 : r.type) === "ArrayExpression" && this.toReferencedListDeep(r.elements);
    }
    parseSpread(e, t) {
      const r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0, t), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      const e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, true), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, t, r, i) {
      const o = [];
      let d = true;
      for (; !this.eat(e); )
        if (d ? d = false : this.expect(12), r && this.match(12))
          o.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (o.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(t)) {
              this.expect(e);
              break;
            }
          } else {
            const u = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(m.UnsupportedParameterDecorator, {
              at: this.state.startLoc
            }); this.match(26); )
              u.push(this.parseDecorator());
            o.push(this.parseAssignableListItem(i, u));
          }
        }
      return o;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      const e = this.startNode(), {
        type: t,
        start: r,
        startLoc: i
      } = this.state;
      return t === 21 ? this.parseBindingRestProperty(e) : (t === 134 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(this.state.value, i), e.key = this.parsePrivateName()) : this.parsePropertyName(e), e.method = false, this.parseObjPropValue(e, r, i, false, false, true, false), e);
    }
    parseAssignableListItem(e, t) {
      const r = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(r);
      const i = this.parseMaybeDefault(r.start, r.loc.start, r);
      return t.length && (r.decorators = t), i;
    }
    parseAssignableListItemTypes(e) {
      return e;
    }
    parseMaybeDefault(e, t, r) {
      var i, o, d;
      if (t = (i = t) != null ? i : this.state.startLoc, e = (o = e) != null ? o : this.state.start, r = (d = r) != null ? d : this.parseBindingAtom(), !this.eat(29))
        return r;
      const u = this.startNodeAt(e, t);
      return u.left = r, u.right = this.parseMaybeAssignAllowIn(), this.finishNode(u, "AssignmentPattern");
    }
    isValidLVal(e, t, r) {
      return vi({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    checkLVal(e, {
      in: t,
      binding: r = Pt,
      checkClashes: i = false,
      strictModeChanged: o = false,
      allowingSloppyLetBinding: d = !(r & pt),
      hasParenthesizedAncestor: u = false
    }) {
      var E;
      const w = e.type;
      if (this.isObjectMethod(e))
        return;
      if (w === "MemberExpression") {
        r !== Pt && this.raise(m.InvalidPropertyBindingPattern, {
          at: e
        });
        return;
      }
      if (e.type === "Identifier") {
        this.checkIdentifier(e, r, o, d);
        const {
          name: Oe
        } = e;
        i && (i.has(Oe) ? this.raise(m.ParamDupe, {
          at: e
        }) : i.add(Oe));
        return;
      }
      const U = this.isValidLVal(e.type, !(u || (E = e.extra) != null && E.parenthesized) && t.type === "AssignmentExpression", r);
      if (U === true)
        return;
      if (U === false) {
        const Oe = r === Pt ? m.InvalidLhs : m.InvalidLhsBinding;
        this.raise(Oe, {
          at: e,
          ancestor: t.type === "UpdateExpression" ? {
            type: "UpdateExpression",
            prefix: t.prefix
          } : {
            type: t.type
          }
        });
        return;
      }
      const [ge, ye] = Array.isArray(U) ? U : [U, w === "ParenthesizedExpression"], Ae = e.type === "ArrayPattern" || e.type === "ObjectPattern" || e.type === "ParenthesizedExpression" ? e : t;
      for (const Oe of [].concat(e[ge]))
        Oe && this.checkLVal(Oe, {
          in: Ae,
          binding: r,
          checkClashes: i,
          allowingSloppyLetBinding: d,
          strictModeChanged: o,
          hasParenthesizedAncestor: ye
        });
    }
    checkIdentifier(e, t, r = false, i = !(t & pt)) {
      this.state.strict && (r ? De(e.name, this.inModule) : qe(e.name)) && (t === Pt ? this.raise(m.StrictEvalArguments, {
        at: e,
        referenceName: e.name
      }) : this.raise(m.StrictEvalArgumentsBinding, {
        at: e,
        bindingName: e.name
      })), !i && e.name === "let" && this.raise(m.LetInLexicalBinding, {
        at: e
      }), t & Pt || this.declareNameFromIdentifier(e, t);
    }
    declareNameFromIdentifier(e, t) {
      this.scope.declareName(e.name, t, e.loc.start);
    }
    checkToRestConversion(e, t) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, t);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (t)
            break;
        default:
          this.raise(m.InvalidRestAssignmentPattern, {
            at: e
          });
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? m.RestTrailingComma : m.ElementAfterRest, {
        at: this.state.startLoc
      }), true) : false;
    }
  }
  class Ci extends Ai {
    checkProto(e, t, r, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      const o = e.key;
      if ((o.type === "Identifier" ? o.name : o.value) === "__proto__") {
        if (t) {
          this.raise(m.RecordNoProto, {
            at: o
          });
          return;
        }
        r.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = o.loc.start) : this.raise(m.DuplicateProto, {
          at: o
        })), r.used = true;
      }
    }
    shouldExitDescending(e, t) {
      return e.type === "ArrowFunctionExpression" && e.start === t;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e = this.parseExpression();
      return this.match(135) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.state.comments, e.errors = this.state.errors, this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, t) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
    }
    parseExpressionBase(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        const o = this.startNodeAt(t, r);
        for (o.expressions = [i]; this.eat(12); )
          o.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(o.expressions), this.finishNode(o, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, t) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
    }
    parseMaybeAssignAllowIn(e, t) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, t));
    }
    setOptionalParametersError(e, t) {
      var r;
      e.optionalParametersLoc = (r = t == null ? void 0 : t.loc) != null ? r : this.state.startLoc;
    }
    parseMaybeAssign(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      if (this.isContextual(105) && this.prodParam.hasYield) {
        let E = this.parseYield();
        return t && (E = t.call(this, E, r, i)), E;
      }
      let o;
      e ? o = false : (e = new Zt(), o = true);
      const {
        type: d
      } = this.state;
      (d === 10 || Te(d)) && (this.state.potentialArrowAt = this.state.start);
      let u = this.parseMaybeConditional(e);
      if (t && (u = t.call(this, u, r, i)), xe(this.state.type)) {
        const E = this.startNodeAt(r, i), w = this.state.value;
        return E.operator = w, this.match(29) ? (this.toAssignable(u, true), E.left = u, e.doubleProtoLoc != null && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), e.privateKeyLoc = null)) : E.left = u, this.next(), E.right = this.parseMaybeAssign(), this.checkLVal(u, {
          in: this.finishNode(E, "AssignmentExpression")
        }), E;
      } else
        o && this.checkExpressionErrors(e, true);
      return u;
    }
    parseMaybeConditional(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseExprOps(e);
      return this.shouldExitDescending(o, i) ? o : this.parseConditional(o, t, r, e);
    }
    parseConditional(e, t, r, i) {
      if (this.eat(17)) {
        const o = this.startNodeAt(t, r);
        return o.test = e, o.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), o.alternate = this.parseMaybeAssign(), this.finishNode(o, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(o, i) ? o : this.parseExprOp(o, t, r, -1);
    }
    parseExprOp(e, t, r, i) {
      if (this.isPrivateName(e)) {
        const d = this.getPrivateNameSV(e);
        (i >= Ge(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(m.PrivateInExpectedIn, {
          at: e,
          identifierName: d
        }), this.classScope.usePrivateName(d, e.loc.start);
      }
      const o = this.state.type;
      if (J(o) && (this.prodParam.hasIn || !this.match(58))) {
        let d = Ge(o);
        if (d > i) {
          if (o === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          const u = this.startNodeAt(t, r);
          u.left = e, u.operator = this.state.value;
          const E = o === 41 || o === 42, w = o === 40;
          if (w && (d = Ge(42)), this.next(), o === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(m.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc
            });
          u.right = this.parseExprOpRightExpr(o, d), this.finishNode(u, E || w ? "LogicalExpression" : "BinaryExpression");
          const U = this.state.type;
          if (w && (U === 41 || U === 42) || E && U === 40)
            throw this.raise(m.MixingCoalesceWithLogical, {
              at: this.state.startLoc
            });
          return this.parseExprOp(u, t, r, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(105))
                  throw this.raise(m.PipeBodyIsTighter, {
                    at: this.state.startLoc
                  });
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r, i);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, t);
      }
    }
    parseExprOpBaseRightExpr(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, i, lt(e) ? t - 1 : t);
    }
    parseHackPipeBody() {
      var e;
      const {
        startLoc: t
      } = this.state, r = this.parseMaybeAssign();
      return T.has(r.type) && !((e = r.extra) != null && e.parenthesized) && this.raise(m.PipeUnparenthesizedBody, {
        at: t,
        type: r.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(m.PipeTopicUnused, {
        at: t
      }), r;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(m.UnexpectedTokenUnaryExponentiation, {
        at: e.argument
      });
    }
    parseMaybeUnary(e, t) {
      const r = this.state.start, i = this.state.startLoc, o = this.isContextual(96);
      if (o && this.isAwaitAllowed()) {
        this.next();
        const w = this.parseAwait(r, i);
        return t || this.checkExponentialAfterUnary(w), w;
      }
      const d = this.match(34), u = this.startNode();
      if (ke(this.state.type)) {
        u.operator = this.state.value, u.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        const w = this.match(89);
        if (this.next(), u.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e, true), this.state.strict && w) {
          const U = u.argument;
          U.type === "Identifier" ? this.raise(m.StrictDelete, {
            at: u
          }) : this.hasPropertyAsPrivateName(U) && this.raise(m.DeletePrivateField, {
            at: u
          });
        }
        if (!d)
          return t || this.checkExponentialAfterUnary(u), this.finishNode(u, "UnaryExpression");
      }
      const E = this.parseUpdate(u, d, e);
      if (o) {
        const {
          type: w
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ce(w) : ce(w) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(m.AwaitNotInAsyncContext, {
            at: i
          }), this.parseAwait(r, i);
      }
      return E;
    }
    parseUpdate(e, t, r) {
      if (t)
        return this.checkLVal(e.argument, {
          in: this.finishNode(e, "UpdateExpression")
        }), e;
      const i = this.state.start, o = this.state.startLoc;
      let d = this.parseExprSubscripts(r);
      if (this.checkExpressionErrors(r, false))
        return d;
      for (; me(this.state.type) && !this.canInsertSemicolon(); ) {
        const u = this.startNodeAt(i, o);
        u.operator = this.state.value, u.prefix = false, u.argument = d, this.next(), this.checkLVal(d, {
          in: d = this.finishNode(u, "UpdateExpression")
        });
      }
      return d;
    }
    parseExprSubscripts(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseExprAtom(e);
      return this.shouldExitDescending(o, i) ? o : this.parseSubscripts(o, t, r);
    }
    parseSubscripts(e, t, r, i) {
      const o = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: false
      };
      do
        e = this.parseSubscript(e, t, r, i, o), o.maybeAsyncArrow = false;
      while (!o.stop);
      return e;
    }
    parseSubscript(e, t, r, i, o) {
      const {
        type: d
      } = this.state;
      if (!i && d === 15)
        return this.parseBind(e, t, r, i, o);
      if (Ze(d))
        return this.parseTaggedTemplateExpression(e, t, r, o);
      let u = false;
      if (d === 18) {
        if (i && this.lookaheadCharCode() === 40)
          return o.stop = true, e;
        o.optionalChainMember = u = true, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, t, r, o, u);
      {
        const E = this.eat(0);
        return E || u || this.eat(16) ? this.parseMember(e, t, r, o, E, u) : (o.stop = true, e);
      }
    }
    parseMember(e, t, r, i, o, d) {
      const u = this.startNodeAt(t, r);
      return u.object = e, u.computed = o, o ? (u.property = this.parseExpression(), this.expect(3)) : this.match(134) ? (e.type === "Super" && this.raise(m.SuperPrivateField, {
        at: r
      }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), u.property = this.parsePrivateName()) : u.property = this.parseIdentifier(true), i.optionalChainMember ? (u.optional = d, this.finishNode(u, "OptionalMemberExpression")) : this.finishNode(u, "MemberExpression");
    }
    parseBind(e, t, r, i, o) {
      const d = this.startNodeAt(t, r);
      return d.object = e, this.next(), d.callee = this.parseNoCallExpr(), o.stop = true, this.parseSubscripts(this.finishNode(d, "BindExpression"), t, r, i);
    }
    parseCoverCallAndAsyncArrowHead(e, t, r, i, o) {
      const d = this.state.maybeInArrowParameters;
      let u = null;
      this.state.maybeInArrowParameters = true, this.next();
      let E = this.startNodeAt(t, r);
      E.callee = e;
      const {
        maybeAsyncArrow: w,
        optionalChainMember: U
      } = i;
      return w && (this.expressionScope.enter(Ys()), u = new Zt()), U && (E.optional = o), o ? E.arguments = this.parseCallExpressionArguments(11) : E.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", E, u), this.finishCallExpression(E, U), w && this.shouldParseAsyncArrow() && !o ? (i.stop = true, this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), E = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t, r), E)) : (w && (this.checkExpressionErrors(u, true), this.expressionScope.exit()), this.toReferencedArguments(E)), this.state.maybeInArrowParameters = d, E;
    }
    toReferencedArguments(e, t) {
      this.toReferencedListDeep(e.arguments, t);
    }
    parseTaggedTemplateExpression(e, t, r, i) {
      const o = this.startNodeAt(t, r);
      return o.tag = e, o.quasi = this.parseTemplate(true), i.optionalChainMember && this.raise(m.OptionalChainingNoTemplate, {
        at: r
      }), this.finishNode(o, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    finishCallExpression(e, t) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(m.ImportCallArity, {
            at: e,
            maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        else
          for (const r of e.arguments)
            r.type === "SpreadElement" && this.raise(m.ImportCallSpreadArgument, {
              at: r
            });
      return this.finishNode(e, t ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, t, r, i, o) {
      const d = [];
      let u = true;
      const E = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e); ) {
        if (u)
          u = false;
        else if (this.expect(12), this.match(e)) {
          t && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(m.ImportCallArgumentTrailingComma, {
            at: this.state.lastTokStartLoc
          }), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        d.push(this.parseExprListItem(false, o, r));
      }
      return this.state.inFSharpPipelineDirectBody = E, d;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, t) {
      var r;
      return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, true, (r = t.extra) == null ? void 0 : r.trailingCommaLoc), t.innerComments && Bt(e, t.innerComments), t.callee.trailingComments && Bt(e, t.callee.trailingComments), e;
    }
    parseNoCallExpr() {
      const e = this.state.start, t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, t, true);
    }
    parseExprAtom(e) {
      let t;
      const {
        type: r
      } = this.state;
      switch (r) {
        case 79:
          return this.parseSuper();
        case 83:
          return t = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : (this.match(10) || this.raise(m.UnsupportedImport, {
            at: this.state.lastTokStartLoc
          }), this.finishNode(t, "Import"));
        case 78:
          return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 130:
          return this.parseNumericLiteral(this.state.value);
        case 131:
          return this.parseBigIntLiteral(this.state.value);
        case 132:
          return this.parseDecimalLiteral(this.state.value);
        case 129:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const i = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(i);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          this.parseDecorators();
        case 80:
          return t = this.startNode(), this.takeDecorators(t), this.parseClass(t, false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          t = this.startNode(), this.next(), t.object = null;
          const i = t.callee = this.parseNoCallExpr();
          if (i.type === "MemberExpression")
            return this.finishNode(t, "BindExpression");
          throw this.raise(m.UnsupportedBind, {
            at: i
          });
        }
        case 134:
          return this.raise(m.PrivateInExpectedIn, {
            at: this.state.startLoc,
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const i = this.getPluginOption("pipelineOperator", "proposal");
          if (i)
            return this.parseTopicReference(i);
          throw this.unexpected();
        }
        case 47: {
          const i = this.input.codePointAt(this.nextTokenStart());
          if (Ne(i) || i === 62) {
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
            break;
          } else
            throw this.unexpected();
        }
        default:
          if (Te(r)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression();
            const i = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, d = this.parseIdentifier();
            if (!o && d.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(d), this.next(), this.parseFunction(this.startNodeAtNode(d), void 0, true);
              if (Te(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(d)) : d;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(d), this.parseDo(this.startNodeAtNode(d), true);
            }
            return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(d), [d], false)) : d;
          } else
            throw this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, t) {
      const r = this.getPluginOption("pipelineOperator", "proposal");
      if (r)
        return this.state.type = e, this.state.value = t, this.state.pos--, this.state.end--, this.state.endLoc = f2(this.state.endLoc, -1), this.parseTopicReference(r);
      throw this.unexpected();
    }
    parseTopicReference(e) {
      const t = this.startNode(), r = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(t, r, e, i);
    }
    finishTopicReference(e, t, r, i) {
      if (this.testTopicReferenceConfiguration(r, t, i)) {
        const o = r === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(r === "smart" ? m.PrimaryTopicNotAllowed : m.PipeTopicUnbound, {
          at: t
        }), this.registerTopicReference(), this.finishNode(e, o);
      } else
        throw this.raise(m.PipeTopicUnconfiguredToken, {
          at: t,
          token: $e(i)
        });
    }
    testTopicReferenceConfiguration(e, t, r) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: $e(r)
          }]);
        case "smart":
          return r === 27;
        default:
          throw this.raise(m.PipeTopicRequiresHackPipes, {
            at: t
          });
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Qt(true, this.prodParam.hasYield));
      const t = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(m.LineTerminatorBeforeArrow, {
        at: this.state.curPosition()
      }), this.expect(19), this.parseArrowExpression(e, t, true), e;
    }
    parseDo(e, t) {
      this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), e.async = t, this.next();
      const r = this.state.labels;
      return this.state.labels = [], t ? (this.prodParam.enter(Yt), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(), this.state.labels = r, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      const e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(m.SuperNotAllowed, {
        at: e
      }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(m.UnexpectedSuper, {
        at: e
      }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(m.UnsupportedSuper, {
        at: e
      }), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      const e = this.startNode(), t = this.startNodeAt(this.state.start + 1, new n(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), r = this.state.value;
      return this.next(), e.id = this.createIdentifier(t, r), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const t = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e, t, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, t, r) {
      e.meta = t;
      const i = this.state.containsEsc;
      return e.property = this.parseIdentifier(true), (e.property.name !== r || i) && this.raise(m.UnsupportedMetaProperty, {
        at: e.property,
        target: t.name,
        onlyValidPropertyName: r
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "import");
      return this.next(), this.isContextual(100) && (this.inModule || this.raise(m.ImportMetaOutsideModule, {
        at: t
      }), this.sawUnambiguousESM = true), this.parseMetaProperty(e, t, "meta");
    }
    parseLiteralAtNode(e, t, r) {
      return this.addExtra(r, "rawValue", e), this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), r.value = e, this.next(), this.finishNode(r, t);
    }
    parseLiteral(e, t) {
      const r = this.startNode();
      return this.parseLiteralAtNode(e, t, r);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      const t = this.parseLiteral(e.value, "RegExpLiteral");
      return t.pattern = e.pattern, t.flags = e.flags, t;
    }
    parseBooleanLiteral(e) {
      const t = this.startNode();
      return t.value = e, this.next(), this.finishNode(t, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      const t = this.state.start, r = this.state.startLoc;
      let i;
      this.next(), this.expressionScope.enter(Js());
      const o = this.state.maybeInArrowParameters, d = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const u = this.state.start, E = this.state.startLoc, w = [], U = new Zt();
      let ge = true, ye, Ae;
      for (; !this.match(11); ) {
        if (ge)
          ge = false;
        else if (this.expect(12, U.optionalParametersLoc === null ? null : U.optionalParametersLoc), this.match(11)) {
          Ae = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const Ke = this.state.start, He = this.state.startLoc;
          if (ye = this.state.startLoc, w.push(this.parseParenItem(this.parseRestBinding(), Ke, He)), !this.checkCommaAfterRest(41))
            break;
        } else
          w.push(this.parseMaybeAssignAllowIn(U, this.parseParenItem));
      }
      const Oe = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = o, this.state.inFSharpPipelineDirectBody = d;
      let Ve = this.startNodeAt(t, r);
      return e && this.shouldParseArrow(w) && (Ve = this.parseArrow(Ve)) ? (this.checkDestructuringPrivate(U), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(Ve, w, false), Ve) : (this.expressionScope.exit(), w.length || this.unexpected(this.state.lastTokStartLoc), Ae && this.unexpected(Ae), ye && this.unexpected(ye), this.checkExpressionErrors(U, true), this.toReferencedListDeep(w, true), w.length > 1 ? (i = this.startNodeAt(u, E), i.expressions = w, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, Oe)) : i = w[0], this.wrapParenthesis(t, r, i));
    }
    wrapParenthesis(e, t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", true), this.addExtra(r, "parenStart", e), this.takeSurroundingComments(r, e, this.state.lastTokEndLoc.index), r;
      const i = this.startNodeAt(e, t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression"), i;
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, t, r) {
      return e;
    }
    parseNewOrNewTarget() {
      const e = this.startNode();
      if (this.next(), this.match(16)) {
        const t = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        const r = this.parseMetaProperty(e, t, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(m.UnexpectedNewTarget, {
          at: r
        }), r;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        const t = this.parseExprList(11);
        this.toReferencedList(t), e.arguments = t;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      e.callee = this.parseNoCallExpr(), e.callee.type === "Import" ? this.raise(m.ImportCallNotNewExpression, {
        at: e.callee
      }) : this.isOptionalChain(e.callee) ? this.raise(m.OptionalChainingNoNew, {
        at: this.state.lastTokEndLoc
      }) : this.eat(18) && this.raise(m.OptionalChainingNoNew, {
        at: this.state.startLoc
      });
    }
    parseTemplateElement(e) {
      const {
        start: t,
        startLoc: r,
        end: i,
        value: o
      } = this.state, d = t + 1, u = this.startNodeAt(d, f2(r, 1));
      o === null && (e || this.raise(m.InvalidEscapeSequenceTemplate, {
        at: f2(r, 2)
      }));
      const E = this.match(24), w = E ? -1 : -2, U = i + w;
      return u.value = {
        raw: this.input.slice(d, U).replace(/\r\n?/g, `
`),
        cooked: o === null ? null : o.slice(1, w)
      }, u.tail = E, this.next(), this.finishNode(u, "TemplateElement"), this.resetEndLocation(u, f2(this.state.lastTokEndLoc, w)), u;
    }
    parseTemplate(e) {
      const t = this.startNode();
      t.expressions = [];
      let r = this.parseTemplateElement(e);
      for (t.quasis = [r]; !r.tail; )
        t.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t.quasis.push(r = this.parseTemplateElement(e));
      return this.finishNode(t, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const d = /* @__PURE__ */ Object.create(null);
      let u = true;
      const E = this.startNode();
      for (E.properties = [], this.next(); !this.match(e); ) {
        if (u)
          u = false;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(E);
          break;
        }
        let U;
        t ? U = this.parseBindingProperty() : (U = this.parsePropertyDefinition(i), this.checkProto(U, r, d, i)), r && !this.isObjectProperty(U) && U.type !== "SpreadElement" && this.raise(m.InvalidRecordProperty, {
          at: U
        }), U.shorthand && this.addExtra(U, "shorthand", true), E.properties.push(U);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = o;
      let w = "ObjectExpression";
      return t ? w = "ObjectPattern" : r && (w = "RecordExpression"), this.finishNode(E, w);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStart), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let t = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(m.UnsupportedPropertyDecorator, {
          at: this.state.startLoc
        }); this.match(26); )
          t.push(this.parseDecorator());
      const r = this.startNode();
      let i = false, o = false, d, u;
      if (this.match(21))
        return t.length && this.unexpected(), this.parseSpread();
      t.length && (r.decorators = t, t = []), r.method = false, e && (d = this.state.start, u = this.state.startLoc);
      let E = this.eat(55);
      this.parsePropertyNamePrefixOperator(r);
      const w = this.state.containsEsc, U = this.parsePropertyName(r, e);
      if (!E && !w && this.maybeAsyncOrAccessorProp(r)) {
        const ge = U.name;
        ge === "async" && !this.hasPrecedingLineBreak() && (i = true, this.resetPreviousNodeTrailingComments(U), E = this.eat(55), this.parsePropertyName(r)), (ge === "get" || ge === "set") && (o = true, this.resetPreviousNodeTrailingComments(U), r.kind = ge, this.match(55) && (E = true, this.raise(m.AccessorIsGenerator, {
          at: this.state.curPosition(),
          kind: ge
        }), this.next()), this.parsePropertyName(r));
      }
      return this.parseObjPropValue(r, d, u, E, i, false, o, e), r;
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var t;
      const r = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== r && this.raise(e.kind === "get" ? m.BadGetterArity : m.BadSetterArity, {
        at: e
      }), e.kind === "set" && ((t = i[i.length - 1]) == null ? void 0 : t.type) === "RestElement" && this.raise(m.BadSetterRestParameter, {
        at: e
      });
    }
    parseObjectMethod(e, t, r, i, o) {
      if (o)
        return this.parseMethod(e, t, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e), e;
      if (r || t || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = true, this.parseMethod(e, t, r, false, false, "ObjectMethod");
    }
    parseObjectProperty(e, t, r, i, o) {
      if (e.shorthand = false, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(o), this.finishNode(e, "ObjectProperty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, true, false), i)
          e.value = this.parseMaybeDefault(t, r, at(e.key));
        else if (this.match(29)) {
          const d = this.state.startLoc;
          o != null ? o.shorthandAssignLoc === null && (o.shorthandAssignLoc = d) : this.raise(m.InvalidCoverInitializedName, {
            at: d
          }), e.value = this.parseMaybeDefault(t, r, at(e.key));
        } else
          e.value = at(e.key);
        return e.shorthand = true, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, t, r, i, o, d, u, E) {
      const w = this.parseObjectMethod(e, i, o, d, u) || this.parseObjectProperty(e, t, r, d, E);
      return w || this.unexpected(), w;
    }
    parsePropertyName(e, t) {
      if (this.eat(0))
        e.computed = true, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: r,
          value: i
        } = this.state;
        let o;
        if (z(r))
          o = this.parseIdentifier(true);
        else
          switch (r) {
            case 130:
              o = this.parseNumericLiteral(i);
              break;
            case 129:
              o = this.parseStringLiteral(i);
              break;
            case 131:
              o = this.parseBigIntLiteral(i);
              break;
            case 132:
              o = this.parseDecimalLiteral(i);
              break;
            case 134: {
              const d = this.state.startLoc;
              t != null ? t.privateKeyLoc === null && (t.privateKeyLoc = d) : this.raise(m.UnexpectedPrivateField, {
                at: d
              }), o = this.parsePrivateName();
              break;
            }
            default:
              throw this.unexpected();
          }
        e.key = o, r !== 134 && (e.computed = false);
      }
      return e.key;
    }
    initFunction(e, t) {
      e.id = null, e.generator = false, e.async = !!t;
    }
    parseMethod(e, t, r, i, o, d, u = false) {
      this.initFunction(e, r), e.generator = !!t;
      const E = i;
      return this.scope.enter(Ye | $t | (u ? xt : 0) | (o ? Mr : 0)), this.prodParam.enter(Qt(r, e.generator)), this.parseFunctionParams(e, E), this.parseFunctionBodyAndFinish(e, d, true), this.prodParam.exit(), this.scope.exit(), e;
    }
    parseArrayLike(e, t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const d = this.startNode();
      return this.next(), d.elements = this.parseExprList(e, !r, i, d), this.state.inFSharpPipelineDirectBody = o, this.finishNode(d, r ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, t, r, i) {
      this.scope.enter(Ye | bt);
      let o = Qt(r, false);
      !this.match(5) && this.prodParam.hasIn && (o |= Nt), this.prodParam.enter(o), this.initFunction(e, r);
      const d = this.state.maybeInArrowParameters;
      return t && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e, t, i)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = d, this.finishNode(e, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e, t, r) {
      this.toAssignableList(t, r, false), e.params = t;
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      this.parseFunctionBody(e, false, r), this.finishNode(e, t);
    }
    parseFunctionBody(e, t, r = false) {
      const i = t && !this.match(5);
      if (this.expressionScope.enter(zr()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, false, t, false);
      else {
        const o = this.state.strict, d = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Xr), e.body = this.parseBlock(true, false, (u) => {
          const E = !this.isSimpleParamList(e.params);
          u && E && this.raise(m.IllegalLanguageModeDirective, {
            at: (e.kind === "method" || e.kind === "constructor") && !!e.key ? e.key.loc.end : e
          });
          const w = !o && this.state.strict;
          this.checkParams(e, !this.state.strict && !t && !r && !E, t, w), this.state.strict && e.id && this.checkIdentifier(e.id, As, w);
        }), this.prodParam.exit(), this.state.labels = d;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let t = 0, r = e.length; t < r; t++)
        if (!this.isSimpleParameter(e[t]))
          return false;
      return true;
    }
    checkParams(e, t, r, i = true) {
      const o = !t && /* @__PURE__ */ new Set(), d = {
        type: "FormalParameters"
      };
      for (const u of e.params)
        this.checkLVal(u, {
          in: d,
          binding: Ht,
          checkClashes: o,
          strictModeChanged: i
        });
    }
    parseExprList(e, t, r, i) {
      const o = [];
      let d = true;
      for (; !this.eat(e); ) {
        if (d)
          d = false;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(t, r));
      }
      return o;
    }
    parseExprListItem(e, t, r) {
      let i;
      if (this.match(12))
        e || this.raise(m.UnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        const o = this.state.start, d = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(t), o, d);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), r || this.raise(m.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc
        });
        const o = this.startNode();
        this.next(), i = this.finishNode(o, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      const t = this.startNode(), r = this.parseIdentifierName(t.start, e);
      return this.createIdentifier(t, r);
    }
    createIdentifier(e, t) {
      return e.name = t, e.loc.identifierName = t, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e, t) {
      let r;
      const {
        startLoc: i,
        type: o
      } = this.state;
      if (z(o))
        r = this.state.value;
      else
        throw this.unexpected();
      const d = pe(o);
      return t ? d && this.replaceToken(128) : this.checkReservedWord(r, i, d, false), this.next(), r;
    }
    checkReservedWord(e, t, r, i) {
      if (e.length > 10 || !Nr(e))
        return;
      if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(m.YieldBindingIdentifier, {
            at: t
          });
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(m.AwaitBindingIdentifier, {
            at: t
          });
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(m.AwaitBindingIdentifierInStaticBlock, {
            at: t
          });
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError({
          at: t
        });
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(m.ArgumentsInClass, {
          at: t
        });
        return;
      }
      if (r && Tt(e)) {
        this.raise(m.UnexpectedKeyword, {
          at: t,
          keyword: e
        });
        return;
      }
      (this.state.strict ? i ? De : ut : gt)(e, this.inModule) && this.raise(m.UnexpectedReservedWord, {
        at: t,
        reservedWord: e
      });
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e, t) {
      const r = this.startNodeAt(e, t);
      return this.expressionScope.recordParameterInitializerError(m.AwaitExpressionFormalParameter, {
        at: r
      }), this.eat(55) && this.raise(m.ObsoleteAwaitStar, {
        at: r
      }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, true)), this.finishNode(r, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      const {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Ze(e) || e === 133 || e === 56 || this.hasPlugin("v8intrinsic") && e === 54;
    }
    parseYield() {
      const e = this.startNode();
      this.expressionScope.recordParameterInitializerError(m.YieldInParameter, {
        at: e
      }), this.next();
      let t = false, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (t = this.eat(55), this.state.type) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!t)
              break;
          default:
            r = this.parseMaybeAssign();
        }
      return e.delegate = t, e.argument = r, this.finishNode(e, "YieldExpression");
    }
    checkPipelineAtInfixOperator(e, t) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(m.PipelineHeadSequenceExpression, {
        at: t
      });
    }
    parseSmartPipelineBodyInStyle(e, t, r) {
      const i = this.startNodeAt(t, r);
      return this.isSimpleReference(e) ? (i.callee = e, this.finishNode(i, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = e, this.finishNode(i, "PipelineTopicExpression"));
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(m.PipelineBodyNoArrow, {
          at: this.state.startLoc
        });
      this.topicReferenceWasUsedInCurrentContext() || this.raise(m.PipelineTopicUnused, {
        at: e
      });
    }
    withTopicBindingContext(e) {
      const t = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = t;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const t = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = t;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      const t = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e();
      } finally {
        this.state.soloAwait = t;
      }
    }
    allowInAnd(e) {
      const t = this.prodParam.currentFlags();
      if (Nt & ~t) {
        this.prodParam.enter(t | Nt);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      const t = this.prodParam.currentFlags();
      if (Nt & t) {
        this.prodParam.enter(t & ~Nt);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      const t = this.state.start, r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const o = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, r, e);
      return this.state.inFSharpPipelineDirectBody = i, o;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e = this.startNode();
      this.next(), this.eat(5);
      const t = this.initializeScopes(true);
      this.enterInitialScopes();
      const r = this.startNode();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        t();
      }
      return this.eat(8), this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }
  const vr = {
    kind: "loop"
  }, wi = {
    kind: "switch"
  }, Ii = 0, Ar = 1, os = 2, ls = 4, Ni = /[\uD800-\uDFFF]/u, Cr = /in(?:stanceof)?/y;
  function ki(a, e) {
    for (let t = 0; t < a.length; t++) {
      const r = a[t], {
        type: i
      } = r;
      if (typeof i == "number") {
        {
          if (i === 134) {
            const {
              loc: o,
              start: d,
              value: u,
              end: E
            } = r, w = d + 1, U = f2(o.start, 1);
            a.splice(t, 1, new ft({
              type: Xe(27),
              value: "#",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            }), new ft({
              type: Xe(128),
              value: u,
              start: w,
              end: E,
              startLoc: U,
              endLoc: o.end
            })), t++;
            continue;
          }
          if (Ze(i)) {
            const {
              loc: o,
              start: d,
              value: u,
              end: E
            } = r, w = d + 1, U = f2(o.start, 1);
            let ge;
            e.charCodeAt(d) === 96 ? ge = new ft({
              type: Xe(22),
              value: "`",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            }) : ge = new ft({
              type: Xe(8),
              value: "}",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            });
            let ye, Ae, Oe, Ve;
            i === 24 ? (Ae = E - 1, Oe = f2(o.end, -1), ye = u === null ? null : u.slice(1, -1), Ve = new ft({
              type: Xe(22),
              value: "`",
              start: Ae,
              end: E,
              startLoc: Oe,
              endLoc: o.end
            })) : (Ae = E - 2, Oe = f2(o.end, -2), ye = u === null ? null : u.slice(1, -2), Ve = new ft({
              type: Xe(23),
              value: "${",
              start: Ae,
              end: E,
              startLoc: Oe,
              endLoc: o.end
            })), a.splice(t, 1, ge, new ft({
              type: Xe(20),
              value: ye,
              start: w,
              end: Ae,
              startLoc: U,
              endLoc: Oe
            }), Ve), t += 2;
            continue;
          }
        }
        r.type = Xe(i);
      }
    }
    return a;
  }
  class Oi extends Ci {
    parseTopLevel(e, t) {
      return e.program = this.parseProgram(t), e.comments = this.state.comments, this.options.tokens && (e.tokens = ki(this.tokens, this.input)), this.finishNode(e, "File");
    }
    parseProgram(e, t = 135, r = this.options.sourceType) {
      if (e.sourceType = r, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, true, true, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (const [i, o] of Array.from(this.scope.undefinedExports))
          this.raise(m.ModuleExportUndefined, {
            at: o,
            localName: i
          });
      return this.finishNode(e, "Program");
    }
    stmtToDirective(e) {
      const t = e;
      t.type = "Directive", t.value = t.expression, delete t.expression;
      const r = t.value, i = r.value, o = this.input.slice(r.start, r.end), d = r.value = o.slice(1, -1);
      return this.addExtra(r, "raw", o), this.addExtra(r, "rawValue", d), this.addExtra(r, "expressionValue", i), r.type = "DirectiveLiteral", t;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet(e) {
      return this.isContextual(99) ? this.isLetKeyword(e) : false;
    }
    isLetKeyword(e) {
      const t = this.nextTokenStart(), r = this.codePointAtPos(t);
      if (r === 92 || r === 91)
        return true;
      if (e)
        return false;
      if (r === 123)
        return true;
      if (Ne(r)) {
        if (Cr.lastIndex = t, Cr.test(this.input)) {
          const i = this.codePointAtPos(Cr.lastIndex);
          if (!Be(i) && i !== 92)
            return false;
        }
        return true;
      }
      return false;
    }
    parseStatement(e, t) {
      return this.match(26) && this.parseDecorators(true), this.parseStatementContent(e, t);
    }
    parseStatementContent(e, t) {
      let r = this.state.type;
      const i = this.startNode();
      let o;
      switch (this.isLet(e) && (r = 74, o = "let"), r) {
        case 60:
          return this.parseBreakContinueStatement(i, true);
        case 63:
          return this.parseBreakContinueStatement(i, false);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return e && (this.state.strict ? this.raise(m.StrictFunction, {
            at: this.state.startLoc
          }) : e !== "if" && e !== "label" && this.raise(m.SloppyFunction, {
            at: this.state.startLoc
          })), this.parseFunctionStatement(i, false, !e);
        case 80:
          return e && this.unexpected(), this.parseClass(i, true);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 75:
        case 74:
          return o = o || this.state.value, e && o !== "var" && this.raise(m.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          }), this.parseVarStatement(i, o);
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          const E = this.lookaheadCharCode();
          if (E === 40 || E === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !t && this.raise(m.UnexpectedImportExport, {
            at: this.state.startLoc
          }), this.next();
          let E;
          return r === 83 ? (E = this.parseImport(i), E.type === "ImportDeclaration" && (!E.importKind || E.importKind === "value") && (this.sawUnambiguousESM = true)) : (E = this.parseExport(i), (E.type === "ExportNamedDeclaration" && (!E.exportKind || E.exportKind === "value") || E.type === "ExportAllDeclaration" && (!E.exportKind || E.exportKind === "value") || E.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(i), E;
        }
        default:
          if (this.isAsyncFunction())
            return e && this.raise(m.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc
            }), this.next(), this.parseFunctionStatement(i, true, !e);
      }
      const d = this.state.value, u = this.parseExpression();
      return Te(r) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, d, u, e) : this.parseExpressionStatement(i, u);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(m.ImportOutsideModule, {
        at: e
      });
    }
    takeDecorators(e) {
      const t = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      t.length && (e.decorators = t, this.resetStartLocationFromNode(e, t[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      const t = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (; this.match(26); ) {
        const r = this.parseDecorator();
        t.push(r);
      }
      if (this.match(82))
        e || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(m.DecoratorExportClass, {
          at: this.state.startLoc
        });
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(m.UnexpectedLeadingDecorator, {
          at: this.state.startLoc
        });
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const t = this.state.start, r = this.state.startLoc;
        let i;
        if (this.match(10)) {
          const o = this.state.start, d = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(o, d, i);
        } else
          for (i = this.parseIdentifier(false); this.eat(16); ) {
            const o = this.startNodeAt(t, r);
            o.object = i, o.property = this.parseIdentifier(true), o.computed = false, i = this.finishNode(o, "MemberExpression");
          }
        e.expression = this.parseMaybeDecoratorArguments(i), this.state.decoratorStack.pop();
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        const t = this.startNodeAtNode(e);
        return t.callee = e, t.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, t) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, t) {
      let r;
      for (r = 0; r < this.state.labels.length; ++r) {
        const i = this.state.labels[r];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (t || i.kind === "loop") || e.label && t))
          break;
      }
      if (r === this.state.labels.length) {
        const i = t ? "BreakStatement" : "ContinueStatement";
        this.raise(m.IllegalBreakContinue, {
          at: e,
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoStatement(e) {
      return this.next(), this.state.labels.push(vr), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(vr);
      let t = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(At), this.expect(10), this.match(13))
        return t !== null && this.unexpected(t), this.parseFor(e, null);
      const r = this.isContextual(99), i = r && this.isLetKeyword();
      if (this.match(74) || this.match(75) || i) {
        const w = this.startNode(), U = i ? "let" : this.state.value;
        return this.next(), this.parseVar(w, true, U), this.finishNode(w, "VariableDeclaration"), (this.match(58) || this.isContextual(101)) && w.declarations.length === 1 ? this.parseForIn(e, w, t) : (t !== null && this.unexpected(t), this.parseFor(e, w));
      }
      const o = this.isContextual(95), d = new Zt(), u = this.parseExpression(true, d), E = this.isContextual(101);
      if (E && (r && this.raise(m.ForOfLet, {
        at: u
      }), t === null && o && u.type === "Identifier" && this.raise(m.ForOfAsync, {
        at: u
      })), E || this.match(58)) {
        this.checkDestructuringPrivate(d), this.toAssignable(u, true);
        const w = E ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(u, {
          in: {
            type: w
          }
        }), this.parseForIn(e, u, t);
      } else
        this.checkExpressionErrors(d, true);
      return t !== null && this.unexpected(t), this.parseFor(e, u);
    }
    parseFunctionStatement(e, t, r) {
      return this.next(), this.parseFunction(e, Ar | (r ? 0 : os), t);
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(m.IllegalReturn, {
        at: this.state.startLoc
      }), this.next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      const t = e.cases = [];
      this.expect(5), this.state.labels.push(wi), this.scope.enter(At);
      let r;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const o = this.match(61);
          r && this.finishNode(r, "SwitchCase"), t.push(r = this.startNode()), r.consequent = [], this.next(), o ? r.test = this.parseExpression() : (i && this.raise(m.MultipleDefaultsInSwitch, {
            at: this.state.lastTokStartLoc
          }), i = true, r.test = null), this.expect(14);
        } else
          r ? r.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), r && this.finishNode(r, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchStatement");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(m.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc
      }), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e = this.parseBindingAtom(), t = e.type === "Identifier";
      return this.scope.enter(t ? ct : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: nt,
        allowingSloppyLetBinding: true
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        const t = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), t.param = this.parseCatchClauseParam(), this.expect(11)) : (t.param = null, this.scope.enter(At)), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e.handler = this.finishNode(t, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(m.NoCatchOrFinally, {
        at: e
      }), this.finishNode(e, "TryStatement");
    }
    parseVarStatement(e, t, r = false) {
      return this.next(), this.parseVar(e, false, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(vr), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(m.StrictWith, {
        at: this.state.startLoc
      }), this.next(), e.object = this.parseHeaderExpression(), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, t, r, i) {
      for (const d of this.state.labels)
        d.name === t && this.raise(m.LabelRedeclaration, {
          at: r,
          labelName: t
        });
      const o = Le(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
      for (let d = this.state.labels.length - 1; d >= 0; d--) {
        const u = this.state.labels[d];
        if (u.statementStart === e.start)
          u.statementStart = this.state.start, u.kind = o;
        else
          break;
      }
      return this.state.labels.push({
        name: t,
        kind: o,
        statementStart: this.state.start
      }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i + "label" : i : "label"), this.state.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, t) {
      return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = false, t = true, r) {
      const i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(At), this.parseBlockBody(i, e, false, 8, r), t && this.scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, t, r, i, o) {
      const d = e.body = [], u = e.directives = [];
      this.parseBlockOrModuleBlockBody(d, t ? u : void 0, r, i, o);
    }
    parseBlockOrModuleBlockBody(e, t, r, i, o) {
      const d = this.state.strict;
      let u = false, E = false;
      for (; !this.match(i); ) {
        const w = this.parseStatement(null, r);
        if (t && !E) {
          if (this.isValidDirective(w)) {
            const U = this.stmtToDirective(w);
            t.push(U), !u && U.value.value === "use strict" && (u = true, this.setStrict(true));
            continue;
          }
          E = true, this.state.strictErrors.clear();
        }
        e.push(w);
      }
      o && o.call(this, u), d || this.setStrict(false), this.next();
    }
    parseFor(e, t) {
      return e.init = t, this.semicolon(false), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, t, r) {
      const i = this.match(58);
      return this.next(), i ? r !== null && this.unexpected(r) : e.await = r !== null, t.type === "VariableDeclaration" && t.declarations[0].init != null && (!i || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(m.ForInOfLoopInitializer, {
        at: t,
        type: i ? "ForInStatement" : "ForOfStatement"
      }), t.type === "AssignmentPattern" && this.raise(m.InvalidLhs, {
        at: t,
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = t, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, t, r, i = false) {
      const o = e.declarations = [];
      for (e.kind = r; ; ) {
        const d = this.startNode();
        if (this.parseVarId(d, r), d.init = this.eat(29) ? t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, d.init === null && !i && (d.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(101))) ? this.raise(m.DeclarationMissingInitializer, {
          at: this.state.lastTokEndLoc,
          kind: "destructuring"
        }) : r === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(m.DeclarationMissingInitializer, {
          at: this.state.lastTokEndLoc,
          kind: "const"
        })), o.push(this.finishNode(d, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return e;
    }
    parseVarId(e, t) {
      e.id = this.parseBindingAtom(), this.checkLVal(e.id, {
        in: {
          type: "VariableDeclarator"
        },
        binding: t === "var" ? Ht : nt
      });
    }
    parseFunction(e, t = Ii, r = false) {
      const i = t & Ar, o = t & os, d = !!i && !(t & ls);
      this.initFunction(e, r), this.match(55) && o && this.raise(m.GeneratorInSingleStatementContext, {
        at: this.state.startLoc
      }), e.generator = this.eat(55), i && (e.id = this.parseFunctionId(d));
      const u = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(Ye), this.prodParam.enter(Qt(r, e.generator)), i || (e.id = this.parseFunctionId()), this.parseFunctionParams(e, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !o && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = u, e;
    }
    parseFunctionId(e) {
      return e || Te(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, t) {
      this.expect(10), this.expressionScope.enter(Xs()), e.params = this.parseBindingList(11, 41, false, t), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      !e.id || this.scope.declareName(e.id.name, this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ? Ht : nt : jr, e.id.loc.start);
    }
    parseClass(e, t, r) {
      this.next(), this.takeDecorators(e);
      const i = this.state.strict;
      return this.state.strict = true, this.parseClassId(e, t, r), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === "constructor" || e.key.value === "constructor");
    }
    parseClassBody(e, t) {
      this.classScope.enter();
      const r = {
        hadConstructor: false,
        hadSuperClass: e
      };
      let i = [];
      const o = this.startNode();
      if (o.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(m.DecoratorSemicolon, {
                at: this.state.lastTokEndLoc
              });
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          const d = this.startNode();
          i.length && (d.decorators = i, this.resetStartLocationFromNode(d, i[0]), i = []), this.parseClassMember(o, d, r), d.kind === "constructor" && d.decorators && d.decorators.length > 0 && this.raise(m.DecoratorConstructor, {
            at: d
          });
        }
      }), this.state.strict = t, this.next(), i.length)
        throw this.raise(m.TrailingDecorator, {
          at: this.state.startLoc
        });
      return this.classScope.exit(), this.finishNode(o, "ClassBody");
    }
    parseClassMemberFromModifier(e, t) {
      const r = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const i = t;
        return i.kind = "method", i.computed = false, i.key = r, i.static = false, this.pushClassMethod(e, i, false, false, false, false), true;
      } else if (this.isClassProperty()) {
        const i = t;
        return i.computed = false, i.key = r, i.static = false, e.body.push(this.parseClassProperty(i)), true;
      }
      return this.resetPreviousNodeTrailingComments(r), false;
    }
    parseClassMember(e, t, r) {
      const i = this.isContextual(104);
      if (i) {
        if (this.parseClassMemberFromModifier(e, t))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, t);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, t, r, i);
    }
    parseClassMemberWithIsStatic(e, t, r, i) {
      const o = t, d = t, u = t, E = t, w = t, U = o, ge = o;
      if (t.static = i, this.parsePropertyNamePrefixOperator(t), this.eat(55)) {
        U.kind = "method";
        const Ke = this.match(134);
        if (this.parseClassElementName(U), Ke) {
          this.pushClassPrivateMethod(e, d, true, false);
          return;
        }
        this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsGenerator, {
          at: o.key
        }), this.pushClassMethod(e, o, true, false, false, false);
        return;
      }
      const ye = Te(this.state.type) && !this.state.containsEsc, Ae = this.match(134), Oe = this.parseClassElementName(t), Ve = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(ge), this.isClassMethod()) {
        if (U.kind = "method", Ae) {
          this.pushClassPrivateMethod(e, d, false, false);
          return;
        }
        const Ke = this.isNonstaticConstructor(o);
        let He = false;
        Ke && (o.kind = "constructor", r.hadConstructor && !this.hasPlugin("typescript") && this.raise(m.DuplicateConstructor, {
          at: Oe
        }), Ke && this.hasPlugin("typescript") && t.override && this.raise(m.OverrideOnConstructor, {
          at: Oe
        }), r.hadConstructor = true, He = r.hadSuperClass), this.pushClassMethod(e, o, false, false, Ke, He);
      } else if (this.isClassProperty())
        Ae ? this.pushClassPrivateProperty(e, E) : this.pushClassProperty(e, u);
      else if (ye && Oe.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(Oe);
        const Ke = this.eat(55);
        ge.optional && this.unexpected(Ve), U.kind = "method";
        const He = this.match(134);
        this.parseClassElementName(U), this.parsePostMemberNameModifiers(ge), He ? this.pushClassPrivateMethod(e, d, Ke, true) : (this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsAsync, {
          at: o.key
        }), this.pushClassMethod(e, o, Ke, true, false, false));
      } else if (ye && (Oe.name === "get" || Oe.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(Oe), U.kind = Oe.name;
        const Ke = this.match(134);
        this.parseClassElementName(o), Ke ? this.pushClassPrivateMethod(e, d, false, false) : (this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsAccessor, {
          at: o.key
        }), this.pushClassMethod(e, o, false, false, false, false)), this.checkGetterSetterParams(o);
      } else if (ye && Oe.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(Oe);
        const Ke = this.match(134);
        this.parseClassElementName(u), this.pushClassAccessorProperty(e, w, Ke);
      } else
        this.isLineTerminator() ? Ae ? this.pushClassPrivateProperty(e, E) : this.pushClassProperty(e, u) : this.unexpected();
    }
    parseClassElementName(e) {
      const {
        type: t,
        value: r
      } = this.state;
      if ((t === 128 || t === 129) && e.static && r === "prototype" && this.raise(m.StaticPrototype, {
        at: this.state.startLoc
      }), t === 134) {
        r === "constructor" && this.raise(m.ConstructorClassPrivateField, {
          at: this.state.startLoc
        });
        const i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e);
    }
    parseClassStaticBlock(e, t) {
      var r;
      this.scope.enter(xt | or | $t);
      const i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(It);
      const o = t.body = [];
      this.parseBlockOrModuleBlockBody(o, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.finishNode(t, "StaticBlock")), (r = t.decorators) != null && r.length && this.raise(m.DecoratorStaticBlock, {
        at: t
      });
    }
    pushClassProperty(e, t) {
      !t.computed && (t.key.name === "constructor" || t.key.value === "constructor") && this.raise(m.ConstructorClassField, {
        at: t.key
      }), e.body.push(this.parseClassProperty(t));
    }
    pushClassPrivateProperty(e, t) {
      const r = this.parseClassPrivateProperty(t);
      e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), mr, r.key.loc.start);
    }
    pushClassAccessorProperty(e, t, r) {
      if (!r && !t.computed) {
        const o = t.key;
        (o.name === "constructor" || o.value === "constructor") && this.raise(m.ConstructorClassField, {
          at: o
        });
      }
      const i = this.parseClassAccessorProperty(t);
      e.body.push(i), r && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), mr, i.key.loc.start);
    }
    pushClassMethod(e, t, r, i, o, d) {
      e.body.push(this.parseMethod(t, r, i, o, d, "ClassMethod", true));
    }
    pushClassPrivateMethod(e, t, r, i) {
      const o = this.parseMethod(t, r, i, false, false, "ClassPrivateMethod", true);
      e.body.push(o);
      const d = o.kind === "get" ? o.static ? Ns : Os : o.kind === "set" ? o.static ? ks : Ds : mr;
      this.declareClassPrivateMethodInScope(o, d);
    }
    declareClassPrivateMethodInScope(e, t) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(xt | $t), this.expressionScope.enter(zr()), this.prodParam.enter(It), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, t, r, i = Fr) {
      if (Te(this.state.type))
        e.id = this.parseIdentifier(), t && this.declareNameFromIdentifier(e.id, i);
      else if (r || !t)
        e.id = null;
      else
        throw this.raise(m.MissingClassName, {
          at: this.state.startLoc
        });
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e) {
      const t = this.maybeParseExportDefaultSpecifier(e), r = !t || this.eat(12), i = r && this.eatExportStar(e), o = i && this.maybeParseExportNamespaceSpecifier(e), d = r && (!o || this.eat(12)), u = t || i;
      if (i && !o)
        return t && this.unexpected(), this.parseExportFrom(e, true), this.finishNode(e, "ExportAllDeclaration");
      const E = this.maybeParseExportNamedSpecifiers(e);
      if (t && r && !i && !E || o && d && !E)
        throw this.unexpected(null, 5);
      let w;
      if (u || E ? (w = false, this.parseExportFrom(e, u)) : w = this.maybeParseExportDeclaration(e), u || E || w)
        return this.checkExport(e, true, false, !!e.source), this.finishNode(e, "ExportNamedDeclaration");
      if (this.eat(65))
        return e.declaration = this.parseExportDefaultExpression(), this.checkExport(e, true, true), this.finishNode(e, "ExportDefaultDeclaration");
      throw this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const t = this.startNode();
        return t.exported = this.parseIdentifier(true), e.specifiers = [this.finishNode(t, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = []);
        const t = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), t.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = []);
        const t = e.exportKind === "type";
        return e.specifiers.push(...this.parseExportSpecifiers(t)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") && (e.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions = []), e.declaration = this.parseExportDeclaration(e), true) : false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      const e = this.nextTokenStart();
      return !yr.test(this.input.slice(this.state.pos, e)) && this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      const e = this.startNode(), t = this.isAsyncFunction();
      if (this.match(68) || t)
        return this.next(), t && this.next(), this.parseFunction(e, Ar | ls, t);
      if (this.match(80))
        return this.parseClass(e, true, true);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(m.DecoratorBeforeExport, {
          at: this.state.startLoc
        }), this.parseDecorators(false), this.parseClass(e, true, true);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(m.UnsupportedDefaultExport, {
          at: this.state.startLoc
        });
      const r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      if (Te(e)) {
        if (e === 95 && !this.state.containsEsc || e === 99)
          return false;
        if ((e === 126 || e === 125) && !this.state.containsEsc) {
          const {
            type: i
          } = this.lookahead();
          if (Te(i) && i !== 97 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65))
        return false;
      const t = this.nextTokenStart(), r = this.isUnparsedContextual(t, "from");
      if (this.input.charCodeAt(t) === 44 || Te(this.state.type) && r)
        return true;
      if (this.match(65) && r) {
        const i = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
        return i === 34 || i === 39;
      }
      return false;
    }
    parseExportFrom(e, t) {
      if (this.eatContextual(97)) {
        e.source = this.parseImportSource(), this.checkExport(e);
        const r = this.maybeParseImportAssertions();
        r && (e.assertions = r, this.checkJSONModuleImport(e));
      } else
        t && this.unexpected();
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      if (e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
          throw this.raise(m.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        return true;
      }
      return e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, t, r, i) {
      if (t) {
        if (r) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            const u = e.declaration;
            u.type === "Identifier" && u.name === "from" && u.end - u.start === 4 && !((o = u.extra) != null && o.parenthesized) && this.raise(m.ExportDefaultFromAsIdentifier, {
              at: u
            });
          }
        } else if (e.specifiers && e.specifiers.length)
          for (const u of e.specifiers) {
            const {
              exported: E
            } = u, w = E.type === "Identifier" ? E.name : E.value;
            if (this.checkDuplicateExports(u, w), !i && u.local) {
              const {
                local: U
              } = u;
              U.type !== "Identifier" ? this.raise(m.ExportBindingIsString, {
                at: u,
                localName: U.value,
                exportName: w
              }) : (this.checkReservedWord(U.name, U.loc.start, true, false), this.scope.checkLocalExport(U));
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === "FunctionDeclaration" || e.declaration.type === "ClassDeclaration") {
            const u = e.declaration.id;
            if (!u)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (e.declaration.type === "VariableDeclaration")
            for (const u of e.declaration.declarations)
              this.checkDeclaration(u.id);
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(m.UnsupportedDecoratorExport, {
          at: e
        });
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (const t of e.properties)
          this.checkDeclaration(t);
      else if (e.type === "ArrayPattern")
        for (const t of e.elements)
          t && this.checkDeclaration(t);
      else
        e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type === "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, t) {
      this.exportedIdentifiers.has(t) && (t === "default" ? this.raise(m.DuplicateDefaultExport, {
        at: e
      }) : this.raise(m.DuplicateExport, {
        at: e,
        exportName: t
      })), this.exportedIdentifiers.add(t);
    }
    parseExportSpecifiers(e) {
      const t = [];
      let r = true;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = false;
        else if (this.expect(12), this.eat(8))
          break;
        const i = this.isContextual(126), o = this.match(129), d = this.startNode();
        d.local = this.parseModuleExportName(), t.push(this.parseExportSpecifier(d, o, e, i));
      }
      return t;
    }
    parseExportSpecifier(e, t, r, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : t ? e.exported = ti(e.local) : e.exported || (e.exported = at(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(129)) {
        const e = this.parseStringLiteral(this.state.value), t = e.value.match(Ni);
        return t && this.raise(m.ModuleExportNameHasLoneSurrogate, {
          at: e,
          surrogateCharCode: t[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: t,
        value: r
      }) => r.value === "json" && (t.type === "Identifier" ? t.name === "type" : t.value === "type")) : false;
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        const {
          specifiers: t
        } = e;
        if (e.specifiers != null) {
          const r = t.find((i) => {
            let o;
            if (i.type === "ExportSpecifier" ? o = i.local : i.type === "ImportSpecifier" && (o = i.imported), o !== void 0)
              return o.type === "Identifier" ? o.name !== "default" : o.value !== "default";
          });
          r !== void 0 && this.raise(m.ImportJSONBindingNotDefault, {
            at: r.loc.start
          });
        }
      }
    }
    parseImport(e) {
      if (e.specifiers = [], !this.match(129)) {
        const i = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12), o = i && this.maybeParseStarImportSpecifier(e);
        i && !o && this.parseNamedImportSpecifiers(e), this.expectContextual(97);
      }
      e.source = this.parseImportSource();
      const t = this.maybeParseImportAssertions();
      if (t)
        e.assertions = t;
      else {
        const r = this.maybeParseModuleAttributes();
        r && (e.attributes = r);
      }
      return this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(129) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(e) {
      return Te(this.state.type);
    }
    parseImportSpecifierLocal(e, t, r) {
      t.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, r));
    }
    finishImportSpecifier(e, t) {
      return this.checkLVal(e.local, {
        in: e,
        binding: nt
      }), this.finishNode(e, t);
    }
    parseAssertEntries() {
      const e = [], t = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const r = this.startNode(), i = this.state.value;
        if (t.has(i) && this.raise(m.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc,
          key: i
        }), t.add(i), this.match(129) ? r.key = this.parseStringLiteral(i) : r.key = this.parseIdentifier(true), this.expect(14), !this.match(129))
          throw this.raise(m.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        r.value = this.parseStringLiteral(this.state.value), this.finishNode(r, "ImportAttribute"), e.push(r);
      } while (this.eat(12));
      return e;
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak())
        this.expectPlugin("moduleAttributes"), this.next();
      else
        return this.hasPlugin("moduleAttributes") ? [] : null;
      const e = [], t = /* @__PURE__ */ new Set();
      do {
        const r = this.startNode();
        if (r.key = this.parseIdentifier(true), r.key.name !== "type" && this.raise(m.ModuleAttributeDifferentFromType, {
          at: r.key
        }), t.has(r.key.name) && this.raise(m.ModuleAttributesWithDuplicateKeys, {
          at: r.key,
          key: r.key.name
        }), t.add(r.key.name), this.expect(14), !this.match(129))
          throw this.raise(m.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        r.value = this.parseStringLiteral(this.state.value), this.finishNode(r, "ImportAttribute"), e.push(r);
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.expectPlugin("importAssertions"), this.next();
      else
        return this.hasPlugin("importAssertions") ? [] : null;
      this.eat(5);
      const e = this.parseAssertEntries();
      return this.eat(8), e;
    }
    maybeParseDefaultImportSpecifier(e) {
      return this.shouldParseDefaultImport(e) ? (this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), true) : false;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        const t = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e) {
      let t = true;
      for (this.expect(5); !this.eat(8); ) {
        if (t)
          t = false;
        else {
          if (this.eat(14))
            throw this.raise(m.DestructureNamedImport, {
              at: this.state.startLoc
            });
          if (this.expect(12), this.eat(8))
            break;
        }
        const r = this.startNode(), i = this.match(129), o = this.isContextual(126);
        r.imported = this.parseModuleExportName();
        const d = this.parseImportSpecifier(r, i, e.importKind === "type" || e.importKind === "typeof", o);
        e.specifiers.push(d);
      }
    }
    parseImportSpecifier(e, t, r, i) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        const {
          imported: o
        } = e;
        if (t)
          throw this.raise(m.ImportBindingIsString, {
            at: e,
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, true, true), e.local || (e.local = at(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier");
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }
  class us extends Oi {
    constructor(e, t) {
      e = Ei(e), super(e, t), this.options = e, this.initializeScopes(), this.plugins = Di(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return xr;
    }
    parse() {
      this.enterInitialScopes();
      const e = this.startNode(), t = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, t), e.errors = this.state.errors, e;
    }
  }
  function Di(a) {
    const e = /* @__PURE__ */ new Map();
    for (const t of a) {
      const [r, i] = Array.isArray(t) ? t : [t, {}];
      e.has(r) || e.set(r, i || {});
    }
    return e;
  }
  function Li(a, e) {
    var t;
    if (((t = e) == null ? void 0 : t.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        const r = jt(e, a), i = r.parse();
        if (r.sawUnambiguousESM)
          return i;
        if (r.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", jt(e, a).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (r) {
        try {
          return e.sourceType = "script", jt(e, a).parse();
        } catch {
        }
        throw r;
      }
    } else
      return jt(e, a).parse();
  }
  function Mi(a, e) {
    const t = jt(e, a);
    return t.options.strictMode && (t.state.strict = true), t.getExpression();
  }
  function Bi(a) {
    const e = {};
    for (const t of Object.keys(a))
      e[t] = Xe(a[t]);
    return e;
  }
  const _i = Bi(Ie);
  function jt(a, e) {
    let t = us;
    return a != null && a.plugins && (Pi(a.plugins), t = Fi(a.plugins)), new t(a, e);
  }
  const cs = {};
  function Fi(a) {
    const e = Si.filter((i) => ze(a, i)), t = e.join("/");
    let r = cs[t];
    if (!r) {
      r = us;
      for (const i of e)
        r = is[i](r);
      cs[t] = r;
    }
    return r;
  }
  return Dn.parse = Li, Dn.parseExpression = Mi, Dn.tokTypes = _i, Dn;
}
var Cd;
function Zy() {
  if (Cd)
    return sl;
  Cd = 1, Object.defineProperty(sl, "__esModule", {
    value: true
  }), sl.default = N;
  var s = Je(), n = WT(), h = Bl();
  const {
    isCallExpression: f2,
    isExpressionStatement: p,
    isFunction: g,
    isIdentifier: P,
    isJSXIdentifier: x,
    isNewExpression: y,
    isPlaceholder: A,
    isStatement: S,
    isStringLiteral: v,
    removePropertiesDeep: T,
    traverse: C
  } = s, I = /^[_$A-Z0-9]+$/;
  function N(L, R, O) {
    const {
      placeholderWhitelist: B,
      placeholderPattern: M,
      preserveComments: j,
      syntacticPlaceholders: $
    } = O, k = m(R, O.parser, $);
    T(k, {
      preserveComments: j
    }), L.validate(k);
    const ne = {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    }, Q = {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    }, q = {
      value: void 0
    };
    return C(k, D, {
      syntactic: ne,
      legacy: Q,
      isLegacyRef: q,
      placeholderWhitelist: B,
      placeholderPattern: M,
      syntacticPlaceholders: $
    }), Object.assign({
      ast: k
    }, q.value ? Q : ne);
  }
  function D(L, R, O) {
    var B;
    let M;
    if (A(L)) {
      if (O.syntacticPlaceholders === false)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      M = L.name.name, O.isLegacyRef.value = false;
    } else {
      if (O.isLegacyRef.value === false || O.syntacticPlaceholders)
        return;
      if (P(L) || x(L))
        M = L.name, O.isLegacyRef.value = true;
      else if (v(L))
        M = L.value, O.isLegacyRef.value = true;
      else
        return;
    }
    if (!O.isLegacyRef.value && (O.placeholderPattern != null || O.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (O.isLegacyRef.value && (O.placeholderPattern === false || !(O.placeholderPattern || I).test(M)) && !((B = O.placeholderWhitelist) != null && B.has(M)))
      return;
    R = R.slice();
    const {
      node: j,
      key: $
    } = R[R.length - 1];
    let k;
    v(L) || A(L, {
      expectedNode: "StringLiteral"
    }) ? k = "string" : y(j) && $ === "arguments" || f2(j) && $ === "arguments" || g(j) && $ === "params" ? k = "param" : p(j) && !A(L) ? (k = "statement", R = R.slice(0, -1)) : S(L) && A(L) ? k = "statement" : k = "other";
    const {
      placeholders: ne,
      placeholderNames: Q
    } = O.isLegacyRef.value ? O.legacy : O.syntactic;
    ne.push({
      name: M,
      type: k,
      resolve: (q) => _(q, R),
      isDuplicate: Q.has(M)
    }), Q.add(M);
  }
  function _(L, R) {
    let O = L;
    for (let j = 0; j < R.length - 1; j++) {
      const {
        key: $,
        index: k
      } = R[j];
      k === void 0 ? O = O[$] : O = O[$][k];
    }
    const {
      key: B,
      index: M
    } = R[R.length - 1];
    return {
      parent: O,
      key: B,
      index: M
    };
  }
  function m(L, R, O) {
    const B = (R.plugins || []).slice();
    O !== false && B.push("placeholders"), R = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, R, {
      plugins: B
    });
    try {
      return (0, n.parse)(L, R);
    } catch (M) {
      const j = M.loc;
      throw j && (M.message += `
` + (0, h.codeFrameColumns)(L, {
        start: j
      }), M.code = "BABEL_TEMPLATE_PARSE_ERROR"), M;
    }
  }
  return sl;
}
var il = {};
var wd;
function e0() {
  if (wd)
    return il;
  wd = 1, Object.defineProperty(il, "__esModule", {
    value: true
  }), il.default = S;
  var s = Je();
  const {
    blockStatement: n,
    cloneNode: h,
    emptyStatement: f2,
    expressionStatement: p,
    identifier: g,
    isStatement: P,
    isStringLiteral: x,
    stringLiteral: y,
    validate: A
  } = s;
  function S(T, C) {
    const I = h(T.ast);
    return C && (T.placeholders.forEach((N) => {
      if (!Object.prototype.hasOwnProperty.call(C, N.name)) {
        const D = N.name;
        throw new Error(`Error: No substitution given for "${D}". If this is not meant to be a
	            placeholder you may want to consider passing one of the following options to @babel/template:
	            - { placeholderPattern: false, placeholderWhitelist: new Set(['${D}'])}
	            - { placeholderPattern: /^${D}$/ }`);
      }
    }), Object.keys(C).forEach((N) => {
      if (!T.placeholderNames.has(N))
        throw new Error(`Unknown substitution "${N}" given`);
    })), T.placeholders.slice().reverse().forEach((N) => {
      try {
        v(N, I, C && C[N.name] || null);
      } catch (D) {
        throw D.message = `@babel/template placeholder "${N.name}": ${D.message}`, D;
      }
    }), I;
  }
  function v(T, C, I) {
    T.isDuplicate && (Array.isArray(I) ? I = I.map((m) => h(m)) : typeof I == "object" && (I = h(I)));
    const {
      parent: N,
      key: D,
      index: _
    } = T.resolve(C);
    if (T.type === "string") {
      if (typeof I == "string" && (I = y(I)), !I || !x(I))
        throw new Error("Expected string substitution");
    } else if (T.type === "statement")
      _ === void 0 ? I ? Array.isArray(I) ? I = n(I) : typeof I == "string" ? I = p(g(I)) : P(I) || (I = p(I)) : I = f2() : I && !Array.isArray(I) && (typeof I == "string" && (I = g(I)), P(I) || (I = p(I)));
    else if (T.type === "param") {
      if (typeof I == "string" && (I = g(I)), _ === void 0)
        throw new Error("Assertion failure.");
    } else if (typeof I == "string" && (I = g(I)), Array.isArray(I))
      throw new Error("Cannot replace single expression with an array.");
    if (_ === void 0)
      A(N, D, I), N[D] = I;
    else {
      const m = N[D].slice();
      T.type === "statement" || T.type === "param" ? I == null ? m.splice(_, 1) : Array.isArray(I) ? m.splice(_, 1, ...I) : m[_] = I : m[_] = I, A(N, D, m), N[D] = m;
    }
  }
  return il;
}
var Id;
function HT() {
  if (Id)
    return rl;
  Id = 1, Object.defineProperty(rl, "__esModule", {
    value: true
  }), rl.default = f2;
  var s = ep(), n = Zy(), h = e0();
  function f2(p, g, P) {
    g = p.code(g);
    let x;
    return (y) => {
      const A = (0, s.normalizeReplacements)(y);
      return x || (x = (0, n.default)(p, g, P)), p.unwrap((0, h.default)(x, A));
    };
  }
  return rl;
}
var nl = {};
var Nd;
function zT() {
  if (Nd)
    return nl;
  Nd = 1, Object.defineProperty(nl, "__esModule", {
    value: true
  }), nl.default = f2;
  var s = ep(), n = Zy(), h = e0();
  function f2(P, x, y) {
    const {
      metadata: A,
      names: S
    } = p(P, x, y);
    return (v) => {
      const T = {};
      return v.forEach((C, I) => {
        T[S[I]] = C;
      }), (C) => {
        const I = (0, s.normalizeReplacements)(C);
        return I && Object.keys(I).forEach((N) => {
          if (Object.prototype.hasOwnProperty.call(T, N))
            throw new Error("Unexpected replacement overlap.");
        }), P.unwrap((0, h.default)(A, I ? Object.assign(I, T) : T));
      };
    };
  }
  function p(P, x, y) {
    let A, S, v, T = "";
    do {
      T += "$";
      const C = g(x, T);
      A = C.names, S = new Set(A), v = (0, n.default)(P, P.code(C.code), {
        parser: y.parser,
        placeholderWhitelist: new Set(C.names.concat(y.placeholderWhitelist ? Array.from(y.placeholderWhitelist) : [])),
        placeholderPattern: y.placeholderPattern,
        preserveComments: y.preserveComments,
        syntacticPlaceholders: y.syntacticPlaceholders
      });
    } while (v.placeholders.some((C) => C.isDuplicate && S.has(C.name)));
    return {
      metadata: v,
      names: A
    };
  }
  function g(P, x) {
    const y = [];
    let A = P[0];
    for (let S = 1; S < P.length; S++) {
      const v = `${x}${S - 1}`;
      y.push(v), A += v + P[S];
    }
    return {
      names: y,
      code: A
    };
  }
  return nl;
}
var kd;
function GT() {
  if (kd)
    return tl;
  kd = 1, Object.defineProperty(tl, "__esModule", {
    value: true
  }), tl.default = p;
  var s = ep(), n = HT(), h = zT();
  const f2 = (0, s.validate)({
    placeholderPattern: false
  });
  function p(P, x) {
    const y = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakMap(), S = x || (0, s.validate)(null);
    return Object.assign((v, ...T) => {
      if (typeof v == "string") {
        if (T.length > 1)
          throw new Error("Unexpected extra params.");
        return g((0, n.default)(P, v, (0, s.merge)(S, (0, s.validate)(T[0]))));
      } else if (Array.isArray(v)) {
        let C = y.get(v);
        return C || (C = (0, h.default)(P, v, S), y.set(v, C)), g(C(T));
      } else if (typeof v == "object" && v) {
        if (T.length > 0)
          throw new Error("Unexpected extra params.");
        return p(P, (0, s.merge)(S, (0, s.validate)(v)));
      }
      throw new Error(`Unexpected template param ${typeof v}`);
    }, {
      ast: (v, ...T) => {
        if (typeof v == "string") {
          if (T.length > 1)
            throw new Error("Unexpected extra params.");
          return (0, n.default)(P, v, (0, s.merge)((0, s.merge)(S, (0, s.validate)(T[0])), f2))();
        } else if (Array.isArray(v)) {
          let C = A.get(v);
          return C || (C = (0, h.default)(P, v, (0, s.merge)(S, f2)), A.set(v, C)), C(T)();
        }
        throw new Error(`Unexpected template param ${typeof v}`);
      }
    });
  }
  function g(P) {
    let x = "";
    try {
      throw new Error();
    } catch (y) {
      y.stack && (x = y.stack.split(`
`).slice(3).join(`
`));
    }
    return (y) => {
      try {
        return P(y);
      } catch (A) {
        throw A.stack += `
    =============
${x}`, A;
      }
    };
  }
  return tl;
}
var Od;
function Pn() {
  if (Od)
    return Dr;
  Od = 1, Object.defineProperty(Dr, "__esModule", {
    value: true
  }), Dr.statements = Dr.statement = Dr.smart = Dr.program = Dr.expression = Dr.default = void 0;
  var s = KT(), n = GT();
  const h = (0, n.default)(s.smart);
  Dr.smart = h;
  const f2 = (0, n.default)(s.statement);
  Dr.statement = f2;
  const p = (0, n.default)(s.statements);
  Dr.statements = p;
  const g = (0, n.default)(s.expression);
  Dr.expression = g;
  const P = (0, n.default)(s.program);
  Dr.program = P;
  var x = Object.assign(h.bind(void 0), {
    smart: h,
    statement: f2,
    statements: p,
    expression: g,
    program: P,
    ast: h.ast
  });
  return Dr.default = x, Dr;
}
Object.defineProperty(ja, "__esModule", {
  value: true
});
ja.default = m1;
var t0 = Pn();
var XT = Je();
var {
  NOT_LOCAL_BINDING: Dd,
  cloneNode: JT,
  identifier: YT,
  isAssignmentExpression: QT,
  isAssignmentPattern: ZT,
  isFunction: r0,
  isIdentifier: Ld,
  isLiteral: Md,
  isNullLiteral: e1,
  isObjectMethod: t1,
  isObjectProperty: r1,
  isRegExpLiteral: s1,
  isRestElement: i1,
  isTemplateLiteral: n1,
  isVariableDeclarator: a1,
  toBindingIdentifierName: o1
} = XT;
function l1(s) {
  const n = s.params.findIndex((h) => ZT(h) || i1(h));
  return n === -1 ? s.params.length : n;
}
var u1 = t0.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
var c1 = t0.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
var p1 = {
  "ReferencedIdentifier|BindingIdentifier"(s, n) {
    s.node.name !== n.name || s.scope.getBindingIdentifier(n.name) !== n.outerDeclar || (n.selfReference = true, s.stop());
  }
};
function f1(s) {
  return e1(s) ? "null" : s1(s) ? `_${s.pattern}_${s.flags}` : n1(s) ? s.quasis.map((n) => n.value.raw).join("") : s.value !== void 0 ? s.value + "" : "";
}
function h1(s, n, h, f2) {
  if (s.selfReference)
    if (f2.hasBinding(h.name) && !f2.hasGlobal(h.name))
      f2.rename(h.name);
    else {
      if (!r0(n))
        return;
      let p = u1;
      n.generator && (p = c1);
      const g = p({
        FUNCTION: n,
        FUNCTION_ID: h,
        FUNCTION_KEY: f2.generateUidIdentifier(h.name)
      }).expression, P = g.callee.body.body[0].params;
      for (let x = 0, y = l1(n); x < y; x++)
        P.push(f2.generateUidIdentifier("x"));
      return g;
    }
  n.id = h, f2.getProgramParent().references[h.name] = true;
}
function d1(s, n, h) {
  const f2 = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: h.getBindingIdentifier(n),
    name: n
  }, p = h.getOwnBinding(n);
  return p ? p.kind === "param" && (f2.selfReference = true) : (f2.outerDeclar || h.hasGlobal(n)) && h.traverse(s, p1, f2), f2;
}
function m1({
  node: s,
  parent: n,
  scope: h,
  id: f2
}, p = false, g = false) {
  if (s.id)
    return;
  if ((r1(n) || t1(n, {
    kind: "method"
  })) && (!n.computed || Md(n.key)))
    f2 = n.key;
  else if (a1(n)) {
    if (f2 = n.id, Ld(f2) && !p) {
      const A = h.parent.getBinding(f2.name);
      if (A && A.constant && h.getBinding(f2.name) === A) {
        s.id = JT(f2), s.id[Dd] = true;
        return;
      }
    }
  } else if (QT(n, {
    operator: "="
  }))
    f2 = n.left;
  else if (!f2)
    return;
  let P;
  if (f2 && Md(f2) ? P = f1(f2) : f2 && Ld(f2) && (P = f2.name), P === void 0 || !g && r0(s) && /[\uD800-\uDFFF]/.test(P))
    return;
  P = o1(P);
  const x = YT(P);
  x[Dd] = true;
  const y = d1(s, P, h);
  return h1(y, s, x, h) || s;
}
var Bd;
function y1() {
  if (Bd)
    return un;
  Bd = 1, Object.defineProperty(un, "__esModule", {
    value: true
  }), un.arrowFunctionToExpression = V, un.arrowFunctionToShadowed = K, un.ensureBlock = ee, un.toComputedKey = q, un.unwrapFunctionEnvironment = G;
  var s = Je(), n = $i, h = ja, f2 = Vy();
  const {
    arrowFunctionExpression: p,
    assignmentExpression: g,
    binaryExpression: P,
    blockStatement: x,
    callExpression: y,
    conditionalExpression: A,
    expressionStatement: S,
    identifier: v,
    isIdentifier: T,
    jsxIdentifier: C,
    logicalExpression: I,
    LOGICAL_OPERATORS: N,
    memberExpression: D,
    metaProperty: _,
    numericLiteral: m,
    objectExpression: L,
    restElement: R,
    returnStatement: O,
    sequenceExpression: B,
    spreadElement: M,
    stringLiteral: j,
    super: $,
    thisExpression: k,
    toExpression: ne,
    unaryExpression: Q
  } = s;
  function q() {
    let pe;
    if (this.isMemberExpression())
      pe = this.node.property;
    else if (this.isProperty() || this.isMethod())
      pe = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || T(pe) && (pe = j(pe.name)), pe;
  }
  function ee() {
    const pe = this.get("body"), z = pe.node;
    if (Array.isArray(pe))
      throw new Error("Can't convert array path to a block statement");
    if (!z)
      throw new Error("Can't convert node without a body");
    if (pe.isBlockStatement())
      return z;
    const W = [];
    let ae = "body", ce, xe;
    pe.isStatement() ? (xe = "body", ce = 0, W.push(pe.node)) : (ae += ".body.0", this.isFunction() ? (ce = "argument", W.push(O(pe.node))) : (ce = "expression", W.push(S(pe.node)))), this.node.body = x(W);
    const Se = this.get(ae);
    return pe.setup(Se, xe ? Se.node[xe] : Se.node, xe, ce), this.node;
  }
  function K() {
    !this.isArrowFunctionExpression() || this.arrowFunctionToExpression();
  }
  function G() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    le(this);
  }
  function V({
    allowInsertArrow: pe = true,
    specCompliant: z = false,
    noNewArrows: W = !z
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    const {
      thisBinding: ae,
      fnPath: ce
    } = le(this, W, pe);
    if (ce.ensureBlock(), ce.node.type = "FunctionExpression", !W) {
      const xe = ae ? null : ce.scope.generateUidIdentifier("arrowCheckId");
      xe && ce.parentPath.scope.push({
        id: xe,
        init: L([])
      }), ce.get("body").unshiftContainer("body", S(y(this.hub.addHelper("newArrowCheck"), [k(), v(xe ? xe.name : ae)]))), ce.replaceWith(y(D((0, h.default)(this, true) || ce.node, v("bind")), [xe ? v(xe.name) : k()]));
    }
  }
  const F = (0, f2.merge)([{
    CallExpression(pe, {
      allSuperCalls: z
    }) {
      !pe.get("callee").isSuper() || z.push(pe);
    }
  }, n.default]);
  function le(pe, z = true, W = true) {
    let ae, ce = pe.findParent((_e) => {
      if (_e.isArrowFunctionExpression()) {
        var Re;
        return (Re = ae) != null || (ae = _e), false;
      }
      return _e.isFunction() || _e.isProgram() || _e.isClassProperty({
        static: false
      }) || _e.isClassPrivateProperty({
        static: false
      });
    });
    const xe = ce.isClassMethod({
      kind: "constructor"
    });
    if (ce.isClassProperty() || ce.isClassPrivateProperty())
      if (ae)
        ce = ae;
      else if (W)
        pe.replaceWith(y(p([], ne(pe.node)), [])), ce = pe.get("callee"), pe = ce.get("body");
      else
        throw pe.buildCodeFrameError("Unable to transform arrow inside class property");
    const {
      thisPaths: Se,
      argumentsPaths: Le,
      newTargetPaths: Ee,
      superProps: J,
      superCalls: me
    } = Te(pe);
    if (xe && me.length > 0) {
      if (!W)
        throw me[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
      const _e = [];
      ce.traverse(F, {
        allSuperCalls: _e
      });
      const Re = we(ce);
      _e.forEach(($e) => {
        const Ge = v(Re);
        Ge.loc = $e.node.callee.loc, $e.get("callee").replaceWith(Ge);
      });
    }
    if (Le.length > 0) {
      const _e = te(ce, "arguments", () => {
        const Re = () => v("arguments");
        return ce.scope.path.isProgram() ? A(P("===", Q("typeof", Re()), j("undefined")), ce.scope.buildUndefinedNode(), Re()) : Re();
      });
      Le.forEach((Re) => {
        const $e = v(_e);
        $e.loc = Re.node.loc, Re.replaceWith($e);
      });
    }
    if (Ee.length > 0) {
      const _e = te(ce, "newtarget", () => _(v("new"), v("target")));
      Ee.forEach((Re) => {
        const $e = v(_e);
        $e.loc = Re.node.loc, Re.replaceWith($e);
      });
    }
    if (J.length > 0) {
      if (!W)
        throw J[0].buildCodeFrameError("Unable to handle nested super.prop usage");
      J.reduce((Re, $e) => Re.concat(fe($e)), []).forEach((Re) => {
        const $e = Re.node.computed ? "" : Re.get("property").node.name, Ge = Re.parentPath, lt = Ge.isAssignmentExpression({
          left: Re.node
        }), Ze = Ge.isCallExpression({
          callee: Re.node
        }), Xe = H(ce, lt, $e), et = [];
        if (Re.node.computed && et.push(Re.get("property").node), lt) {
          const re = Ge.node.right;
          et.push(re);
        }
        const st = y(v(Xe), et);
        Ze ? (Ge.unshiftContainer("arguments", k()), Re.replaceWith(D(st, v("call"))), Se.push(Ge.get("arguments.0"))) : lt ? Ge.replaceWith(st) : Re.replaceWith(st);
      });
    }
    let ke;
    return (Se.length > 0 || !z) && (ke = Pe(ce, xe), (z || xe && he(ce)) && (Se.forEach((_e) => {
      const Re = _e.isJSX() ? C(ke) : v(ke);
      Re.loc = _e.node.loc, _e.replaceWith(Re);
    }), z || (ke = null))), {
      thisBinding: ke,
      fnPath: pe
    };
  }
  function oe(pe) {
    return N.includes(pe);
  }
  function fe(pe) {
    if (pe.parentPath.isAssignmentExpression() && pe.parentPath.node.operator !== "=") {
      const W = pe.parentPath, ae = W.node.operator.slice(0, -1), ce = W.node.right, xe = oe(ae);
      if (pe.node.computed) {
        const Se = pe.scope.generateDeclaredUidIdentifier("tmp"), Le = pe.node.object, Ee = pe.node.property;
        W.get("left").replaceWith(D(Le, g("=", Se, Ee), true)), W.get("right").replaceWith(z(xe ? "=" : ae, D(Le, v(Se.name), true), ce));
      } else {
        const Se = pe.node.object, Le = pe.node.property;
        W.get("left").replaceWith(D(Se, Le)), W.get("right").replaceWith(z(xe ? "=" : ae, D(Se, v(Le.name)), ce));
      }
      return xe ? W.replaceWith(I(ae, W.node.left, W.node.right)) : W.node.operator = "=", [W.get("left"), W.get("right").get("left")];
    } else if (pe.parentPath.isUpdateExpression()) {
      const W = pe.parentPath, ae = pe.scope.generateDeclaredUidIdentifier("tmp"), ce = pe.node.computed ? pe.scope.generateDeclaredUidIdentifier("prop") : null, xe = [g("=", ae, D(pe.node.object, ce ? g("=", ce, pe.node.property) : pe.node.property, pe.node.computed)), g("=", D(pe.node.object, ce ? v(ce.name) : pe.node.property, pe.node.computed), P(pe.parentPath.node.operator[0], v(ae.name), m(1)))];
      pe.parentPath.node.prefix || xe.push(v(ae.name)), W.replaceWith(B(xe));
      const Se = W.get("expressions.0.right"), Le = W.get("expressions.1.left");
      return [Se, Le];
    }
    return [pe];
    function z(W, ae, ce) {
      return W === "=" ? g("=", ae, ce) : P(W, ae, ce);
    }
  }
  function he(pe) {
    return pe.isClassMethod() && !!pe.parentPath.parentPath.node.superClass;
  }
  const de = (0, f2.merge)([{
    CallExpression(pe, {
      supers: z,
      thisBinding: W
    }) {
      !pe.get("callee").isSuper() || z.has(pe.node) || (z.add(pe.node), pe.replaceWithMultiple([pe.node, g("=", v(W), v("this"))]));
    }
  }, n.default]);
  function Pe(pe, z) {
    return te(pe, "this", (W) => {
      if (!z || !he(pe))
        return k();
      pe.traverse(de, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: W
      });
    });
  }
  function we(pe) {
    return te(pe, "supercall", () => {
      const z = pe.scope.generateUidIdentifier("args");
      return p([R(z)], y($(), [M(v(z.name))]));
    });
  }
  function H(pe, z, W) {
    return te(pe, `superprop_${z ? "set" : "get"}:${W || ""}`, () => {
      const ce = [];
      let xe;
      if (W)
        xe = D($(), v(W));
      else {
        const Se = pe.scope.generateUidIdentifier("prop");
        ce.unshift(Se), xe = D($(), v(Se.name), true);
      }
      if (z) {
        const Se = pe.scope.generateUidIdentifier("value");
        ce.push(Se), xe = g("=", xe, v(Se.name));
      }
      return p(ce, xe);
    });
  }
  function te(pe, z, W) {
    const ae = "binding:" + z;
    let ce = pe.getData(ae);
    if (!ce) {
      const xe = pe.scope.generateUidIdentifier(z);
      ce = xe.name, pe.setData(ae, ce), pe.scope.push({
        id: xe,
        init: W(ce)
      });
    }
    return ce;
  }
  const Ie = (0, f2.merge)([{
    ThisExpression(pe, {
      thisPaths: z
    }) {
      z.push(pe);
    },
    JSXIdentifier(pe, {
      thisPaths: z
    }) {
      pe.node.name === "this" && (!pe.parentPath.isJSXMemberExpression({
        object: pe.node
      }) && !pe.parentPath.isJSXOpeningElement({
        name: pe.node
      }) || z.push(pe));
    },
    CallExpression(pe, {
      superCalls: z
    }) {
      pe.get("callee").isSuper() && z.push(pe);
    },
    MemberExpression(pe, {
      superProps: z
    }) {
      pe.get("object").isSuper() && z.push(pe);
    },
    Identifier(pe, {
      argumentsPaths: z
    }) {
      if (!pe.isReferencedIdentifier({
        name: "arguments"
      }))
        return;
      let W = pe.scope;
      do {
        if (W.hasOwnBinding("arguments")) {
          W.rename("arguments");
          return;
        }
        if (W.path.isFunction() && !W.path.isArrowFunctionExpression())
          break;
      } while (W = W.parent);
      z.push(pe);
    },
    MetaProperty(pe, {
      newTargetPaths: z
    }) {
      !pe.get("meta").isIdentifier({
        name: "new"
      }) || !pe.get("property").isIdentifier({
        name: "target"
      }) || z.push(pe);
    }
  }, n.default]);
  function Te(pe) {
    const z = [], W = [], ae = [], ce = [], xe = [];
    return pe.traverse(Ie, {
      thisPaths: z,
      argumentsPaths: W,
      newTargetPaths: ae,
      superProps: ce,
      superCalls: xe
    }), {
      thisPaths: z,
      argumentsPaths: W,
      newTargetPaths: ae,
      superProps: ce,
      superCalls: xe
    };
  }
  return un;
}
var Rt = {};
var _d;
function b1() {
  if (_d)
    return Rt;
  _d = 1, Object.defineProperty(Rt, "__esModule", {
    value: true
  }), Rt._guessExecutionStatusRelativeTo = ne, Rt._resolve = V, Rt.canHaveVariableDeclarationOrExpression = _, Rt.canSwapBetweenExpressionAndStatement = m, Rt.equals = N, Rt.getSource = B, Rt.has = v, Rt.is = void 0, Rt.isCompletionRecord = L, Rt.isConstantExpression = F, Rt.isInStrictMode = le, Rt.isNodeType = D, Rt.isStatementOrBlock = R, Rt.isStatic = T, Rt.isnt = I, Rt.matchesPattern = S, Rt.referencesImport = O, Rt.resolve = G, Rt.willIMaybeExecuteBefore = M;
  var s = Je();
  const {
    STATEMENT_OR_BLOCK_KEYS: n,
    VISITOR_KEYS: h,
    isBlockStatement: f2,
    isExpression: p,
    isIdentifier: g,
    isLiteral: P,
    isStringLiteral: x,
    isType: y,
    matchesPattern: A
  } = s;
  function S(oe, fe) {
    return A(this.node, oe, fe);
  }
  function v(oe) {
    const fe = this.node && this.node[oe];
    return fe && Array.isArray(fe) ? !!fe.length : !!fe;
  }
  function T() {
    return this.scope.isStatic(this.node);
  }
  const C = v;
  Rt.is = C;
  function I(oe) {
    return !this.has(oe);
  }
  function N(oe, fe) {
    return this.node[oe] === fe;
  }
  function D(oe) {
    return y(this.type, oe);
  }
  function _() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  function m(oe) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? false : this.isExpression() ? f2(oe) : this.isBlockStatement() ? p(oe) : false;
  }
  function L(oe) {
    let fe = this, he = true;
    do {
      const {
        type: de,
        container: Pe
      } = fe;
      if (!he && (fe.isFunction() || de === "StaticBlock"))
        return !!oe;
      if (he = false, Array.isArray(Pe) && fe.key !== Pe.length - 1)
        return false;
    } while ((fe = fe.parentPath) && !fe.isProgram() && !fe.isDoExpression());
    return true;
  }
  function R() {
    return this.parentPath.isLabeledStatement() || f2(this.container) ? false : n.includes(this.key);
  }
  function O(oe, fe) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === fe || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? x(this.node.property, {
        value: fe
      }) : this.node.property.name === fe)) {
        const we = this.get("object");
        return we.isReferencedIdentifier() && we.referencesImport(oe, "*");
      }
      return false;
    }
    const he = this.scope.getBinding(this.node.name);
    if (!he || he.kind !== "module")
      return false;
    const de = he.path, Pe = de.parentPath;
    if (!Pe.isImportDeclaration())
      return false;
    if (Pe.node.source.value === oe) {
      if (!fe)
        return true;
    } else
      return false;
    return !!(de.isImportDefaultSpecifier() && fe === "default" || de.isImportNamespaceSpecifier() && fe === "*" || de.isImportSpecifier() && g(de.node.imported, {
      name: fe
    }));
  }
  function B() {
    const oe = this.node;
    if (oe.end) {
      const fe = this.hub.getCode();
      if (fe)
        return fe.slice(oe.start, oe.end);
    }
    return "";
  }
  function M(oe) {
    return this._guessExecutionStatusRelativeTo(oe) !== "after";
  }
  function j(oe) {
    return (oe.scope.getFunctionParent() || oe.scope.getProgramParent()).path;
  }
  function $(oe, fe) {
    switch (oe) {
      case "LogicalExpression":
        return fe === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return fe === "consequent" || fe === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return fe === "body";
      case "ForStatement":
        return fe === "body" || fe === "update";
      case "SwitchStatement":
        return fe === "cases";
      case "TryStatement":
        return fe === "handler";
      case "AssignmentPattern":
        return fe === "right";
      case "OptionalMemberExpression":
        return fe === "property";
      case "OptionalCallExpression":
        return fe === "arguments";
      default:
        return false;
    }
  }
  function k(oe, fe) {
    for (let he = 0; he < fe; he++) {
      const de = oe[he];
      if ($(de.parent.type, de.parentKey))
        return true;
    }
    return false;
  }
  function ne(oe) {
    return Q(this, oe, /* @__PURE__ */ new Map());
  }
  function Q(oe, fe, he) {
    const de = {
      this: j(oe),
      target: j(fe)
    };
    if (de.target.node !== de.this.node)
      return K(oe, de.target, he);
    const Pe = {
      target: fe.getAncestry(),
      this: oe.getAncestry()
    };
    if (Pe.target.indexOf(oe) >= 0)
      return "after";
    if (Pe.this.indexOf(fe) >= 0)
      return "before";
    let we;
    const H = {
      target: 0,
      this: 0
    };
    for (; !we && H.this < Pe.this.length; ) {
      const pe = Pe.this[H.this];
      H.target = Pe.target.indexOf(pe), H.target >= 0 ? we = pe : H.this++;
    }
    if (!we)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (k(Pe.this, H.this - 1) || k(Pe.target, H.target - 1))
      return "unknown";
    const te = {
      this: Pe.this[H.this - 1],
      target: Pe.target[H.target - 1]
    };
    if (te.target.listKey && te.this.listKey && te.target.container === te.this.container)
      return te.target.key > te.this.key ? "before" : "after";
    const Ie = h[we.type], Te = {
      this: Ie.indexOf(te.this.parentKey),
      target: Ie.indexOf(te.target.parentKey)
    };
    return Te.target > Te.this ? "before" : "after";
  }
  const q = /* @__PURE__ */ new Set();
  function ee(oe, fe, he) {
    if (!fe.isFunctionDeclaration() || fe.parentPath.isExportDeclaration())
      return "unknown";
    const de = fe.scope.getBinding(fe.node.id.name);
    if (!de.references)
      return "before";
    const Pe = de.referencePaths;
    let we;
    for (const H of Pe)
      if (!H.find((Ie) => Ie.node === fe.node)) {
        if (H.key !== "callee" || !H.parentPath.isCallExpression())
          return "unknown";
        if (!q.has(H.node)) {
          q.add(H.node);
          try {
            const Ie = Q(oe, H, he);
            if (we && we !== Ie)
              return "unknown";
            we = Ie;
          } finally {
            q.delete(H.node);
          }
        }
      }
    return we;
  }
  function K(oe, fe, he) {
    let de = he.get(oe.node);
    if (!de)
      he.set(oe.node, de = /* @__PURE__ */ new Map());
    else if (de.has(fe.node))
      return de.get(fe.node);
    const Pe = ee(oe, fe, he);
    return de.set(fe.node, Pe), Pe;
  }
  function G(oe, fe) {
    return this._resolve(oe, fe) || this;
  }
  function V(oe, fe) {
    if (!(fe && fe.indexOf(this) >= 0))
      if (fe = fe || [], fe.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(oe, fe);
      } else if (this.isReferencedIdentifier()) {
        const he = this.scope.getBinding(this.node.name);
        if (!he || !he.constant || he.kind === "module")
          return;
        if (he.path !== this) {
          const de = he.path.resolve(oe, fe);
          return this.find((Pe) => Pe.node === de.node) ? void 0 : de;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(oe, fe);
        if (oe && this.isMemberExpression()) {
          const he = this.toComputedKey();
          if (!P(he))
            return;
          const de = he.value, Pe = this.get("object").resolve(oe, fe);
          if (Pe.isObjectExpression()) {
            const we = Pe.get("properties");
            for (const H of we) {
              if (!H.isProperty())
                continue;
              const te = H.get("key");
              let Ie = H.isnt("computed") && te.isIdentifier({
                name: de
              });
              if (Ie = Ie || te.isLiteral({
                value: de
              }), Ie)
                return H.get("value").resolve(oe, fe);
            }
          } else if (Pe.isArrayExpression() && !isNaN(+de)) {
            const H = Pe.get("elements")[de];
            if (H)
              return H.resolve(oe, fe);
          }
        }
      }
  }
  function F() {
    if (this.isIdentifier()) {
      const oe = this.scope.getBinding(this.node.name);
      return oe ? oe.constant : false;
    }
    return this.isLiteral() ? this.isRegExpLiteral() ? false : this.isTemplateLiteral() ? this.get("expressions").every((oe) => oe.isConstantExpression()) : true : this.isUnaryExpression() ? this.node.operator !== "void" ? false : this.get("argument").isConstantExpression() : this.isBinaryExpression() ? this.get("left").isConstantExpression() && this.get("right").isConstantExpression() : false;
  }
  function le() {
    return !!(this.isProgram() ? this : this.parentPath).find((he) => {
      if (he.isProgram({
        sourceType: "module"
      }) || he.isClass())
        return true;
      if (he.isArrowFunctionExpression() && !he.get("body").isBlockStatement())
        return false;
      let de;
      if (he.isFunction())
        de = he.node.body;
      else if (he.isProgram())
        de = he.node;
      else
        return false;
      for (const Pe of de.directives)
        if (Pe.value.value === "use strict")
          return true;
    });
  }
  return Rt;
}
var Mt = {};
var Fd;
function g1() {
  if (Fd)
    return Mt;
  Fd = 1, Object.defineProperty(Mt, "__esModule", {
    value: true
  }), Mt._call = f2, Mt._getQueueContexts = B, Mt._resyncKey = I, Mt._resyncList = N, Mt._resyncParent = C, Mt._resyncRemoved = D, Mt.call = h, Mt.isBlacklisted = Mt.isDenylisted = p, Mt.popContext = _, Mt.pushContext = m, Mt.requeue = O, Mt.resync = T, Mt.setContext = v, Mt.setKey = R, Mt.setScope = S, Mt.setup = L, Mt.skip = x, Mt.skipKey = y, Mt.stop = A, Mt.visit = P;
  var s = s0(), n = nn();
  function h(M) {
    const j = this.opts;
    return this.debug(M), this.node && this._call(j[M]) ? true : this.node ? this._call(j[this.node.type] && j[this.node.type][M]) : false;
  }
  function f2(M) {
    if (!M)
      return false;
    for (const j of M) {
      if (!j)
        continue;
      const $ = this.node;
      if (!$)
        return true;
      const k = j.call(this.state, this, this.state);
      if (k && typeof k == "object" && typeof k.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (k)
        throw new Error(`Unexpected return value from visitor method ${j}`);
      if (this.node !== $ || this._traverseFlags > 0)
        return true;
    }
    return false;
  }
  function p() {
    var M;
    const j = (M = this.opts.denylist) != null ? M : this.opts.blacklist;
    return j && j.indexOf(this.node.type) > -1;
  }
  function g(M, j) {
    M.context !== j && (M.context = j, M.state = j.state, M.opts = j.opts);
  }
  function P() {
    if (!this.node || this.isDenylisted() || this.opts.shouldSkip && this.opts.shouldSkip(this))
      return false;
    const M = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (g(this, M), this.debug("Recursing into..."), this.shouldStop = (0, s.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), g(this, M), this.call("exit"), this.shouldStop);
  }
  function x() {
    this.shouldSkip = true;
  }
  function y(M) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[M] = true;
  }
  function A() {
    this._traverseFlags |= n.SHOULD_SKIP | n.SHOULD_STOP;
  }
  function S() {
    if (this.opts && this.opts.noScope)
      return;
    let M = this.parentPath;
    (this.key === "key" || this.listKey === "decorators") && M.isMethod() && (M = M.parentPath);
    let j;
    for (; M && !j; ) {
      if (M.opts && M.opts.noScope)
        return;
      j = M.scope, M = M.parentPath;
    }
    this.scope = this.getScope(j), this.scope && this.scope.init();
  }
  function v(M) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, M && (this.context = M, this.state = M.state, this.opts = M.opts), this.setScope(), this;
  }
  function T() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  function C() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  function I() {
    if (!!this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let M = 0; M < this.container.length; M++)
          if (this.container[M] === this.node)
            return this.setKey(M);
      } else
        for (const M of Object.keys(this.container))
          if (this.container[M] === this.node)
            return this.setKey(M);
      this.key = null;
    }
  }
  function N() {
    if (!this.parent || !this.inList)
      return;
    const M = this.parent[this.listKey];
    this.container !== M && (this.container = M || null);
  }
  function D() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  function _() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  function m(M) {
    this.contexts.push(M), this.setContext(M);
  }
  function L(M, j, $, k) {
    this.listKey = $, this.container = j, this.parentPath = M || this.parentPath, this.setKey(k);
  }
  function R(M) {
    var j;
    this.key = M, this.node = this.container[this.key], this.type = (j = this.node) == null ? void 0 : j.type;
  }
  function O(M = this) {
    if (M.removed)
      return;
    const j = this.contexts;
    for (const $ of j)
      $.maybeQueue(M);
  }
  function B() {
    let M = this, j = this.contexts;
    for (; !j.length && (M = M.parentPath, !!M); )
      j = M.contexts;
    return j;
  }
  return Mt;
}
var Yi = {};
var ba = {};
var jd;
function T1() {
  if (jd)
    return ba;
  jd = 1, Object.defineProperty(ba, "__esModule", {
    value: true
  }), ba.hooks = void 0, nn();
  const s = [function(n, h) {
    if (n.key === "test" && (h.isWhile() || h.isSwitchCase()) || n.key === "declaration" && h.isExportDeclaration() || n.key === "body" && h.isLabeledStatement() || n.listKey === "declarations" && h.isVariableDeclaration() && h.node.declarations.length === 1 || n.key === "expression" && h.isExpressionStatement())
      return h.remove(), true;
  }, function(n, h) {
    if (h.isSequenceExpression() && h.node.expressions.length === 1)
      return h.replaceWith(h.node.expressions[0]), true;
  }, function(n, h) {
    if (h.isBinary())
      return n.key === "left" ? h.replaceWith(h.node.right) : h.replaceWith(h.node.left), true;
  }, function(n, h) {
    if (h.isIfStatement() && (n.key === "consequent" || n.key === "alternate") || n.key === "body" && (h.isLoop() || h.isArrowFunctionExpression()))
      return n.replaceWith({
        type: "BlockStatement",
        body: []
      }), true;
  }];
  return ba.hooks = s, ba;
}
var Rd;
function x1() {
  if (Rd)
    return Yi;
  Rd = 1, Object.defineProperty(Yi, "__esModule", {
    value: true
  }), Yi._assertUnremoved = y, Yi._callRemovalHooks = g, Yi._markRemoved = x, Yi._remove = P, Yi._removeFromScope = p, Yi.remove = f2;
  var s = T1(), n = Wn(), h = nn();
  function f2() {
    var A;
    if (this._assertUnremoved(), this.resync(), (A = this.opts) != null && A.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  function p() {
    const A = this.getBindingIdentifiers();
    Object.keys(A).forEach((S) => this.scope.removeBinding(S));
  }
  function g() {
    for (const A of s.hooks)
      if (A(this, this.parentPath))
        return true;
  }
  function P() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  function x() {
    this._traverseFlags |= h.SHOULD_SKIP | h.REMOVED, this.parent && n.path.get(this.parent).delete(this.node), this.node = null;
  }
  function y() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  return Yi;
}
var ms = {};
var ga = {};
var Ud;
function P1() {
  if (Ud)
    return ga;
  Ud = 1, Object.defineProperty(ga, "__esModule", {
    value: true
  }), ga.default = void 0;
  var s = Je(), n = s;
  const {
    react: h
  } = s, {
    cloneNode: f2,
    jsxExpressionContainer: p,
    variableDeclaration: g,
    variableDeclarator: P
  } = n, x = {
    ReferencedIdentifier(A, S) {
      if (A.isJSXIdentifier() && h.isCompatTag(A.node.name) && !A.parentPath.isJSXMemberExpression())
        return;
      if (A.node.name === "this") {
        let T = A.scope;
        do
          if (T.path.isFunction() && !T.path.isArrowFunctionExpression())
            break;
        while (T = T.parent);
        T && S.breakOnScopePaths.push(T.path);
      }
      const v = A.scope.getBinding(A.node.name);
      if (!!v) {
        for (const T of v.constantViolations)
          if (T.scope !== v.path.scope) {
            S.mutableBinding = true, A.stop();
            return;
          }
        v === S.scope.getBinding(A.node.name) && (S.bindings[A.node.name] = v);
      }
    }
  };
  class y {
    constructor(S, v) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = v, this.path = S, this.attachAfter = false;
    }
    isCompatibleScope(S) {
      for (const v of Object.keys(this.bindings)) {
        const T = this.bindings[v];
        if (!S.bindingIdentifierEquals(v, T.identifier))
          return false;
      }
      return true;
    }
    getCompatibleScopes() {
      let S = this.path.scope;
      do {
        if (this.isCompatibleScope(S))
          this.scopes.push(S);
        else
          break;
        if (this.breakOnScopePaths.indexOf(S.path) >= 0)
          break;
      } while (S = S.parent);
    }
    getAttachmentPath() {
      let S = this._getAttachmentPath();
      if (!S)
        return;
      let v = S.scope;
      if (v.path === S && (v = S.scope.parent), v.path.isProgram() || v.path.isFunction())
        for (const T of Object.keys(this.bindings)) {
          if (!v.hasOwnBinding(T))
            continue;
          const C = this.bindings[T];
          if (C.kind === "param" || C.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(C.path).key >= S.key) {
            this.attachAfter = true, S = C.path;
            for (const N of C.constantViolations)
              this.getAttachmentParentForPath(N).key > S.key && (S = N);
          }
        }
      return S;
    }
    _getAttachmentPath() {
      const v = this.scopes.pop();
      if (!!v) {
        if (v.path.isFunction())
          if (this.hasOwnParamBindings(v)) {
            if (this.scope === v)
              return;
            const T = v.path.get("body").get("body");
            for (let C = 0; C < T.length; C++)
              if (!T[C].node._blockHoist)
                return T[C];
          } else
            return this.getNextScopeAttachmentParent();
        else if (v.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const S = this.scopes.pop();
      if (S)
        return this.getAttachmentParentForPath(S.path);
    }
    getAttachmentParentForPath(S) {
      do
        if (!S.parentPath || Array.isArray(S.container) && S.isStatement())
          return S;
      while (S = S.parentPath);
    }
    hasOwnParamBindings(S) {
      for (const v of Object.keys(this.bindings)) {
        if (!S.hasOwnBinding(v))
          continue;
        const T = this.bindings[v];
        if (T.kind === "param" && T.constant)
          return true;
      }
      return false;
    }
    run() {
      if (this.path.traverse(x, this), this.mutableBinding)
        return;
      this.getCompatibleScopes();
      const S = this.getAttachmentPath();
      if (!S || S.getFunctionParent() === this.path.getFunctionParent())
        return;
      let v = S.scope.generateUidIdentifier("ref");
      const T = P(v, this.path.node), C = this.attachAfter ? "insertAfter" : "insertBefore", [I] = S[C]([S.isVariableDeclarator() ? T : g("var", [T])]), N = this.path.parentPath;
      return N.isJSXElement() && this.path.container === N.node.children && (v = p(v)), this.path.replaceWith(f2(v)), S.isVariableDeclarator() ? I.get("init") : I.get("declarations.0.init");
    }
  }
  return ga.default = y, ga;
}
var $d;
function S1() {
  if ($d)
    return ms;
  $d = 1, Object.defineProperty(ms, "__esModule", {
    value: true
  }), ms._containerInsert = L, ms._containerInsertAfter = O, ms._containerInsertBefore = R, ms._verifyNodeList = ne, ms.hoist = ee, ms.insertAfter = $, ms.insertBefore = m, ms.pushContainer = q, ms.unshiftContainer = Q, ms.updateSiblingKeys = k;
  var s = Wn(), n = P1(), h = nn(), f2 = Je();
  const {
    arrowFunctionExpression: p,
    assertExpression: g,
    assignmentExpression: P,
    blockStatement: x,
    callExpression: y,
    cloneNode: A,
    expressionStatement: S,
    isAssignmentExpression: v,
    isCallExpression: T,
    isExpression: C,
    isIdentifier: I,
    isSequenceExpression: N,
    isSuper: D,
    thisExpression: _
  } = f2;
  function m(K) {
    this._assertUnremoved();
    const G = this._verifyNodeList(K), {
      parentPath: V
    } = this;
    if (V.isExpressionStatement() || V.isLabeledStatement() || V.isExportNamedDeclaration() || V.isExportDefaultDeclaration() && this.isDeclaration())
      return V.insertBefore(G);
    if (this.isNodeType("Expression") && !this.isJSXElement() || V.isForStatement() && this.key === "init")
      return this.node && G.push(this.node), this.replaceExpressionWithStatements(G);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(G);
    if (this.isStatementOrBlock()) {
      const F = this.node, le = F && (!this.isExpressionStatement() || F.expression != null);
      return this.replaceWith(x(le ? [F] : [])), this.unshiftContainer("body", G);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  function L(K, G) {
    this.updateSiblingKeys(K, G.length);
    const V = [];
    this.container.splice(K, 0, ...G);
    for (let le = 0; le < G.length; le++) {
      const oe = K + le, fe = this.getSibling(oe);
      V.push(fe), this.context && this.context.queue && fe.pushContext(this.context);
    }
    const F = this._getQueueContexts();
    for (const le of V) {
      le.setScope(), le.debug("Inserted.");
      for (const oe of F)
        oe.maybeQueue(le, true);
    }
    return V;
  }
  function R(K) {
    return this._containerInsert(this.key, K);
  }
  function O(K) {
    return this._containerInsert(this.key + 1, K);
  }
  const B = (K) => K[K.length - 1];
  function M(K) {
    return N(K.parent) && (B(K.parent.expressions) !== K.node || M(K.parentPath));
  }
  function j(K, G) {
    if (!v(K) || !I(K.left))
      return false;
    const V = G.getBlockParent();
    return V.hasOwnBinding(K.left.name) && V.getOwnBinding(K.left.name).constantViolations.length <= 1;
  }
  function $(K) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return B(this.get("expressions")).insertAfter(K);
    const G = this._verifyNodeList(K), {
      parentPath: V
    } = this;
    if (V.isExpressionStatement() || V.isLabeledStatement() || V.isExportNamedDeclaration() || V.isExportDefaultDeclaration() && this.isDeclaration())
      return V.insertAfter(G.map((F) => C(F) ? S(F) : F));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !V.isJSXElement() || V.isForStatement() && this.key === "init") {
      if (this.node) {
        const F = this.node;
        let {
          scope: le
        } = this;
        if (le.path.isPattern())
          return g(F), this.replaceWith(y(p([], F), [])), this.get("callee.body").insertAfter(G), [this];
        if (M(this))
          G.unshift(F);
        else if (T(F) && D(F.callee))
          G.unshift(F), G.push(_());
        else if (j(F, le))
          G.unshift(F), G.push(A(F.left));
        else if (le.isPure(F, true))
          G.push(F);
        else {
          V.isMethod({
            computed: true,
            key: F
          }) && (le = le.parent);
          const oe = le.generateDeclaredUidIdentifier();
          G.unshift(S(P("=", A(oe), F))), G.push(S(A(oe)));
        }
      }
      return this.replaceExpressionWithStatements(G);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(G);
      if (this.isStatementOrBlock()) {
        const F = this.node, le = F && (!this.isExpressionStatement() || F.expression != null);
        return this.replaceWith(x(le ? [F] : [])), this.pushContainer("body", G);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function k(K, G) {
    if (!this.parent)
      return;
    const V = s.path.get(this.parent);
    for (const [, F] of V)
      F.key >= K && (F.key += G);
  }
  function ne(K) {
    if (!K)
      return [];
    Array.isArray(K) || (K = [K]);
    for (let G = 0; G < K.length; G++) {
      const V = K[G];
      let F;
      if (V ? typeof V != "object" ? F = "contains a non-object node" : V.type ? V instanceof h.default && (F = "has a NodePath when it expected a raw object") : F = "without a type" : F = "has falsy node", F) {
        const le = Array.isArray(V) ? "array" : typeof V;
        throw new Error(`Node list ${F} with the index of ${G} and type of ${le}`);
      }
    }
    return K;
  }
  function Q(K, G) {
    return this._assertUnremoved(), G = this._verifyNodeList(G), h.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[K],
      listKey: K,
      key: 0
    }).setContext(this.context)._containerInsertBefore(G);
  }
  function q(K, G) {
    this._assertUnremoved();
    const V = this._verifyNodeList(G), F = this.node[K];
    return h.default.get({
      parentPath: this,
      parent: this.node,
      container: F,
      listKey: K,
      key: F.length
    }).setContext(this.context).replaceWithMultiple(V);
  }
  function ee(K = this.scope) {
    return new n.default(this, K).run();
  }
  return ms;
}
var wr = {};
var qd;
function E1() {
  if (qd)
    return wr;
  qd = 1, Object.defineProperty(wr, "__esModule", {
    value: true
  }), wr._getKey = $, wr._getPattern = k, wr.get = j, wr.getAllNextSiblings = B, wr.getAllPrevSiblings = M, wr.getBindingIdentifierPaths = q, wr.getBindingIdentifiers = ne, wr.getCompletionRecords = m, wr.getNextSibling = O, wr.getOpposite = v, wr.getOuterBindingIdentifierPaths = ee, wr.getOuterBindingIdentifiers = Q, wr.getPrevSibling = R, wr.getSibling = L;
  var s = nn(), n = Je();
  const {
    getBindingIdentifiers: h,
    getOuterBindingIdentifiers: f2,
    isDeclaration: p,
    numericLiteral: g,
    unaryExpression: P
  } = n, x = 0, y = 1;
  function A(K) {
    return {
      type: x,
      path: K
    };
  }
  function S(K) {
    return {
      type: y,
      path: K
    };
  }
  function v() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  function T(K, G, V) {
    return K && G.push(..._(K, V)), G;
  }
  function C(K, G, V) {
    let F = [];
    for (let le = 0; le < K.length; le++) {
      const oe = K[le], fe = _(oe, V), he = [], de = [];
      for (const Pe of fe)
        Pe.type === x && he.push(Pe), Pe.type === y && de.push(Pe);
      he.length && (F = he), G.push(...de);
    }
    return G.push(...F), G;
  }
  function I(K) {
    K.forEach((G) => {
      G.type = y;
    });
  }
  function N(K, G) {
    K.forEach((V) => {
      V.path.isBreakStatement({
        label: null
      }) && (G ? V.path.replaceWith(P("void", g(0))) : V.path.remove());
    });
  }
  function D(K, G) {
    const V = [];
    if (G.canHaveBreak) {
      let F = [];
      for (let le = 0; le < K.length; le++) {
        const oe = K[le], fe = Object.assign({}, G, {
          inCaseClause: false
        });
        oe.isBlockStatement() && (G.inCaseClause || G.shouldPopulateBreak) ? fe.shouldPopulateBreak = true : fe.shouldPopulateBreak = false;
        const he = _(oe, fe);
        if (he.length > 0 && he.every((de) => de.type === y)) {
          F.length > 0 && he.every((de) => de.path.isBreakStatement({
            label: null
          })) ? (I(F), V.push(...F), F.some((de) => de.path.isDeclaration()) && (V.push(...he), N(he, true)), N(he, false)) : (V.push(...he), G.shouldPopulateBreak || N(he, true));
          break;
        }
        if (le === K.length - 1)
          V.push(...he);
        else {
          F = [];
          for (let de = 0; de < he.length; de++) {
            const Pe = he[de];
            Pe.type === y && V.push(Pe), Pe.type === x && F.push(Pe);
          }
        }
      }
    } else if (K.length)
      for (let F = K.length - 1; F >= 0; F--) {
        const le = _(K[F], G);
        if (le.length > 1 || le.length === 1 && !le[0].path.isVariableDeclaration()) {
          V.push(...le);
          break;
        }
      }
    return V;
  }
  function _(K, G) {
    let V = [];
    if (K.isIfStatement())
      V = T(K.get("consequent"), V, G), V = T(K.get("alternate"), V, G);
    else {
      if (K.isDoExpression() || K.isFor() || K.isWhile() || K.isLabeledStatement())
        return T(K.get("body"), V, G);
      if (K.isProgram() || K.isBlockStatement())
        return D(K.get("body"), G);
      if (K.isFunction())
        return _(K.get("body"), G);
      if (K.isTryStatement())
        V = T(K.get("block"), V, G), V = T(K.get("handler"), V, G);
      else {
        if (K.isCatchClause())
          return T(K.get("body"), V, G);
        if (K.isSwitchStatement())
          return C(K.get("cases"), V, G);
        if (K.isSwitchCase())
          return D(K.get("consequent"), {
            canHaveBreak: true,
            shouldPopulateBreak: false,
            inCaseClause: true
          });
        K.isBreakStatement() ? V.push(S(K)) : V.push(A(K));
      }
    }
    return V;
  }
  function m() {
    return _(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false
    }).map((G) => G.path);
  }
  function L(K) {
    return s.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: K
    }).setContext(this.context);
  }
  function R() {
    return this.getSibling(this.key - 1);
  }
  function O() {
    return this.getSibling(this.key + 1);
  }
  function B() {
    let K = this.key, G = this.getSibling(++K);
    const V = [];
    for (; G.node; )
      V.push(G), G = this.getSibling(++K);
    return V;
  }
  function M() {
    let K = this.key, G = this.getSibling(--K);
    const V = [];
    for (; G.node; )
      V.push(G), G = this.getSibling(--K);
    return V;
  }
  function j(K, G = true) {
    G === true && (G = this.context);
    const V = K.split(".");
    return V.length === 1 ? this._getKey(K, G) : this._getPattern(V, G);
  }
  function $(K, G) {
    const V = this.node, F = V[K];
    return Array.isArray(F) ? F.map((le, oe) => s.default.get({
      listKey: K,
      parentPath: this,
      parent: V,
      container: F,
      key: oe
    }).setContext(G)) : s.default.get({
      parentPath: this,
      parent: V,
      container: V,
      key: K
    }).setContext(G);
  }
  function k(K, G) {
    let V = this;
    for (const F of K)
      F === "." ? V = V.parentPath : Array.isArray(V) ? V = V[F] : V = V.get(F, G);
    return V;
  }
  function ne(K) {
    return h(this.node, K);
  }
  function Q(K) {
    return f2(this.node, K);
  }
  function q(K = false, G = false) {
    const F = [this], le = /* @__PURE__ */ Object.create(null);
    for (; F.length; ) {
      const oe = F.shift();
      if (!oe || !oe.node)
        continue;
      const fe = h.keys[oe.node.type];
      if (oe.isIdentifier()) {
        K ? (le[oe.node.name] = le[oe.node.name] || []).push(oe) : le[oe.node.name] = oe;
        continue;
      }
      if (oe.isExportDeclaration()) {
        const he = oe.get("declaration");
        p(he) && F.push(he);
        continue;
      }
      if (G) {
        if (oe.isFunctionDeclaration()) {
          F.push(oe.get("id"));
          continue;
        }
        if (oe.isFunctionExpression())
          continue;
      }
      if (fe)
        for (let he = 0; he < fe.length; he++) {
          const de = fe[he], Pe = oe.get(de);
          Array.isArray(Pe) ? F.push(...Pe) : Pe.node && F.push(Pe);
        }
    }
    return le;
  }
  function ee(K) {
    return this.getBindingIdentifierPaths(K, true);
  }
  return wr;
}
var Ln = {};
var Vd;
function v1() {
  if (Vd)
    return Ln;
  Vd = 1, Object.defineProperty(Ln, "__esModule", {
    value: true
  }), Ln.addComment = p, Ln.addComments = g, Ln.shareCommentsWithSiblings = f2;
  var s = Je();
  const {
    addComment: n,
    addComments: h
  } = s;
  function f2() {
    if (typeof this.key == "string")
      return;
    const P = this.node;
    if (!P)
      return;
    const x = P.trailingComments, y = P.leadingComments;
    if (!x && !y)
      return;
    const A = this.getSibling(this.key - 1), S = this.getSibling(this.key + 1), v = Boolean(A.node), T = Boolean(S.node);
    v && !T ? A.addComments("trailing", x) : T && !v && S.addComments("leading", y);
  }
  function p(P, x, y) {
    n(this.node, P, x, y);
  }
  function g(P, x) {
    h(this.node, P, x);
  }
  return Ln;
}
var Kd;
function nn() {
  if (Kd)
    return Ri;
  Kd = 1, Object.defineProperty(Ri, "__esModule", {
    value: true
  }), Ri.default = Ri.SHOULD_STOP = Ri.SHOULD_SKIP = Ri.REMOVED = void 0;
  var s = qy(), n = Yc(), h = qi(), f2 = Wy(), p = Je(), g = p, P = Wn(), x = Zc(), y = CT(), A = NT(), S = qT(), v = VT(), T = y1(), C = b1(), I = g1(), N = x1(), D = S1(), _ = E1(), m = v1();
  const {
    validate: L
  } = p, R = n("babel"), O = 1 << 0;
  Ri.REMOVED = O;
  const B = 1 << 1;
  Ri.SHOULD_STOP = B;
  const M = 1 << 2;
  Ri.SHOULD_SKIP = M;
  class j {
    constructor(ne, Q) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = Q, this.hub = ne, this.data = null, this.context = null, this.scope = null;
    }
    static get({
      hub: ne,
      parentPath: Q,
      parent: q,
      container: ee,
      listKey: K,
      key: G
    }) {
      if (!ne && Q && (ne = Q.hub), !q)
        throw new Error("To get a node path the parent needs to exist");
      const V = ee[G];
      let F = P.path.get(q);
      F || (F = /* @__PURE__ */ new Map(), P.path.set(q, F));
      let le = F.get(V);
      return le || (le = new j(ne, q), V && F.set(V, le)), le.setup(Q, ee, K, G), le;
    }
    getScope(ne) {
      return this.isScope() ? new f2.default(this) : ne;
    }
    setData(ne, Q) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[ne] = Q;
    }
    getData(ne, Q) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let q = this.data[ne];
      return q === void 0 && Q !== void 0 && (q = this.data[ne] = Q), q;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(ne, Q = SyntaxError) {
      return this.hub.buildError(this.node, ne, Q);
    }
    traverse(ne, Q) {
      (0, h.default)(this.node, ne, this.scope, Q, this);
    }
    set(ne, Q) {
      L(this.node, ne, Q), this.node[ne] = Q;
    }
    getPathLocation() {
      const ne = [];
      let Q = this;
      do {
        let q = Q.key;
        Q.inList && (q = `${Q.listKey}[${q}]`), ne.unshift(q);
      } while (Q = Q.parentPath);
      return ne.join(".");
    }
    debug(ne) {
      !R.enabled || R(`${this.getPathLocation()} ${this.type}: ${ne}`);
    }
    toString() {
      return (0, x.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(ne) {
      ne || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & M);
    }
    set shouldSkip(ne) {
      ne ? this._traverseFlags |= M : this._traverseFlags &= ~M;
    }
    get shouldStop() {
      return !!(this._traverseFlags & B);
    }
    set shouldStop(ne) {
      ne ? this._traverseFlags |= B : this._traverseFlags &= ~B;
    }
    get removed() {
      return !!(this._traverseFlags & O);
    }
    set removed(ne) {
      ne ? this._traverseFlags |= O : this._traverseFlags &= ~O;
    }
  }
  Object.assign(j.prototype, y, A, S, v, T, C, I, N, D, _, m), j.prototype._guessExecutionStatusRelativeToDifferentFunctions = C._guessExecutionStatusRelativeTo;
  for (const k of g.TYPES) {
    const ne = `is${k}`, Q = g[ne];
    j.prototype[ne] = function(q) {
      return Q(this.node, q);
    }, j.prototype[`assert${k}`] = function(q) {
      if (!Q(this.node, q))
        throw new TypeError(`Expected node path of type ${k}`);
    };
  }
  for (const k of Object.keys(s)) {
    if (k[0] === "_")
      continue;
    g.TYPES.indexOf(k) < 0 && g.TYPES.push(k);
    const ne = s[k];
    j.prototype[`is${k}`] = function(Q) {
      return ne.checkPath(this, Q);
    };
  }
  var $ = j;
  return Ri.default = $, Ri;
}
var Wd;
function A1() {
  if (Wd)
    return aa;
  Wd = 1, Object.defineProperty(aa, "__esModule", {
    value: true
  }), aa.default = void 0;
  var s = nn(), n = Je();
  const {
    VISITOR_KEYS: h
  } = n;
  class f2 {
    constructor(g, P, x, y) {
      this.queue = null, this.priorityQueue = null, this.parentPath = y, this.scope = g, this.state = x, this.opts = P;
    }
    shouldVisit(g) {
      const P = this.opts;
      if (P.enter || P.exit || P[g.type])
        return true;
      const x = h[g.type];
      if (!(x != null && x.length))
        return false;
      for (const y of x)
        if (g[y])
          return true;
      return false;
    }
    create(g, P, x, y) {
      return s.default.get({
        parentPath: this.parentPath,
        parent: g,
        container: P,
        key: x,
        listKey: y
      });
    }
    maybeQueue(g, P) {
      this.queue && (P ? this.queue.push(g) : this.priorityQueue.push(g));
    }
    visitMultiple(g, P, x) {
      if (g.length === 0)
        return false;
      const y = [];
      for (let A = 0; A < g.length; A++) {
        const S = g[A];
        S && this.shouldVisit(S) && y.push(this.create(P, g, A, x));
      }
      return this.visitQueue(y);
    }
    visitSingle(g, P) {
      return this.shouldVisit(g[P]) ? this.visitQueue([this.create(g, g, P)]) : false;
    }
    visitQueue(g) {
      this.queue = g, this.priorityQueue = [];
      const P = /* @__PURE__ */ new WeakSet();
      let x = false;
      for (const y of g) {
        if (y.resync(), (y.contexts.length === 0 || y.contexts[y.contexts.length - 1] !== this) && y.pushContext(this), y.key === null)
          continue;
        const {
          node: A
        } = y;
        if (!P.has(A)) {
          if (A && P.add(A), y.visit()) {
            x = true;
            break;
          }
          if (this.priorityQueue.length && (x = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = g, x))
            break;
        }
      }
      for (const y of g)
        y.popContext();
      return this.queue = null, x;
    }
    visit(g, P) {
      const x = g[P];
      return x ? Array.isArray(x) ? this.visitMultiple(x, g, P) : this.visitSingle(g, P) : false;
    }
  }
  return aa.default = f2, aa;
}
var Hd;
function s0() {
  if (Hd)
    return Ho;
  Hd = 1, Object.defineProperty(Ho, "__esModule", {
    value: true
  }), Ho.traverseNode = f2;
  var s = A1(), n = Je();
  const {
    VISITOR_KEYS: h
  } = n;
  function f2(p, g, P, x, y, A) {
    const S = h[p.type];
    if (!S)
      return false;
    const v = new s.default(P, g, x, y);
    for (const T of S)
      if (!(A && A[T]) && v.visit(p, T))
        return true;
    return false;
  }
  return Ho;
}
var Ta = {};
var zd;
function C1() {
  if (zd)
    return Ta;
  zd = 1, Object.defineProperty(Ta, "__esModule", {
    value: true
  }), Ta.default = void 0;
  class s {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(h, f2, p = TypeError) {
      return new p(f2);
    }
  }
  return Ta.default = s, Ta;
}
var Gd;
function qi() {
  return Gd || (Gd = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "Hub", {
      enumerable: true,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(s, "NodePath", {
      enumerable: true,
      get: function() {
        return g.default;
      }
    }), Object.defineProperty(s, "Scope", {
      enumerable: true,
      get: function() {
        return P.default;
      }
    }), s.visitors = s.default = void 0;
    var n = Vy();
    s.visitors = n;
    var h = Je(), f2 = Wn(), p = s0(), g = nn(), P = Wy(), x = C1();
    const {
      VISITOR_KEYS: y,
      removeProperties: A,
      traverseFast: S
    } = h;
    function v(I, N = {}, D, _, m) {
      if (!!I) {
        if (!N.noScope && !D && I.type !== "Program" && I.type !== "File")
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${I.type} node without passing scope and parentPath.`);
        !y[I.type] || (n.explode(N), (0, p.traverseNode)(I, N, D, _, m));
      }
    }
    var T = v;
    s.default = T, v.visitors = n, v.verify = n.verify, v.explode = n.explode, v.cheap = function(I, N) {
      return S(I, N);
    }, v.node = function(I, N, D, _, m, L) {
      (0, p.traverseNode)(I, N, D, _, m, L);
    }, v.clearNode = function(I, N) {
      A(I, N), f2.path.delete(I);
    }, v.removeProperties = function(I, N) {
      return S(I, v.clearNode, N), I;
    };
    function C(I, N) {
      I.node.type === N.type && (N.has = true, I.stop());
    }
    v.hasType = function(I, N, D) {
      if (D != null && D.includes(I.type))
        return false;
      if (I.type === N)
        return true;
      const _ = {
        has: false,
        type: N
      };
      return v(I, {
        noScope: true,
        denylist: D,
        enter: C
      }, null, _), _.has;
    }, v.cache = f2;
  }(Mu)), Mu;
}
var xa = {};
var Pa = {};
var Xd;
function w1() {
  if (Xd)
    return Pa;
  Xd = 1, Object.defineProperty(Pa, "__esModule", {
    value: true
  }), Pa.default = void 0;
  var s = Pn();
  function n(f2, p) {
    return Object.freeze({
      minVersion: f2,
      ast: () => s.default.program.ast(p, {
        preserveComments: true
      })
    });
  }
  var h = Object.freeze({
    applyDecs: n("7.17.8", 'function createMetadataMethodsForProperty(metadataMap,kind,property,decoratorFinishedRef){return{getMetadata:function(key){assertNotFinished(decoratorFinishedRef,"getMetadata"),assertMetadataKey(key);var metadataForKey=metadataMap[key];if(void 0!==metadataForKey)if(1===kind){var pub=metadataForKey.public;if(void 0!==pub)return pub[property]}else if(2===kind){var priv=metadataForKey.private;if(void 0!==priv)return priv.get(property)}else if(Object.hasOwnProperty.call(metadataForKey,"constructor"))return metadataForKey.constructor},setMetadata:function(key,value){assertNotFinished(decoratorFinishedRef,"setMetadata"),assertMetadataKey(key);var metadataForKey=metadataMap[key];if(void 0===metadataForKey&&(metadataForKey=metadataMap[key]={}),1===kind){var pub=metadataForKey.public;void 0===pub&&(pub=metadataForKey.public={}),pub[property]=value}else if(2===kind){var priv=metadataForKey.priv;void 0===priv&&(priv=metadataForKey.private=new Map),priv.set(property,value)}else metadataForKey.constructor=value}}}function convertMetadataMapToFinal(obj,metadataMap){var parentMetadataMap=obj[Symbol.metadata||Symbol.for("Symbol.metadata")],metadataKeys=Object.getOwnPropertySymbols(metadataMap);if(0!==metadataKeys.length){for(var i=0;i<metadataKeys.length;i++){var key=metadataKeys[i],metaForKey=metadataMap[key],parentMetaForKey=parentMetadataMap?parentMetadataMap[key]:null,pub=metaForKey.public,parentPub=parentMetaForKey?parentMetaForKey.public:null;pub&&parentPub&&Object.setPrototypeOf(pub,parentPub);var priv=metaForKey.private;if(priv){var privArr=Array.from(priv.values()),parentPriv=parentMetaForKey?parentMetaForKey.private:null;parentPriv&&(privArr=privArr.concat(parentPriv)),metaForKey.private=privArr}parentMetaForKey&&Object.setPrototypeOf(metaForKey,parentMetaForKey)}parentMetadataMap&&Object.setPrototypeOf(metadataMap,parentMetadataMap),obj[Symbol.metadata||Symbol.for("Symbol.metadata")]=metadataMap}}function createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){assertNotFinished(decoratorFinishedRef,"addInitializer"),assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function memberDec(dec,name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var metadataKind,metadataName,ctx={kind:kindStr,name:isPrivate?"#"+name:name,isStatic:isStatic,isPrivate:isPrivate},decoratorFinishedRef={v:!1};if(0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers,decoratorFinishedRef)),isPrivate){metadataKind=2,metadataName=Symbol(name);var access={};0===kind?(access.get=desc.get,access.set=desc.set):2===kind?access.get=function(){return desc.value}:(1!==kind&&3!==kind||(access.get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(access.set=function(v){desc.set.call(this,v)})),ctx.access=access}else metadataKind=1,metadataName=name;try{return dec(value,Object.assign(ctx,createMetadataMethodsForProperty(metadataMap,metadataKind,metadataName,decoratorFinishedRef)))}finally{decoratorFinishedRef.v=!0}}function assertNotFinished(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}function assertMetadataKey(key){if("symbol"!=typeof key)throw new TypeError("Metadata keys must be symbols, received: "+key)}function assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&assertCallable(value.get,"accessor.get"),void 0!==value.set&&assertCallable(value.set,"accessor.set"),void 0!==value.init&&assertCallable(value.init,"accessor.init"),void 0!==value.initializer&&assertCallable(value.initializer,"accessor.initializer")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function getInit(desc){var initializer;return null==(initializer=desc.init)&&(initializer=desc.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),initializer}function applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers){var desc,initializer,value,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=memberDec(decs,name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value))&&(assertValidReturnValue(kind,newValue),0===kind?initializer=newValue:1===kind?(initializer=getInit(newValue),get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=memberDec(decs[i],name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=getInit(newValue),get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===initializer?initializer=newInit:"function"==typeof initializer?initializer=[initializer,newInit]:initializer.push(newInit))}if(0===kind||1===kind){if(void 0===initializer)initializer=function(instance,init){return init};else if("function"!=typeof initializer){var ownInitializers=initializer;initializer=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=initializer;initializer=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(initializer)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function applyMemberDecs(ret,Class,protoMetadataMap,staticMetadataMap,decInfos){for(var protoInitializers,staticInitializers,existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,metadataMap,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,metadataMap=staticMetadataMap,0!==(kind-=5)&&(initializers=staticInitializers=staticInitializers||[])):(base=Class.prototype,metadataMap=protoMetadataMap,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers)}}pushInitializers(ret,protoInitializers),pushInitializers(ret,staticInitializers)}function pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}function applyClassDecs(ret,targetClass,metadataMap,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var ctx=Object.assign({kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers,decoratorFinishedRef)},createMetadataMethodsForProperty(metadataMap,0,name,decoratorFinishedRef)),nextNewClass=classDecs[i](newClass,ctx)}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}ret.push(newClass,(function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}))}}export default function applyDecs(targetClass,memberDecs,classDecs){var ret=[],staticMetadataMap={},protoMetadataMap={};return applyMemberDecs(ret,targetClass,protoMetadataMap,staticMetadataMap,memberDecs),convertMetadataMapToFinal(targetClass.prototype,protoMetadataMap),applyClassDecs(ret,targetClass,staticMetadataMap,classDecs),convertMetadataMapToFinal(targetClass,staticMetadataMap),ret}'),
    asyncIterator: n("7.15.9", 'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'),
    jsx: n("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'),
    objectSpread2: n("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'),
    regeneratorRuntime: n("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return generator._invoke=function(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}(innerFn,self,context),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==typeof value&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;this._invoke=function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}}function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(undefined===method){if(context.delegate=null,"throw"===context.method){if(delegate.iterator.return&&(context.method="return",context.arg=undefined,maybeInvokeDelegate(delegate,context),"throw"===context.method))return ContinueSentinel;context.method="throw",context.arg=new TypeError("The iterator does not provide a 'throw' method")}return ContinueSentinel}var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=undefined),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=undefined,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:undefined,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(Gp,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(object){var keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=undefined,this.done=!1,this.delegate=null,this.method="next",this.arg=undefined,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=undefined)},stop:function(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=undefined),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=undefined),ContinueSentinel}},exports}`),
    typeof: n("7.0.0-beta.0", 'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'),
    wrapRegExp: n("7.2.6", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(re,groups){return new BabelRegExp(re,void 0,groups)};var _super=RegExp.prototype,_groups=new WeakMap;function BabelRegExp(re,flags,groups){var _this=new RegExp(re,flags);return _groups.set(_this,groups||_groups.get(re)),setPrototypeOf(_this,BabelRegExp.prototype)}function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce((function(groups,name){return groups[name]=result[g[name]],groups}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);return result&&(result.groups=buildGroups(result,this)),result},BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if("string"==typeof substitution){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\\$<([^>]+)>/g,(function(_,name){return"$"+groups[name]})))}if("function"==typeof substitution){var _this=this;return _super[Symbol.replace].call(this,str,(function(){var args=arguments;return"object"!=typeof args[args.length-1]&&(args=[].slice.call(args)).push(buildGroups(args,_this)),substitution.apply(this,args)}))}return _super[Symbol.replace].call(this,str,substitution)},_wrapRegExp.apply(this,arguments)}')
  });
  return Pa.default = h, Pa;
}
var Jd;
function I1() {
  if (Jd)
    return xa;
  Jd = 1, Object.defineProperty(xa, "__esModule", {
    value: true
  }), xa.default = void 0;
  var s = Pn(), n = w1();
  const h = Object.assign({
    __proto__: null
  }, n.default);
  var f2 = h;
  xa.default = f2;
  const p = (g) => (P) => ({
    minVersion: g,
    ast: () => s.default.program.ast(P)
  });
  return h.AwaitValue = p("7.0.0-beta.0")`
	  export default function _AwaitValue(value) {
	    this.wrapped = value;
	  }
	`, h.AsyncGenerator = p("7.0.0-beta.0")`
	  import AwaitValue from "AwaitValue";

	  export default function AsyncGenerator(gen) {
	    var front, back;

	    function send(key, arg) {
	      return new Promise(function (resolve, reject) {
	        var request = {
	          key: key,
	          arg: arg,
	          resolve: resolve,
	          reject: reject,
	          next: null,
	        };

	        if (back) {
	          back = back.next = request;
	        } else {
	          front = back = request;
	          resume(key, arg);
	        }
	      });
	    }

	    function resume(key, arg) {
	      try {
	        var result = gen[key](arg)
	        var value = result.value;
	        var wrappedAwait = value instanceof AwaitValue;

	        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
	          function (arg) {
	            if (wrappedAwait) {
	              resume(key === "return" ? "return" : "next", arg);
	              return
	            }

	            settle(result.done ? "return" : "normal", arg);
	          },
	          function (err) { resume("throw", err); });
	      } catch (err) {
	        settle("throw", err);
	      }
	    }

	    function settle(type, value) {
	      switch (type) {
	        case "return":
	          front.resolve({ value: value, done: true });
	          break;
	        case "throw":
	          front.reject(value);
	          break;
	        default:
	          front.resolve({ value: value, done: false });
	          break;
	      }

	      front = front.next;
	      if (front) {
	        resume(front.key, front.arg);
	      } else {
	        back = null;
	      }
	    }

	    this._invoke = send;

	    // Hide "return" method if generator return is not supported
	    if (typeof gen.return !== "function") {
	      this.return = undefined;
	    }
	  }

	  AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

	  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };
	  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };
	  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
	`, h.wrapAsyncGenerator = p("7.0.0-beta.0")`
	  import AsyncGenerator from "AsyncGenerator";

	  export default function _wrapAsyncGenerator(fn) {
	    return function () {
	      return new AsyncGenerator(fn.apply(this, arguments));
	    };
	  }
	`, h.awaitAsyncGenerator = p("7.0.0-beta.0")`
	  import AwaitValue from "AwaitValue";

	  export default function _awaitAsyncGenerator(value) {
	    return new AwaitValue(value);
	  }
	`, h.asyncGeneratorDelegate = p("7.0.0-beta.0")`
	  export default function _asyncGeneratorDelegate(inner, awaitWrap) {
	    var iter = {}, waiting = false;

	    function pump(key, value) {
	      waiting = true;
	      value = new Promise(function (resolve) { resolve(inner[key](value)); });
	      return { done: false, value: awaitWrap(value) };
	    };

	    iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; };

	    iter.next = function (value) {
	      if (waiting) {
	        waiting = false;
	        return value;
	      }
	      return pump("next", value);
	    };

	    if (typeof inner.throw === "function") {
	      iter.throw = function (value) {
	        if (waiting) {
	          waiting = false;
	          throw value;
	        }
	        return pump("throw", value);
	      };
	    }

	    if (typeof inner.return === "function") {
	      iter.return = function (value) {
	        if (waiting) {
	          waiting = false;
	          return value;
	        }
	        return pump("return", value);
	      };
	    }

	    return iter;
	  }
	`, h.asyncToGenerator = p("7.0.0-beta.0")`
	  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	    try {
	      var info = gen[key](arg);
	      var value = info.value;
	    } catch (error) {
	      reject(error);
	      return;
	    }

	    if (info.done) {
	      resolve(value);
	    } else {
	      Promise.resolve(value).then(_next, _throw);
	    }
	  }

	  export default function _asyncToGenerator(fn) {
	    return function () {
	      var self = this, args = arguments;
	      return new Promise(function (resolve, reject) {
	        var gen = fn.apply(self, args);
	        function _next(value) {
	          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	        }
	        function _throw(err) {
	          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	        }

	        _next(undefined);
	      });
	    };
	  }
	`, h.classCallCheck = p("7.0.0-beta.0")`
	  export default function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }
	`, h.createClass = p("7.0.0-beta.0")`
	  function _defineProperties(target, props) {
	    for (var i = 0; i < props.length; i ++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  export default function _createClass(Constructor, protoProps, staticProps) {
	    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) _defineProperties(Constructor, staticProps);
	    Object.defineProperty(Constructor, "prototype", { writable: false });
	    return Constructor;
	  }
	`, h.defineEnumerableProperties = p("7.0.0-beta.0")`
	  export default function _defineEnumerableProperties(obj, descs) {
	    for (var key in descs) {
	      var desc = descs[key];
	      desc.configurable = desc.enumerable = true;
	      if ("value" in desc) desc.writable = true;
	      Object.defineProperty(obj, key, desc);
	    }

	    // Symbols are not enumerated over by for-in loops. If native
	    // Symbols are available, fetch all of the descs object's own
	    // symbol properties and define them on our target object too.
	    if (Object.getOwnPropertySymbols) {
	      var objectSymbols = Object.getOwnPropertySymbols(descs);
	      for (var i = 0; i < objectSymbols.length; i++) {
	        var sym = objectSymbols[i];
	        var desc = descs[sym];
	        desc.configurable = desc.enumerable = true;
	        if ("value" in desc) desc.writable = true;
	        Object.defineProperty(obj, sym, desc);
	      }
	    }
	    return obj;
	  }
	`, h.defaults = p("7.0.0-beta.0")`
	  export default function _defaults(obj, defaults) {
	    var keys = Object.getOwnPropertyNames(defaults);
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var value = Object.getOwnPropertyDescriptor(defaults, key);
	      if (value && value.configurable && obj[key] === undefined) {
	        Object.defineProperty(obj, key, value);
	      }
	    }
	    return obj;
	  }
	`, h.defineProperty = p("7.0.0-beta.0")`
	  export default function _defineProperty(obj, key, value) {
	    // Shortcircuit the slow defineProperty path when possible.
	    // We are trying to avoid issues where setters defined on the
	    // prototype cause side effects under the fast path of simple
	    // assignment. By checking for existence of the property with
	    // the in operator, we can optimize most of this overhead away.
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	`, h.extends = p("7.0.0-beta.0")`
	  export default function _extends() {
	    _extends = Object.assign ? Object.assign.bind() : function (target) {
	      for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];
	        for (var key in source) {
	          if (Object.prototype.hasOwnProperty.call(source, key)) {
	            target[key] = source[key];
	          }
	        }
	      }
	      return target;
	    };

	    return _extends.apply(this, arguments);
	  }
	`, h.objectSpread = p("7.0.0-beta.0")`
	  import defineProperty from "defineProperty";

	  export default function _objectSpread(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
	      var ownKeys = Object.keys(source);
	      if (typeof Object.getOwnPropertySymbols === 'function') {
	        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
	          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	        }));
	      }
	      ownKeys.forEach(function(key) {
	        defineProperty(target, key, source[key]);
	      });
	    }
	    return target;
	  }
	`, h.inherits = p("7.0.0-beta.0")`
	  import setPrototypeOf from "setPrototypeOf";

	  export default function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function");
	    }
	    // We can't use defineProperty to set the prototype in a single step because it
	    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
	    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        writable: true,
	        configurable: true
	      }
	    });
	    Object.defineProperty(subClass, "prototype", { writable: false });
	    if (superClass) setPrototypeOf(subClass, superClass);
	  }
	`, h.inheritsLoose = p("7.0.0-beta.0")`
	  import setPrototypeOf from "setPrototypeOf";

	  export default function _inheritsLoose(subClass, superClass) {
	    subClass.prototype = Object.create(superClass.prototype);
	    subClass.prototype.constructor = subClass;
	    setPrototypeOf(subClass, superClass);
	  }
	`, h.getPrototypeOf = p("7.0.0-beta.0")`
	  export default function _getPrototypeOf(o) {
	    _getPrototypeOf = Object.setPrototypeOf
	      ? Object.getPrototypeOf.bind()
	      : function _getPrototypeOf(o) {
	          return o.__proto__ || Object.getPrototypeOf(o);
	        };
	    return _getPrototypeOf(o);
	  }
	`, h.setPrototypeOf = p("7.0.0-beta.0")`
	  export default function _setPrototypeOf(o, p) {
	    _setPrototypeOf = Object.setPrototypeOf
	      ? Object.setPrototypeOf.bind()
	      : function _setPrototypeOf(o, p) {
	          o.__proto__ = p;
	          return o;
	        };
	    return _setPrototypeOf(o, p);
	  }
	`, h.isNativeReflectConstruct = p("7.9.0")`
	  export default function _isNativeReflectConstruct() {
	    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

	    // core-js@3
	    if (Reflect.construct.sham) return false;

	    // Proxy can't be polyfilled. Every browser implemented
	    // proxies before or at the same time as Reflect.construct,
	    // so if they support Proxy they also support Reflect.construct.
	    if (typeof Proxy === "function") return true;

	    // Since Reflect.construct can't be properly polyfilled, some
	    // implementations (e.g. core-js@2) don't set the correct internal slots.
	    // Those polyfills don't allow us to subclass built-ins, so we need to
	    // use our fallback implementation.
	    try {
	      // If the internal slots aren't set, this throws an error similar to
	      //   TypeError: this is not a Boolean object.

	      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	`, h.construct = p("7.0.0-beta.0")`
	  import setPrototypeOf from "setPrototypeOf";
	  import isNativeReflectConstruct from "isNativeReflectConstruct";

	  export default function _construct(Parent, args, Class) {
	    if (isNativeReflectConstruct()) {
	      _construct = Reflect.construct.bind();
	    } else {
	      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
	      //       calling the constructor.
	      _construct = function _construct(Parent, args, Class) {
	        var a = [null];
	        a.push.apply(a, args);
	        var Constructor = Function.bind.apply(Parent, a);
	        var instance = new Constructor();
	        if (Class) setPrototypeOf(instance, Class.prototype);
	        return instance;
	      };
	    }
	    // Avoid issues with Class being present but undefined when it wasn't
	    // present in the original call.
	    return _construct.apply(null, arguments);
	  }
	`, h.isNativeFunction = p("7.0.0-beta.0")`
	  export default function _isNativeFunction(fn) {
	    // Note: This function returns "true" for core-js functions.
	    return Function.toString.call(fn).indexOf("[native code]") !== -1;
	  }
	`, h.wrapNativeSuper = p("7.0.0-beta.0")`
	  import getPrototypeOf from "getPrototypeOf";
	  import setPrototypeOf from "setPrototypeOf";
	  import isNativeFunction from "isNativeFunction";
	  import construct from "construct";

	  export default function _wrapNativeSuper(Class) {
	    var _cache = typeof Map === "function" ? new Map() : undefined;

	    _wrapNativeSuper = function _wrapNativeSuper(Class) {
	      if (Class === null || !isNativeFunction(Class)) return Class;
	      if (typeof Class !== "function") {
	        throw new TypeError("Super expression must either be null or a function");
	      }
	      if (typeof _cache !== "undefined") {
	        if (_cache.has(Class)) return _cache.get(Class);
	        _cache.set(Class, Wrapper);
	      }
	      function Wrapper() {
	        return construct(Class, arguments, getPrototypeOf(this).constructor)
	      }
	      Wrapper.prototype = Object.create(Class.prototype, {
	        constructor: {
	          value: Wrapper,
	          enumerable: false,
	          writable: true,
	          configurable: true,
	        }
	      });

	      return setPrototypeOf(Wrapper, Class);
	    }

	    return _wrapNativeSuper(Class)
	  }
	`, h.instanceof = p("7.0.0-beta.0")`
	  export default function _instanceof(left, right) {
	    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
	      return !!right[Symbol.hasInstance](left);
	    } else {
	      return left instanceof right;
	    }
	  }
	`, h.interopRequireDefault = p("7.0.0-beta.0")`
	  export default function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	  }
	`, h.interopRequireWildcard = p("7.14.0")`
	  function _getRequireWildcardCache(nodeInterop) {
	    if (typeof WeakMap !== "function") return null;

	    var cacheBabelInterop = new WeakMap();
	    var cacheNodeInterop = new WeakMap();
	    return (_getRequireWildcardCache = function (nodeInterop) {
	      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
	    })(nodeInterop);
	  }

	  export default function _interopRequireWildcard(obj, nodeInterop) {
	    if (!nodeInterop && obj && obj.__esModule) {
	      return obj;
	    }

	    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
	      return { default: obj }
	    }

	    var cache = _getRequireWildcardCache(nodeInterop);
	    if (cache && cache.has(obj)) {
	      return cache.get(obj);
	    }

	    var newObj = {};
	    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	    for (var key in obj) {
	      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	        var desc = hasPropertyDescriptor
	          ? Object.getOwnPropertyDescriptor(obj, key)
	          : null;
	        if (desc && (desc.get || desc.set)) {
	          Object.defineProperty(newObj, key, desc);
	        } else {
	          newObj[key] = obj[key];
	        }
	      }
	    }
	    newObj.default = obj;
	    if (cache) {
	      cache.set(obj, newObj);
	    }
	    return newObj;
	  }
	`, h.newArrowCheck = p("7.0.0-beta.0")`
	  export default function _newArrowCheck(innerThis, boundThis) {
	    if (innerThis !== boundThis) {
	      throw new TypeError("Cannot instantiate an arrow function");
	    }
	  }
	`, h.objectDestructuringEmpty = p("7.0.0-beta.0")`
	  export default function _objectDestructuringEmpty(obj) {
	    if (obj == null) throw new TypeError("Cannot destructure undefined");
	  }
	`, h.objectWithoutPropertiesLoose = p("7.0.0-beta.0")`
	  export default function _objectWithoutPropertiesLoose(source, excluded) {
	    if (source == null) return {};

	    var target = {};
	    var sourceKeys = Object.keys(source);
	    var key, i;

	    for (i = 0; i < sourceKeys.length; i++) {
	      key = sourceKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      target[key] = source[key];
	    }

	    return target;
	  }
	`, h.objectWithoutProperties = p("7.0.0-beta.0")`
	  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

	  export default function _objectWithoutProperties(source, excluded) {
	    if (source == null) return {};

	    var target = objectWithoutPropertiesLoose(source, excluded);
	    var key, i;

	    if (Object.getOwnPropertySymbols) {
	      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
	      for (i = 0; i < sourceSymbolKeys.length; i++) {
	        key = sourceSymbolKeys[i];
	        if (excluded.indexOf(key) >= 0) continue;
	        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	        target[key] = source[key];
	      }
	    }

	    return target;
	  }
	`, h.assertThisInitialized = p("7.0.0-beta.0")`
	  export default function _assertThisInitialized(self) {
	    if (self === void 0) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }
	    return self;
	  }
	`, h.possibleConstructorReturn = p("7.0.0-beta.0")`
	  import assertThisInitialized from "assertThisInitialized";

	  export default function _possibleConstructorReturn(self, call) {
	    if (call && (typeof call === "object" || typeof call === "function")) {
	      return call;
	    } else if (call !== void 0) {
	      throw new TypeError("Derived constructors may only return object or undefined");
	    }

	    return assertThisInitialized(self);
	  }
	`, h.createSuper = p("7.9.0")`
	  import getPrototypeOf from "getPrototypeOf";
	  import isNativeReflectConstruct from "isNativeReflectConstruct";
	  import possibleConstructorReturn from "possibleConstructorReturn";

	  export default function _createSuper(Derived) {
	    var hasNativeReflectConstruct = isNativeReflectConstruct();

	    return function _createSuperInternal() {
	      var Super = getPrototypeOf(Derived), result;
	      if (hasNativeReflectConstruct) {
	        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
	        var NewTarget = getPrototypeOf(this).constructor;
	        result = Reflect.construct(Super, arguments, NewTarget);
	      } else {
	        result = Super.apply(this, arguments);
	      }
	      return possibleConstructorReturn(this, result);
	    }
	  }
	 `, h.superPropBase = p("7.0.0-beta.0")`
	  import getPrototypeOf from "getPrototypeOf";

	  export default function _superPropBase(object, property) {
	    // Yes, this throws if object is null to being with, that's on purpose.
	    while (!Object.prototype.hasOwnProperty.call(object, property)) {
	      object = getPrototypeOf(object);
	      if (object === null) break;
	    }
	    return object;
	  }
	`, h.get = p("7.0.0-beta.0")`
	  import superPropBase from "superPropBase";

	  export default function _get() {
	    if (typeof Reflect !== "undefined" && Reflect.get) {
	      _get = Reflect.get.bind();
	    } else {
	      _get = function _get(target, property, receiver) {
	        var base = superPropBase(target, property);

	        if (!base) return;

	        var desc = Object.getOwnPropertyDescriptor(base, property);
	        if (desc.get) {
	          // STEP 3. If receiver is not present, then set receiver to target.
	          return desc.get.call(arguments.length < 3 ? target : receiver);
	        }

	        return desc.value;
	      };
	    }
	    return _get.apply(this, arguments);
	  }
	`, h.set = p("7.0.0-beta.0")`
	  import superPropBase from "superPropBase";
	  import defineProperty from "defineProperty";

	  function set(target, property, value, receiver) {
	    if (typeof Reflect !== "undefined" && Reflect.set) {
	      set = Reflect.set;
	    } else {
	      set = function set(target, property, value, receiver) {
	        var base = superPropBase(target, property);
	        var desc;

	        if (base) {
	          desc = Object.getOwnPropertyDescriptor(base, property);
	          if (desc.set) {
	            desc.set.call(receiver, value);
	            return true;
	          } else if (!desc.writable) {
	            // Both getter and non-writable fall into this.
	            return false;
	          }
	        }

	        // Without a super that defines the property, spec boils down to
	        // "define on receiver" for some reason.
	        desc = Object.getOwnPropertyDescriptor(receiver, property);
	        if (desc) {
	          if (!desc.writable) {
	            // Setter, getter, and non-writable fall into this.
	            return false;
	          }

	          desc.value = value;
	          Object.defineProperty(receiver, property, desc);
	        } else {
	          // Avoid setters that may be defined on Sub's prototype, but not on
	          // the instance.
	          defineProperty(receiver, property, value);
	        }

	        return true;
	      };
	    }

	    return set(target, property, value, receiver);
	  }

	  export default function _set(target, property, value, receiver, isStrict) {
	    var s = set(target, property, value, receiver || target);
	    if (!s && isStrict) {
	      throw new Error('failed to set property');
	    }

	    return value;
	  }
	`, h.taggedTemplateLiteral = p("7.0.0-beta.0")`
	  export default function _taggedTemplateLiteral(strings, raw) {
	    if (!raw) { raw = strings.slice(0); }
	    return Object.freeze(Object.defineProperties(strings, {
	        raw: { value: Object.freeze(raw) }
	    }));
	  }
	`, h.taggedTemplateLiteralLoose = p("7.0.0-beta.0")`
	  export default function _taggedTemplateLiteralLoose(strings, raw) {
	    if (!raw) { raw = strings.slice(0); }
	    strings.raw = raw;
	    return strings;
	  }
	`, h.readOnlyError = p("7.0.0-beta.0")`
	  export default function _readOnlyError(name) {
	    throw new TypeError("\\"" + name + "\\" is read-only");
	  }
	`, h.writeOnlyError = p("7.12.13")`
	  export default function _writeOnlyError(name) {
	    throw new TypeError("\\"" + name + "\\" is write-only");
	  }
	`, h.classNameTDZError = p("7.0.0-beta.0")`
	  export default function _classNameTDZError(name) {
	    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
	  }
	`, h.temporalUndefined = p("7.0.0-beta.0")`
	  // This function isn't mean to be called, but to be used as a reference.
	  // We can't use a normal object because it isn't hoisted.
	  export default function _temporalUndefined() {}
	`, h.tdz = p("7.5.5")`
	  export default function _tdzError(name) {
	    throw new ReferenceError(name + " is not defined - temporal dead zone");
	  }
	`, h.temporalRef = p("7.0.0-beta.0")`
	  import undef from "temporalUndefined";
	  import err from "tdz";

	  export default function _temporalRef(val, name) {
	    return val === undef ? err(name) : val;
	  }
	`, h.slicedToArray = p("7.0.0-beta.0")`
	  import arrayWithHoles from "arrayWithHoles";
	  import iterableToArrayLimit from "iterableToArrayLimit";
	  import unsupportedIterableToArray from "unsupportedIterableToArray";
	  import nonIterableRest from "nonIterableRest";

	  export default function _slicedToArray(arr, i) {
	    return (
	      arrayWithHoles(arr) ||
	      iterableToArrayLimit(arr, i) ||
	      unsupportedIterableToArray(arr, i) ||
	      nonIterableRest()
	    );
	  }
	`, h.slicedToArrayLoose = p("7.0.0-beta.0")`
	  import arrayWithHoles from "arrayWithHoles";
	  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
	  import unsupportedIterableToArray from "unsupportedIterableToArray";
	  import nonIterableRest from "nonIterableRest";

	  export default function _slicedToArrayLoose(arr, i) {
	    return (
	      arrayWithHoles(arr) ||
	      iterableToArrayLimitLoose(arr, i) ||
	      unsupportedIterableToArray(arr, i) ||
	      nonIterableRest()
	    );
	  }
	`, h.toArray = p("7.0.0-beta.0")`
	  import arrayWithHoles from "arrayWithHoles";
	  import iterableToArray from "iterableToArray";
	  import unsupportedIterableToArray from "unsupportedIterableToArray";
	  import nonIterableRest from "nonIterableRest";

	  export default function _toArray(arr) {
	    return (
	      arrayWithHoles(arr) ||
	      iterableToArray(arr) ||
	      unsupportedIterableToArray(arr) ||
	      nonIterableRest()
	    );
	  }
	`, h.toConsumableArray = p("7.0.0-beta.0")`
	  import arrayWithoutHoles from "arrayWithoutHoles";
	  import iterableToArray from "iterableToArray";
	  import unsupportedIterableToArray from "unsupportedIterableToArray";
	  import nonIterableSpread from "nonIterableSpread";

	  export default function _toConsumableArray(arr) {
	    return (
	      arrayWithoutHoles(arr) ||
	      iterableToArray(arr) ||
	      unsupportedIterableToArray(arr) ||
	      nonIterableSpread()
	    );
	  }
	`, h.arrayWithoutHoles = p("7.0.0-beta.0")`
	  import arrayLikeToArray from "arrayLikeToArray";

	  export default function _arrayWithoutHoles(arr) {
	    if (Array.isArray(arr)) return arrayLikeToArray(arr);
	  }
	`, h.arrayWithHoles = p("7.0.0-beta.0")`
	  export default function _arrayWithHoles(arr) {
	    if (Array.isArray(arr)) return arr;
	  }
	`, h.maybeArrayLike = p("7.9.0")`
	  import arrayLikeToArray from "arrayLikeToArray";

	  export default function _maybeArrayLike(next, arr, i) {
	    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
	      var len = arr.length;
	      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
	    }
	    return next(arr, i);
	  }
	`, h.iterableToArray = p("7.0.0-beta.0")`
	  export default function _iterableToArray(iter) {
	    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	  }
	`, h.iterableToArrayLimit = p("7.0.0-beta.0")`
	  export default function _iterableToArrayLimit(arr, i) {
	    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
	    // iterators etc. variable names have been minimised to reduce the size of this massive
	    // helper. sometimes spec compliance is annoying :(
	    //
	    // _n = _iteratorNormalCompletion
	    // _d = _didIteratorError
	    // _e = _iteratorError
	    // _i = _iterator
	    // _s = _step

	    var _i = arr == null ? null : (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
	    if (_i == null) return;

	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _s, _e;
	    try {
	      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"] != null) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	`, h.iterableToArrayLimitLoose = p("7.0.0-beta.0")`
	  export default function _iterableToArrayLimitLoose(arr, i) {
	    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
	    if (_i == null) return;

	    var _arr = [];
	    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
	      _arr.push(_step.value);
	      if (i && _arr.length === i) break;
	    }
	    return _arr;
	  }
	`, h.unsupportedIterableToArray = p("7.9.0")`
	  import arrayLikeToArray from "arrayLikeToArray";

	  export default function _unsupportedIterableToArray(o, minLen) {
	    if (!o) return;
	    if (typeof o === "string") return arrayLikeToArray(o, minLen);
	    var n = Object.prototype.toString.call(o).slice(8, -1);
	    if (n === "Object" && o.constructor) n = o.constructor.name;
	    if (n === "Map" || n === "Set") return Array.from(o);
	    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
	      return arrayLikeToArray(o, minLen);
	  }
	`, h.arrayLikeToArray = p("7.9.0")`
	  export default function _arrayLikeToArray(arr, len) {
	    if (len == null || len > arr.length) len = arr.length;
	    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	    return arr2;
	  }
	`, h.nonIterableSpread = p("7.0.0-beta.0")`
	  export default function _nonIterableSpread() {
	    throw new TypeError(
	      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
	    );
	  }
	`, h.nonIterableRest = p("7.0.0-beta.0")`
	  export default function _nonIterableRest() {
	    throw new TypeError(
	      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
	    );
	  }
	`, h.createForOfIteratorHelper = p("7.9.0")`
	  import unsupportedIterableToArray from "unsupportedIterableToArray";

	  // s: start (create the iterator)
	  // n: next
	  // e: error (called whenever something throws)
	  // f: finish (always called at the end)

	  export default function _createForOfIteratorHelper(o, allowArrayLike) {
	    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	    if (!it) {
	      // Fallback for engines without symbol support
	      if (
	        Array.isArray(o) ||
	        (it = unsupportedIterableToArray(o)) ||
	        (allowArrayLike && o && typeof o.length === "number")
	      ) {
	        if (it) o = it;
	        var i = 0;
	        var F = function(){};
	        return {
	          s: F,
	          n: function() {
	            if (i >= o.length) return { done: true };
	            return { done: false, value: o[i++] };
	          },
	          e: function(e) { throw e; },
	          f: F,
	        };
	      }

	      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	    }

	    var normalCompletion = true, didErr = false, err;

	    return {
	      s: function() {
	        it = it.call(o);
	      },
	      n: function() {
	        var step = it.next();
	        normalCompletion = step.done;
	        return step;
	      },
	      e: function(e) {
	        didErr = true;
	        err = e;
	      },
	      f: function() {
	        try {
	          if (!normalCompletion && it.return != null) it.return();
	        } finally {
	          if (didErr) throw err;
	        }
	      }
	    };
	  }
	`, h.createForOfIteratorHelperLoose = p("7.9.0")`
	  import unsupportedIterableToArray from "unsupportedIterableToArray";

	  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	    if (it) return (it = it.call(o)).next.bind(it);

	    // Fallback for engines without symbol support
	    if (
	      Array.isArray(o) ||
	      (it = unsupportedIterableToArray(o)) ||
	      (allowArrayLike && o && typeof o.length === "number")
	    ) {
	      if (it) o = it;
	      var i = 0;
	      return function() {
	        if (i >= o.length) return { done: true };
	        return { done: false, value: o[i++] };
	      }
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }
	`, h.skipFirstGeneratorNext = p("7.0.0-beta.0")`
	  export default function _skipFirstGeneratorNext(fn) {
	    return function () {
	      var it = fn.apply(this, arguments);
	      it.next();
	      return it;
	    }
	  }
	`, h.toPrimitive = p("7.1.5")`
	  export default function _toPrimitive(
	    input,
	    hint /*: "default" | "string" | "number" | void */
	  ) {
	    if (typeof input !== "object" || input === null) return input;
	    var prim = input[Symbol.toPrimitive];
	    if (prim !== undefined) {
	      var res = prim.call(input, hint || "default");
	      if (typeof res !== "object") return res;
	      throw new TypeError("@@toPrimitive must return a primitive value.");
	    }
	    return (hint === "string" ? String : Number)(input);
	  }
	`, h.toPropertyKey = p("7.1.5")`
	  import toPrimitive from "toPrimitive";

	  export default function _toPropertyKey(arg) {
	    var key = toPrimitive(arg, "string");
	    return typeof key === "symbol" ? key : String(key);
	  }
	`, h.initializerWarningHelper = p("7.0.0-beta.0")`
	    export default function _initializerWarningHelper(descriptor, context){
	        throw new Error(
	          'Decorating class property failed. Please ensure that ' +
	          'proposal-class-properties is enabled and runs after the decorators transform.'
	        );
	    }
	`, h.initializerDefineProperty = p("7.0.0-beta.0")`
	    export default function _initializerDefineProperty(target, property, descriptor, context){
	        if (!descriptor) return;

	        Object.defineProperty(target, property, {
	            enumerable: descriptor.enumerable,
	            configurable: descriptor.configurable,
	            writable: descriptor.writable,
	            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
	        });
	    }
	`, h.applyDecoratedDescriptor = p("7.0.0-beta.0")`
	    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
	        var desc = {};
	        Object.keys(descriptor).forEach(function(key){
	            desc[key] = descriptor[key];
	        });
	        desc.enumerable = !!desc.enumerable;
	        desc.configurable = !!desc.configurable;
	        if ('value' in desc || desc.initializer){
	            desc.writable = true;
	        }

	        desc = decorators.slice().reverse().reduce(function(desc, decorator){
	            return decorator(target, property, desc) || desc;
	        }, desc);

	        if (context && desc.initializer !== void 0){
	            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
	            desc.initializer = undefined;
	        }

	        if (desc.initializer === void 0){
	            Object.defineProperty(target, property, desc);
	            desc = null;
	        }

	        return desc;
	    }
	`, h.classPrivateFieldLooseKey = p("7.0.0-beta.0")`
	  var id = 0;
	  export default function _classPrivateFieldKey(name) {
	    return "__private_" + (id++) + "_" + name;
	  }
	`, h.classPrivateFieldLooseBase = p("7.0.0-beta.0")`
	  export default function _classPrivateFieldBase(receiver, privateKey) {
	    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
	      throw new TypeError("attempted to use private field on non-instance");
	    }
	    return receiver;
	  }
	`, h.classPrivateFieldGet = p("7.0.0-beta.0")`
	  import classApplyDescriptorGet from "classApplyDescriptorGet";
	  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
	  export default function _classPrivateFieldGet(receiver, privateMap) {
	    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
	    return classApplyDescriptorGet(receiver, descriptor);
	  }
	`, h.classPrivateFieldSet = p("7.0.0-beta.0")`
	  import classApplyDescriptorSet from "classApplyDescriptorSet";
	  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
	  export default function _classPrivateFieldSet(receiver, privateMap, value) {
	    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
	    classApplyDescriptorSet(receiver, descriptor, value);
	    return value;
	  }
	`, h.classPrivateFieldDestructureSet = p("7.4.4")`
	  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
	  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
	  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
	    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
	    return classApplyDescriptorDestructureSet(receiver, descriptor);
	  }
	`, h.classExtractFieldDescriptor = p("7.13.10")`
	  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
	    if (!privateMap.has(receiver)) {
	      throw new TypeError("attempted to " + action + " private field on non-instance");
	    }
	    return privateMap.get(receiver);
	  }
	`, h.classStaticPrivateFieldSpecGet = p("7.0.2")`
	  import classApplyDescriptorGet from "classApplyDescriptorGet";
	  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
	  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
	  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
	    classCheckPrivateStaticAccess(receiver, classConstructor);
	    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
	    return classApplyDescriptorGet(receiver, descriptor);
	  }
	`, h.classStaticPrivateFieldSpecSet = p("7.0.2")`
	  import classApplyDescriptorSet from "classApplyDescriptorSet";
	  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
	  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
	  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
	    classCheckPrivateStaticAccess(receiver, classConstructor);
	    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
	    classApplyDescriptorSet(receiver, descriptor, value);
	    return value;
	  }
	`, h.classStaticPrivateMethodGet = p("7.3.2")`
	  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
	  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
	    classCheckPrivateStaticAccess(receiver, classConstructor);
	    return method;
	  }
	`, h.classStaticPrivateMethodSet = p("7.3.2")`
	  export default function _classStaticPrivateMethodSet() {
	    throw new TypeError("attempted to set read only static private field");
	  }
	`, h.classApplyDescriptorGet = p("7.13.10")`
	  export default function _classApplyDescriptorGet(receiver, descriptor) {
	    if (descriptor.get) {
	      return descriptor.get.call(receiver);
	    }
	    return descriptor.value;
	  }
	`, h.classApplyDescriptorSet = p("7.13.10")`
	  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
	    if (descriptor.set) {
	      descriptor.set.call(receiver, value);
	    } else {
	      if (!descriptor.writable) {
	        // This should only throw in strict mode, but class bodies are
	        // always strict and private fields can only be used inside
	        // class bodies.
	        throw new TypeError("attempted to set read only private field");
	      }
	      descriptor.value = value;
	    }
	  }
	`, h.classApplyDescriptorDestructureSet = p("7.13.10")`
	  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
	    if (descriptor.set) {
	      if (!("__destrObj" in descriptor)) {
	        descriptor.__destrObj = {
	          set value(v) {
	            descriptor.set.call(receiver, v)
	          },
	        };
	      }
	      return descriptor.__destrObj;
	    } else {
	      if (!descriptor.writable) {
	        // This should only throw in strict mode, but class bodies are
	        // always strict and private fields can only be used inside
	        // class bodies.
	        throw new TypeError("attempted to set read only private field");
	      }

	      return descriptor;
	    }
	  }
	`, h.classStaticPrivateFieldDestructureSet = p("7.13.10")`
	  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
	  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
	  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
	  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
	    classCheckPrivateStaticAccess(receiver, classConstructor);
	    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
	    return classApplyDescriptorDestructureSet(receiver, descriptor);
	  }
	`, h.classCheckPrivateStaticAccess = p("7.13.10")`
	  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
	    if (receiver !== classConstructor) {
	      throw new TypeError("Private static access of wrong provenance");
	    }
	  }
	`, h.classCheckPrivateStaticFieldDescriptor = p("7.13.10")`
	  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
	    if (descriptor === undefined) {
	      throw new TypeError("attempted to " + action + " private static field before its declaration");
	    }
	  }
	`, h.decorate = p("7.1.5")`
	  import toArray from "toArray";
	  import toPropertyKey from "toPropertyKey";

	  // These comments are stripped by @babel/template
	  /*::
	  type PropertyDescriptor =
	    | {
	        value: any,
	        writable: boolean,
	        configurable: boolean,
	        enumerable: boolean,
	      }
	    | {
	        get?: () => any,
	        set?: (v: any) => void,
	        configurable: boolean,
	        enumerable: boolean,
	      };

	  type FieldDescriptor ={
	    writable: boolean,
	    configurable: boolean,
	    enumerable: boolean,
	  };

	  type Placement = "static" | "prototype" | "own";
	  type Key = string | symbol; // PrivateName is not supported yet.

	  type ElementDescriptor =
	    | {
	        kind: "method",
	        key: Key,
	        placement: Placement,
	        descriptor: PropertyDescriptor
	      }
	    | {
	        kind: "field",
	        key: Key,
	        placement: Placement,
	        descriptor: FieldDescriptor,
	        initializer?: () => any,
	      };

	  // This is exposed to the user code
	  type ElementObjectInput = ElementDescriptor & {
	    [@@toStringTag]?: "Descriptor"
	  };

	  // This is exposed to the user code
	  type ElementObjectOutput = ElementDescriptor & {
	    [@@toStringTag]?: "Descriptor"
	    extras?: ElementDescriptor[],
	    finisher?: ClassFinisher,
	  };

	  // This is exposed to the user code
	  type ClassObject = {
	    [@@toStringTag]?: "Descriptor",
	    kind: "class",
	    elements: ElementDescriptor[],
	  };

	  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
	  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
	  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

	  // Only used by Babel in the transform output, not part of the spec.
	  type ElementDefinition =
	    | {
	        kind: "method",
	        value: any,
	        key: Key,
	        static?: boolean,
	        decorators?: ElementDecorator[],
	      }
	    | {
	        kind: "field",
	        value: () => any,
	        key: Key,
	        static?: boolean,
	        decorators?: ElementDecorator[],
	    };

	  declare function ClassFactory<C>(initialize: (instance: C) => void): {
	    F: Class<C>,
	    d: ElementDefinition[]
	  }

	  */

	  /*::
	  // Various combinations with/without extras and with one or many finishers

	  type ElementFinisherExtras = {
	    element: ElementDescriptor,
	    finisher?: ClassFinisher,
	    extras?: ElementDescriptor[],
	  };

	  type ElementFinishersExtras = {
	    element: ElementDescriptor,
	    finishers: ClassFinisher[],
	    extras: ElementDescriptor[],
	  };

	  type ElementsFinisher = {
	    elements: ElementDescriptor[],
	    finisher?: ClassFinisher,
	  };

	  type ElementsFinishers = {
	    elements: ElementDescriptor[],
	    finishers: ClassFinisher[],
	  };

	  */

	  /*::

	  type Placements = {
	    static: Key[],
	    prototype: Key[],
	    own: Key[],
	  };

	  */

	  // ClassDefinitionEvaluation (Steps 26-*)
	  export default function _decorate(
	    decorators /*: ClassDecorator[] */,
	    factory /*: ClassFactory */,
	    superClass /*: ?Class<*> */,
	    mixins /*: ?Array<Function> */,
	  ) /*: Class<*> */ {
	    var api = _getDecoratorsApi();
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        api = mixins[i](api);
	      }
	    }

	    var r = factory(function initialize(O) {
	      api.initializeInstanceElements(O, decorated.elements);
	    }, superClass);
	    var decorated = api.decorateClass(
	      _coalesceClassElements(r.d.map(_createElementDescriptor)),
	      decorators,
	    );

	    api.initializeClassElements(r.F, decorated.elements);

	    return api.runClassFinishers(r.F, decorated.finishers);
	  }

	  function _getDecoratorsApi() {
	    _getDecoratorsApi = function() {
	      return api;
	    };

	    var api = {
	      elementsDefinitionOrder: [["method"], ["field"]],

	      // InitializeInstanceElements
	      initializeInstanceElements: function(
	        /*::<C>*/ O /*: C */,
	        elements /*: ElementDescriptor[] */,
	      ) {
	        ["method", "field"].forEach(function(kind) {
	          elements.forEach(function(element /*: ElementDescriptor */) {
	            if (element.kind === kind && element.placement === "own") {
	              this.defineClassElement(O, element);
	            }
	          }, this);
	        }, this);
	      },

	      // InitializeClassElements
	      initializeClassElements: function(
	        /*::<C>*/ F /*: Class<C> */,
	        elements /*: ElementDescriptor[] */,
	      ) {
	        var proto = F.prototype;

	        ["method", "field"].forEach(function(kind) {
	          elements.forEach(function(element /*: ElementDescriptor */) {
	            var placement = element.placement;
	            if (
	              element.kind === kind &&
	              (placement === "static" || placement === "prototype")
	            ) {
	              var receiver = placement === "static" ? F : proto;
	              this.defineClassElement(receiver, element);
	            }
	          }, this);
	        }, this);
	      },

	      // DefineClassElement
	      defineClassElement: function(
	        /*::<C>*/ receiver /*: C | Class<C> */,
	        element /*: ElementDescriptor */,
	      ) {
	        var descriptor /*: PropertyDescriptor */ = element.descriptor;
	        if (element.kind === "field") {
	          var initializer = element.initializer;
	          descriptor = {
	            enumerable: descriptor.enumerable,
	            writable: descriptor.writable,
	            configurable: descriptor.configurable,
	            value: initializer === void 0 ? void 0 : initializer.call(receiver),
	          };
	        }
	        Object.defineProperty(receiver, element.key, descriptor);
	      },

	      // DecorateClass
	      decorateClass: function(
	        elements /*: ElementDescriptor[] */,
	        decorators /*: ClassDecorator[] */,
	      ) /*: ElementsFinishers */ {
	        var newElements /*: ElementDescriptor[] */ = [];
	        var finishers /*: ClassFinisher[] */ = [];
	        var placements /*: Placements */ = {
	          static: [],
	          prototype: [],
	          own: [],
	        };

	        elements.forEach(function(element /*: ElementDescriptor */) {
	          this.addElementPlacement(element, placements);
	        }, this);

	        elements.forEach(function(element /*: ElementDescriptor */) {
	          if (!_hasDecorators(element)) return newElements.push(element);

	          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
	            element,
	            placements,
	          );
	          newElements.push(elementFinishersExtras.element);
	          newElements.push.apply(newElements, elementFinishersExtras.extras);
	          finishers.push.apply(finishers, elementFinishersExtras.finishers);
	        }, this);

	        if (!decorators) {
	          return { elements: newElements, finishers: finishers };
	        }

	        var result /*: ElementsFinishers */ = this.decorateConstructor(
	          newElements,
	          decorators,
	        );
	        finishers.push.apply(finishers, result.finishers);
	        result.finishers = finishers;

	        return result;
	      },

	      // AddElementPlacement
	      addElementPlacement: function(
	        element /*: ElementDescriptor */,
	        placements /*: Placements */,
	        silent /*: boolean */,
	      ) {
	        var keys = placements[element.placement];
	        if (!silent && keys.indexOf(element.key) !== -1) {
	          throw new TypeError("Duplicated element (" + element.key + ")");
	        }
	        keys.push(element.key);
	      },

	      // DecorateElement
	      decorateElement: function(
	        element /*: ElementDescriptor */,
	        placements /*: Placements */,
	      ) /*: ElementFinishersExtras */ {
	        var extras /*: ElementDescriptor[] */ = [];
	        var finishers /*: ClassFinisher[] */ = [];

	        for (
	          var decorators = element.decorators, i = decorators.length - 1;
	          i >= 0;
	          i--
	        ) {
	          // (inlined) RemoveElementPlacement
	          var keys = placements[element.placement];
	          keys.splice(keys.indexOf(element.key), 1);

	          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
	            element,
	          );
	          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
	            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
	              elementObject,
	          );

	          element = elementFinisherExtras.element;
	          this.addElementPlacement(element, placements);

	          if (elementFinisherExtras.finisher) {
	            finishers.push(elementFinisherExtras.finisher);
	          }

	          var newExtras /*: ElementDescriptor[] | void */ =
	            elementFinisherExtras.extras;
	          if (newExtras) {
	            for (var j = 0; j < newExtras.length; j++) {
	              this.addElementPlacement(newExtras[j], placements);
	            }
	            extras.push.apply(extras, newExtras);
	          }
	        }

	        return { element: element, finishers: finishers, extras: extras };
	      },

	      // DecorateConstructor
	      decorateConstructor: function(
	        elements /*: ElementDescriptor[] */,
	        decorators /*: ClassDecorator[] */,
	      ) /*: ElementsFinishers */ {
	        var finishers /*: ClassFinisher[] */ = [];

	        for (var i = decorators.length - 1; i >= 0; i--) {
	          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
	          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
	            (0, decorators[i])(obj) /*: ClassObject */ || obj,
	          );

	          if (elementsAndFinisher.finisher !== undefined) {
	            finishers.push(elementsAndFinisher.finisher);
	          }

	          if (elementsAndFinisher.elements !== undefined) {
	            elements = elementsAndFinisher.elements;

	            for (var j = 0; j < elements.length - 1; j++) {
	              for (var k = j + 1; k < elements.length; k++) {
	                if (
	                  elements[j].key === elements[k].key &&
	                  elements[j].placement === elements[k].placement
	                ) {
	                  throw new TypeError(
	                    "Duplicated element (" + elements[j].key + ")",
	                  );
	                }
	              }
	            }
	          }
	        }

	        return { elements: elements, finishers: finishers };
	      },

	      // FromElementDescriptor
	      fromElementDescriptor: function(
	        element /*: ElementDescriptor */,
	      ) /*: ElementObject */ {
	        var obj /*: ElementObject */ = {
	          kind: element.kind,
	          key: element.key,
	          placement: element.placement,
	          descriptor: element.descriptor,
	        };

	        var desc = {
	          value: "Descriptor",
	          configurable: true,
	        };
	        Object.defineProperty(obj, Symbol.toStringTag, desc);

	        if (element.kind === "field") obj.initializer = element.initializer;

	        return obj;
	      },

	      // ToElementDescriptors
	      toElementDescriptors: function(
	        elementObjects /*: ElementObject[] */,
	      ) /*: ElementDescriptor[] */ {
	        if (elementObjects === undefined) return;
	        return toArray(elementObjects).map(function(elementObject) {
	          var element = this.toElementDescriptor(elementObject);
	          this.disallowProperty(elementObject, "finisher", "An element descriptor");
	          this.disallowProperty(elementObject, "extras", "An element descriptor");
	          return element;
	        }, this);
	      },

	      // ToElementDescriptor
	      toElementDescriptor: function(
	        elementObject /*: ElementObject */,
	      ) /*: ElementDescriptor */ {
	        var kind = String(elementObject.kind);
	        if (kind !== "method" && kind !== "field") {
	          throw new TypeError(
	            'An element descriptor\\'s .kind property must be either "method" or' +
	              ' "field", but a decorator created an element descriptor with' +
	              ' .kind "' +
	              kind +
	              '"',
	          );
	        }

	        var key = toPropertyKey(elementObject.key);

	        var placement = String(elementObject.placement);
	        if (
	          placement !== "static" &&
	          placement !== "prototype" &&
	          placement !== "own"
	        ) {
	          throw new TypeError(
	            'An element descriptor\\'s .placement property must be one of "static",' +
	              ' "prototype" or "own", but a decorator created an element descriptor' +
	              ' with .placement "' +
	              placement +
	              '"',
	          );
	        }

	        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

	        this.disallowProperty(elementObject, "elements", "An element descriptor");

	        var element /*: ElementDescriptor */ = {
	          kind: kind,
	          key: key,
	          placement: placement,
	          descriptor: Object.assign({}, descriptor),
	        };

	        if (kind !== "field") {
	          this.disallowProperty(elementObject, "initializer", "A method descriptor");
	        } else {
	          this.disallowProperty(
	            descriptor,
	            "get",
	            "The property descriptor of a field descriptor",
	          );
	          this.disallowProperty(
	            descriptor,
	            "set",
	            "The property descriptor of a field descriptor",
	          );
	          this.disallowProperty(
	            descriptor,
	            "value",
	            "The property descriptor of a field descriptor",
	          );

	          element.initializer = elementObject.initializer;
	        }

	        return element;
	      },

	      toElementFinisherExtras: function(
	        elementObject /*: ElementObject */,
	      ) /*: ElementFinisherExtras */ {
	        var element /*: ElementDescriptor */ = this.toElementDescriptor(
	          elementObject,
	        );
	        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
	          elementObject,
	          "finisher",
	        );
	        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
	          elementObject.extras,
	        );

	        return { element: element, finisher: finisher, extras: extras };
	      },

	      // FromClassDescriptor
	      fromClassDescriptor: function(
	        elements /*: ElementDescriptor[] */,
	      ) /*: ClassObject */ {
	        var obj = {
	          kind: "class",
	          elements: elements.map(this.fromElementDescriptor, this),
	        };

	        var desc = { value: "Descriptor", configurable: true };
	        Object.defineProperty(obj, Symbol.toStringTag, desc);

	        return obj;
	      },

	      // ToClassDescriptor
	      toClassDescriptor: function(
	        obj /*: ClassObject */,
	      ) /*: ElementsFinisher */ {
	        var kind = String(obj.kind);
	        if (kind !== "class") {
	          throw new TypeError(
	            'A class descriptor\\'s .kind property must be "class", but a decorator' +
	              ' created a class descriptor with .kind "' +
	              kind +
	              '"',
	          );
	        }

	        this.disallowProperty(obj, "key", "A class descriptor");
	        this.disallowProperty(obj, "placement", "A class descriptor");
	        this.disallowProperty(obj, "descriptor", "A class descriptor");
	        this.disallowProperty(obj, "initializer", "A class descriptor");
	        this.disallowProperty(obj, "extras", "A class descriptor");

	        var finisher = _optionalCallableProperty(obj, "finisher");
	        var elements = this.toElementDescriptors(obj.elements);

	        return { elements: elements, finisher: finisher };
	      },

	      // RunClassFinishers
	      runClassFinishers: function(
	        constructor /*: Class<*> */,
	        finishers /*: ClassFinisher[] */,
	      ) /*: Class<*> */ {
	        for (var i = 0; i < finishers.length; i++) {
	          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
	          if (newConstructor !== undefined) {
	            // NOTE: This should check if IsConstructor(newConstructor) is false.
	            if (typeof newConstructor !== "function") {
	              throw new TypeError("Finishers must return a constructor.");
	            }
	            constructor = newConstructor;
	          }
	        }
	        return constructor;
	      },

	      disallowProperty: function(obj, name, objectType) {
	        if (obj[name] !== undefined) {
	          throw new TypeError(objectType + " can't have a ." + name + " property.");
	        }
	      }
	    };

	    return api;
	  }

	  // ClassElementEvaluation
	  function _createElementDescriptor(
	    def /*: ElementDefinition */,
	  ) /*: ElementDescriptor */ {
	    var key = toPropertyKey(def.key);

	    var descriptor /*: PropertyDescriptor */;
	    if (def.kind === "method") {
	      descriptor = {
	        value: def.value,
	        writable: true,
	        configurable: true,
	        enumerable: false,
	      };
	    } else if (def.kind === "get") {
	      descriptor = { get: def.value, configurable: true, enumerable: false };
	    } else if (def.kind === "set") {
	      descriptor = { set: def.value, configurable: true, enumerable: false };
	    } else if (def.kind === "field") {
	      descriptor = { configurable: true, writable: true, enumerable: true };
	    }

	    var element /*: ElementDescriptor */ = {
	      kind: def.kind === "field" ? "field" : "method",
	      key: key,
	      placement: def.static
	        ? "static"
	        : def.kind === "field"
	        ? "own"
	        : "prototype",
	      descriptor: descriptor,
	    };
	    if (def.decorators) element.decorators = def.decorators;
	    if (def.kind === "field") element.initializer = def.value;

	    return element;
	  }

	  // CoalesceGetterSetter
	  function _coalesceGetterSetter(
	    element /*: ElementDescriptor */,
	    other /*: ElementDescriptor */,
	  ) {
	    if (element.descriptor.get !== undefined) {
	      other.descriptor.get = element.descriptor.get;
	    } else {
	      other.descriptor.set = element.descriptor.set;
	    }
	  }

	  // CoalesceClassElements
	  function _coalesceClassElements(
	    elements /*: ElementDescriptor[] */,
	  ) /*: ElementDescriptor[] */ {
	    var newElements /*: ElementDescriptor[] */ = [];

	    var isSameElement = function(
	      other /*: ElementDescriptor */,
	    ) /*: boolean */ {
	      return (
	        other.kind === "method" &&
	        other.key === element.key &&
	        other.placement === element.placement
	      );
	    };

	    for (var i = 0; i < elements.length; i++) {
	      var element /*: ElementDescriptor */ = elements[i];
	      var other /*: ElementDescriptor */;

	      if (
	        element.kind === "method" &&
	        (other = newElements.find(isSameElement))
	      ) {
	        if (
	          _isDataDescriptor(element.descriptor) ||
	          _isDataDescriptor(other.descriptor)
	        ) {
	          if (_hasDecorators(element) || _hasDecorators(other)) {
	            throw new ReferenceError(
	              "Duplicated methods (" + element.key + ") can't be decorated.",
	            );
	          }
	          other.descriptor = element.descriptor;
	        } else {
	          if (_hasDecorators(element)) {
	            if (_hasDecorators(other)) {
	              throw new ReferenceError(
	                "Decorators can't be placed on different accessors with for " +
	                  "the same property (" +
	                  element.key +
	                  ").",
	              );
	            }
	            other.decorators = element.decorators;
	          }
	          _coalesceGetterSetter(element, other);
	        }
	      } else {
	        newElements.push(element);
	      }
	    }

	    return newElements;
	  }

	  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
	    return element.decorators && element.decorators.length;
	  }

	  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
	    return (
	      desc !== undefined &&
	      !(desc.value === undefined && desc.writable === undefined)
	    );
	  }

	  function _optionalCallableProperty /*::<T>*/(
	    obj /*: T */,
	    name /*: $Keys<T> */,
	  ) /*: ?Function */ {
	    var value = obj[name];
	    if (value !== undefined && typeof value !== "function") {
	      throw new TypeError("Expected '" + name + "' to be a function");
	    }
	    return value;
	  }

	`, h.classPrivateMethodGet = p("7.1.6")`
	  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
	    if (!privateSet.has(receiver)) {
	      throw new TypeError("attempted to get private field on non-instance");
	    }
	    return fn;
	  }
	`, h.checkPrivateRedeclaration = p("7.14.1")`
	  export default function _checkPrivateRedeclaration(obj, privateCollection) {
	    if (privateCollection.has(obj)) {
	      throw new TypeError("Cannot initialize the same private elements twice on an object");
	    }
	  }
	`, h.classPrivateFieldInitSpec = p("7.14.1")`
	  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

	  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
	    checkPrivateRedeclaration(obj, privateMap);
	    privateMap.set(obj, value);
	  }
	`, h.classPrivateMethodInitSpec = p("7.14.1")`
	  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

	  export default function _classPrivateMethodInitSpec(obj, privateSet) {
	    checkPrivateRedeclaration(obj, privateSet);
	    privateSet.add(obj);
	  }
	`, h.classPrivateMethodSet = p("7.1.6")`
	    export default function _classPrivateMethodSet() {
	      throw new TypeError("attempted to reassign private method");
	    }
	  `, h.identity = p("7.17.0")`
	  export default function _identity(x) {
	    return x;
	  }
	`, xa;
}
var Yd;
function i0() {
  if (Yd)
    return ji;
  Yd = 1, Object.defineProperty(ji, "__esModule", {
    value: true
  }), ji.default = void 0, ji.ensure = _, ji.get = I, ji.getDependencies = D, ji.list = void 0, ji.minVersion = N;
  var s = qi(), n = Je(), h = I1();
  const {
    assignmentExpression: f2,
    cloneNode: p,
    expressionStatement: g,
    file: P,
    identifier: x
  } = n;
  function y(R) {
    const O = [];
    for (; R.parentPath; R = R.parentPath)
      O.push(R.key), R.inList && O.push(R.listKey);
    return O.reverse().join(".");
  }
  let A;
  function S(R) {
    const O = /* @__PURE__ */ new Set(), B = /* @__PURE__ */ new Set(), M = /* @__PURE__ */ new Map();
    let j, $;
    const k = [], ne = [], Q = [], q = {
      ImportDeclaration(K) {
        const G = K.node.source.value;
        if (!h.default[G])
          throw K.buildCodeFrameError(`Unknown helper ${G}`);
        if (K.get("specifiers").length !== 1 || !K.get("specifiers.0").isImportDefaultSpecifier())
          throw K.buildCodeFrameError("Helpers can only import a default value");
        const V = K.node.specifiers[0].local;
        M.set(V, G), ne.push(y(K));
      },
      ExportDefaultDeclaration(K) {
        const G = K.get("declaration");
        if (!G.isFunctionDeclaration() || !G.node.id)
          throw G.buildCodeFrameError("Helpers can only export named function declarations");
        j = G.node.id.name, $ = y(K);
      },
      ExportAllDeclaration(K) {
        throw K.buildCodeFrameError("Helpers can only export default");
      },
      ExportNamedDeclaration(K) {
        throw K.buildCodeFrameError("Helpers can only export default");
      },
      Statement(K) {
        K.isModuleDeclaration() || K.skip();
      }
    }, ee = {
      Program(K) {
        const G = K.scope.getAllBindings();
        Object.keys(G).forEach((V) => {
          V !== j && (M.has(G[V].identifier) || B.add(V));
        });
      },
      ReferencedIdentifier(K) {
        const G = K.node.name, V = K.scope.getBinding(G);
        V ? M.has(V.identifier) && Q.push(y(K)) : O.add(G);
      },
      AssignmentExpression(K) {
        const G = K.get("left");
        if (!(j in G.getBindingIdentifiers()))
          return;
        if (!G.isIdentifier())
          throw G.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
        const V = K.scope.getBinding(j);
        V != null && V.scope.path.isProgram() && k.push(y(K));
      }
    };
    if ((0, s.default)(R.ast, q, R.scope), (0, s.default)(R.ast, ee, R.scope), !$)
      throw new Error("Helpers must have a default export.");
    return k.reverse(), {
      globals: Array.from(O),
      localBindingNames: Array.from(B),
      dependencies: M,
      exportBindingAssignments: k,
      exportPath: $,
      exportName: j,
      importBindingsReferences: Q,
      importPaths: ne
    };
  }
  function v(R, O, B, M, j) {
    if (M && !B)
      throw new Error("Unexpected local bindings for module-based helpers.");
    if (!B)
      return;
    const {
      localBindingNames: $,
      dependencies: k,
      exportBindingAssignments: ne,
      exportPath: Q,
      exportName: q,
      importBindingsReferences: ee,
      importPaths: K
    } = O, G = {};
    k.forEach((Pe, we) => {
      G[we.name] = typeof j == "function" && j(Pe) || we;
    });
    const V = {}, F = new Set(M || []);
    $.forEach((Pe) => {
      let we = Pe;
      for (; F.has(we); )
        we = "_" + we;
      we !== Pe && (V[Pe] = we);
    }), B.type === "Identifier" && q !== B.name && (V[q] = B.name);
    const {
      path: le
    } = R, oe = le.get(Q), fe = K.map((Pe) => le.get(Pe)), he = ee.map((Pe) => le.get(Pe)), de = oe.get("declaration");
    if (B.type === "Identifier")
      oe.replaceWith(de);
    else if (B.type === "MemberExpression")
      ne.forEach((Pe) => {
        const we = le.get(Pe);
        we.replaceWith(f2("=", B, we.node));
      }), oe.replaceWith(de), le.pushContainer("body", g(f2("=", B, x(q))));
    else
      throw new Error("Unexpected helper format.");
    Object.keys(V).forEach((Pe) => {
      le.scope.rename(Pe, V[Pe]);
    });
    for (const Pe of fe)
      Pe.remove();
    for (const Pe of he) {
      const we = p(G[Pe.node.name]);
      Pe.replaceWith(we);
    }
  }
  const T = /* @__PURE__ */ Object.create(null);
  function C(R) {
    if (!T[R]) {
      const O = h.default[R];
      if (!O)
        throw Object.assign(new ReferenceError(`Unknown helper ${R}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: R
        });
      const B = () => {
        if (!A) {
          const j = {
            ast: P(O.ast()),
            path: null
          };
          return (0, s.default)(j.ast, {
            Program: ($) => (j.path = $).stop()
          }), j;
        }
        return new A({
          filename: `babel-helper://${R}`
        }, {
          ast: P(O.ast()),
          code: "[internal Babel helper code]",
          inputMap: null
        });
      };
      let M = null;
      T[R] = {
        minVersion: O.minVersion,
        build(j, $, k) {
          const ne = B();
          return M || (M = S(ne)), v(ne, M, $, k, j), {
            nodes: ne.ast.program.body,
            globals: M.globals
          };
        },
        getDependencies() {
          return M || (M = S(B())), Array.from(M.dependencies.values());
        }
      };
    }
    return T[R];
  }
  function I(R, O, B, M) {
    return C(R).build(O, B, M);
  }
  function N(R) {
    return C(R).minVersion;
  }
  function D(R) {
    return C(R).getDependencies();
  }
  function _(R, O) {
    A || (A = O), C(R);
  }
  const m = Object.keys(h.default).map((R) => R.replace(/^_/, ""));
  ji.list = m;
  var L = I;
  return ji.default = L, ji;
}
var nc = {};
function N1(s, n) {
  if (!Boolean(s))
    throw new Error(n || "unknown assertion error");
}
var Ra = N1;
var ac = {};
var Sa = {};
var Ea = {};
var Qd;
function k1() {
  if (Qd)
    return Ea;
  Qd = 1, Object.defineProperty(Ea, "__esModule", {
    value: true
  }), Ea.default = void 0;
  var s = Ra, n = Je();
  const {
    callExpression: h,
    cloneNode: f2,
    expressionStatement: p,
    identifier: g,
    importDeclaration: P,
    importDefaultSpecifier: x,
    importNamespaceSpecifier: y,
    importSpecifier: A,
    memberExpression: S,
    stringLiteral: v,
    variableDeclaration: T,
    variableDeclarator: C
  } = n;
  class I {
    constructor(D, _, m) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = _, this._hub = m, this._importedSource = D;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(P([], v(this._importedSource))), this;
    }
    require() {
      return this._statements.push(p(h(g("require"), [v(this._importedSource)]))), this;
    }
    namespace(D = "namespace") {
      const _ = this._scope.generateUidIdentifier(D), m = this._statements[this._statements.length - 1];
      return s(m.type === "ImportDeclaration"), s(m.specifiers.length === 0), m.specifiers = [y(_)], this._resultName = f2(_), this;
    }
    default(D) {
      const _ = this._scope.generateUidIdentifier(D), m = this._statements[this._statements.length - 1];
      return s(m.type === "ImportDeclaration"), s(m.specifiers.length === 0), m.specifiers = [x(_)], this._resultName = f2(_), this;
    }
    named(D, _) {
      if (_ === "default")
        return this.default(D);
      const m = this._scope.generateUidIdentifier(D), L = this._statements[this._statements.length - 1];
      return s(L.type === "ImportDeclaration"), s(L.specifiers.length === 0), L.specifiers = [A(m, g(_))], this._resultName = f2(m), this;
    }
    var(D) {
      const _ = this._scope.generateUidIdentifier(D);
      let m = this._statements[this._statements.length - 1];
      return m.type !== "ExpressionStatement" && (s(this._resultName), m = p(this._resultName), this._statements.push(m)), this._statements[this._statements.length - 1] = T("var", [C(_, m.expression)]), this._resultName = f2(_), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(D) {
      const _ = this._statements[this._statements.length - 1];
      return _.type === "ExpressionStatement" ? _.expression = h(D, [_.expression]) : _.type === "VariableDeclaration" ? (s(_.declarations.length === 1), _.declarations[0].init = h(D, [_.declarations[0].init])) : s.fail("Unexpected type."), this;
    }
    prop(D) {
      const _ = this._statements[this._statements.length - 1];
      return _.type === "ExpressionStatement" ? _.expression = S(_.expression, g(D)) : _.type === "VariableDeclaration" ? (s(_.declarations.length === 1), _.declarations[0].init = S(_.declarations[0].init, g(D))) : s.fail("Unexpected type:" + _.type), this;
    }
    read(D) {
      this._resultName = S(this._resultName, g(D));
    }
  }
  return Ea.default = I, Ea;
}
var al = {};
var Zd;
function n0() {
  if (Zd)
    return al;
  Zd = 1, Object.defineProperty(al, "__esModule", {
    value: true
  }), al.default = s;
  function s(n) {
    const {
      sourceType: h
    } = n.node;
    if (h !== "module" && h !== "script")
      throw n.buildCodeFrameError(`Unknown sourceType "${h}", cannot transform.`);
    return n.node.sourceType === "module";
  }
  return al;
}
var em;
function O1() {
  if (em)
    return Sa;
  em = 1, Object.defineProperty(Sa, "__esModule", {
    value: true
  }), Sa.default = void 0;
  var s = Ra, n = Je(), h = k1(), f2 = n0();
  const {
    numericLiteral: p,
    sequenceExpression: g
  } = n;
  class P {
    constructor(y, A, S) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: false,
        ensureNoContext: false,
        importPosition: "before"
      };
      const v = y.find((T) => T.isProgram());
      this._programPath = v, this._programScope = v.scope, this._hub = v.hub, this._defaultOpts = this._applyDefaults(A, S, true);
    }
    addDefault(y, A) {
      return this.addNamed("default", y, A);
    }
    addNamed(y, A, S) {
      return s(typeof y == "string"), this._generateImport(this._applyDefaults(A, S), y);
    }
    addNamespace(y, A) {
      return this._generateImport(this._applyDefaults(y, A), null);
    }
    addSideEffect(y, A) {
      return this._generateImport(this._applyDefaults(y, A), void 0);
    }
    _applyDefaults(y, A, S = false) {
      let v;
      return typeof y == "string" ? v = Object.assign({}, this._defaultOpts, {
        importedSource: y
      }, A) : (s(!A, "Unexpected secondary arguments."), v = Object.assign({}, this._defaultOpts, y)), !S && A && (A.nameHint !== void 0 && (v.nameHint = A.nameHint), A.blockHoist !== void 0 && (v.blockHoist = A.blockHoist)), v;
    }
    _generateImport(y, A) {
      const S = A === "default", v = !!A && !S, T = A === null, {
        importedSource: C,
        importedType: I,
        importedInterop: N,
        importingInterop: D,
        ensureLiveReference: _,
        ensureNoContext: m,
        nameHint: L,
        importPosition: R,
        blockHoist: O
      } = y;
      let B = L || A;
      const M = (0, f2.default)(this._programPath), j = M && D === "node", $ = M && D === "babel";
      if (R === "after" && !M)
        throw new Error('"importPosition": "after" is only supported in modules');
      const k = new h.default(C, this._programScope, this._hub);
      if (I === "es6") {
        if (!j && !$)
          throw new Error("Cannot import an ES6 module from CommonJS");
        k.import(), T ? k.namespace(L || C) : (S || v) && k.named(B, A);
      } else {
        if (I !== "commonjs")
          throw new Error(`Unexpected interopType "${I}"`);
        if (N === "babel")
          if (j) {
            B = B !== "default" ? B : C;
            const q = `${C}$es6Default`;
            k.import(), T ? k.default(q).var(B || C).wildcardInterop() : S ? _ ? k.default(q).var(B || C).defaultInterop().read("default") : k.default(q).var(B).defaultInterop().prop(A) : v && k.default(q).read(A);
          } else
            $ ? (k.import(), T ? k.namespace(B || C) : (S || v) && k.named(B, A)) : (k.require(), T ? k.var(B || C).wildcardInterop() : (S || v) && _ ? S ? (B = B !== "default" ? B : C, k.var(B).read(A), k.defaultInterop()) : k.var(C).read(A) : S ? k.var(B).defaultInterop().prop(A) : v && k.var(B).prop(A));
        else if (N === "compiled")
          j ? (k.import(), T ? k.default(B || C) : (S || v) && k.default(C).read(B)) : $ ? (k.import(), T ? k.namespace(B || C) : (S || v) && k.named(B, A)) : (k.require(), T ? k.var(B || C) : (S || v) && (_ ? k.var(C).read(B) : k.prop(A).var(B)));
        else if (N === "uncompiled") {
          if (S && _)
            throw new Error("No live reference for commonjs default");
          j ? (k.import(), T ? k.default(B || C) : S ? k.default(B) : v && k.default(C).read(B)) : $ ? (k.import(), T ? k.default(B || C) : S ? k.default(B) : v && k.named(B, A)) : (k.require(), T ? k.var(B || C) : S ? k.var(B) : v && (_ ? k.var(C).read(B) : k.var(B).prop(A)));
        } else
          throw new Error(`Unknown importedInterop "${N}".`);
      }
      const {
        statements: ne,
        resultName: Q
      } = k.done();
      return this._insertStatements(ne, R, O), (S || v) && m && Q.type !== "Identifier" ? g([p(0), Q]) : Q;
    }
    _insertStatements(y, A = "before", S = 3) {
      const v = this._programPath.get("body");
      if (A === "after") {
        for (let T = v.length - 1; T >= 0; T--)
          if (v[T].isImportDeclaration()) {
            v[T].insertAfter(y);
            return;
          }
      } else {
        y.forEach((C) => {
          C._blockHoist = S;
        });
        const T = v.find((C) => {
          const I = C.node._blockHoist;
          return Number.isFinite(I) && I < 4;
        });
        if (T) {
          T.insertBefore(y);
          return;
        }
      }
      this._programPath.unshiftContainer("body", y);
    }
  }
  return Sa.default = P, Sa;
}
var tm;
function D1() {
  return tm || (tm = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "ImportInjector", {
      enumerable: true,
      get: function() {
        return n.default;
      }
    }), s.addDefault = f2, s.addNamed = p, s.addNamespace = g, s.addSideEffect = P, Object.defineProperty(s, "isModule", {
      enumerable: true,
      get: function() {
        return h.default;
      }
    });
    var n = O1(), h = n0();
    function f2(x, y, A) {
      return new n.default(x).addDefault(y, A);
    }
    function p(x, y, A, S) {
      return new n.default(x).addNamed(y, A, S);
    }
    function g(x, y, A) {
      return new n.default(x).addNamespace(y, A);
    }
    function P(x, y, A) {
      return new n.default(x).addSideEffect(y, A);
    }
  }(ac)), ac;
}
var ol = {};
var rm;
function L1() {
  if (rm)
    return ol;
  rm = 1, Object.defineProperty(ol, "__esModule", {
    value: true
  }), ol.default = g;
  var s = $i, n = qi(), h = Je();
  const {
    numericLiteral: f2,
    unaryExpression: p
  } = h;
  function g(x) {
    (0, n.default)(x.node, Object.assign({}, P, {
      noScope: true
    }));
  }
  const P = n.default.visitors.merge([s.default, {
    ThisExpression(x) {
      x.replaceWith(p("void", f2(0), true));
    }
  }]);
  return ol;
}
var ll = {};
var ul = {};
var sm;
function M1() {
  if (sm)
    return ul;
  sm = 1, Object.defineProperty(ul, "__esModule", {
    value: true
  }), ul.default = S;
  var s = Je();
  const {
    LOGICAL_OPERATORS: n,
    assignmentExpression: h,
    binaryExpression: f2,
    cloneNode: p,
    identifier: g,
    logicalExpression: P,
    numericLiteral: x,
    sequenceExpression: y,
    unaryExpression: A
  } = s;
  function S(T, C, I = true) {
    T.traverse(v, {
      scope: T.scope,
      bindingNames: C,
      seen: /* @__PURE__ */ new WeakSet(),
      includeUpdateExpression: I
    });
  }
  const v = {
    UpdateExpression: {
      exit(T) {
        const {
          scope: C,
          bindingNames: I,
          includeUpdateExpression: N
        } = this;
        if (!N)
          return;
        const D = T.get("argument");
        if (!D.isIdentifier())
          return;
        const _ = D.node.name;
        if (!!I.has(_) && C.getBinding(_) === T.scope.getBinding(_))
          if (T.parentPath.isExpressionStatement() && !T.isCompletionRecord()) {
            const m = T.node.operator == "++" ? "+=" : "-=";
            T.replaceWith(h(m, D.node, x(1)));
          } else if (T.node.prefix)
            T.replaceWith(h("=", g(_), f2(T.node.operator[0], A("+", D.node), x(1))));
          else {
            const m = T.scope.generateUidIdentifierBasedOnNode(D.node, "old"), L = m.name;
            T.scope.push({
              id: m
            });
            const R = f2(T.node.operator[0], g(L), x(1));
            T.replaceWith(y([h("=", g(L), A("+", D.node)), h("=", p(D.node), R), g(L)]));
          }
      }
    },
    AssignmentExpression: {
      exit(T) {
        const {
          scope: C,
          seen: I,
          bindingNames: N
        } = this;
        if (T.node.operator === "=" || I.has(T.node))
          return;
        I.add(T.node);
        const D = T.get("left");
        if (!D.isIdentifier())
          return;
        const _ = D.node.name;
        if (!N.has(_) || C.getBinding(_) !== T.scope.getBinding(_))
          return;
        const m = T.node.operator.slice(0, -1);
        n.includes(m) ? T.replaceWith(P(m, T.node.left, h("=", p(T.node.left), T.node.right))) : (T.node.right = f2(m, p(T.node.left), T.node.right), T.node.operator = "=");
      }
    }
  };
  return ul;
}
var im;
function B1() {
  if (im)
    return ll;
  im = 1, Object.defineProperty(ll, "__esModule", {
    value: true
  }), ll.default = O;
  var s = Ra, n = Je(), h = Pn(), f2 = M1();
  const {
    assignmentExpression: p,
    callExpression: g,
    cloneNode: P,
    expressionStatement: x,
    getOuterBindingIdentifiers: y,
    identifier: A,
    isMemberExpression: S,
    isVariableDeclaration: v,
    jsxIdentifier: T,
    jsxMemberExpression: C,
    memberExpression: I,
    numericLiteral: N,
    sequenceExpression: D,
    stringLiteral: _,
    variableDeclaration: m,
    variableDeclarator: L
  } = n;
  function R(k) {
    do
      switch (k.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return true;
        case "ExportSpecifier":
          return k.parentPath.parent.exportKind === "type";
        default:
          if (k.parentPath.isStatement() || k.parentPath.isExpression())
            return false;
      }
    while (k = k.parentPath);
  }
  function O(k, ne) {
    const Q = /* @__PURE__ */ new Map(), q = /* @__PURE__ */ new Map(), ee = (V) => {
      k.requeue(V);
    };
    for (const [V, F] of ne.source) {
      for (const [le, oe] of F.imports)
        Q.set(le, [V, oe, null]);
      for (const le of F.importsNamespace)
        Q.set(le, [V, null, le]);
    }
    for (const [V, F] of ne.local) {
      let le = q.get(V);
      le || (le = [], q.set(V, le)), le.push(...F.names);
    }
    const K = {
      metadata: ne,
      requeueInParent: ee,
      scope: k.scope,
      exported: q
    };
    k.traverse(B, K), (0, f2.default)(k, /* @__PURE__ */ new Set([...Array.from(Q.keys()), ...Array.from(q.keys())]), false);
    const G = {
      seen: /* @__PURE__ */ new WeakSet(),
      metadata: ne,
      requeueInParent: ee,
      scope: k.scope,
      imported: Q,
      exported: q,
      buildImportReference: ([V, F, le], oe) => {
        const fe = ne.source.get(V);
        if (le)
          return fe.lazy && (oe = g(oe, [])), oe;
        let he = A(fe.name);
        if (fe.lazy && (he = g(he, [])), F === "default" && fe.interop === "node-default")
          return he;
        const de = ne.stringSpecifiers.has(F);
        return I(he, de ? _(F) : A(F), de);
      }
    };
    k.traverse($, G);
  }
  const B = {
    Scope(k) {
      k.skip();
    },
    ClassDeclaration(k) {
      const {
        requeueInParent: ne,
        exported: Q,
        metadata: q
      } = this, {
        id: ee
      } = k.node;
      if (!ee)
        throw new Error("Expected class to have a name");
      const K = ee.name, G = Q.get(K) || [];
      if (G.length > 0) {
        const V = x(M(q, G, A(K), k.scope));
        V._blockHoist = k.node._blockHoist, ne(k.insertAfter(V)[0]);
      }
    },
    VariableDeclaration(k) {
      const {
        requeueInParent: ne,
        exported: Q,
        metadata: q
      } = this;
      Object.keys(k.getOuterBindingIdentifiers()).forEach((ee) => {
        const K = Q.get(ee) || [];
        if (K.length > 0) {
          const G = x(M(q, K, A(ee), k.scope));
          G._blockHoist = k.node._blockHoist, ne(k.insertAfter(G)[0]);
        }
      });
    }
  }, M = (k, ne, Q, q) => {
    const ee = k.exportName;
    for (let K = q; K != null; K = K.parent)
      K.hasOwnBinding(ee) && K.rename(ee);
    return (ne || []).reduce((K, G) => {
      const {
        stringSpecifiers: V
      } = k, F = V.has(G);
      return p("=", I(A(ee), F ? _(G) : A(G), F), K);
    }, Q);
  }, j = (k) => h.default.expression.ast`
	    (function() {
	      throw new Error('"' + '${k}' + '" is read-only.');
	    })()
	  `, $ = {
    ReferencedIdentifier(k) {
      const {
        seen: ne,
        buildImportReference: Q,
        scope: q,
        imported: ee,
        requeueInParent: K
      } = this;
      if (ne.has(k.node))
        return;
      ne.add(k.node);
      const G = k.node.name, V = ee.get(G);
      if (V) {
        if (R(k))
          throw k.buildCodeFrameError(`Cannot transform the imported binding "${G}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        const F = k.scope.getBinding(G);
        if (q.getBinding(G) !== F)
          return;
        const oe = Q(V, k.node);
        if (oe.loc = k.node.loc, (k.parentPath.isCallExpression({
          callee: k.node
        }) || k.parentPath.isOptionalCallExpression({
          callee: k.node
        }) || k.parentPath.isTaggedTemplateExpression({
          tag: k.node
        })) && S(oe))
          k.replaceWith(D([N(0), oe]));
        else if (k.isJSXIdentifier() && S(oe)) {
          const {
            object: fe,
            property: he
          } = oe;
          k.replaceWith(C(T(fe.name), T(he.name)));
        } else
          k.replaceWith(oe);
        K(k), k.skip();
      }
    },
    UpdateExpression(k) {
      const {
        scope: ne,
        seen: Q,
        imported: q,
        exported: ee,
        requeueInParent: K,
        buildImportReference: G
      } = this;
      if (Q.has(k.node))
        return;
      Q.add(k.node);
      const V = k.get("argument");
      if (V.isMemberExpression())
        return;
      const F = k.node;
      if (V.isIdentifier()) {
        const le = V.node.name;
        if (ne.getBinding(le) !== k.scope.getBinding(le))
          return;
        const oe = ee.get(le), fe = q.get(le);
        if ((oe == null ? void 0 : oe.length) > 0 || fe)
          if (fe)
            k.replaceWith(p(F.operator[0] + "=", G(fe, V.node), j(le)));
          else if (F.prefix)
            k.replaceWith(M(this.metadata, oe, P(F), k.scope));
          else {
            const he = ne.generateDeclaredUidIdentifier(le);
            k.replaceWith(D([p("=", P(he), P(F)), M(this.metadata, oe, A(le), k.scope), P(he)]));
          }
      }
      K(k), k.skip();
    },
    AssignmentExpression: {
      exit(k) {
        const {
          scope: ne,
          seen: Q,
          imported: q,
          exported: ee,
          requeueInParent: K,
          buildImportReference: G
        } = this;
        if (Q.has(k.node))
          return;
        Q.add(k.node);
        const V = k.get("left");
        if (!V.isMemberExpression())
          if (V.isIdentifier()) {
            const F = V.node.name;
            if (ne.getBinding(F) !== k.scope.getBinding(F))
              return;
            const le = ee.get(F), oe = q.get(F);
            if ((le == null ? void 0 : le.length) > 0 || oe) {
              s(k.node.operator === "=", "Path was not simplified");
              const fe = k.node;
              oe && (fe.left = G(oe, V.node), fe.right = D([fe.right, j(F)])), k.replaceWith(M(this.metadata, le, fe, k.scope)), K(k);
            }
          } else {
            const F = V.getOuterBindingIdentifiers(), le = Object.keys(F).filter((he) => ne.getBinding(he) === k.scope.getBinding(he)), oe = le.find((he) => q.has(he));
            oe && (k.node.right = D([k.node.right, j(oe)]));
            const fe = [];
            if (le.forEach((he) => {
              const de = ee.get(he) || [];
              de.length > 0 && fe.push(M(this.metadata, de, A(he), k.scope));
            }), fe.length > 0) {
              let he = D(fe);
              k.parentPath.isExpressionStatement() && (he = x(he), he._blockHoist = k.parentPath.node._blockHoist);
              const de = k.insertAfter(he)[0];
              K(de);
            }
          }
      }
    },
    "ForOfStatement|ForInStatement"(k) {
      const {
        scope: ne,
        node: Q
      } = k, {
        left: q
      } = Q, {
        exported: ee,
        imported: K,
        scope: G
      } = this;
      if (!v(q)) {
        let V = false, F;
        const le = k.get("body").scope;
        for (const he of Object.keys(y(q)))
          G.getBinding(he) === ne.getBinding(he) && (ee.has(he) && (V = true, le.hasOwnBinding(he) && le.rename(he)), K.has(he) && !F && (F = he));
        if (!V && !F)
          return;
        k.ensureBlock();
        const oe = k.get("body"), fe = ne.generateUidIdentifierBasedOnNode(q);
        k.get("left").replaceWith(m("let", [L(P(fe))])), ne.registerDeclaration(k.get("left")), V && oe.unshiftContainer("body", x(p("=", q, fe))), F && oe.unshiftContainer("body", x(j(F)));
      }
    }
  };
  return ll;
}
var dn = {};
var oc;
var nm;
function an() {
  if (nm)
    return oc;
  nm = 1;
  function s(p) {
    if (typeof p != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(p));
  }
  function n(p, g) {
    for (var P = "", x = 0, y = -1, A = 0, S, v = 0; v <= p.length; ++v) {
      if (v < p.length)
        S = p.charCodeAt(v);
      else {
        if (S === 47)
          break;
        S = 47;
      }
      if (S === 47) {
        if (!(y === v - 1 || A === 1))
          if (y !== v - 1 && A === 2) {
            if (P.length < 2 || x !== 2 || P.charCodeAt(P.length - 1) !== 46 || P.charCodeAt(P.length - 2) !== 46) {
              if (P.length > 2) {
                var T = P.lastIndexOf("/");
                if (T !== P.length - 1) {
                  T === -1 ? (P = "", x = 0) : (P = P.slice(0, T), x = P.length - 1 - P.lastIndexOf("/")), y = v, A = 0;
                  continue;
                }
              } else if (P.length === 2 || P.length === 1) {
                P = "", x = 0, y = v, A = 0;
                continue;
              }
            }
            g && (P.length > 0 ? P += "/.." : P = "..", x = 2);
          } else
            P.length > 0 ? P += "/" + p.slice(y + 1, v) : P = p.slice(y + 1, v), x = v - y - 1;
        y = v, A = 0;
      } else
        S === 46 && A !== -1 ? ++A : A = -1;
    }
    return P;
  }
  function h(p, g) {
    var P = g.dir || g.root, x = g.base || (g.name || "") + (g.ext || "");
    return P ? P === g.root ? P + x : P + p + x : x;
  }
  var f2 = {
    resolve: function() {
      for (var g = "", P = false, x, y = arguments.length - 1; y >= -1 && !P; y--) {
        var A;
        y >= 0 ? A = arguments[y] : (x === void 0 && (x = process.cwd()), A = x), s(A), A.length !== 0 && (g = A + "/" + g, P = A.charCodeAt(0) === 47);
      }
      return g = n(g, !P), P ? g.length > 0 ? "/" + g : "/" : g.length > 0 ? g : ".";
    },
    normalize: function(g) {
      if (s(g), g.length === 0)
        return ".";
      var P = g.charCodeAt(0) === 47, x = g.charCodeAt(g.length - 1) === 47;
      return g = n(g, !P), g.length === 0 && !P && (g = "."), g.length > 0 && x && (g += "/"), P ? "/" + g : g;
    },
    isAbsolute: function(g) {
      return s(g), g.length > 0 && g.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var g, P = 0; P < arguments.length; ++P) {
        var x = arguments[P];
        s(x), x.length > 0 && (g === void 0 ? g = x : g += "/" + x);
      }
      return g === void 0 ? "." : f2.normalize(g);
    },
    relative: function(g, P) {
      if (s(g), s(P), g === P || (g = f2.resolve(g), P = f2.resolve(P), g === P))
        return "";
      for (var x = 1; x < g.length && g.charCodeAt(x) === 47; ++x)
        ;
      for (var y = g.length, A = y - x, S = 1; S < P.length && P.charCodeAt(S) === 47; ++S)
        ;
      for (var v = P.length, T = v - S, C = A < T ? A : T, I = -1, N = 0; N <= C; ++N) {
        if (N === C) {
          if (T > C) {
            if (P.charCodeAt(S + N) === 47)
              return P.slice(S + N + 1);
            if (N === 0)
              return P.slice(S + N);
          } else
            A > C && (g.charCodeAt(x + N) === 47 ? I = N : N === 0 && (I = 0));
          break;
        }
        var D = g.charCodeAt(x + N), _ = P.charCodeAt(S + N);
        if (D !== _)
          break;
        D === 47 && (I = N);
      }
      var m = "";
      for (N = x + I + 1; N <= y; ++N)
        (N === y || g.charCodeAt(N) === 47) && (m.length === 0 ? m += ".." : m += "/..");
      return m.length > 0 ? m + P.slice(S + I) : (S += I, P.charCodeAt(S) === 47 && ++S, P.slice(S));
    },
    _makeLong: function(g) {
      return g;
    },
    dirname: function(g) {
      if (s(g), g.length === 0)
        return ".";
      for (var P = g.charCodeAt(0), x = P === 47, y = -1, A = true, S = g.length - 1; S >= 1; --S)
        if (P = g.charCodeAt(S), P === 47) {
          if (!A) {
            y = S;
            break;
          }
        } else
          A = false;
      return y === -1 ? x ? "/" : "." : x && y === 1 ? "//" : g.slice(0, y);
    },
    basename: function(g, P) {
      if (P !== void 0 && typeof P != "string")
        throw new TypeError('"ext" argument must be a string');
      s(g);
      var x = 0, y = -1, A = true, S;
      if (P !== void 0 && P.length > 0 && P.length <= g.length) {
        if (P.length === g.length && P === g)
          return "";
        var v = P.length - 1, T = -1;
        for (S = g.length - 1; S >= 0; --S) {
          var C = g.charCodeAt(S);
          if (C === 47) {
            if (!A) {
              x = S + 1;
              break;
            }
          } else
            T === -1 && (A = false, T = S + 1), v >= 0 && (C === P.charCodeAt(v) ? --v === -1 && (y = S) : (v = -1, y = T));
        }
        return x === y ? y = T : y === -1 && (y = g.length), g.slice(x, y);
      } else {
        for (S = g.length - 1; S >= 0; --S)
          if (g.charCodeAt(S) === 47) {
            if (!A) {
              x = S + 1;
              break;
            }
          } else
            y === -1 && (A = false, y = S + 1);
        return y === -1 ? "" : g.slice(x, y);
      }
    },
    extname: function(g) {
      s(g);
      for (var P = -1, x = 0, y = -1, A = true, S = 0, v = g.length - 1; v >= 0; --v) {
        var T = g.charCodeAt(v);
        if (T === 47) {
          if (!A) {
            x = v + 1;
            break;
          }
          continue;
        }
        y === -1 && (A = false, y = v + 1), T === 46 ? P === -1 ? P = v : S !== 1 && (S = 1) : P !== -1 && (S = -1);
      }
      return P === -1 || y === -1 || S === 0 || S === 1 && P === y - 1 && P === x + 1 ? "" : g.slice(P, y);
    },
    format: function(g) {
      if (g === null || typeof g != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof g);
      return h("/", g);
    },
    parse: function(g) {
      s(g);
      var P = { root: "", dir: "", base: "", ext: "", name: "" };
      if (g.length === 0)
        return P;
      var x = g.charCodeAt(0), y = x === 47, A;
      y ? (P.root = "/", A = 1) : A = 0;
      for (var S = -1, v = 0, T = -1, C = true, I = g.length - 1, N = 0; I >= A; --I) {
        if (x = g.charCodeAt(I), x === 47) {
          if (!C) {
            v = I + 1;
            break;
          }
          continue;
        }
        T === -1 && (C = false, T = I + 1), x === 46 ? S === -1 ? S = I : N !== 1 && (N = 1) : S !== -1 && (N = -1);
      }
      return S === -1 || T === -1 || N === 0 || N === 1 && S === T - 1 && S === v + 1 ? T !== -1 && (v === 0 && y ? P.base = P.name = g.slice(1, T) : P.base = P.name = g.slice(v, T)) : (v === 0 && y ? (P.name = g.slice(1, S), P.base = g.slice(1, T)) : (P.name = g.slice(v, S), P.base = g.slice(v, T)), P.ext = g.slice(S, T)), v > 0 ? P.dir = g.slice(0, v - 1) : y && (P.dir = "/"), P;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return f2.posix = f2, oc = f2, oc;
}
var am;
function _1() {
  if (am)
    return dn;
  am = 1, Object.defineProperty(dn, "__esModule", {
    value: true
  }), dn.default = x, dn.hasExports = f2, dn.isSideEffectImport = p, dn.validateImportInteropOption = g;
  var s = an(), n = Ba(), h = Fa;
  function f2(I) {
    return I.hasExports;
  }
  function p(I) {
    return I.imports.size === 0 && I.importsNamespace.size === 0 && I.reexports.size === 0 && I.reexportNamespace.size === 0 && !I.reexportAll;
  }
  function g(I) {
    if (typeof I != "function" && I !== "none" && I !== "babel" && I !== "node")
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${I}).`);
    return I;
  }
  function P(I, N, D) {
    return typeof I == "function" ? g(I(N, D)) : I;
  }
  function x(I, N, {
    importInterop: D,
    initializeReexports: _ = false,
    lazy: m = false,
    esNamespaceOnly: L = false,
    filename: R
  }) {
    N || (N = I.scope.generateUidIdentifier("exports").name);
    const O = /* @__PURE__ */ new Set();
    T(I);
    const {
      local: B,
      source: M,
      hasExports: j
    } = S(I, {
      initializeReexports: _,
      lazy: m
    }, O);
    C(I);
    for (const [, $] of M) {
      $.importsNamespace.size > 0 && ($.name = $.importsNamespace.values().next().value);
      const k = P(D, $.source, R);
      k === "none" ? $.interop = "none" : k === "node" && $.interop === "namespace" ? $.interop = "node-namespace" : k === "node" && $.interop === "default" ? $.interop = "node-default" : L && $.interop === "namespace" && ($.interop = "default");
    }
    return {
      exportName: N,
      exportNameListName: null,
      hasExports: j,
      local: B,
      source: M,
      stringSpecifiers: O
    };
  }
  function y(I, N) {
    if (I.isIdentifier())
      return I.node.name;
    if (I.isStringLiteral()) {
      const D = I.node.value;
      return (0, n.isIdentifierName)(D) || N.add(D), D;
    } else
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${I.node.type}`);
  }
  function A(I) {
    if (!I.isExportSpecifier())
      throw I.isExportNamespaceSpecifier() ? I.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.") : I.buildCodeFrameError("Unexpected export specifier type");
  }
  function S(I, {
    lazy: N,
    initializeReexports: D
  }, _) {
    const m = v(I, D, _), L = /* @__PURE__ */ new Map(), R = (B) => {
      const M = B.value;
      let j = L.get(M);
      return j || (j = {
        name: I.scope.generateUidIdentifier((0, s.basename)(M, (0, s.extname)(M))).name,
        interop: "none",
        loc: null,
        imports: /* @__PURE__ */ new Map(),
        importsNamespace: /* @__PURE__ */ new Set(),
        reexports: /* @__PURE__ */ new Map(),
        reexportNamespace: /* @__PURE__ */ new Set(),
        reexportAll: null,
        lazy: false,
        source: M
      }, L.set(M, j)), j;
    };
    let O = false;
    I.get("body").forEach((B) => {
      if (B.isImportDeclaration()) {
        const M = R(B.node.source);
        M.loc || (M.loc = B.node.loc), B.get("specifiers").forEach((j) => {
          if (j.isImportDefaultSpecifier()) {
            const $ = j.get("local").node.name;
            M.imports.set($, "default");
            const k = m.get($);
            k && (m.delete($), k.names.forEach((ne) => {
              M.reexports.set(ne, "default");
            }));
          } else if (j.isImportNamespaceSpecifier()) {
            const $ = j.get("local").node.name;
            M.importsNamespace.add($);
            const k = m.get($);
            k && (m.delete($), k.names.forEach((ne) => {
              M.reexportNamespace.add(ne);
            }));
          } else if (j.isImportSpecifier()) {
            const $ = y(j.get("imported"), _), k = j.get("local").node.name;
            M.imports.set(k, $);
            const ne = m.get(k);
            ne && (m.delete(k), ne.names.forEach((Q) => {
              M.reexports.set(Q, $);
            }));
          }
        });
      } else if (B.isExportAllDeclaration()) {
        O = true;
        const M = R(B.node.source);
        M.loc || (M.loc = B.node.loc), M.reexportAll = {
          loc: B.node.loc
        };
      } else if (B.isExportNamedDeclaration() && B.node.source) {
        O = true;
        const M = R(B.node.source);
        M.loc || (M.loc = B.node.loc), B.get("specifiers").forEach((j) => {
          A(j);
          const $ = y(j.get("local"), _), k = y(j.get("exported"), _);
          if (M.reexports.set(k, $), k === "__esModule")
            throw j.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        });
      } else
        (B.isExportNamedDeclaration() || B.isExportDefaultDeclaration()) && (O = true);
    });
    for (const B of L.values()) {
      let M = false, j = false;
      B.importsNamespace.size > 0 && (M = true, j = true), B.reexportAll && (j = true);
      for (const $ of B.imports.values())
        $ === "default" ? M = true : j = true;
      for (const $ of B.reexports.values())
        $ === "default" ? M = true : j = true;
      M && j ? B.interop = "namespace" : M && (B.interop = "default");
    }
    for (const [B, M] of L)
      if (N !== false && !(p(M) || M.reexportAll))
        if (N === true)
          M.lazy = !/\./.test(B);
        else if (Array.isArray(N))
          M.lazy = N.indexOf(B) !== -1;
        else if (typeof N == "function")
          M.lazy = N(B);
        else
          throw new Error(".lazy must be a boolean, string array, or function");
    return {
      hasExports: O,
      local: m,
      source: L
    };
  }
  function v(I, N, D) {
    const _ = /* @__PURE__ */ new Map();
    I.get("body").forEach((R) => {
      let O;
      if (R.isImportDeclaration())
        O = "import";
      else {
        if (R.isExportDefaultDeclaration() && (R = R.get("declaration")), R.isExportNamedDeclaration()) {
          if (R.node.declaration)
            R = R.get("declaration");
          else if (N && R.node.source && R.get("source").isStringLiteral()) {
            R.get("specifiers").forEach((B) => {
              A(B), _.set(B.get("local").node.name, "block");
            });
            return;
          }
        }
        if (R.isFunctionDeclaration())
          O = "hoisted";
        else if (R.isClassDeclaration())
          O = "block";
        else if (R.isVariableDeclaration({
          kind: "var"
        }))
          O = "var";
        else if (R.isVariableDeclaration())
          O = "block";
        else
          return;
      }
      Object.keys(R.getOuterBindingIdentifiers()).forEach((B) => {
        _.set(B, O);
      });
    });
    const m = /* @__PURE__ */ new Map(), L = (R) => {
      const O = R.node.name;
      let B = m.get(O);
      if (!B) {
        const M = _.get(O);
        if (M === void 0)
          throw R.buildCodeFrameError(`Exporting local "${O}", which is not declared.`);
        B = {
          names: [],
          kind: M
        }, m.set(O, B);
      }
      return B;
    };
    return I.get("body").forEach((R) => {
      if (R.isExportNamedDeclaration() && (N || !R.node.source))
        if (R.node.declaration) {
          const O = R.get("declaration"), B = O.getOuterBindingIdentifierPaths();
          Object.keys(B).forEach((M) => {
            if (M === "__esModule")
              throw O.buildCodeFrameError('Illegal export "__esModule".');
            L(B[M]).names.push(M);
          });
        } else
          R.get("specifiers").forEach((O) => {
            const B = O.get("local"), M = O.get("exported"), j = L(B), $ = y(M, D);
            if ($ === "__esModule")
              throw M.buildCodeFrameError('Illegal export "__esModule".');
            j.names.push($);
          });
      else if (R.isExportDefaultDeclaration()) {
        const O = R.get("declaration");
        if (O.isFunctionDeclaration() || O.isClassDeclaration())
          L(O.get("id")).names.push("default");
        else
          throw O.buildCodeFrameError("Unexpected default expression export.");
      }
    }), m;
  }
  function T(I) {
    I.get("body").forEach((N) => {
      !N.isExportDefaultDeclaration() || (0, h.default)(N);
    });
  }
  function C(I) {
    I.get("body").forEach((N) => {
      if (N.isImportDeclaration())
        N.remove();
      else if (N.isExportNamedDeclaration())
        N.node.declaration ? (N.node.declaration._blockHoist = N.node._blockHoist, N.replaceWith(N.node.declaration)) : N.remove();
      else if (N.isExportDefaultDeclaration()) {
        const D = N.get("declaration");
        if (D.isFunctionDeclaration() || D.isClassDeclaration())
          D._blockHoist = N.node._blockHoist, N.replaceWith(D);
        else
          throw D.buildCodeFrameError("Unexpected default expression export.");
      } else
        N.isExportAllDeclaration() && N.remove();
    });
  }
  return dn;
}
var va = {};
var om;
function F1() {
  if (om)
    return va;
  om = 1, Object.defineProperty(va, "__esModule", {
    value: true
  }), va.default = s;
  {
    const n = s;
    va.default = s = function(f2, p) {
      var g, P, x, y;
      return n(f2, {
        moduleId: (g = p.moduleId) != null ? g : f2.moduleId,
        moduleIds: (P = p.moduleIds) != null ? P : f2.moduleIds,
        getModuleId: (x = p.getModuleId) != null ? x : f2.getModuleId,
        moduleRoot: (y = p.moduleRoot) != null ? y : f2.moduleRoot
      });
    };
  }
  function s(n, h) {
    const {
      filename: f2,
      filenameRelative: p = f2,
      sourceRoot: g = h.moduleRoot
    } = n, {
      moduleId: P,
      moduleIds: x = !!P,
      getModuleId: y,
      moduleRoot: A = g
    } = h;
    if (!x)
      return null;
    if (P != null && !y)
      return P;
    let S = A != null ? A + "/" : "";
    if (p) {
      const v = g != null ? new RegExp("^" + g + "/?") : "";
      S += p.replace(v, "").replace(/\.(\w*?)$/, "");
    }
    return S = S.replace(/\\/g, "/"), y && y(S) || S;
  }
  return va;
}
var lm;
function j1() {
  return lm || (lm = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), s.buildNamespaceInitStatements = $, s.ensureStatementsHoisted = M, Object.defineProperty(s, "getModuleName", {
      enumerable: true,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(s, "hasExports", {
      enumerable: true,
      get: function() {
        return x.hasExports;
      }
    }), Object.defineProperty(s, "isModule", {
      enumerable: true,
      get: function() {
        return p.isModule;
      }
    }), Object.defineProperty(s, "isSideEffectImport", {
      enumerable: true,
      get: function() {
        return x.isSideEffectImport;
      }
    }), s.rewriteModuleStatementsAndPrepareHeader = B, Object.defineProperty(s, "rewriteThis", {
      enumerable: true,
      get: function() {
        return g.default;
      }
    }), s.wrapInterop = j;
    var n = Ra, h = Je(), f2 = Pn(), p = D1(), g = L1(), P = B1(), x = _1(), y = F1();
    const {
      booleanLiteral: A,
      callExpression: S,
      cloneNode: v,
      directive: T,
      directiveLiteral: C,
      expressionStatement: I,
      identifier: N,
      isIdentifier: D,
      memberExpression: _,
      stringLiteral: m,
      valueToNode: L,
      variableDeclaration: R,
      variableDeclarator: O
    } = h;
    function B(F, {
      loose: le,
      exportName: oe,
      strict: fe,
      allowTopLevelThis: he,
      strictMode: de,
      noInterop: Pe,
      importInterop: we = Pe ? "none" : "babel",
      lazy: H,
      esNamespaceOnly: te,
      filename: Ie,
      constantReexports: Te = le,
      enumerableModuleMeta: pe = le,
      noIncompleteNsImportDetection: z
    }) {
      (0, x.validateImportInteropOption)(we), n((0, p.isModule)(F), "Cannot process module statements in a script"), F.node.sourceType = "script";
      const W = (0, x.default)(F, oe, {
        importInterop: we,
        initializeReexports: Te,
        lazy: H,
        esNamespaceOnly: te,
        filename: Ie
      });
      he || (0, g.default)(F), (0, P.default)(F, W), de !== false && (F.node.directives.some((Se) => Se.value.value === "use strict") || F.unshiftContainer("directives", T(C("use strict"))));
      const ae = [];
      (0, x.hasExports)(W) && !fe && ae.push(Q(W, pe));
      const ce = ee(F, W);
      return ce && (W.exportNameListName = ce.name, ae.push(ce.statement)), ae.push(...K(F, W, Te, z)), {
        meta: W,
        headers: ae
      };
    }
    function M(F) {
      F.forEach((le) => {
        le._blockHoist = 3;
      });
    }
    function j(F, le, oe) {
      if (oe === "none")
        return null;
      if (oe === "node-namespace")
        return S(F.hub.addHelper("interopRequireWildcard"), [le, A(true)]);
      if (oe === "node-default")
        return null;
      let fe;
      if (oe === "default")
        fe = "interopRequireDefault";
      else if (oe === "namespace")
        fe = "interopRequireWildcard";
      else
        throw new Error(`Unknown interop: ${oe}`);
      return S(F.hub.addHelper(fe), [le]);
    }
    function $(F, le, oe = false) {
      const fe = [];
      let he = N(le.name);
      le.lazy && (he = S(he, []));
      for (const de of le.importsNamespace)
        de !== le.name && fe.push(f2.default.statement`var NAME = SOURCE;`({
          NAME: de,
          SOURCE: v(he)
        }));
      oe && fe.push(...ne(F, le, true));
      for (const de of le.reexportNamespace)
        fe.push((le.lazy ? f2.default.statement`
		            Object.defineProperty(EXPORTS, "NAME", {
		              enumerable: true,
		              get: function() {
		                return NAMESPACE;
		              }
		            });
		          ` : f2.default.statement`EXPORTS.NAME = NAMESPACE;`)({
          EXPORTS: F.exportName,
          NAME: de,
          NAMESPACE: v(he)
        }));
      if (le.reexportAll) {
        const de = q(F, v(he), oe);
        de.loc = le.reexportAll.loc, fe.push(de);
      }
      return fe;
    }
    const k = {
      constant: f2.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,
      constantComputed: f2.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,
      spec: f2.default.statement`
		    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
		      enumerable: true,
		      get: function() {
		        return NAMESPACE_IMPORT;
		      },
		    });
		    `
    }, ne = (F, le, oe) => {
      const fe = le.lazy ? S(N(le.name), []) : N(le.name), {
        stringSpecifiers: he
      } = F;
      return Array.from(le.reexports, ([de, Pe]) => {
        let we = v(fe);
        Pe === "default" && le.interop === "node-default" || (he.has(Pe) ? we = _(we, m(Pe), true) : we = _(we, N(Pe)));
        const H = {
          EXPORTS: F.exportName,
          EXPORT_NAME: de,
          NAMESPACE_IMPORT: we
        };
        return oe || D(we) ? he.has(de) ? k.constantComputed(H) : k.constant(H) : k.spec(H);
      });
    };
    function Q(F, le = false) {
      return (le ? f2.default.statement`
		        EXPORTS.__esModule = true;
		      ` : f2.default.statement`
		        Object.defineProperty(EXPORTS, "__esModule", {
		          value: true,
		        });
		      `)({
        EXPORTS: F.exportName
      });
    }
    function q(F, le, oe) {
      return (oe ? f2.default.statement`
		        Object.keys(NAMESPACE).forEach(function(key) {
		          if (key === "default" || key === "__esModule") return;
		          VERIFY_NAME_LIST;
		          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

		          EXPORTS[key] = NAMESPACE[key];
		        });
		      ` : f2.default.statement`
		        Object.keys(NAMESPACE).forEach(function(key) {
		          if (key === "default" || key === "__esModule") return;
		          VERIFY_NAME_LIST;
		          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

		          Object.defineProperty(EXPORTS, key, {
		            enumerable: true,
		            get: function() {
		              return NAMESPACE[key];
		            },
		          });
		        });
		    `)({
        NAMESPACE: le,
        EXPORTS: F.exportName,
        VERIFY_NAME_LIST: F.exportNameListName ? (0, f2.default)`
		            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
		          `({
          EXPORTS_LIST: F.exportNameListName
        }) : null
      });
    }
    function ee(F, le) {
      const oe = /* @__PURE__ */ Object.create(null);
      for (const de of le.local.values())
        for (const Pe of de.names)
          oe[Pe] = true;
      let fe = false;
      for (const de of le.source.values()) {
        for (const Pe of de.reexports.keys())
          oe[Pe] = true;
        for (const Pe of de.reexportNamespace)
          oe[Pe] = true;
        fe = fe || !!de.reexportAll;
      }
      if (!fe || Object.keys(oe).length === 0)
        return null;
      const he = F.scope.generateUidIdentifier("exportNames");
      return delete oe.default, {
        name: he.name,
        statement: R("var", [O(he, L(oe))])
      };
    }
    function K(F, le, oe = false, fe = false) {
      const he = [];
      for (const [Pe, we] of le.local)
        if (we.kind !== "import") {
          if (we.kind === "hoisted")
            he.push([we.names[0], V(le, we.names, N(Pe))]);
          else if (!fe)
            for (const H of we.names)
              he.push([H, null]);
        }
      for (const Pe of le.source.values()) {
        if (!oe) {
          const we = ne(le, Pe, false), H = [...Pe.reexports.keys()];
          for (let te = 0; te < we.length; te++)
            he.push([H[te], we[te]]);
        }
        if (!fe)
          for (const we of Pe.reexportNamespace)
            he.push([we, null]);
      }
      he.sort(([Pe], [we]) => Pe < we ? -1 : we < Pe ? 1 : 0);
      const de = [];
      if (fe)
        for (const [, Pe] of he)
          de.push(Pe);
      else
        for (let we = 0; we < he.length; we += 100) {
          let H = [];
          for (let te = 0; te < 100 && we + te < he.length; te++) {
            const [Ie, Te] = he[we + te];
            Te !== null ? (H.length > 0 && (de.push(V(le, H, F.scope.buildUndefinedNode())), H = []), de.push(Te)) : H.push(Ie);
          }
          H.length > 0 && de.push(V(le, H, F.scope.buildUndefinedNode()));
        }
      return de;
    }
    const G = {
      computed: f2.default.expression`EXPORTS["NAME"] = VALUE`,
      default: f2.default.expression`EXPORTS.NAME = VALUE`
    };
    function V(F, le, oe) {
      const {
        stringSpecifiers: fe,
        exportName: he
      } = F;
      return I(le.reduce((de, Pe) => {
        const we = {
          EXPORTS: he,
          NAME: Pe,
          VALUE: de
        };
        return fe.has(Pe) ? G.computed(we) : G.default(we);
      }, oe));
    }
  }(nc)), nc;
}
var cl = { exports: {} };
var um;
function Hn() {
  return um || (um = 1, function(s, n) {
    n = s.exports = m;
    var h;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? h = function() {
      var re = Array.prototype.slice.call(arguments, 0);
      re.unshift("SEMVER"), console.log.apply(console, re);
    } : h = function() {
    }, n.SEMVER_SPEC_VERSION = "2.0.0";
    var f2 = 256, p = Number.MAX_SAFE_INTEGER || 9007199254740991, g = 16, P = n.re = [], x = n.src = [], y = n.tokens = {}, A = 0;
    function S(re) {
      y[re] = A++;
    }
    S("NUMERICIDENTIFIER"), x[y.NUMERICIDENTIFIER] = "0|[1-9]\\d*", S("NUMERICIDENTIFIERLOOSE"), x[y.NUMERICIDENTIFIERLOOSE] = "[0-9]+", S("NONNUMERICIDENTIFIER"), x[y.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", S("MAINVERSION"), x[y.MAINVERSION] = "(" + x[y.NUMERICIDENTIFIER] + ")\\.(" + x[y.NUMERICIDENTIFIER] + ")\\.(" + x[y.NUMERICIDENTIFIER] + ")", S("MAINVERSIONLOOSE"), x[y.MAINVERSIONLOOSE] = "(" + x[y.NUMERICIDENTIFIERLOOSE] + ")\\.(" + x[y.NUMERICIDENTIFIERLOOSE] + ")\\.(" + x[y.NUMERICIDENTIFIERLOOSE] + ")", S("PRERELEASEIDENTIFIER"), x[y.PRERELEASEIDENTIFIER] = "(?:" + x[y.NUMERICIDENTIFIER] + "|" + x[y.NONNUMERICIDENTIFIER] + ")", S("PRERELEASEIDENTIFIERLOOSE"), x[y.PRERELEASEIDENTIFIERLOOSE] = "(?:" + x[y.NUMERICIDENTIFIERLOOSE] + "|" + x[y.NONNUMERICIDENTIFIER] + ")", S("PRERELEASE"), x[y.PRERELEASE] = "(?:-(" + x[y.PRERELEASEIDENTIFIER] + "(?:\\." + x[y.PRERELEASEIDENTIFIER] + ")*))", S("PRERELEASELOOSE"), x[y.PRERELEASELOOSE] = "(?:-?(" + x[y.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + x[y.PRERELEASEIDENTIFIERLOOSE] + ")*))", S("BUILDIDENTIFIER"), x[y.BUILDIDENTIFIER] = "[0-9A-Za-z-]+", S("BUILD"), x[y.BUILD] = "(?:\\+(" + x[y.BUILDIDENTIFIER] + "(?:\\." + x[y.BUILDIDENTIFIER] + ")*))", S("FULL"), S("FULLPLAIN"), x[y.FULLPLAIN] = "v?" + x[y.MAINVERSION] + x[y.PRERELEASE] + "?" + x[y.BUILD] + "?", x[y.FULL] = "^" + x[y.FULLPLAIN] + "$", S("LOOSEPLAIN"), x[y.LOOSEPLAIN] = "[v=\\s]*" + x[y.MAINVERSIONLOOSE] + x[y.PRERELEASELOOSE] + "?" + x[y.BUILD] + "?", S("LOOSE"), x[y.LOOSE] = "^" + x[y.LOOSEPLAIN] + "$", S("GTLT"), x[y.GTLT] = "((?:<|>)?=?)", S("XRANGEIDENTIFIERLOOSE"), x[y.XRANGEIDENTIFIERLOOSE] = x[y.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", S("XRANGEIDENTIFIER"), x[y.XRANGEIDENTIFIER] = x[y.NUMERICIDENTIFIER] + "|x|X|\\*", S("XRANGEPLAIN"), x[y.XRANGEPLAIN] = "[v=\\s]*(" + x[y.XRANGEIDENTIFIER] + ")(?:\\.(" + x[y.XRANGEIDENTIFIER] + ")(?:\\.(" + x[y.XRANGEIDENTIFIER] + ")(?:" + x[y.PRERELEASE] + ")?" + x[y.BUILD] + "?)?)?", S("XRANGEPLAINLOOSE"), x[y.XRANGEPLAINLOOSE] = "[v=\\s]*(" + x[y.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + x[y.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + x[y.XRANGEIDENTIFIERLOOSE] + ")(?:" + x[y.PRERELEASELOOSE] + ")?" + x[y.BUILD] + "?)?)?", S("XRANGE"), x[y.XRANGE] = "^" + x[y.GTLT] + "\\s*" + x[y.XRANGEPLAIN] + "$", S("XRANGELOOSE"), x[y.XRANGELOOSE] = "^" + x[y.GTLT] + "\\s*" + x[y.XRANGEPLAINLOOSE] + "$", S("COERCE"), x[y.COERCE] = "(^|[^\\d])(\\d{1," + g + "})(?:\\.(\\d{1," + g + "}))?(?:\\.(\\d{1," + g + "}))?(?:$|[^\\d])", S("COERCERTL"), P[y.COERCERTL] = new RegExp(x[y.COERCE], "g"), S("LONETILDE"), x[y.LONETILDE] = "(?:~>?)", S("TILDETRIM"), x[y.TILDETRIM] = "(\\s*)" + x[y.LONETILDE] + "\\s+", P[y.TILDETRIM] = new RegExp(x[y.TILDETRIM], "g");
    var v = "$1~";
    S("TILDE"), x[y.TILDE] = "^" + x[y.LONETILDE] + x[y.XRANGEPLAIN] + "$", S("TILDELOOSE"), x[y.TILDELOOSE] = "^" + x[y.LONETILDE] + x[y.XRANGEPLAINLOOSE] + "$", S("LONECARET"), x[y.LONECARET] = "(?:\\^)", S("CARETTRIM"), x[y.CARETTRIM] = "(\\s*)" + x[y.LONECARET] + "\\s+", P[y.CARETTRIM] = new RegExp(x[y.CARETTRIM], "g");
    var T = "$1^";
    S("CARET"), x[y.CARET] = "^" + x[y.LONECARET] + x[y.XRANGEPLAIN] + "$", S("CARETLOOSE"), x[y.CARETLOOSE] = "^" + x[y.LONECARET] + x[y.XRANGEPLAINLOOSE] + "$", S("COMPARATORLOOSE"), x[y.COMPARATORLOOSE] = "^" + x[y.GTLT] + "\\s*(" + x[y.LOOSEPLAIN] + ")$|^$", S("COMPARATOR"), x[y.COMPARATOR] = "^" + x[y.GTLT] + "\\s*(" + x[y.FULLPLAIN] + ")$|^$", S("COMPARATORTRIM"), x[y.COMPARATORTRIM] = "(\\s*)" + x[y.GTLT] + "\\s*(" + x[y.LOOSEPLAIN] + "|" + x[y.XRANGEPLAIN] + ")", P[y.COMPARATORTRIM] = new RegExp(x[y.COMPARATORTRIM], "g");
    var C = "$1$2$3";
    S("HYPHENRANGE"), x[y.HYPHENRANGE] = "^\\s*(" + x[y.XRANGEPLAIN] + ")\\s+-\\s+(" + x[y.XRANGEPLAIN] + ")\\s*$", S("HYPHENRANGELOOSE"), x[y.HYPHENRANGELOOSE] = "^\\s*(" + x[y.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + x[y.XRANGEPLAINLOOSE] + ")\\s*$", S("STAR"), x[y.STAR] = "(<|>)?=?\\s*\\*";
    for (var I = 0; I < A; I++)
      h(I, x[I]), P[I] || (P[I] = new RegExp(x[I]));
    n.parse = N;
    function N(re, be) {
      if ((!be || typeof be != "object") && (be = {
        loose: !!be,
        includePrerelease: false
      }), re instanceof m)
        return re;
      if (typeof re != "string" || re.length > f2)
        return null;
      var ue = be.loose ? P[y.LOOSE] : P[y.FULL];
      if (!ue.test(re))
        return null;
      try {
        return new m(re, be);
      } catch {
        return null;
      }
    }
    n.valid = D;
    function D(re, be) {
      var ue = N(re, be);
      return ue ? ue.version : null;
    }
    n.clean = _;
    function _(re, be) {
      var ue = N(re.trim().replace(/^[=v]+/, ""), be);
      return ue ? ue.version : null;
    }
    n.SemVer = m;
    function m(re, be) {
      if ((!be || typeof be != "object") && (be = {
        loose: !!be,
        includePrerelease: false
      }), re instanceof m) {
        if (re.loose === be.loose)
          return re;
        re = re.version;
      } else if (typeof re != "string")
        throw new TypeError("Invalid Version: " + re);
      if (re.length > f2)
        throw new TypeError("version is longer than " + f2 + " characters");
      if (!(this instanceof m))
        return new m(re, be);
      h("SemVer", re, be), this.options = be, this.loose = !!be.loose;
      var ue = re.trim().match(be.loose ? P[y.LOOSE] : P[y.FULL]);
      if (!ue)
        throw new TypeError("Invalid Version: " + re);
      if (this.raw = re, this.major = +ue[1], this.minor = +ue[2], this.patch = +ue[3], this.major > p || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > p || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > p || this.patch < 0)
        throw new TypeError("Invalid patch version");
      ue[4] ? this.prerelease = ue[4].split(".").map(function(Me) {
        if (/^[0-9]+$/.test(Me)) {
          var Y = +Me;
          if (Y >= 0 && Y < p)
            return Y;
        }
        return Me;
      }) : this.prerelease = [], this.build = ue[5] ? ue[5].split(".") : [], this.format();
    }
    m.prototype.format = function() {
      return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    }, m.prototype.toString = function() {
      return this.version;
    }, m.prototype.compare = function(re) {
      return h("SemVer.compare", this.version, this.options, re), re instanceof m || (re = new m(re, this.options)), this.compareMain(re) || this.comparePre(re);
    }, m.prototype.compareMain = function(re) {
      return re instanceof m || (re = new m(re, this.options)), B(this.major, re.major) || B(this.minor, re.minor) || B(this.patch, re.patch);
    }, m.prototype.comparePre = function(re) {
      if (re instanceof m || (re = new m(re, this.options)), this.prerelease.length && !re.prerelease.length)
        return -1;
      if (!this.prerelease.length && re.prerelease.length)
        return 1;
      if (!this.prerelease.length && !re.prerelease.length)
        return 0;
      var be = 0;
      do {
        var ue = this.prerelease[be], Me = re.prerelease[be];
        if (h("prerelease compare", be, ue, Me), ue === void 0 && Me === void 0)
          return 0;
        if (Me === void 0)
          return 1;
        if (ue === void 0)
          return -1;
        if (ue === Me)
          continue;
        return B(ue, Me);
      } while (++be);
    }, m.prototype.compareBuild = function(re) {
      re instanceof m || (re = new m(re, this.options));
      var be = 0;
      do {
        var ue = this.build[be], Me = re.build[be];
        if (h("prerelease compare", be, ue, Me), ue === void 0 && Me === void 0)
          return 0;
        if (Me === void 0)
          return 1;
        if (ue === void 0)
          return -1;
        if (ue === Me)
          continue;
        return B(ue, Me);
      } while (++be);
    }, m.prototype.inc = function(re, be) {
      switch (re) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", be);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", be);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", be), this.inc("pre", be);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", be), this.inc("pre", be);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            for (var ue = this.prerelease.length; --ue >= 0; )
              typeof this.prerelease[ue] == "number" && (this.prerelease[ue]++, ue = -2);
            ue === -1 && this.prerelease.push(0);
          }
          be && (this.prerelease[0] === be ? isNaN(this.prerelease[1]) && (this.prerelease = [be, 0]) : this.prerelease = [be, 0]);
          break;
        default:
          throw new Error("invalid increment argument: " + re);
      }
      return this.format(), this.raw = this.version, this;
    }, n.inc = L;
    function L(re, be, ue, Me) {
      typeof ue == "string" && (Me = ue, ue = void 0);
      try {
        return new m(re, ue).inc(be, Me).version;
      } catch {
        return null;
      }
    }
    n.diff = R;
    function R(re, be) {
      if (le(re, be))
        return null;
      var ue = N(re), Me = N(be), Y = "";
      if (ue.prerelease.length || Me.prerelease.length) {
        Y = "pre";
        var Ne = "prerelease";
      }
      for (var Be in ue)
        if ((Be === "major" || Be === "minor" || Be === "patch") && ue[Be] !== Me[Be])
          return Y + Be;
      return Ne;
    }
    n.compareIdentifiers = B;
    var O = /^[0-9]+$/;
    function B(re, be) {
      var ue = O.test(re), Me = O.test(be);
      return ue && Me && (re = +re, be = +be), re === be ? 0 : ue && !Me ? -1 : Me && !ue ? 1 : re < be ? -1 : 1;
    }
    n.rcompareIdentifiers = M;
    function M(re, be) {
      return B(be, re);
    }
    n.major = j;
    function j(re, be) {
      return new m(re, be).major;
    }
    n.minor = $;
    function $(re, be) {
      return new m(re, be).minor;
    }
    n.patch = k;
    function k(re, be) {
      return new m(re, be).patch;
    }
    n.compare = ne;
    function ne(re, be, ue) {
      return new m(re, ue).compare(new m(be, ue));
    }
    n.compareLoose = Q;
    function Q(re, be) {
      return ne(re, be, true);
    }
    n.compareBuild = q;
    function q(re, be, ue) {
      var Me = new m(re, ue), Y = new m(be, ue);
      return Me.compare(Y) || Me.compareBuild(Y);
    }
    n.rcompare = ee;
    function ee(re, be, ue) {
      return ne(be, re, ue);
    }
    n.sort = K;
    function K(re, be) {
      return re.sort(function(ue, Me) {
        return n.compareBuild(ue, Me, be);
      });
    }
    n.rsort = G;
    function G(re, be) {
      return re.sort(function(ue, Me) {
        return n.compareBuild(Me, ue, be);
      });
    }
    n.gt = V;
    function V(re, be, ue) {
      return ne(re, be, ue) > 0;
    }
    n.lt = F;
    function F(re, be, ue) {
      return ne(re, be, ue) < 0;
    }
    n.eq = le;
    function le(re, be, ue) {
      return ne(re, be, ue) === 0;
    }
    n.neq = oe;
    function oe(re, be, ue) {
      return ne(re, be, ue) !== 0;
    }
    n.gte = fe;
    function fe(re, be, ue) {
      return ne(re, be, ue) >= 0;
    }
    n.lte = he;
    function he(re, be, ue) {
      return ne(re, be, ue) <= 0;
    }
    n.cmp = de;
    function de(re, be, ue, Me) {
      switch (be) {
        case "===":
          return typeof re == "object" && (re = re.version), typeof ue == "object" && (ue = ue.version), re === ue;
        case "!==":
          return typeof re == "object" && (re = re.version), typeof ue == "object" && (ue = ue.version), re !== ue;
        case "":
        case "=":
        case "==":
          return le(re, ue, Me);
        case "!=":
          return oe(re, ue, Me);
        case ">":
          return V(re, ue, Me);
        case ">=":
          return fe(re, ue, Me);
        case "<":
          return F(re, ue, Me);
        case "<=":
          return he(re, ue, Me);
        default:
          throw new TypeError("Invalid operator: " + be);
      }
    }
    n.Comparator = Pe;
    function Pe(re, be) {
      if ((!be || typeof be != "object") && (be = {
        loose: !!be,
        includePrerelease: false
      }), re instanceof Pe) {
        if (re.loose === !!be.loose)
          return re;
        re = re.value;
      }
      if (!(this instanceof Pe))
        return new Pe(re, be);
      h("comparator", re, be), this.options = be, this.loose = !!be.loose, this.parse(re), this.semver === we ? this.value = "" : this.value = this.operator + this.semver.version, h("comp", this);
    }
    var we = {};
    Pe.prototype.parse = function(re) {
      var be = this.options.loose ? P[y.COMPARATORLOOSE] : P[y.COMPARATOR], ue = re.match(be);
      if (!ue)
        throw new TypeError("Invalid comparator: " + re);
      this.operator = ue[1] !== void 0 ? ue[1] : "", this.operator === "=" && (this.operator = ""), ue[2] ? this.semver = new m(ue[2], this.options.loose) : this.semver = we;
    }, Pe.prototype.toString = function() {
      return this.value;
    }, Pe.prototype.test = function(re) {
      if (h("Comparator.test", re, this.options.loose), this.semver === we || re === we)
        return true;
      if (typeof re == "string")
        try {
          re = new m(re, this.options);
        } catch {
          return false;
        }
      return de(re, this.operator, this.semver, this.options);
    }, Pe.prototype.intersects = function(re, be) {
      if (!(re instanceof Pe))
        throw new TypeError("a Comparator is required");
      (!be || typeof be != "object") && (be = {
        loose: !!be,
        includePrerelease: false
      });
      var ue;
      if (this.operator === "")
        return this.value === "" ? true : (ue = new H(re.value, be), me(this.value, ue, be));
      if (re.operator === "")
        return re.value === "" ? true : (ue = new H(this.value, be), me(re.semver, ue, be));
      var Me = (this.operator === ">=" || this.operator === ">") && (re.operator === ">=" || re.operator === ">"), Y = (this.operator === "<=" || this.operator === "<") && (re.operator === "<=" || re.operator === "<"), Ne = this.semver.version === re.semver.version, Be = (this.operator === ">=" || this.operator === "<=") && (re.operator === ">=" || re.operator === "<="), X = de(this.semver, "<", re.semver, be) && (this.operator === ">=" || this.operator === ">") && (re.operator === "<=" || re.operator === "<"), je = de(this.semver, ">", re.semver, be) && (this.operator === "<=" || this.operator === "<") && (re.operator === ">=" || re.operator === ">");
      return Me || Y || Ne && Be || X || je;
    }, n.Range = H;
    function H(re, be) {
      if ((!be || typeof be != "object") && (be = {
        loose: !!be,
        includePrerelease: false
      }), re instanceof H)
        return re.loose === !!be.loose && re.includePrerelease === !!be.includePrerelease ? re : new H(re.raw, be);
      if (re instanceof Pe)
        return new H(re.value, be);
      if (!(this instanceof H))
        return new H(re, be);
      if (this.options = be, this.loose = !!be.loose, this.includePrerelease = !!be.includePrerelease, this.raw = re, this.set = re.split(/\s*\|\|\s*/).map(function(ue) {
        return this.parseRange(ue.trim());
      }, this).filter(function(ue) {
        return ue.length;
      }), !this.set.length)
        throw new TypeError("Invalid SemVer Range: " + re);
      this.format();
    }
    H.prototype.format = function() {
      return this.range = this.set.map(function(re) {
        return re.join(" ").trim();
      }).join("||").trim(), this.range;
    }, H.prototype.toString = function() {
      return this.range;
    }, H.prototype.parseRange = function(re) {
      var be = this.options.loose;
      re = re.trim();
      var ue = be ? P[y.HYPHENRANGELOOSE] : P[y.HYPHENRANGE];
      re = re.replace(ue, Ee), h("hyphen replace", re), re = re.replace(P[y.COMPARATORTRIM], C), h("comparator trim", re, P[y.COMPARATORTRIM]), re = re.replace(P[y.TILDETRIM], v), re = re.replace(P[y.CARETTRIM], T), re = re.split(/\s+/).join(" ");
      var Me = be ? P[y.COMPARATORLOOSE] : P[y.COMPARATOR], Y = re.split(" ").map(function(Ne) {
        return Te(Ne, this.options);
      }, this).join(" ").split(/\s+/);
      return this.options.loose && (Y = Y.filter(function(Ne) {
        return !!Ne.match(Me);
      })), Y = Y.map(function(Ne) {
        return new Pe(Ne, this.options);
      }, this), Y;
    }, H.prototype.intersects = function(re, be) {
      if (!(re instanceof H))
        throw new TypeError("a Range is required");
      return this.set.some(function(ue) {
        return te(ue, be) && re.set.some(function(Me) {
          return te(Me, be) && ue.every(function(Y) {
            return Me.every(function(Ne) {
              return Y.intersects(Ne, be);
            });
          });
        });
      });
    };
    function te(re, be) {
      for (var ue = true, Me = re.slice(), Y = Me.pop(); ue && Me.length; )
        ue = Me.every(function(Ne) {
          return Y.intersects(Ne, be);
        }), Y = Me.pop();
      return ue;
    }
    n.toComparators = Ie;
    function Ie(re, be) {
      return new H(re, be).set.map(function(ue) {
        return ue.map(function(Me) {
          return Me.value;
        }).join(" ").trim().split(" ");
      });
    }
    function Te(re, be) {
      return h("comp", re, be), re = ae(re, be), h("caret", re), re = z(re, be), h("tildes", re), re = xe(re, be), h("xrange", re), re = Le(re, be), h("stars", re), re;
    }
    function pe(re) {
      return !re || re.toLowerCase() === "x" || re === "*";
    }
    function z(re, be) {
      return re.trim().split(/\s+/).map(function(ue) {
        return W(ue, be);
      }).join(" ");
    }
    function W(re, be) {
      var ue = be.loose ? P[y.TILDELOOSE] : P[y.TILDE];
      return re.replace(ue, function(Me, Y, Ne, Be, X) {
        h("tilde", re, Me, Y, Ne, Be, X);
        var je;
        return pe(Y) ? je = "" : pe(Ne) ? je = ">=" + Y + ".0.0 <" + (+Y + 1) + ".0.0" : pe(Be) ? je = ">=" + Y + "." + Ne + ".0 <" + Y + "." + (+Ne + 1) + ".0" : X ? (h("replaceTilde pr", X), je = ">=" + Y + "." + Ne + "." + Be + "-" + X + " <" + Y + "." + (+Ne + 1) + ".0") : je = ">=" + Y + "." + Ne + "." + Be + " <" + Y + "." + (+Ne + 1) + ".0", h("tilde return", je), je;
      });
    }
    function ae(re, be) {
      return re.trim().split(/\s+/).map(function(ue) {
        return ce(ue, be);
      }).join(" ");
    }
    function ce(re, be) {
      h("caret", re, be);
      var ue = be.loose ? P[y.CARETLOOSE] : P[y.CARET];
      return re.replace(ue, function(Me, Y, Ne, Be, X) {
        h("caret", re, Me, Y, Ne, Be, X);
        var je;
        return pe(Y) ? je = "" : pe(Ne) ? je = ">=" + Y + ".0.0 <" + (+Y + 1) + ".0.0" : pe(Be) ? Y === "0" ? je = ">=" + Y + "." + Ne + ".0 <" + Y + "." + (+Ne + 1) + ".0" : je = ">=" + Y + "." + Ne + ".0 <" + (+Y + 1) + ".0.0" : X ? (h("replaceCaret pr", X), Y === "0" ? Ne === "0" ? je = ">=" + Y + "." + Ne + "." + Be + "-" + X + " <" + Y + "." + Ne + "." + (+Be + 1) : je = ">=" + Y + "." + Ne + "." + Be + "-" + X + " <" + Y + "." + (+Ne + 1) + ".0" : je = ">=" + Y + "." + Ne + "." + Be + "-" + X + " <" + (+Y + 1) + ".0.0") : (h("no pr"), Y === "0" ? Ne === "0" ? je = ">=" + Y + "." + Ne + "." + Be + " <" + Y + "." + Ne + "." + (+Be + 1) : je = ">=" + Y + "." + Ne + "." + Be + " <" + Y + "." + (+Ne + 1) + ".0" : je = ">=" + Y + "." + Ne + "." + Be + " <" + (+Y + 1) + ".0.0"), h("caret return", je), je;
      });
    }
    function xe(re, be) {
      return h("replaceXRanges", re, be), re.split(/\s+/).map(function(ue) {
        return Se(ue, be);
      }).join(" ");
    }
    function Se(re, be) {
      re = re.trim();
      var ue = be.loose ? P[y.XRANGELOOSE] : P[y.XRANGE];
      return re.replace(ue, function(Me, Y, Ne, Be, X, je) {
        h("xRange", re, Me, Y, Ne, Be, X, je);
        var rt = pe(Ne), vt = rt || pe(Be), gt = vt || pe(X), ut = gt;
        return Y === "=" && ut && (Y = ""), je = be.includePrerelease ? "-0" : "", rt ? Y === ">" || Y === "<" ? Me = "<0.0.0-0" : Me = "*" : Y && ut ? (vt && (Be = 0), X = 0, Y === ">" ? (Y = ">=", vt ? (Ne = +Ne + 1, Be = 0, X = 0) : (Be = +Be + 1, X = 0)) : Y === "<=" && (Y = "<", vt ? Ne = +Ne + 1 : Be = +Be + 1), Me = Y + Ne + "." + Be + "." + X + je) : vt ? Me = ">=" + Ne + ".0.0" + je + " <" + (+Ne + 1) + ".0.0" + je : gt && (Me = ">=" + Ne + "." + Be + ".0" + je + " <" + Ne + "." + (+Be + 1) + ".0" + je), h("xRange return", Me), Me;
      });
    }
    function Le(re, be) {
      return h("replaceStars", re, be), re.trim().replace(P[y.STAR], "");
    }
    function Ee(re, be, ue, Me, Y, Ne, Be, X, je, rt, vt, gt, ut) {
      return pe(ue) ? be = "" : pe(Me) ? be = ">=" + ue + ".0.0" : pe(Y) ? be = ">=" + ue + "." + Me + ".0" : be = ">=" + be, pe(je) ? X = "" : pe(rt) ? X = "<" + (+je + 1) + ".0.0" : pe(vt) ? X = "<" + je + "." + (+rt + 1) + ".0" : gt ? X = "<=" + je + "." + rt + "." + vt + "-" + gt : X = "<=" + X, (be + " " + X).trim();
    }
    H.prototype.test = function(re) {
      if (!re)
        return false;
      if (typeof re == "string")
        try {
          re = new m(re, this.options);
        } catch {
          return false;
        }
      for (var be = 0; be < this.set.length; be++)
        if (J(this.set[be], re, this.options))
          return true;
      return false;
    };
    function J(re, be, ue) {
      for (var Me = 0; Me < re.length; Me++)
        if (!re[Me].test(be))
          return false;
      if (be.prerelease.length && !ue.includePrerelease) {
        for (Me = 0; Me < re.length; Me++)
          if (h(re[Me].semver), re[Me].semver !== we && re[Me].semver.prerelease.length > 0) {
            var Y = re[Me].semver;
            if (Y.major === be.major && Y.minor === be.minor && Y.patch === be.patch)
              return true;
          }
        return false;
      }
      return true;
    }
    n.satisfies = me;
    function me(re, be, ue) {
      try {
        be = new H(be, ue);
      } catch {
        return false;
      }
      return be.test(re);
    }
    n.maxSatisfying = ke;
    function ke(re, be, ue) {
      var Me = null, Y = null;
      try {
        var Ne = new H(be, ue);
      } catch {
        return null;
      }
      return re.forEach(function(Be) {
        Ne.test(Be) && (!Me || Y.compare(Be) === -1) && (Me = Be, Y = new m(Me, ue));
      }), Me;
    }
    n.minSatisfying = _e;
    function _e(re, be, ue) {
      var Me = null, Y = null;
      try {
        var Ne = new H(be, ue);
      } catch {
        return null;
      }
      return re.forEach(function(Be) {
        Ne.test(Be) && (!Me || Y.compare(Be) === 1) && (Me = Be, Y = new m(Me, ue));
      }), Me;
    }
    n.minVersion = Re;
    function Re(re, be) {
      re = new H(re, be);
      var ue = new m("0.0.0");
      if (re.test(ue) || (ue = new m("0.0.0-0"), re.test(ue)))
        return ue;
      ue = null;
      for (var Me = 0; Me < re.set.length; ++Me) {
        var Y = re.set[Me];
        Y.forEach(function(Ne) {
          var Be = new m(Ne.semver.version);
          switch (Ne.operator) {
            case ">":
              Be.prerelease.length === 0 ? Be.patch++ : Be.prerelease.push(0), Be.raw = Be.format();
            case "":
            case ">=":
              (!ue || V(ue, Be)) && (ue = Be);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + Ne.operator);
          }
        });
      }
      return ue && re.test(ue) ? ue : null;
    }
    n.validRange = $e;
    function $e(re, be) {
      try {
        return new H(re, be).range || "*";
      } catch {
        return null;
      }
    }
    n.ltr = Ge;
    function Ge(re, be, ue) {
      return Ze(re, be, "<", ue);
    }
    n.gtr = lt;
    function lt(re, be, ue) {
      return Ze(re, be, ">", ue);
    }
    n.outside = Ze;
    function Ze(re, be, ue, Me) {
      re = new m(re, Me), be = new H(be, Me);
      var Y, Ne, Be, X, je;
      switch (ue) {
        case ">":
          Y = V, Ne = he, Be = F, X = ">", je = ">=";
          break;
        case "<":
          Y = F, Ne = fe, Be = V, X = "<", je = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (me(re, be, Me))
        return false;
      for (var rt = 0; rt < be.set.length; ++rt) {
        var vt = be.set[rt], gt = null, ut = null;
        if (vt.forEach(function(qe) {
          qe.semver === we && (qe = new Pe(">=0.0.0")), gt = gt || qe, ut = ut || qe, Y(qe.semver, gt.semver, Me) ? gt = qe : Be(qe.semver, ut.semver, Me) && (ut = qe);
        }), gt.operator === X || gt.operator === je || (!ut.operator || ut.operator === X) && Ne(re, ut.semver))
          return false;
        if (ut.operator === je && Be(re, ut.semver))
          return false;
      }
      return true;
    }
    n.prerelease = Xe;
    function Xe(re, be) {
      var ue = N(re, be);
      return ue && ue.prerelease.length ? ue.prerelease : null;
    }
    n.intersects = et;
    function et(re, be, ue) {
      return re = new H(re, ue), be = new H(be, ue), re.intersects(be);
    }
    n.coerce = st;
    function st(re, be) {
      if (re instanceof m)
        return re;
      if (typeof re == "number" && (re = String(re)), typeof re != "string")
        return null;
      be = be || {};
      var ue = null;
      if (!be.rtl)
        ue = re.match(P[y.COERCE]);
      else {
        for (var Me; (Me = P[y.COERCERTL].exec(re)) && (!ue || ue.index + ue[0].length !== re.length); )
          (!ue || Me.index + Me[0].length !== ue.index + ue[0].length) && (ue = Me), P[y.COERCERTL].lastIndex = Me.index + Me[1].length + Me[2].length;
        P[y.COERCERTL].lastIndex = -1;
      }
      return ue === null ? null : N(ue[2] + "." + (ue[3] || "0") + "." + (ue[4] || "0"), be);
    }
  }(cl, cl.exports)), cl.exports;
}
Object.defineProperty(Kn, "__esModule", {
  value: true
});
Kn.default = void 0;
function Na() {
  const s = i0();
  return Na = function() {
    return s;
  }, s;
}
function Dc() {
  const s = qi();
  return Dc = function() {
    return s;
  }, s;
}
function a0() {
  const s = Bl();
  return a0 = function() {
    return s;
  }, s;
}
function o0() {
  const s = Je();
  return o0 = function() {
    return s;
  }, s;
}
function l0() {
  const s = j1();
  return l0 = function() {
    return s;
  }, s;
}
function xl() {
  const s = Hn();
  return xl = function() {
    return s;
  }, s;
}
var {
  cloneNode: R1,
  interpreterDirective: U1
} = o0();
var $1 = {
  enter(s, n) {
    const h = s.node.loc;
    h && (n.loc = h, s.stop());
  }
};
var tp = class _tp {
  constructor(n, {
    code: h,
    ast: f2,
    inputMap: p
  }) {
    this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
      file: this,
      getCode: () => this.code,
      getScope: () => this.scope,
      addHelper: this.addHelper.bind(this),
      buildError: this.buildCodeFrameError.bind(this)
    }, this.opts = n, this.code = h, this.ast = f2, this.inputMap = p, this.path = Dc().NodePath.get({
      hub: this.hub,
      parentPath: null,
      parent: this.ast,
      container: this.ast,
      key: "program"
    }).setContext(), this.scope = this.path.scope;
  }
  get shebang() {
    const {
      interpreter: n
    } = this.path.node;
    return n ? n.value : "";
  }
  set shebang(n) {
    n ? this.path.get("interpreter").replaceWith(U1(n)) : this.path.get("interpreter").remove();
  }
  set(n, h) {
    if (n === "helpersNamespace")
      throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
    this._map.set(n, h);
  }
  get(n) {
    return this._map.get(n);
  }
  has(n) {
    return this._map.has(n);
  }
  getModuleName() {
    return (0, l0().getModuleName)(this.opts, this.opts);
  }
  addImport() {
    throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
  }
  availableHelper(n, h) {
    let f2;
    try {
      f2 = Na().minVersion(n);
    } catch (p) {
      if (p.code !== "BABEL_HELPER_UNKNOWN")
        throw p;
      return false;
    }
    return typeof h != "string" ? true : (xl().valid(h) && (h = `^${h}`), !xl().intersects(`<${f2}`, h) && !xl().intersects(">=8.0.0", h));
  }
  addHelper(n) {
    const h = this.declarations[n];
    if (h)
      return R1(h);
    const f2 = this.get("helperGenerator");
    if (f2) {
      const y = f2(n);
      if (y)
        return y;
    }
    Na().ensure(n, _tp);
    const p = this.declarations[n] = this.scope.generateUidIdentifier(n), g = {};
    for (const y of Na().getDependencies(n))
      g[y] = this.addHelper(y);
    const {
      nodes: P,
      globals: x
    } = Na().get(n, (y) => g[y], p, Object.keys(this.scope.getAllBindings()));
    return x.forEach((y) => {
      this.path.scope.hasBinding(y, true) && this.path.scope.rename(y);
    }), P.forEach((y) => {
      y._compact = true;
    }), this.path.unshiftContainer("body", P), this.path.get("body").forEach((y) => {
      P.indexOf(y.node) !== -1 && y.isVariableDeclaration() && this.scope.registerDeclaration(y);
    }), p;
  }
  addTemplateObject() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }
  buildCodeFrameError(n, h, f2 = SyntaxError) {
    let p = n && (n.loc || n._loc);
    if (!p && n) {
      const g = {
        loc: null
      };
      (0, Dc().default)(n, $1, this.scope, g), p = g.loc;
      let P = "This is an error on an internal node. Probably an internal error.";
      p && (P += " Location has been estimated."), h += ` (${P})`;
    }
    if (p) {
      const {
        highlightCode: g = true
      } = this.opts;
      h += `
` + (0, a0().codeFrameColumns)(this.code, {
        start: {
          line: p.start.line,
          column: p.start.column + 1
        },
        end: p.end && p.start.line === p.end.line ? {
          line: p.end.line,
          column: p.end.column + 1
        } : void 0
      }, {
        highlightCode: g
      });
    }
    return new f2(h);
  }
};
Kn.default = tp;
var rp = {};
Object.defineProperty(rp, "__esModule", {
  value: true
});
rp.default = ix;
function Pl() {
  const s = i0();
  return Pl = function() {
    return s;
  }, s;
}
function u0() {
  const s = Zc();
  return u0 = function() {
    return s;
  }, s;
}
function c0() {
  const s = Pn();
  return c0 = function() {
    return s;
  }, s;
}
function p0() {
  const s = Je();
  return p0 = function() {
    return s;
  }, s;
}
var q1 = Kn;
var {
  arrayExpression: V1,
  assignmentExpression: f0,
  binaryExpression: K1,
  blockStatement: W1,
  callExpression: H1,
  cloneNode: z1,
  conditionalExpression: G1,
  exportNamedDeclaration: X1,
  exportSpecifier: J1,
  expressionStatement: h0,
  functionExpression: Y1,
  identifier: kr,
  memberExpression: sp,
  objectExpression: ip,
  program: _l,
  stringLiteral: d0,
  unaryExpression: Q1,
  variableDeclaration: np,
  variableDeclarator: ap
} = p0();
var Z1 = (s) => c0().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(s);
function ex(s) {
  const n = kr("babelHelpers"), h = [], f2 = Y1(null, [kr("global")], W1(h)), p = _l([h0(H1(f2, [G1(K1("===", Q1("typeof", kr("global")), d0("undefined")), kr("self"), kr("global"))]))]);
  return h.push(np("var", [ap(n, f0("=", sp(kr("global"), n), ip([])))])), Fl(h, n, s), p;
}
function tx(s) {
  const n = [], h = Fl(n, null, s);
  return n.unshift(X1(null, Object.keys(h).map((f2) => J1(z1(h[f2]), kr(f2))))), _l(n, [], "module");
}
function rx(s) {
  const n = kr("babelHelpers"), h = [];
  return h.push(np("var", [ap(n, kr("global"))])), Fl(h, n, s), _l([Z1({
    FACTORY_PARAMETERS: kr("global"),
    BROWSER_ARGUMENTS: f0("=", sp(kr("root"), n), ip([])),
    COMMON_ARGUMENTS: kr("exports"),
    AMD_ARGUMENTS: V1([d0("exports")]),
    FACTORY_BODY: h,
    UMD_ROOT: kr("this")
  })]);
}
function sx(s) {
  const n = kr("babelHelpers"), h = [];
  h.push(np("var", [ap(n, ip([]))]));
  const f2 = _l(h);
  return Fl(h, n, s), h.push(h0(n)), f2;
}
function Fl(s, n, h) {
  const f2 = (g) => n ? sp(n, kr(g)) : kr(`_${g}`), p = {};
  return Pl().list.forEach(function(g) {
    if (h && h.indexOf(g) < 0)
      return;
    const P = p[g] = f2(g);
    Pl().ensure(g, q1.default);
    const {
      nodes: x
    } = Pl().get(g, f2, P);
    s.push(...x);
  }), p;
}
function ix(s, n = "global") {
  let h;
  const f2 = {
    global: ex,
    module: tx,
    umd: rx,
    var: sx
  }[n];
  if (f2)
    h = f2(s);
  else
    throw new Error(`Unsupported output type ${n}`);
  return (0, u0().default)(h).code;
}
var Ir = {};
Object.defineProperty(Ir, "__esModule", {
  value: true
});
Ir.ROOT_CONFIG_FILENAMES = void 0;
Ir.findConfigUpwards = nx;
Ir.findPackageData = ax;
Ir.findRelativeConfig = ox;
Ir.findRootConfig = lx;
Ir.loadConfig = ux;
Ir.loadPlugin = dx;
Ir.loadPreset = mx;
Ir.resolvePlugin = fx;
Ir.resolvePreset = hx;
Ir.resolveShowConfigPath = cx;
function nx(s) {
  return null;
}
function* ax(s) {
  return {
    filepath: s,
    directories: [],
    pkg: null,
    isPackage: false
  };
}
function* ox(s, n, h) {
  return {
    config: null,
    ignore: null
  };
}
function* lx(s, n, h) {
  return null;
}
function* ux(s, n, h, f2) {
  throw new Error(`Cannot load ${s} relative to ${n} in a browser`);
}
function* cx(s) {
  return null;
}
var px = [];
Ir.ROOT_CONFIG_FILENAMES = px;
function fx(s, n) {
  return null;
}
function hx(s, n) {
  return null;
}
function dx(s, n) {
  throw new Error(`Cannot load plugin ${s} relative to ${n} in a browser`);
}
function mx(s, n) {
  throw new Error(`Cannot load preset ${s} relative to ${n} in a browser`);
}
var jl = {};
Object.defineProperty(jl, "__esModule", {
  value: true
});
jl.getEnv = yx;
function yx(s = "development") {
  return process.env.BABEL_ENV || "development";
}
var Mn = {};
var cm;
function m0() {
  if (cm)
    return Mn;
  cm = 1, Object.defineProperty(Mn, "__esModule", { value: true });
  function s(a, e) {
    if (a == null)
      return {};
    var t = {}, r = Object.keys(a), i, o;
    for (o = 0; o < r.length; o++)
      i = r[o], !(e.indexOf(i) >= 0) && (t[i] = a[i]);
    return t;
  }
  class n {
    constructor(e, t, r) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = t, this.index = r;
    }
  }
  class h {
    constructor(e, t) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = t;
    }
  }
  function f2(a, e) {
    const {
      line: t,
      column: r,
      index: i
    } = a;
    return new n(t, r + e, i + e);
  }
  const p = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
  }), g = (a, e = a.length - 1) => ({
    get() {
      return a.reduce((t, r) => t[r], this);
    },
    set(t) {
      a.reduce((r, i, o) => o === e ? r[i] = t : r[i], this);
    }
  }), P = (a, e, t) => Object.keys(t).map((r) => [r, t[r]]).filter(([, r]) => !!r).map(([r, i]) => [r, typeof i == "function" ? {
    value: i,
    enumerable: false
  } : typeof i.reflect == "string" ? Object.assign({}, i, g(i.reflect.split("."))) : i]).reduce((r, [i, o]) => Object.defineProperty(r, i, Object.assign({
    configurable: true
  }, o)), Object.assign(new a(), e));
  var x = (a) => ({
    ImportMetaOutsideModule: a(`import.meta may appear only with 'sourceType: "module"'`, {
      code: p.SourceTypeModuleError
    }),
    ImportOutsideModule: a(`'import' and 'export' may appear only with 'sourceType: "module"'`, {
      code: p.SourceTypeModuleError
    })
  });
  const y = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, A = ({
    type: a,
    prefix: e
  }) => a === "UpdateExpression" ? y.UpdateExpression[String(e)] : y[a];
  var S = (a) => ({
    AccessorIsGenerator: a(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`),
    ArgumentsInClass: a("'arguments' is only allowed in functions and class methods."),
    AsyncFunctionInSingleStatementContext: a("Async functions can only be declared at the top level or inside a block."),
    AwaitBindingIdentifier: a("Can not use 'await' as identifier inside an async function."),
    AwaitBindingIdentifierInStaticBlock: a("Can not use 'await' as identifier inside a static block."),
    AwaitExpressionFormalParameter: a("'await' is not allowed in async function parameters."),
    AwaitNotInAsyncContext: a("'await' is only allowed within async functions and at the top levels of modules."),
    AwaitNotInAsyncFunction: a("'await' is only allowed within async functions."),
    BadGetterArity: a("A 'get' accesor must not have any formal parameters."),
    BadSetterArity: a("A 'set' accesor must have exactly one formal parameter."),
    BadSetterRestParameter: a("A 'set' accesor function argument must not be a rest parameter."),
    ConstructorClassField: a("Classes may not have a field named 'constructor'."),
    ConstructorClassPrivateField: a("Classes may not have a private field named '#constructor'."),
    ConstructorIsAccessor: a("Class constructor may not be an accessor."),
    ConstructorIsAsync: a("Constructor can't be an async function."),
    ConstructorIsGenerator: a("Constructor can't be a generator."),
    DeclarationMissingInitializer: a(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`),
    DecoratorBeforeExport: a("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."),
    DecoratorConstructor: a("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
    DecoratorExportClass: a("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."),
    DecoratorSemicolon: a("Decorators must not be followed by a semicolon."),
    DecoratorStaticBlock: a("Decorators can't be used with a static block."),
    DeletePrivateField: a("Deleting a private field is not allowed."),
    DestructureNamedImport: a("ES2015 named imports do not destructure. Use another statement for destructuring after the import."),
    DuplicateConstructor: a("Duplicate constructor in the same class."),
    DuplicateDefaultExport: a("Only one default export allowed per module."),
    DuplicateExport: a(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`),
    DuplicateProto: a("Redefinition of __proto__ property."),
    DuplicateRegExpFlags: a("Duplicate regular expression flag."),
    ElementAfterRest: a("Rest element must be last element."),
    EscapedCharNotAnIdentifier: a("Invalid Unicode escape."),
    ExportBindingIsString: a(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`),
    ExportDefaultFromAsIdentifier: a("'from' is not allowed as an identifier after 'export default'."),
    ForInOfLoopInitializer: a(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`),
    ForOfAsync: a("The left-hand side of a for-of loop may not be 'async'."),
    ForOfLet: a("The left-hand side of a for-of loop may not start with 'let'."),
    GeneratorInSingleStatementContext: a("Generators can only be declared at the top level or inside a block."),
    IllegalBreakContinue: a(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`),
    IllegalLanguageModeDirective: a("Illegal 'use strict' directive in function with non-simple parameter list."),
    IllegalReturn: a("'return' outside of function."),
    ImportBindingIsString: a(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`),
    ImportCallArgumentTrailingComma: a("Trailing comma is disallowed inside import(...) arguments."),
    ImportCallArity: a(({
      maxArgumentCount: e
    }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`),
    ImportCallNotNewExpression: a("Cannot use new with import(...)."),
    ImportCallSpreadArgument: a("`...` is not allowed in `import()`."),
    ImportJSONBindingNotDefault: a("A JSON module can only be imported with `default`."),
    IncompatibleRegExpUVFlags: a("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
    InvalidBigIntLiteral: a("Invalid BigIntLiteral."),
    InvalidCodePoint: a("Code point out of bounds."),
    InvalidCoverInitializedName: a("Invalid shorthand property initializer."),
    InvalidDecimal: a("Invalid decimal."),
    InvalidDigit: a(({
      radix: e
    }) => `Expected number in radix ${e}.`),
    InvalidEscapeSequence: a("Bad character escape sequence."),
    InvalidEscapeSequenceTemplate: a("Invalid escape sequence in template."),
    InvalidEscapedReservedWord: a(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`),
    InvalidIdentifier: a(({
      identifierName: e
    }) => `Invalid identifier ${e}.`),
    InvalidLhs: a(({
      ancestor: e
    }) => `Invalid left-hand side in ${A(e)}.`),
    InvalidLhsBinding: a(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${A(e)}.`),
    InvalidNumber: a("Invalid number."),
    InvalidOrMissingExponent: a("Floating-point numbers require a valid exponent after the 'e'."),
    InvalidOrUnexpectedToken: a(({
      unexpected: e
    }) => `Unexpected character '${e}'.`),
    InvalidParenthesizedAssignment: a("Invalid parenthesized assignment pattern."),
    InvalidPrivateFieldResolution: a(({
      identifierName: e
    }) => `Private name #${e} is not defined.`),
    InvalidPropertyBindingPattern: a("Binding member expression."),
    InvalidRecordProperty: a("Only properties and spread elements are allowed in record definitions."),
    InvalidRestAssignmentPattern: a("Invalid rest operator's argument."),
    LabelRedeclaration: a(({
      labelName: e
    }) => `Label '${e}' is already declared.`),
    LetInLexicalBinding: a("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
    LineTerminatorBeforeArrow: a("No line break is allowed before '=>'."),
    MalformedRegExpFlags: a("Invalid regular expression flag."),
    MissingClassName: a("A class name is required."),
    MissingEqInAssignment: a("Only '=' operator can be used for specifying default value."),
    MissingSemicolon: a("Missing semicolon."),
    MissingPlugin: a(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`),
    MissingOneOfPlugins: a(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`),
    MissingUnicodeEscape: a("Expecting Unicode escape sequence \\uXXXX."),
    MixingCoalesceWithLogical: a("Nullish coalescing operator(??) requires parens when mixing with logical operators."),
    ModuleAttributeDifferentFromType: a("The only accepted module attribute is `type`."),
    ModuleAttributeInvalidValue: a("Only string literals are allowed as module attribute values."),
    ModuleAttributesWithDuplicateKeys: a(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`),
    ModuleExportNameHasLoneSurrogate: a(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`),
    ModuleExportUndefined: a(({
      localName: e
    }) => `Export '${e}' is not defined.`),
    MultipleDefaultsInSwitch: a("Multiple default clauses."),
    NewlineAfterThrow: a("Illegal newline after throw."),
    NoCatchOrFinally: a("Missing catch or finally clause."),
    NumberIdentifier: a("Identifier directly after number."),
    NumericSeparatorInEscapeSequence: a("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."),
    ObsoleteAwaitStar: a("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
    OptionalChainingNoNew: a("Constructors in/after an Optional Chain are not allowed."),
    OptionalChainingNoTemplate: a("Tagged Template Literals are not allowed in optionalChain."),
    OverrideOnConstructor: a("'override' modifier cannot appear on a constructor declaration."),
    ParamDupe: a("Argument name clash."),
    PatternHasAccessor: a("Object pattern can't contain getter or setter."),
    PatternHasMethod: a("Object pattern can't contain methods."),
    PrivateInExpectedIn: a(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`),
    PrivateNameRedeclaration: a(({
      identifierName: e
    }) => `Duplicate private name #${e}.`),
    RecordExpressionBarIncorrectEndSyntaxType: a("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    RecordExpressionBarIncorrectStartSyntaxType: a("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    RecordExpressionHashIncorrectStartSyntaxType: a("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
    RecordNoProto: a("'__proto__' is not allowed in Record expressions."),
    RestTrailingComma: a("Unexpected trailing comma after rest element."),
    SloppyFunction: a("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."),
    StaticPrototype: a("Classes may not have static property named prototype."),
    SuperNotAllowed: a("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"),
    SuperPrivateField: a("Private fields can't be accessed on super."),
    TrailingDecorator: a("Decorators must be attached to a class element."),
    TupleExpressionBarIncorrectEndSyntaxType: a("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    TupleExpressionBarIncorrectStartSyntaxType: a("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
    TupleExpressionHashIncorrectStartSyntaxType: a("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
    UnexpectedArgumentPlaceholder: a("Unexpected argument placeholder."),
    UnexpectedAwaitAfterPipelineBody: a('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'),
    UnexpectedDigitAfterHash: a("Unexpected digit after hash token."),
    UnexpectedImportExport: a("'import' and 'export' may only appear at the top level."),
    UnexpectedKeyword: a(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`),
    UnexpectedLeadingDecorator: a("Leading decorators must be attached to a class declaration."),
    UnexpectedLexicalDeclaration: a("Lexical declaration cannot appear in a single-statement context."),
    UnexpectedNewTarget: a("`new.target` can only be used in functions or class properties."),
    UnexpectedNumericSeparator: a("A numeric separator is only allowed between two digits."),
    UnexpectedPrivateField: a("Unexpected private name."),
    UnexpectedReservedWord: a(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`),
    UnexpectedSuper: a("'super' is only allowed in object methods and classes."),
    UnexpectedToken: a(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`),
    UnexpectedTokenUnaryExponentiation: a("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."),
    UnsupportedBind: a("Binding should be performed on object property."),
    UnsupportedDecoratorExport: a("A decorated export must export a class declaration."),
    UnsupportedDefaultExport: a("Only expressions, functions or classes are allowed as the `default` export."),
    UnsupportedImport: a("`import` can only be used in `import()` or `import.meta`."),
    UnsupportedMetaProperty: a(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`),
    UnsupportedParameterDecorator: a("Decorators cannot be used to decorate parameters."),
    UnsupportedPropertyDecorator: a("Decorators cannot be used to decorate object literal properties."),
    UnsupportedSuper: a("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."),
    UnterminatedComment: a("Unterminated comment."),
    UnterminatedRegExp: a("Unterminated regular expression."),
    UnterminatedString: a("Unterminated string constant."),
    UnterminatedTemplate: a("Unterminated template."),
    VarRedeclaration: a(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`),
    YieldBindingIdentifier: a("Can not use 'yield' as identifier inside a generator."),
    YieldInParameter: a("Yield expression is not allowed in formal parameters."),
    ZeroDigitNumericSeparator: a("Numeric separator can not be used after leading 0.")
  }), v = (a) => ({
    StrictDelete: a("Deleting local variable in strict mode."),
    StrictEvalArguments: a(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`),
    StrictEvalArgumentsBinding: a(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`),
    StrictFunction: a("In strict mode code, functions can only be declared at top level or inside a block."),
    StrictNumericEscape: a("The only valid numeric escape in strict mode is '\\0'."),
    StrictOctalLiteral: a("Legacy octal literals are not allowed in strict mode."),
    StrictWith: a("'with' in strict mode.")
  });
  const T = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var C = (a) => ({
    PipeBodyIsTighter: a("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."),
    PipeTopicRequiresHackPipes: a('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'),
    PipeTopicUnbound: a("Topic reference is unbound; it must be inside a pipe body."),
    PipeTopicUnconfiguredToken: a(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`),
    PipeTopicUnused: a("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."),
    PipeUnparenthesizedBody: a(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${A({
      type: e
    })}; please wrap it in parentheses.`),
    PipelineBodyNoArrow: a('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'),
    PipelineBodySequenceExpression: a("Pipeline body may not be a comma-separated sequence expression."),
    PipelineHeadSequenceExpression: a("Pipeline head should not be a comma-separated sequence expression."),
    PipelineTopicUnused: a("Pipeline is in topic style but does not use topic reference."),
    PrimaryTopicNotAllowed: a("Topic reference was used in a lexical context without topic binding."),
    PrimaryTopicRequiresSmartPipeline: a('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.')
  });
  const I = ["toMessage"];
  function N(a) {
    let {
      toMessage: e
    } = a, t = s(a, I);
    return function r({
      loc: i,
      details: o
    }) {
      return P(SyntaxError, Object.assign({}, t, {
        loc: i
      }), {
        clone(d = {}) {
          const u = d.loc || {};
          return r({
            loc: new n("line" in u ? u.line : this.loc.line, "column" in u ? u.column : this.loc.column, "index" in u ? u.index : this.loc.index),
            details: Object.assign({}, this.details, d.details)
          });
        },
        details: {
          value: o,
          enumerable: false
        },
        message: {
          get() {
            return `${e(this.details)} (${this.loc.line}:${this.loc.column})`;
          },
          set(d) {
            Object.defineProperty(this, "message", {
              value: d
            });
          }
        },
        pos: {
          reflect: "loc.index",
          enumerable: true
        },
        missingPlugin: "missingPlugin" in o && {
          reflect: "details.missingPlugin",
          enumerable: true
        }
      });
    };
  }
  function D(a, e) {
    return Object.assign({
      toMessage: typeof a == "string" ? () => a : a
    }, e);
  }
  function _(a, e) {
    if (Array.isArray(a))
      return (i) => _(i, a[0]);
    const t = a(D), r = {};
    for (const i of Object.keys(t))
      r[i] = N(Object.assign({
        code: p.SyntaxError,
        reasonCode: i
      }, e ? {
        syntaxPlugin: e
      } : {}, t[i]));
    return r;
  }
  const m = Object.assign({}, _(x), _(S), _(v), _`pipelineOperator`(C)), {
    defineProperty: L
  } = Object, R = (a, e) => L(a, e, {
    enumerable: false,
    value: a[e]
  });
  function O(a) {
    return a.loc.start && R(a.loc.start, "index"), a.loc.end && R(a.loc.end, "index"), a;
  }
  var B = (a) => class extends a {
    parse() {
      const e = O(super.parse());
      return this.options.tokens && (e.tokens = e.tokens.map(O)), e;
    }
    parseRegExpLiteral({
      pattern: e,
      flags: t
    }) {
      let r = null;
      try {
        r = new RegExp(e, t);
      } catch {
      }
      const i = this.estreeParseLiteral(r);
      return i.regex = {
        pattern: e,
        flags: t
      }, i;
    }
    parseBigIntLiteral(e) {
      let t;
      try {
        t = BigInt(e);
      } catch {
        t = null;
      }
      const r = this.estreeParseLiteral(t);
      return r.bigint = String(r.value || e), r;
    }
    parseDecimalLiteral(e) {
      const r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || e), r;
    }
    estreeParseLiteral(e) {
      return this.parseLiteral(e, "Literal");
    }
    parseStringLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNumericLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    directiveToStmt(e) {
      const t = e.value, r = this.startNodeAt(e.start, e.loc.start), i = this.startNodeAt(t.start, t.loc.start);
      return i.value = t.extra.expressionValue, i.raw = t.extra.raw, r.expression = this.finishNodeAt(i, "Literal", t.loc.end), r.directive = t.extra.raw.slice(1, -1), this.finishNodeAt(r, "ExpressionStatement", e.loc.end);
    }
    initFunction(e, t) {
      super.initFunction(e, t), e.expression = false;
    }
    checkDeclaration(e) {
      e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
    }
    getObjectOrClassMethodParams(e) {
      return e.value.params;
    }
    isValidDirective(e) {
      var t;
      return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((t = e.expression.extra) != null && t.parenthesized);
    }
    parseBlockBody(e, ...t) {
      super.parseBlockBody(e, ...t);
      const r = e.directives.map((i) => this.directiveToStmt(i));
      e.body = r.concat(e.body), delete e.directives;
    }
    pushClassMethod(e, t, r, i, o, d) {
      this.parseMethod(t, r, i, o, d, "ClassMethod", true), t.typeParameters && (t.value.typeParameters = t.typeParameters, delete t.typeParameters), e.body.push(t);
    }
    parsePrivateName() {
      const e = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
    }
    convertPrivateNameToPrivateIdentifier(e) {
      const t = super.getPrivateNameSV(e);
      return e = e, delete e.id, e.name = t, e.type = "PrivateIdentifier", e;
    }
    isPrivateName(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
    }
    getPrivateNameSV(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
    }
    parseLiteral(e, t) {
      const r = super.parseLiteral(e, t);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(e, t, r = false) {
      super.parseFunctionBody(e, t, r), e.expression = e.body.type !== "BlockStatement";
    }
    parseMethod(e, t, r, i, o, d, u = false) {
      let E = this.startNode();
      return E.kind = e.kind, E = super.parseMethod(E, t, r, i, o, d, u), E.type = "FunctionExpression", delete E.kind, e.value = E, d === "ClassPrivateMethod" && (e.computed = false), d = "MethodDefinition", this.finishNode(e, d);
    }
    parseClassProperty(...e) {
      const t = super.parseClassProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition"), t;
    }
    parseClassPrivateProperty(...e) {
      const t = super.parseClassPrivateProperty(...e);
      return this.getPluginOption("estree", "classFeatures") && (t.type = "PropertyDefinition", t.computed = false), t;
    }
    parseObjectMethod(e, t, r, i, o) {
      const d = super.parseObjectMethod(e, t, r, i, o);
      return d && (d.type = "Property", d.kind === "method" && (d.kind = "init"), d.shorthand = false), d;
    }
    parseObjectProperty(e, t, r, i, o) {
      const d = super.parseObjectProperty(e, t, r, i, o);
      return d && (d.kind = "init", d.type = "Property"), d;
    }
    isValidLVal(e, ...t) {
      return e === "Property" ? "value" : super.isValidLVal(e, ...t);
    }
    isAssignable(e, t) {
      return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
    }
    toAssignable(e, t = false) {
      if (e != null && this.isObjectProperty(e)) {
        const {
          key: r,
          value: i
        } = e;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(i, t);
      } else
        super.toAssignable(e, t);
    }
    toAssignableObjectExpressionProp(e) {
      e.kind === "get" || e.kind === "set" ? this.raise(m.PatternHasAccessor, {
        at: e.key
      }) : e.method ? this.raise(m.PatternHasMethod, {
        at: e.key
      }) : super.toAssignableObjectExpressionProp(...arguments);
    }
    finishCallExpression(e, t) {
      if (super.finishCallExpression(e, t), e.callee.type === "Import") {
        if (e.type = "ImportExpression", e.source = e.arguments[0], this.hasPlugin("importAssertions")) {
          var r;
          e.attributes = (r = e.arguments[1]) != null ? r : null;
        }
        delete e.arguments, delete e.callee;
      }
      return e;
    }
    toReferencedArguments(e) {
      e.type !== "ImportExpression" && super.toReferencedArguments(e);
    }
    parseExport(e) {
      switch (super.parseExport(e), e.type) {
        case "ExportAllDeclaration":
          e.exported = null;
          break;
        case "ExportNamedDeclaration":
          e.specifiers.length === 1 && e.specifiers[0].type === "ExportNamespaceSpecifier" && (e.type = "ExportAllDeclaration", e.exported = e.specifiers[0].exported, delete e.specifiers);
          break;
      }
      return e;
    }
    parseSubscript(e, t, r, i, o) {
      const d = super.parseSubscript(e, t, r, i, o);
      if (o.optionalChainMember) {
        if ((d.type === "OptionalMemberExpression" || d.type === "OptionalCallExpression") && (d.type = d.type.substring(8)), o.stop) {
          const u = this.startNodeAtNode(d);
          return u.expression = d, this.finishNode(u, "ChainExpression");
        }
      } else
        (d.type === "MemberExpression" || d.type === "CallExpression") && (d.optional = false);
      return d;
    }
    hasPropertyAsPrivateName(e) {
      return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
    }
    isOptionalChain(e) {
      return e.type === "ChainExpression";
    }
    isObjectProperty(e) {
      return e.type === "Property" && e.kind === "init" && !e.method;
    }
    isObjectMethod(e) {
      return e.method || e.kind === "get" || e.kind === "set";
    }
    finishNodeAt(e, t, r) {
      return O(super.finishNodeAt(e, t, r));
    }
    resetStartLocation(e, t, r) {
      super.resetStartLocation(e, t, r), O(e);
    }
    resetEndLocation(e, t = this.state.lastTokEndLoc) {
      super.resetEndLocation(e, t), O(e);
    }
  };
  class M {
    constructor(e, t) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!t;
    }
  }
  const j = {
    brace: new M("{"),
    j_oTag: new M("<tag"),
    j_cTag: new M("</tag"),
    j_expr: new M("<tag>...</tag>", true)
  };
  j.template = new M("`", true);
  const $ = true, k = true, ne = true, Q = true, q = true, ee = true;
  class K {
    constructor(e, t = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.rightAssociative = !!t.rightAssociative, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop != null ? t.binop : null, this.updateContext = null;
    }
  }
  const G = /* @__PURE__ */ new Map();
  function V(a, e = {}) {
    e.keyword = a;
    const t = H(a, e);
    return G.set(a, t), t;
  }
  function F(a, e) {
    return H(a, {
      beforeExpr: $,
      binop: e
    });
  }
  let le = -1;
  const oe = [], fe = [], he = [], de = [], Pe = [], we = [];
  function H(a, e = {}) {
    var t, r, i, o;
    return ++le, fe.push(a), he.push((t = e.binop) != null ? t : -1), de.push((r = e.beforeExpr) != null ? r : false), Pe.push((i = e.startsExpr) != null ? i : false), we.push((o = e.prefix) != null ? o : false), oe.push(new K(a, e)), le;
  }
  function te(a, e = {}) {
    var t, r, i, o;
    return ++le, G.set(a, le), fe.push(a), he.push((t = e.binop) != null ? t : -1), de.push((r = e.beforeExpr) != null ? r : false), Pe.push((i = e.startsExpr) != null ? i : false), we.push((o = e.prefix) != null ? o : false), oe.push(new K("name", e)), le;
  }
  const Ie = {
    bracketL: H("[", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketHashL: H("#[", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketBarL: H("[|", {
      beforeExpr: $,
      startsExpr: k
    }),
    bracketR: H("]"),
    bracketBarR: H("|]"),
    braceL: H("{", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceBarL: H("{|", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceHashL: H("#{", {
      beforeExpr: $,
      startsExpr: k
    }),
    braceR: H("}"),
    braceBarR: H("|}"),
    parenL: H("(", {
      beforeExpr: $,
      startsExpr: k
    }),
    parenR: H(")"),
    comma: H(",", {
      beforeExpr: $
    }),
    semi: H(";", {
      beforeExpr: $
    }),
    colon: H(":", {
      beforeExpr: $
    }),
    doubleColon: H("::", {
      beforeExpr: $
    }),
    dot: H("."),
    question: H("?", {
      beforeExpr: $
    }),
    questionDot: H("?."),
    arrow: H("=>", {
      beforeExpr: $
    }),
    template: H("template"),
    ellipsis: H("...", {
      beforeExpr: $
    }),
    backQuote: H("`", {
      startsExpr: k
    }),
    dollarBraceL: H("${", {
      beforeExpr: $,
      startsExpr: k
    }),
    templateTail: H("...`", {
      startsExpr: k
    }),
    templateNonTail: H("...${", {
      beforeExpr: $,
      startsExpr: k
    }),
    at: H("@"),
    hash: H("#", {
      startsExpr: k
    }),
    interpreterDirective: H("#!..."),
    eq: H("=", {
      beforeExpr: $,
      isAssign: Q
    }),
    assign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    slashAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    xorAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    moduloAssign: H("_=", {
      beforeExpr: $,
      isAssign: Q
    }),
    incDec: H("++/--", {
      prefix: q,
      postfix: ee,
      startsExpr: k
    }),
    bang: H("!", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    tilde: H("~", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    doubleCaret: H("^^", {
      startsExpr: k
    }),
    doubleAt: H("@@", {
      startsExpr: k
    }),
    pipeline: F("|>", 0),
    nullishCoalescing: F("??", 1),
    logicalOR: F("||", 1),
    logicalAND: F("&&", 2),
    bitwiseOR: F("|", 3),
    bitwiseXOR: F("^", 4),
    bitwiseAND: F("&", 5),
    equality: F("==/!=/===/!==", 6),
    lt: F("</>/<=/>=", 7),
    gt: F("</>/<=/>=", 7),
    relational: F("</>/<=/>=", 7),
    bitShift: F("<</>>/>>>", 8),
    bitShiftL: F("<</>>/>>>", 8),
    bitShiftR: F("<</>>/>>>", 8),
    plusMin: H("+/-", {
      beforeExpr: $,
      binop: 9,
      prefix: q,
      startsExpr: k
    }),
    modulo: H("%", {
      binop: 10,
      startsExpr: k
    }),
    star: H("*", {
      binop: 10
    }),
    slash: F("/", 10),
    exponent: H("**", {
      beforeExpr: $,
      binop: 11,
      rightAssociative: true
    }),
    _in: V("in", {
      beforeExpr: $,
      binop: 7
    }),
    _instanceof: V("instanceof", {
      beforeExpr: $,
      binop: 7
    }),
    _break: V("break"),
    _case: V("case", {
      beforeExpr: $
    }),
    _catch: V("catch"),
    _continue: V("continue"),
    _debugger: V("debugger"),
    _default: V("default", {
      beforeExpr: $
    }),
    _else: V("else", {
      beforeExpr: $
    }),
    _finally: V("finally"),
    _function: V("function", {
      startsExpr: k
    }),
    _if: V("if"),
    _return: V("return", {
      beforeExpr: $
    }),
    _switch: V("switch"),
    _throw: V("throw", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _try: V("try"),
    _var: V("var"),
    _const: V("const"),
    _with: V("with"),
    _new: V("new", {
      beforeExpr: $,
      startsExpr: k
    }),
    _this: V("this", {
      startsExpr: k
    }),
    _super: V("super", {
      startsExpr: k
    }),
    _class: V("class", {
      startsExpr: k
    }),
    _extends: V("extends", {
      beforeExpr: $
    }),
    _export: V("export"),
    _import: V("import", {
      startsExpr: k
    }),
    _null: V("null", {
      startsExpr: k
    }),
    _true: V("true", {
      startsExpr: k
    }),
    _false: V("false", {
      startsExpr: k
    }),
    _typeof: V("typeof", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _void: V("void", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _delete: V("delete", {
      beforeExpr: $,
      prefix: q,
      startsExpr: k
    }),
    _do: V("do", {
      isLoop: ne,
      beforeExpr: $
    }),
    _for: V("for", {
      isLoop: ne
    }),
    _while: V("while", {
      isLoop: ne
    }),
    _as: te("as", {
      startsExpr: k
    }),
    _assert: te("assert", {
      startsExpr: k
    }),
    _async: te("async", {
      startsExpr: k
    }),
    _await: te("await", {
      startsExpr: k
    }),
    _from: te("from", {
      startsExpr: k
    }),
    _get: te("get", {
      startsExpr: k
    }),
    _let: te("let", {
      startsExpr: k
    }),
    _meta: te("meta", {
      startsExpr: k
    }),
    _of: te("of", {
      startsExpr: k
    }),
    _sent: te("sent", {
      startsExpr: k
    }),
    _set: te("set", {
      startsExpr: k
    }),
    _static: te("static", {
      startsExpr: k
    }),
    _yield: te("yield", {
      startsExpr: k
    }),
    _asserts: te("asserts", {
      startsExpr: k
    }),
    _checks: te("checks", {
      startsExpr: k
    }),
    _exports: te("exports", {
      startsExpr: k
    }),
    _global: te("global", {
      startsExpr: k
    }),
    _implements: te("implements", {
      startsExpr: k
    }),
    _intrinsic: te("intrinsic", {
      startsExpr: k
    }),
    _infer: te("infer", {
      startsExpr: k
    }),
    _is: te("is", {
      startsExpr: k
    }),
    _mixins: te("mixins", {
      startsExpr: k
    }),
    _proto: te("proto", {
      startsExpr: k
    }),
    _require: te("require", {
      startsExpr: k
    }),
    _keyof: te("keyof", {
      startsExpr: k
    }),
    _readonly: te("readonly", {
      startsExpr: k
    }),
    _unique: te("unique", {
      startsExpr: k
    }),
    _abstract: te("abstract", {
      startsExpr: k
    }),
    _declare: te("declare", {
      startsExpr: k
    }),
    _enum: te("enum", {
      startsExpr: k
    }),
    _module: te("module", {
      startsExpr: k
    }),
    _namespace: te("namespace", {
      startsExpr: k
    }),
    _interface: te("interface", {
      startsExpr: k
    }),
    _type: te("type", {
      startsExpr: k
    }),
    _opaque: te("opaque", {
      startsExpr: k
    }),
    name: H("name", {
      startsExpr: k
    }),
    string: H("string", {
      startsExpr: k
    }),
    num: H("num", {
      startsExpr: k
    }),
    bigint: H("bigint", {
      startsExpr: k
    }),
    decimal: H("decimal", {
      startsExpr: k
    }),
    regexp: H("regexp", {
      startsExpr: k
    }),
    privateName: H("#name", {
      startsExpr: k
    }),
    eof: H("eof"),
    jsxName: H("jsxName"),
    jsxText: H("jsxText", {
      beforeExpr: true
    }),
    jsxTagStart: H("jsxTagStart", {
      startsExpr: true
    }),
    jsxTagEnd: H("jsxTagEnd"),
    placeholder: H("%%", {
      startsExpr: true
    })
  };
  function Te(a) {
    return a >= 93 && a <= 128;
  }
  function pe(a) {
    return a <= 92;
  }
  function z(a) {
    return a >= 58 && a <= 128;
  }
  function W(a) {
    return a >= 58 && a <= 132;
  }
  function ae(a) {
    return de[a];
  }
  function ce(a) {
    return Pe[a];
  }
  function xe(a) {
    return a >= 29 && a <= 33;
  }
  function Se(a) {
    return a >= 125 && a <= 127;
  }
  function Le(a) {
    return a >= 90 && a <= 92;
  }
  function Ee(a) {
    return a >= 58 && a <= 92;
  }
  function J(a) {
    return a >= 39 && a <= 59;
  }
  function me(a) {
    return a === 34;
  }
  function ke(a) {
    return we[a];
  }
  function _e(a) {
    return a >= 117 && a <= 119;
  }
  function Re(a) {
    return a >= 120 && a <= 126;
  }
  function $e(a) {
    return fe[a];
  }
  function Ge(a) {
    return he[a];
  }
  function lt(a) {
    return a === 57;
  }
  function Ze(a) {
    return a >= 24 && a <= 25;
  }
  function Xe(a) {
    return oe[a];
  }
  oe[8].updateContext = (a) => {
    a.pop();
  }, oe[5].updateContext = oe[7].updateContext = oe[23].updateContext = (a) => {
    a.push(j.brace);
  }, oe[22].updateContext = (a) => {
    a[a.length - 1] === j.template ? a.pop() : a.push(j.template);
  }, oe[138].updateContext = (a) => {
    a.push(j.j_expr, j.j_oTag);
  };
  let et = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", st = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const re = new RegExp("[" + et + "]"), be = new RegExp("[" + et + st + "]");
  et = st = null;
  const ue = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Me = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Y(a, e) {
    let t = 65536;
    for (let r = 0, i = e.length; r < i; r += 2) {
      if (t += e[r], t > a)
        return false;
      if (t += e[r + 1], t >= a)
        return true;
    }
    return false;
  }
  function Ne(a) {
    return a < 65 ? a === 36 : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && re.test(String.fromCharCode(a)) : Y(a, ue);
  }
  function Be(a) {
    return a < 48 ? a === 36 : a < 58 ? true : a < 65 ? false : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && be.test(String.fromCharCode(a)) : Y(a, ue) || Y(a, Me);
  }
  const X = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, je = new Set(X.keyword), rt = new Set(X.strict), vt = new Set(X.strictBind);
  function gt(a, e) {
    return e && a === "await" || a === "enum";
  }
  function ut(a, e) {
    return gt(a, e) || rt.has(a);
  }
  function qe(a) {
    return vt.has(a);
  }
  function De(a, e) {
    return ut(a, e) || qe(a);
  }
  function Tt(a) {
    return je.has(a);
  }
  function sr(a, e, t) {
    return a === 64 && e === 64 && Ne(t);
  }
  const ar = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Nr(a) {
    return ar.has(a);
  }
  const At = 0, Dt = 1, Ye = 2, bt = 4, ct = 8, $t = 16, Mr = 32, xt = 64, or = 128, qt = 256, Vt = Dt | Ye | qt, it = 1, wt = 2, Br = 4, pt = 8, Kt = 16, _r = 64, Wt = 128, lr = 256, ur = 512, cr = 1024, pr = 2048, Fr = it | wt | pt | Wt, nt = it | 0 | pt | 0, Ht = it | 0 | Br | 0, jr = it | 0 | Kt | 0, Es = 0 | wt | 0 | Wt, vs = 0 | wt | 0 | 0, Rr = it | wt | pt | lr, Ur = 0 | cr, Pt = 0 | _r, As = it | 0 | 0 | _r, Cs = Rr | ur, ws = 0 | cr, Is = pr, zt = 4, fr = 2, hr = 1, dr = fr | hr, Ns = fr | zt, ks = hr | zt, Os = fr, Ds = hr, mr = 0;
  class Ls {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        const [t, r] = e;
        if (!this.hasPlugin(t))
          return false;
        const i = this.plugins.get(t);
        for (const o of Object.keys(r))
          if ((i == null ? void 0 : i[o]) !== r[o])
            return false;
        return true;
      }
    }
    getPluginOption(e, t) {
      var r;
      return (r = this.plugins.get(e)) == null ? void 0 : r[t];
    }
  }
  function $r(a, e) {
    a.trailingComments === void 0 ? a.trailingComments = e : a.trailingComments.unshift(...e);
  }
  function Ms(a, e) {
    a.leadingComments === void 0 ? a.leadingComments = e : a.leadingComments.unshift(...e);
  }
  function Bt(a, e) {
    a.innerComments === void 0 ? a.innerComments = e : a.innerComments.unshift(...e);
  }
  function _t(a, e, t) {
    let r = null, i = e.length;
    for (; r === null && i > 0; )
      r = e[--i];
    r === null || r.start > t.start ? Bt(a, t.comments) : $r(r, t.comments);
  }
  class Bs extends Ls {
    addComment(e) {
      this.filename && (e.loc.filename = this.filename), this.state.comments.push(e);
    }
    processComment(e) {
      const {
        commentStack: t
      } = this.state, r = t.length;
      if (r === 0)
        return;
      let i = r - 1;
      const o = t[i];
      o.start === e.end && (o.leadingNode = e, i--);
      const {
        start: d
      } = e;
      for (; i >= 0; i--) {
        const u = t[i], E = u.end;
        if (E > d)
          u.containingNode = e, this.finalizeComment(u), t.splice(i, 1);
        else {
          E === d && (u.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      const {
        comments: t
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && $r(e.leadingNode, t), e.trailingNode !== null && Ms(e.trailingNode, t);
      else {
        const {
          containingNode: r,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (r.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              _t(r, r.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              _t(r, r.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              _t(r, r.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              _t(r, r.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              _t(r, r.specifiers, e);
              break;
            default:
              Bt(r, t);
          }
        else
          Bt(r, t);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack: e
      } = this.state;
      for (let t = e.length - 1; t >= 0; t--)
        this.finalizeComment(e[t]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      const {
        commentStack: t
      } = this.state, {
        length: r
      } = t;
      if (r === 0)
        return;
      const i = t[r - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    takeSurroundingComments(e, t, r) {
      const {
        commentStack: i
      } = this.state, o = i.length;
      if (o === 0)
        return;
      let d = o - 1;
      for (; d >= 0; d--) {
        const u = i[d], E = u.end;
        if (u.start === r)
          u.leadingNode = e;
        else if (E === t)
          u.trailingNode = e;
        else if (E < t)
          break;
      }
    }
  }
  const yr = /\r\n?|[\n\u2028\u2029]/, Gt = new RegExp(yr.source, "g");
  function St(a) {
    switch (a) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const br = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, _s = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, qr = new RegExp("(?=(" + _s.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Fs(a) {
    switch (a) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class gr {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 135, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [j.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    init({
      strictMode: e,
      sourceType: t,
      startLine: r,
      startColumn: i
    }) {
      this.strict = e === false ? false : e === true ? true : t === "module", this.curLine = r, this.lineStart = -i, this.startLoc = this.endLoc = new n(r, i, 0);
    }
    curPosition() {
      return new n(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(e) {
      const t = new gr(), r = Object.keys(this);
      for (let i = 0, o = r.length; i < o; i++) {
        const d = r[i];
        let u = this[d];
        !e && Array.isArray(u) && (u = u.slice()), t[d] = u;
      }
      return t;
    }
  }
  const js = ["at"], Rs = ["at"];
  var Us = function(e) {
    return e >= 48 && e <= 57;
  };
  const $s = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Vr = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Xt = {
    bin: (a) => a === 48 || a === 49,
    oct: (a) => a >= 48 && a <= 55,
    dec: (a) => a >= 48 && a <= 57,
    hex: (a) => a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102
  };
  class ft {
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new h(e.startLoc, e.endLoc);
    }
  }
  class qs extends Bs {
    constructor(e, t) {
      super(), this.isLookahead = void 0, this.tokens = [], this.state = new gr(), this.state.init(e), this.input = t, this.length = t.length, this.isLookahead = false;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ft(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), true) : false;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      const e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t = this.state;
      return this.state = e, t;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return br.lastIndex = e, br.test(this.input) ? br.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(e) {
      let t = this.input.charCodeAt(e);
      if ((t & 64512) === 55296 && ++e < this.input.length) {
        const r = this.input.charCodeAt(e);
        (r & 64512) === 56320 && (t = 65536 + ((t & 1023) << 10) + (r & 1023));
      }
      return t;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([t, r]) => this.raise(t, {
        at: r
      })), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(135);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
      let e;
      this.isLookahead || (e = this.state.curPosition());
      const t = this.state.pos, r = this.input.indexOf("*/", t + 2);
      if (r === -1)
        throw this.raise(m.UnterminatedComment, {
          at: this.state.curPosition()
        });
      for (this.state.pos = r + 2, Gt.lastIndex = t + 2; Gt.test(this.input) && Gt.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = Gt.lastIndex;
      if (this.isLookahead)
        return;
      const i = {
        type: "CommentBlock",
        value: this.input.slice(t + 2, r),
        start: t,
        end: r + 2,
        loc: new h(e, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(i), i;
    }
    skipLineComment(e) {
      const t = this.state.pos;
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !St(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      const o = this.state.pos, d = this.input.slice(t + e, o), u = {
        type: "CommentLine",
        value: d,
        start: t,
        end: o,
        loc: new h(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(u), u;
    }
    skipSpace() {
      const e = this.state.pos, t = [];
      e:
        for (; this.state.pos < this.length; ) {
          const r = this.input.charCodeAt(this.state.pos);
          switch (r) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const i = this.skipBlockComment();
                  i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
                  break;
                }
                case 47: {
                  const i = this.skipLineComment(2);
                  i !== void 0 && (this.addComment(i), this.options.attachComment && t.push(i));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Fs(r))
                ++this.state.pos;
              else if (r === 45 && !this.inModule) {
                const i = this.state.pos;
                if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                  const o = this.skipLineComment(3);
                  o !== void 0 && (this.addComment(o), this.options.attachComment && t.push(o));
                } else
                  break e;
              } else if (r === 60 && !this.inModule) {
                const i = this.state.pos;
                if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                  const o = this.skipLineComment(4);
                  o !== void 0 && (this.addComment(o), this.options.attachComment && t.push(o));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (t.length > 0) {
        const r = this.state.pos, i = {
          start: e,
          end: r,
          comments: t,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, t) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const r = this.state.type;
      this.state.type = e, this.state.value = t, this.isLookahead || this.updateContext(r);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const e = this.state.pos + 1, t = this.codePointAtPos(e);
      if (t >= 48 && t <= 57)
        throw this.raise(m.UnexpectedDigitAfterHash, {
          at: this.state.curPosition()
        });
      if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
          throw this.raise(t === 123 ? m.RecordExpressionHashIncorrectStartSyntaxType : m.TupleExpressionHashIncorrectStartSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, t === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        Ne(t) ? (++this.state.pos, this.finishToken(134, this.readWord1(t))) : t === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(true);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33)
        return false;
      const t = this.state.pos;
      for (this.state.pos += 1; !St(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      const r = this.input.slice(t + 2, this.state.pos);
      return this.finishToken(28, r), true;
    }
    readToken_mult_modulo(e) {
      let t = e === 42 ? 55 : 54, r = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (r++, i = this.input.charCodeAt(this.state.pos + 2), t = 57), i === 61 && !this.state.inType && (r++, t = e === 37 ? 33 : 30), this.finishOp(t, r);
    }
    readToken_pipe_amp(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (t === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && t === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(m.RecordExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && t === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(m.TupleExpressionBarIncorrectEndSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (t === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const e = this.input.charCodeAt(this.state.pos + 1);
      if (e === 61 && !this.state.inType)
        this.finishOp(32, 2);
      else if (e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
          throw this.unexpected();
      } else
        this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === e) {
        this.finishOp(34, 2);
        return;
      }
      t === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: e
      } = this.state, t = this.input.charCodeAt(e + 1);
      if (t === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (t === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: e
      } = this.state, t = this.input.charCodeAt(e + 1);
      if (t === 62) {
        const r = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + r) === 61) {
          this.finishOp(30, r + 1);
          return;
        }
        this.finishOp(52, r);
        return;
      }
      if (t === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (t === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && t === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const e = this.input.charCodeAt(this.state.pos + 1), t = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? t === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(t >= 48 && t <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(m.TupleExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(m.RecordExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const t = this.input.charCodeAt(this.state.pos + 1);
          if (t === 120 || t === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (t === 111 || t === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (t === 98 || t === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ne(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(m.InvalidOrUnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, t) {
      const r = this.input.slice(this.state.pos, this.state.pos + t);
      this.state.pos += t, this.finishToken(e, r);
    }
    readRegexp() {
      const e = this.state.startLoc, t = this.state.start + 1;
      let r, i, {
        pos: o
      } = this.state;
      for (; ; ++o) {
        if (o >= this.length)
          throw this.raise(m.UnterminatedRegExp, {
            at: f2(e, 1)
          });
        const w = this.input.charCodeAt(o);
        if (St(w))
          throw this.raise(m.UnterminatedRegExp, {
            at: f2(e, 1)
          });
        if (r)
          r = false;
        else {
          if (w === 91)
            i = true;
          else if (w === 93 && i)
            i = false;
          else if (w === 47 && !i)
            break;
          r = w === 92;
        }
      }
      const d = this.input.slice(t, o);
      ++o;
      let u = "";
      const E = () => f2(e, o + 2 - t);
      for (; o < this.length; ) {
        const w = this.codePointAtPos(o), U = String.fromCharCode(w);
        if ($s.has(w))
          w === 118 ? (this.expectPlugin("regexpUnicodeSets", E()), u.includes("u") && this.raise(m.IncompatibleRegExpUVFlags, {
            at: E()
          })) : w === 117 && u.includes("v") && this.raise(m.IncompatibleRegExpUVFlags, {
            at: E()
          }), u.includes(U) && this.raise(m.DuplicateRegExpFlags, {
            at: E()
          });
        else if (Be(w) || w === 92)
          this.raise(m.MalformedRegExpFlags, {
            at: E()
          });
        else
          break;
        ++o, u += U;
      }
      this.state.pos = o, this.finishToken(133, {
        pattern: d,
        flags: u
      });
    }
    readInt(e, t, r, i = true) {
      const o = this.state.pos, d = e === 16 ? Vr.hex : Vr.decBinOct, u = e === 16 ? Xt.hex : e === 10 ? Xt.dec : e === 8 ? Xt.oct : Xt.bin;
      let E = false, w = 0;
      for (let U = 0, ge = t == null ? 1 / 0 : t; U < ge; ++U) {
        const ye = this.input.charCodeAt(this.state.pos);
        let Ae;
        if (ye === 95 && i !== "bail") {
          const Oe = this.input.charCodeAt(this.state.pos - 1), Ve = this.input.charCodeAt(this.state.pos + 1);
          i ? (Number.isNaN(Ve) || !u(Ve) || d.has(Oe) || d.has(Ve)) && this.raise(m.UnexpectedNumericSeparator, {
            at: this.state.curPosition()
          }) : this.raise(m.NumericSeparatorInEscapeSequence, {
            at: this.state.curPosition()
          }), ++this.state.pos;
          continue;
        }
        if (ye >= 97 ? Ae = ye - 97 + 10 : ye >= 65 ? Ae = ye - 65 + 10 : Us(ye) ? Ae = ye - 48 : Ae = 1 / 0, Ae >= e)
          if (this.options.errorRecovery && Ae <= 9)
            Ae = 0, this.raise(m.InvalidDigit, {
              at: this.state.curPosition(),
              radix: e
            });
          else if (r)
            Ae = 0, E = true;
          else
            break;
        ++this.state.pos, w = w * e + Ae;
      }
      return this.state.pos === o || t != null && this.state.pos - o !== t || E ? null : w;
    }
    readRadixNumber(e) {
      const t = this.state.curPosition();
      let r = false;
      this.state.pos += 2;
      const i = this.readInt(e);
      i == null && this.raise(m.InvalidDigit, {
        at: f2(t, 2),
        radix: e
      });
      const o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = true;
      else if (o === 109)
        throw this.raise(m.InvalidDecimal, {
          at: t
        });
      if (Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(m.NumberIdentifier, {
          at: this.state.curPosition()
        });
      if (r) {
        const d = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(131, d);
        return;
      }
      this.finishToken(130, i);
    }
    readNumber(e) {
      const t = this.state.pos, r = this.state.curPosition();
      let i = false, o = false, d = false, u = false, E = false;
      !e && this.readInt(10) === null && this.raise(m.InvalidNumber, {
        at: this.state.curPosition()
      });
      const w = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
      if (w) {
        const Ae = this.input.slice(t, this.state.pos);
        if (this.recordStrictModeErrors(m.StrictOctalLiteral, {
          at: r
        }), !this.state.strict) {
          const Oe = Ae.indexOf("_");
          Oe > 0 && this.raise(m.ZeroDigitNumericSeparator, {
            at: f2(r, Oe)
          });
        }
        E = w && !/[89]/.test(Ae);
      }
      let U = this.input.charCodeAt(this.state.pos);
      if (U === 46 && !E && (++this.state.pos, this.readInt(10), i = true, U = this.input.charCodeAt(this.state.pos)), (U === 69 || U === 101) && !E && (U = this.input.charCodeAt(++this.state.pos), (U === 43 || U === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(m.InvalidOrMissingExponent, {
        at: r
      }), i = true, u = true, U = this.input.charCodeAt(this.state.pos)), U === 110 && ((i || w) && this.raise(m.InvalidBigIntLiteral, {
        at: r
      }), ++this.state.pos, o = true), U === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (u || w) && this.raise(m.InvalidDecimal, {
        at: r
      }), ++this.state.pos, d = true), Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(m.NumberIdentifier, {
          at: this.state.curPosition()
        });
      const ge = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
      if (o) {
        this.finishToken(131, ge);
        return;
      }
      if (d) {
        this.finishToken(132, ge);
        return;
      }
      const ye = E ? parseInt(ge, 8) : parseFloat(ge);
      this.finishToken(130, ye);
    }
    readCodePoint(e) {
      const t = this.input.charCodeAt(this.state.pos);
      let r;
      if (t === 123) {
        if (++this.state.pos, r = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e), ++this.state.pos, r !== null && r > 1114111)
          if (e)
            this.raise(m.InvalidCodePoint, {
              at: this.state.curPosition()
            });
          else
            return null;
      } else
        r = this.readHexChar(4, false, e);
      return r;
    }
    readString(e) {
      let t = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedString, {
            at: this.state.startLoc
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === e)
          break;
        if (i === 92)
          t += this.input.slice(r, this.state.pos), t += this.readEscapedChar(false), r = this.state.pos;
        else if (i === 8232 || i === 8233)
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        else {
          if (St(i))
            throw this.raise(m.UnterminatedString, {
              at: this.state.startLoc
            });
          ++this.state.pos;
        }
      }
      t += this.input.slice(r, this.state.pos++), this.finishToken(129, t);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = "", t = this.state.pos, r = false;
      for (++this.state.pos; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedTemplate, {
            at: f2(this.state.startLoc, 1)
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === 96) {
          ++this.state.pos, e += this.input.slice(t, this.state.pos), this.finishToken(24, r ? null : e);
          return;
        }
        if (i === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          this.state.pos += 2, e += this.input.slice(t, this.state.pos), this.finishToken(25, r ? null : e);
          return;
        }
        if (i === 92) {
          e += this.input.slice(t, this.state.pos);
          const o = this.readEscapedChar(true);
          o === null ? r = true : e += o, t = this.state.pos;
        } else if (St(i)) {
          switch (e += this.input.slice(t, this.state.pos), ++this.state.pos, i) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
            case 10:
              e += `
`;
              break;
            default:
              e += String.fromCharCode(i);
              break;
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, t = this.state.pos;
        } else
          ++this.state.pos;
      }
    }
    recordStrictModeErrors(e, {
      at: t
    }) {
      const r = t.index;
      this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, {
        at: t
      }) : this.state.strictErrors.set(r, [e, t]);
    }
    readEscapedChar(e) {
      const t = !e, r = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, r) {
        case 110:
          return `
`;
        case 114:
          return "\r";
        case 120: {
          const i = this.readHexChar(2, false, t);
          return i === null ? null : String.fromCharCode(i);
        }
        case 117: {
          const i = this.readCodePoint(t);
          return i === null ? null : String.fromCodePoint(i);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
        case 10:
          this.state.lineStart = this.state.pos, ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (e)
            return null;
          this.recordStrictModeErrors(m.StrictNumericEscape, {
            at: f2(this.state.curPosition(), -1)
          });
        default:
          if (r >= 48 && r <= 55) {
            const i = f2(this.state.curPosition(), -1);
            let d = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0], u = parseInt(d, 8);
            u > 255 && (d = d.slice(0, -1), u = parseInt(d, 8)), this.state.pos += d.length - 1;
            const E = this.input.charCodeAt(this.state.pos);
            if (d !== "0" || E === 56 || E === 57) {
              if (e)
                return null;
              this.recordStrictModeErrors(m.StrictNumericEscape, {
                at: i
              });
            }
            return String.fromCharCode(u);
          }
          return String.fromCharCode(r);
      }
    }
    readHexChar(e, t, r) {
      const i = this.state.curPosition(), o = this.readInt(16, e, t, false);
      return o === null && (r ? this.raise(m.InvalidEscapeSequence, {
        at: i
      }) : this.state.pos = i.index - 1), o;
    }
    readWord1(e) {
      this.state.containsEsc = false;
      let t = "";
      const r = this.state.pos;
      let i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const o = this.codePointAtPos(this.state.pos);
        if (Be(o))
          this.state.pos += o <= 65535 ? 1 : 2;
        else if (o === 92) {
          this.state.containsEsc = true, t += this.input.slice(i, this.state.pos);
          const d = this.state.curPosition(), u = this.state.pos === r ? Ne : Be;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(m.MissingUnicodeEscape, {
              at: this.state.curPosition()
            }), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const E = this.readCodePoint(true);
          E !== null && (u(E) || this.raise(m.EscapedCharNotAnIdentifier, {
            at: d
          }), t += String.fromCodePoint(E)), i = this.state.pos;
        } else
          break;
      }
      return t + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      const t = this.readWord1(e), r = G.get(t);
      r !== void 0 ? this.finishToken(r, $e(r)) : this.finishToken(128, t);
    }
    checkKeywordEscapes() {
      const {
        type: e
      } = this.state;
      Ee(e) && this.state.containsEsc && this.raise(m.InvalidEscapedReservedWord, {
        at: this.state.startLoc,
        reservedWord: $e(e)
      });
    }
    raise(e, t) {
      const {
        at: r
      } = t, i = s(t, js), o = r instanceof n ? r : r.loc.start, d = e({
        loc: o,
        details: i
      });
      if (!this.options.errorRecovery)
        throw d;
      return this.isLookahead || this.state.errors.push(d), d;
    }
    raiseOverwrite(e, t) {
      const {
        at: r
      } = t, i = s(t, Rs), o = r instanceof n ? r : r.loc.start, d = o.index, u = this.state.errors;
      for (let E = u.length - 1; E >= 0; E--) {
        const w = u[E];
        if (w.loc.index === d)
          return u[E] = e({
            loc: o,
            details: i
          });
        if (w.loc.index < d)
          break;
      }
      return this.raise(e, t);
    }
    updateContext(e) {
    }
    unexpected(e, t) {
      throw this.raise(m.UnexpectedToken, {
        expected: t ? $e(t) : null,
        at: e != null ? e : this.state.startLoc
      });
    }
    expectPlugin(e, t) {
      if (this.hasPlugin(e))
        return true;
      throw this.raise(m.MissingPlugin, {
        at: t != null ? t : this.state.startLoc,
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((t) => this.hasPlugin(t)))
        throw this.raise(m.MissingOneOfPlugins, {
          at: this.state.startLoc,
          missingPlugin: e
        });
    }
  }
  class Tr {
    constructor(e) {
      this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = e;
    }
  }
  class xr {
    constructor(e, t) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e, this.inModule = t;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & Ye) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & $t) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & Mr) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & xt) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e = this.currentThisScopeFlags();
      return (e & xt) > 0 && (e & Ye) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & or)
          return true;
        if (t & (Vt | xt))
          return false;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & Ye) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Tr(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & (Ye | or) || !this.parser.inModule && e.flags & Dt);
    }
    declareName(e, t, r) {
      let i = this.currentScope();
      if (t & pt || t & Kt)
        this.checkRedeclarationInScope(i, e, t, r), t & Kt ? i.functions.add(e) : i.lexical.add(e), t & pt && this.maybeExportDefined(i, e);
      else if (t & Br)
        for (let o = this.scopeStack.length - 1; o >= 0 && (i = this.scopeStack[o], this.checkRedeclarationInScope(i, e, t, r), i.var.add(e), this.maybeExportDefined(i, e), !(i.flags & Vt)); --o)
          ;
      this.parser.inModule && i.flags & Dt && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, t) {
      this.parser.inModule && e.flags & Dt && this.undefinedExports.delete(t);
    }
    checkRedeclarationInScope(e, t, r, i) {
      this.isRedeclaredInScope(e, t, r) && this.parser.raise(m.VarRedeclaration, {
        at: i,
        identifierName: t
      });
    }
    isRedeclaredInScope(e, t, r) {
      return r & it ? r & pt ? e.lexical.has(t) || e.functions.has(t) || e.var.has(t) : r & Kt ? e.lexical.has(t) || !this.treatFunctionsAsVarInScope(e) && e.var.has(t) : e.lexical.has(t) && !(e.flags & ct && e.lexical.values().next().value === t) || !this.treatFunctionsAsVarInScope(e) && e.functions.has(t) : false;
    }
    checkLocalExport(e) {
      const {
        name: t
      } = e, r = this.scopeStack[0];
      !r.lexical.has(t) && !r.var.has(t) && !r.functions.has(t) && this.undefinedExports.set(t, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & Vt)
          return t;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        const {
          flags: t
        } = this.scopeStack[e];
        if (t & (Vt | xt) && !(t & bt))
          return t;
      }
    }
  }
  class Vs extends Tr {
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class Ks extends xr {
    createScope(e) {
      return new Vs(e);
    }
    declareName(e, t, r) {
      const i = this.currentScope();
      if (t & pr) {
        this.checkRedeclarationInScope(i, e, t, r), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(...arguments);
    }
    isRedeclaredInScope(e, t, r) {
      return super.isRedeclaredInScope(...arguments) ? true : r & pr ? !e.declareFunctions.has(t) && (e.lexical.has(t) || e.functions.has(t)) : false;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }
  class Ws {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class Hs {
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Ws());
    }
    exit() {
      const e = this.stack.pop(), t = this.current();
      for (const [r, i] of Array.from(e.undefinedPrivateNames))
        t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, i) : this.parser.raise(m.InvalidPrivateFieldResolution, {
          at: i,
          identifierName: r
        });
    }
    declarePrivateName(e, t, r) {
      const {
        privateNames: i,
        loneAccessors: o,
        undefinedPrivateNames: d
      } = this.current();
      let u = i.has(e);
      if (t & dr) {
        const E = u && o.get(e);
        if (E) {
          const w = E & zt, U = t & zt, ge = E & dr, ye = t & dr;
          u = ge === ye || w !== U, u || o.delete(e);
        } else
          u || o.set(e, t);
      }
      u && this.parser.raise(m.PrivateNameRedeclaration, {
        at: r,
        identifierName: e
      }), i.add(e), d.delete(e);
    }
    usePrivateName(e, t) {
      let r;
      for (r of this.stack)
        if (r.privateNames.has(e))
          return;
      r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(m.InvalidPrivateFieldResolution, {
        at: t,
        identifierName: e
      });
    }
  }
  const zs = 0, Kr = 1, Pr = 2, Wr = 3;
  class Jt {
    constructor(e = zs) {
      this.type = void 0, this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === Pr || this.type === Kr;
    }
    isCertainlyParameterDeclaration() {
      return this.type === Wr;
    }
  }
  class Hr extends Jt {
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, {
      at: t
    }) {
      const r = t.index;
      this.declarationErrors.set(r, [e, t]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }
  class Gs {
    constructor(e) {
      this.parser = void 0, this.stack = [new Jt()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, {
      at: t
    }) {
      const r = {
        at: t.loc.start
      }, {
        stack: i
      } = this;
      let o = i.length - 1, d = i[o];
      for (; !d.isCertainlyParameterDeclaration(); ) {
        if (d.canBeArrowParameterDeclaration())
          d.recordDeclarationError(e, r);
        else
          return;
        d = i[--o];
      }
      this.parser.raise(e, r);
    }
    recordArrowParemeterBindingError(e, {
      at: t
    }) {
      const {
        stack: r
      } = this, i = r[r.length - 1], o = {
        at: t.loc.start
      };
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, o);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, o);
      else
        return;
    }
    recordAsyncArrowParametersError({
      at: e
    }) {
      const {
        stack: t
      } = this;
      let r = t.length - 1, i = t[r];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === Pr && i.recordDeclarationError(m.AwaitBindingIdentifier, {
          at: e
        }), i = t[--r];
    }
    validateAsPattern() {
      const {
        stack: e
      } = this, t = e[e.length - 1];
      !t.canBeArrowParameterDeclaration() || t.iterateErrors(([r, i]) => {
        this.parser.raise(r, {
          at: i
        });
        let o = e.length - 2, d = e[o];
        for (; d.canBeArrowParameterDeclaration(); )
          d.clearDeclarationError(i.index), d = e[--o];
      });
    }
  }
  function Xs() {
    return new Jt(Wr);
  }
  function Js() {
    return new Hr(Kr);
  }
  function Ys() {
    return new Hr(Pr);
  }
  function zr() {
    return new Jt();
  }
  const It = 0, Gr = 1, Yt = 2, Xr = 4, Nt = 8;
  class Qs {
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & Yt) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & Gr) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & Xr) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & Nt) > 0;
    }
  }
  function Qt(a, e) {
    return (a ? Yt : 0) | (e ? Gr : 0);
  }
  class Zs extends qs {
    addExtra(e, t, r, i = true) {
      if (!e)
        return;
      const o = e.extra = e.extra || {};
      i ? o[t] = r : Object.defineProperty(o, t, {
        enumerable: i,
        value: r
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, t) {
      const r = e + t.length;
      if (this.input.slice(e, r) === t) {
        const i = this.input.charCodeAt(r);
        return !(Be(i) || (i & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(e) {
      const t = this.nextTokenStart();
      return this.isUnparsedContextual(t, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), true) : false;
    }
    expectContextual(e, t) {
      if (!this.eatContextual(e))
        throw t != null ? this.raise(t, {
          at: this.state.startLoc
        }) : this.unexpected(null, e);
    }
    canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return yr.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return qr.lastIndex = this.state.end, qr.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = true) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(m.MissingSemicolon, {
        at: this.state.lastTokEndLoc
      });
    }
    expect(e, t) {
      this.eat(e) || this.unexpected(t, e);
    }
    tryParse(e, t = this.state.clone()) {
      const r = {
        node: null
      };
      try {
        const i = e((o = null) => {
          throw r.node = o, r;
        });
        if (this.state.errors.length > t.errors.length) {
          const o = this.state;
          return this.state = t, this.state.tokensLength = o.tokensLength, {
            node: i,
            error: o.errors[t.errors.length],
            thrown: false,
            aborted: false,
            failState: o
          };
        }
        return {
          node: i,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (i) {
        const o = this.state;
        if (this.state = t, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: true,
            aborted: false,
            failState: o
          };
        if (i === r)
          return {
            node: r.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: o
          };
        throw i;
      }
    }
    checkExpressionErrors(e, t) {
      if (!e)
        return false;
      const {
        shorthandAssignLoc: r,
        doubleProtoLoc: i,
        privateKeyLoc: o,
        optionalParametersLoc: d
      } = e, u = !!r || !!i || !!d || !!o;
      if (!t)
        return u;
      r != null && this.raise(m.InvalidCoverInitializedName, {
        at: r
      }), i != null && this.raise(m.DuplicateProto, {
        at: i
      }), o != null && this.raise(m.UnexpectedPrivateField, {
        at: o
      }), d != null && this.unexpected(d);
    }
    isLiteralPropertyName() {
      return W(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isOptionalChain(e) {
      return e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression";
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      const t = this.state.labels;
      this.state.labels = [];
      const r = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const i = this.inModule;
      this.inModule = e;
      const o = this.scope, d = this.getScopeHandler();
      this.scope = new d(this, e);
      const u = this.prodParam;
      this.prodParam = new Qs();
      const E = this.classScope;
      this.classScope = new Hs(this);
      const w = this.expressionScope;
      return this.expressionScope = new Gs(this), () => {
        this.state.labels = t, this.exportedIdentifiers = r, this.inModule = i, this.scope = o, this.prodParam = u, this.classScope = E, this.expressionScope = w;
      };
    }
    enterInitialScopes() {
      let e = It;
      this.inModule && (e |= Yt), this.scope.enter(Dt), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      const {
        privateKeyLoc: t
      } = e;
      t !== null && this.expectPlugin("destructuringPrivate", t);
    }
  }
  class Zt {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class er {
    constructor(e, t, r) {
      this.type = "", this.start = t, this.end = 0, this.loc = new h(r), e != null && e.options.ranges && (this.range = [t, 0]), e != null && e.filename && (this.loc.filename = e.filename);
    }
  }
  const Sr = er.prototype;
  Sr.__clone = function() {
    const a = new er(), e = Object.keys(this);
    for (let t = 0, r = e.length; t < r; t++) {
      const i = e[t];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (a[i] = this[i]);
    }
    return a;
  };
  function ei(a) {
    return at(a);
  }
  function at(a) {
    const {
      type: e,
      start: t,
      end: r,
      loc: i,
      range: o,
      extra: d,
      name: u
    } = a, E = Object.create(Sr);
    return E.type = e, E.start = t, E.end = r, E.loc = i, E.range = o, E.extra = d, E.name = u, e === "Placeholder" && (E.expectedNode = a.expectedNode), E;
  }
  function ti(a) {
    const {
      type: e,
      start: t,
      end: r,
      loc: i,
      range: o,
      extra: d
    } = a;
    if (e === "Placeholder")
      return ei(a);
    const u = Object.create(Sr);
    return u.type = e, u.start = t, u.end = r, u.loc = i, u.range = o, a.raw !== void 0 ? u.raw = a.raw : u.extra = d, u.value = a.value, u;
  }
  class ri extends Zs {
    startNode() {
      return new er(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(e, t) {
      return new er(this, e, t);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.start, e.loc.start);
    }
    finishNode(e, t) {
      return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, t, r) {
      return e.type = t, e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index), this.options.attachComment && this.processComment(e), e;
    }
    resetStartLocation(e, t, r) {
      e.start = t, e.loc.start = r, this.options.ranges && (e.range[0] = t);
    }
    resetEndLocation(e, t = this.state.lastTokEndLoc) {
      e.end = t.index, e.loc.end = t, this.options.ranges && (e.range[1] = t.index);
    }
    resetStartLocationFromNode(e, t) {
      this.resetStartLocation(e, t.start, t.loc.start);
    }
  }
  const si = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Ce = _`flow`((a) => ({
    AmbiguousConditionalArrow: a("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."),
    AmbiguousDeclareModuleKind: a("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."),
    AssignReservedType: a(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`),
    DeclareClassElement: a("The `declare` modifier can only appear on class fields."),
    DeclareClassFieldInitializer: a("Initializers are not allowed in fields with the `declare` modifier."),
    DuplicateDeclareModuleExports: a("Duplicate `declare module.exports` statement."),
    EnumBooleanMemberNotInitialized: a(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`),
    EnumDuplicateMemberName: a(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`),
    EnumInconsistentMemberValues: a(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`),
    EnumInvalidExplicitType: a(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`),
    EnumInvalidExplicitTypeUnknownSupplied: a(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`),
    EnumInvalidMemberInitializerPrimaryType: a(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`),
    EnumInvalidMemberInitializerSymbolType: a(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`),
    EnumInvalidMemberInitializerUnknownType: a(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`),
    EnumInvalidMemberName: a(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`),
    EnumNumberMemberNotInitialized: a(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`),
    EnumStringMemberInconsistentlyInitailized: a(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`),
    GetterMayNotHaveThisParam: a("A getter cannot have a `this` parameter."),
    ImportTypeShorthandOnlyInPureImport: a("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."),
    InexactInsideExact: a("Explicit inexact syntax cannot appear inside an explicit exact object type."),
    InexactInsideNonObject: a("Explicit inexact syntax cannot appear in class or interface definitions."),
    InexactVariance: a("Explicit inexact syntax cannot have variance."),
    InvalidNonTypeImportInDeclareModule: a("Imports within a `declare module` body must always be `import type` or `import typeof`."),
    MissingTypeParamDefault: a("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),
    NestedDeclareModule: a("`declare module` cannot be used inside another `declare module`."),
    NestedFlowComment: a("Cannot have a flow comment inside another flow comment."),
    PatternIsOptional: a("A binding pattern parameter cannot be optional in an implementation signature.", {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: a("A setter cannot have a `this` parameter."),
    SpreadVariance: a("Spread properties cannot have variance."),
    ThisParamAnnotationRequired: a("A type annotation is required for the `this` parameter."),
    ThisParamBannedInConstructor: a("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."),
    ThisParamMayNotBeOptional: a("The `this` parameter cannot be optional."),
    ThisParamMustBeFirst: a("The `this` parameter must be the first function parameter."),
    ThisParamNoDefault: a("The `this` parameter may not have a default value."),
    TypeBeforeInitializer: a("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
    TypeCastInPattern: a("The type cast expression is expected to be wrapped with parenthesis."),
    UnexpectedExplicitInexactInObject: a("Explicit inexact syntax must appear at the end of an inexact object."),
    UnexpectedReservedType: a(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`),
    UnexpectedReservedUnderscore: a("`_` is only allowed as a type argument to call or new."),
    UnexpectedSpaceBetweenModuloChecks: a("Spaces between `%` and `checks` are not allowed here."),
    UnexpectedSpreadType: a("Spread operator cannot appear in class or interface definitions."),
    UnexpectedSubtractionOperand: a('Unexpected token, expected "number" or "bigint".'),
    UnexpectedTokenAfterTypeParameter: a("Expected an arrow function after this type parameter declaration."),
    UnexpectedTypeParameterBeforeAsyncArrowFunction: a("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."),
    UnsupportedDeclareExportKind: a(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`),
    UnsupportedStatementInDeclareModule: a("Only declares and type imports are allowed inside declare module."),
    UnterminatedFlowComment: a("Unterminated flow-comment.")
  }));
  function ii(a) {
    return a.type === "DeclareExportAllDeclaration" || a.type === "DeclareExportDeclaration" && (!a.declaration || a.declaration.type !== "TypeAlias" && a.declaration.type !== "InterfaceDeclaration");
  }
  function Er(a) {
    return a.importKind === "type" || a.importKind === "typeof";
  }
  function Jr(a) {
    return z(a) && a !== 97;
  }
  const ni = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function ai(a, e) {
    const t = [], r = [];
    for (let i = 0; i < a.length; i++)
      (e(a[i], i, a) ? t : r).push(a[i]);
    return [t, r];
  }
  const oi = /\*?\s*@((?:no)?flow)\b/;
  var li = (a) => class extends a {
    constructor(...e) {
      super(...e), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Ks;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e, t) {
      return e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, t);
    }
    addComment(e) {
      if (this.flowPragma === void 0) {
        const t = oi.exec(e.value);
        if (t)
          if (t[1] === "flow")
            this.flowPragma = "flow";
          else if (t[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      return super.addComment(e);
    }
    flowParseTypeInitialiser(e) {
      const t = this.state.inType;
      this.state.inType = true, this.expect(e || 14);
      const r = this.flowParseType();
      return this.state.inType = t, r;
    }
    flowParsePredicate() {
      const e = this.startNode(), t = this.state.startLoc;
      return this.next(), this.expectContextual(107), this.state.lastTokStart > t.index + 1 && this.raise(Ce.UnexpectedSpaceBetweenModuloChecks, {
        at: t
      }), this.eat(10) ? (e.value = this.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e = this.state.inType;
      this.state.inType = true, this.expect(14);
      let t = null, r = null;
      return this.match(54) ? (this.state.inType = e, r = this.flowParsePredicate()) : (t = this.flowParseType(), this.state.inType = e, this.match(54) && (r = this.flowParsePredicate())), [t, r];
    }
    flowParseDeclareClass(e) {
      return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
    }
    flowParseDeclareFunction(e) {
      this.next();
      const t = e.id = this.parseIdentifier(), r = this.startNode(), i = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      const o = this.flowParseFunctionTypeParams();
      return r.params = o.params, r.rest = o.rest, r.this = o._this, this.expect(11), [r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), t.typeAnnotation = this.finishNode(i, "TypeAnnotation"), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, Is, e.id.loc.start), this.finishNode(e, "DeclareFunction");
    }
    flowParseDeclare(e, t) {
      if (this.match(80))
        return this.flowParseDeclareClass(e);
      if (this.match(68))
        return this.flowParseDeclareFunction(e);
      if (this.match(74))
        return this.flowParseDeclareVariable(e);
      if (this.eatContextual(123))
        return this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(Ce.NestedDeclareModule, {
          at: this.state.lastTokStartLoc
        }), this.flowParseDeclareModule(e));
      if (this.isContextual(126))
        return this.flowParseDeclareTypeAlias(e);
      if (this.isContextual(127))
        return this.flowParseDeclareOpaqueType(e);
      if (this.isContextual(125))
        return this.flowParseDeclareInterface(e);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(e, t);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e) {
      return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, Ht, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
    }
    flowParseDeclareModule(e) {
      this.scope.enter(At), this.match(129) ? e.id = this.parseExprAtom() : e.id = this.parseIdentifier();
      const t = e.body = this.startNode(), r = t.body = [];
      for (this.expect(5); !this.match(8); ) {
        let d = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(126) && !this.match(87) && this.raise(Ce.InvalidNonTypeImportInDeclareModule, {
          at: this.state.lastTokStartLoc
        }), this.parseImport(d)) : (this.expectContextual(121, Ce.UnsupportedStatementInDeclareModule), d = this.flowParseDeclare(d, true)), r.push(d);
      }
      this.scope.exit(), this.expect(8), this.finishNode(t, "BlockStatement");
      let i = null, o = false;
      return r.forEach((d) => {
        ii(d) ? (i === "CommonJS" && this.raise(Ce.AmbiguousDeclareModuleKind, {
          at: d
        }), i = "ES") : d.type === "DeclareModuleExports" && (o && this.raise(Ce.DuplicateDeclareModuleExports, {
          at: d
        }), i === "ES" && this.raise(Ce.AmbiguousDeclareModuleKind, {
          at: d
        }), i = "CommonJS", o = true);
      }), e.kind = i || "CommonJS", this.finishNode(e, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e, t) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !t) {
        const r = this.state.value;
        throw this.raise(Ce.UnsupportedDeclareExportKind, {
          at: this.state.startLoc,
          unsupportedExportKind: r,
          suggestion: ni[r]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
        return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127))
        return e = this.parseExport(e), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e) {
      return this.next(), this.expectContextual(108), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e) {
      return this.next(), this.flowParseTypeAlias(e), e.type = "DeclareTypeAlias", e;
    }
    flowParseDeclareOpaqueType(e) {
      return this.next(), this.flowParseOpaqueType(e, true), e.type = "DeclareOpaqueType", e;
    }
    flowParseDeclareInterface(e) {
      return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, "DeclareInterface");
    }
    flowParseInterfaceish(e, t = false) {
      if (e.id = this.flowParseRestrictedIdentifier(!t, true), this.scope.declareName(e.id.name, t ? jr : nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (!t && this.eat(12));
      if (this.isContextual(114)) {
        this.next();
        do
          e.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      if (this.isContextual(110)) {
        this.next();
        do
          e.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      e.body = this.flowParseObjectType({
        allowStatic: t,
        allowExact: false,
        allowSpread: false,
        allowProto: t,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const e = this.startNode();
      return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
    }
    flowParseInterface(e) {
      return this.flowParseInterfaceish(e), this.finishNode(e, "InterfaceDeclaration");
    }
    checkNotUnderscore(e) {
      e === "_" && this.raise(Ce.UnexpectedReservedUnderscore, {
        at: this.state.startLoc
      });
    }
    checkReservedType(e, t, r) {
      !si.has(e) || this.raise(r ? Ce.AssignReservedType : Ce.UnexpectedReservedType, {
        at: t,
        reservedType: e
      });
    }
    flowParseRestrictedIdentifier(e, t) {
      return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
    }
    flowParseTypeAlias(e) {
      return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
    }
    flowParseOpaqueType(e, t) {
      return this.expectContextual(126), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, nt, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
    }
    flowParseTypeParameter(e = false) {
      const t = this.state.startLoc, r = this.startNode(), i = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return r.name = o.name, r.variance = i, r.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) : e && this.raise(Ce.MissingTypeParamDefault, {
        at: t
      }), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e = this.state.inType, t = this.startNode();
      t.params = [], this.state.inType = true, this.match(47) || this.match(138) ? this.next() : this.unexpected();
      let r = false;
      do {
        const i = this.flowParseTypeParameter(r);
        t.params.push(i), i.default && (r = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e, this.finishNode(t, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e = this.startNode(), t = this.state.inType;
      e.params = [], this.state.inType = true, this.expect(47);
      const r = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); )
        e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = r, this.expect(48), this.state.inType = t, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e = this.startNode(), t = this.state.inType;
      for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
        e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = t, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e = this.startNode();
      if (this.expectContextual(125), e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return e.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      }), this.finishNode(e, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e, t, r) {
      return e.static = t, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = r, this.finishNode(e, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e, t) {
      return e.static = t, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e) {
      for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e, t) {
      const r = this.startNode();
      return e.static = t, e.value = this.flowParseObjectTypeMethodish(r), this.finishNode(e, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: e,
      allowExact: t,
      allowSpread: r,
      allowProto: i,
      allowInexact: o
    }) {
      const d = this.state.inType;
      this.state.inType = true;
      const u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let E, w, U = false;
      for (t && this.match(6) ? (this.expect(6), E = 9, w = true) : (this.expect(5), E = 8, w = false), u.exact = w; !this.match(E); ) {
        let ye = false, Ae = null, Oe = null;
        const Ve = this.startNode();
        if (i && this.isContextual(115)) {
          const He = this.lookahead();
          He.type !== 14 && He.type !== 17 && (this.next(), Ae = this.state.startLoc, e = false);
        }
        if (e && this.isContextual(104)) {
          const He = this.lookahead();
          He.type !== 14 && He.type !== 17 && (this.next(), ye = true);
        }
        const Ke = this.flowParseVariance();
        if (this.eat(0))
          Ae != null && this.unexpected(Ae), this.eat(0) ? (Ke && this.unexpected(Ke.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(Ve, ye))) : u.indexers.push(this.flowParseObjectTypeIndexer(Ve, ye, Ke));
        else if (this.match(10) || this.match(47))
          Ae != null && this.unexpected(Ae), Ke && this.unexpected(Ke.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(Ve, ye));
        else {
          let He = "init";
          if (this.isContextual(98) || this.isContextual(103)) {
            const zi = this.lookahead();
            W(zi.type) && (He = this.state.value, this.next());
          }
          const bs = this.flowParseObjectTypeProperty(Ve, ye, Ae, Ke, He, r, o != null ? o : !w);
          bs === null ? (U = true, Oe = this.state.lastTokStartLoc) : u.properties.push(bs);
        }
        this.flowObjectTypeSemicolon(), Oe && !this.match(8) && !this.match(9) && this.raise(Ce.UnexpectedExplicitInexactInObject, {
          at: Oe
        });
      }
      this.expect(E), r && (u.inexact = U);
      const ge = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = d, ge;
    }
    flowParseObjectTypeProperty(e, t, r, i, o, d, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (d ? u || this.raise(Ce.InexactInsideExact, {
          at: this.state.lastTokStartLoc
        }) : this.raise(Ce.InexactInsideNonObject, {
          at: this.state.lastTokStartLoc
        }), i && this.raise(Ce.InexactVariance, {
          at: i
        }), null) : (d || this.raise(Ce.UnexpectedSpreadType, {
          at: this.state.lastTokStartLoc
        }), r != null && this.unexpected(r), i && this.raise(Ce.SpreadVariance, {
          at: i
        }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
      {
        e.key = this.flowParseObjectPropertyKey(), e.static = t, e.proto = r != null, e.kind = o;
        let E = false;
        return this.match(47) || this.match(10) ? (e.method = true, r != null && this.unexpected(r), i && this.unexpected(i.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(e), !d && e.key.name === "constructor" && e.value.this && this.raise(Ce.ThisParamBannedInConstructor, {
          at: e.value.this
        })) : (o !== "init" && this.unexpected(), e.method = false, this.eat(17) && (E = true), e.value = this.flowParseTypeInitialiser(), e.variance = i), e.optional = E, this.finishNode(e, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e) {
      const t = e.kind === "get" ? 0 : 1, r = e.value.params.length + (e.value.rest ? 1 : 0);
      e.value.this && this.raise(e.kind === "get" ? Ce.GetterMayNotHaveThisParam : Ce.SetterMayNotHaveThisParam, {
        at: e.value.this
      }), r !== t && this.raise(e.kind === "get" ? m.BadGetterArity : m.BadSetterArity, {
        at: e
      }), e.kind === "set" && e.value.rest && this.raise(m.BadSetterRestParameter, {
        at: e
      });
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e, t, r) {
      e = e || this.state.start, t = t || this.state.startLoc;
      let i = r || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        const o = this.startNodeAt(e, t);
        o.qualification = i, o.id = this.flowParseRestrictedIdentifier(true), i = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return i;
    }
    flowParseGenericType(e, t, r) {
      const i = this.startNodeAt(e, t);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, t, r), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e = this.startNode();
      return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e = this.startNode();
      for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e) {
      let t = null, r = false, i = null;
      const o = this.startNode(), d = this.lookahead(), u = this.state.type === 78;
      return d.type === 14 || d.type === 17 ? (u && !e && this.raise(Ce.ThisParamMustBeFirst, {
        at: o
      }), t = this.parseIdentifier(u), this.eat(17) && (r = true, u && this.raise(Ce.ThisParamMayNotBeOptional, {
        at: o
      })), i = this.flowParseTypeInitialiser()) : i = this.flowParseType(), o.name = t, o.optional = r, o.typeAnnotation = i, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e) {
      const t = this.startNodeAt(e.start, e.loc.start);
      return t.name = null, t.optional = false, t.typeAnnotation = e, this.finishNode(t, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(e = []) {
      let t = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(true), r.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (t = this.flowParseFunctionTypeParam(false)), {
        params: e,
        rest: t,
        _this: r
      };
    }
    flowIdentToTypeAnnotation(e, t, r, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(r, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(r, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(r, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(r, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(r, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(r, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(r, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, t, i);
      }
    }
    flowParsePrimaryType() {
      const e = this.state.start, t = this.state.startLoc, r = this.startNode();
      let i, o, d = false;
      const u = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case 0:
          return this.state.noAnonFunctionType = false, o = this.flowParseTupleType(), this.state.noAnonFunctionType = u, o;
        case 47:
          return r.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), this.finishNode(r, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (Te(this.state.type) || this.match(78)) {
              const E = this.lookahead().type;
              d = E !== 17 && E !== 14;
            } else
              d = true;
          if (d) {
            if (this.state.noAnonFunctionType = false, o = this.flowParseType(), this.state.noAnonFunctionType = u, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), o;
            this.eat(12);
          }
          return o ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(o)]) : i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation");
        case 129:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return r.value = this.match(85), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(130))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r);
            if (this.match(131))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r);
            throw this.raise(Ce.UnexpectedSubtractionOperand, {
              at: this.state.startLoc
            });
          }
          throw this.unexpected();
        case 130:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 131:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(r, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(r, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ee(this.state.type)) {
            const E = $e(this.state.type);
            return this.next(), super.createIdentifier(r, E);
          } else if (Te(this.state.type))
            return this.isContextual(125) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, t, r, this.parseIdentifier());
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const e = this.state.start, t = this.state.startLoc;
      let r = this.flowParsePrimaryType(), i = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const o = this.startNodeAt(e, t), d = this.eat(18);
        i = i || d, this.expect(0), !d && this.match(3) ? (o.elementType = r, this.next(), r = this.finishNode(o, "ArrayTypeAnnotation")) : (o.objectType = r, o.indexType = this.flowParseType(), this.expect(3), i ? (o.optional = d, r = this.finishNode(o, "OptionalIndexedAccessType")) : r = this.finishNode(o, "IndexedAccessType"));
      }
      return r;
    }
    flowParsePrefixType() {
      const e = this.startNode();
      return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const t = this.startNodeAt(e.start, e.loc.start);
        return t.params = [this.reinterpretTypeAsFunctionTypeParam(e)], t.rest = null, t.this = null, t.returnType = this.flowParseType(), t.typeParameters = null, this.finishNode(t, "FunctionTypeAnnotation");
      }
      return e;
    }
    flowParseIntersectionType() {
      const e = this.startNode();
      this.eat(45);
      const t = this.flowParseAnonFunctionWithoutParens();
      for (e.types = [t]; this.eat(45); )
        e.types.push(this.flowParseAnonFunctionWithoutParens());
      return e.types.length === 1 ? t : this.finishNode(e, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e = this.startNode();
      this.eat(43);
      const t = this.flowParseIntersectionType();
      for (e.types = [t]; this.eat(43); )
        e.types.push(this.flowParseIntersectionType());
      return e.types.length === 1 ? t : this.finishNode(e, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e = this.state.inType;
      this.state.inType = true;
      const t = this.flowParseUnionType();
      return this.state.inType = e, t;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 128 && this.state.value === "_") {
        const e = this.state.start, t = this.state.startLoc, r = this.parseIdentifier();
        return this.flowParseGenericType(e, t, r);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e = this.startNode();
      return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e) {
      const t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t)), t;
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    flowParseVariance() {
      let e = null;
      return this.match(53) && (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")), e;
    }
    parseFunctionBody(e, t, r = false) {
      return t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, r)) : super.parseFunctionBody(e, false, r);
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      if (this.match(14)) {
        const i = this.startNode();
        [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = i.typeAnnotation ? this.finishNode(i, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e, t, r);
    }
    parseStatement(e, t) {
      if (this.state.strict && this.isContextual(125)) {
        const i = this.lookahead();
        if (z(i.type)) {
          const o = this.startNode();
          return this.next(), this.flowParseInterface(o);
        }
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        const i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      const r = super.parseStatement(e, t);
      return this.flowPragma === void 0 && !this.isValidDirective(r) && (this.flowPragma = null), r;
    }
    parseExpressionStatement(e, t) {
      if (t.type === "Identifier") {
        if (t.name === "declare") {
          if (this.match(80) || Te(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(e);
        } else if (Te(this.state.type)) {
          if (t.name === "interface")
            return this.flowParseInterface(e);
          if (t.name === "type")
            return this.flowParseTypeAlias(e);
          if (t.name === "opaque")
            return this.flowParseOpaqueType(e, false);
        }
      }
      return super.parseExpressionStatement(e, t);
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      return Se(e) || this.shouldParseEnums() && e === 122 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      return Se(e) || this.shouldParseEnums() && e === 122 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(122)) {
        const e = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e, t, r, i) {
      if (!this.match(17))
        return e;
      if (this.state.maybeInArrowParameters) {
        const ye = this.lookaheadCharCode();
        if (ye === 44 || ye === 61 || ye === 58 || ye === 41)
          return this.setOptionalParametersError(i), e;
      }
      this.expect(17);
      const o = this.state.clone(), d = this.state.noArrowAt, u = this.startNodeAt(t, r);
      let {
        consequent: E,
        failed: w
      } = this.tryParseConditionalConsequent(), [U, ge] = this.getArrowLikeExpressions(E);
      if (w || ge.length > 0) {
        const ye = [...d];
        if (ge.length > 0) {
          this.state = o, this.state.noArrowAt = ye;
          for (let Ae = 0; Ae < ge.length; Ae++)
            ye.push(ge[Ae].start);
          ({
            consequent: E,
            failed: w
          } = this.tryParseConditionalConsequent()), [U, ge] = this.getArrowLikeExpressions(E);
        }
        w && U.length > 1 && this.raise(Ce.AmbiguousConditionalArrow, {
          at: o.startLoc
        }), w && U.length === 1 && (this.state = o, ye.push(U[0].start), this.state.noArrowAt = ye, {
          consequent: E,
          failed: w
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(E, true), this.state.noArrowAt = d, this.expect(14), u.test = e, u.consequent = E, u.alternate = this.forwardNoArrowParamsConversionAt(u, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(u, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e = this.parseMaybeAssignAllowIn(), t = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: e,
        failed: t
      };
    }
    getArrowLikeExpressions(e, t) {
      const r = [e], i = [];
      for (; r.length !== 0; ) {
        const o = r.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : i.push(o), r.push(o.body)) : o.type === "ConditionalExpression" && (r.push(o.consequent), r.push(o.alternate));
      }
      return t ? (i.forEach((o) => this.finishArrowValidation(o)), [i, []]) : ai(i, (o) => o.params.every((d) => this.isAssignable(d, true)));
    }
    finishArrowValidation(e) {
      var t;
      this.toAssignableList(e.params, (t = e.extra) == null ? void 0 : t.trailingCommaLoc, false), this.scope.enter(Ye | bt), super.checkParams(e, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e, t) {
      let r;
      return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), r = t(), this.state.noArrowParamsConversionAt.pop()) : r = t(), r;
    }
    parseParenItem(e, t, r) {
      if (e = super.parseParenItem(e, t, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        const i = this.startNodeAt(t, r);
        return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
      }
      return e;
    }
    assertModuleNodeAllowed(e) {
      e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
    }
    parseExport(e) {
      const t = super.parseExport(e);
      return (t.type === "ExportNamedDeclaration" || t.type === "ExportAllDeclaration") && (t.exportKind = t.exportKind || "value"), t;
    }
    parseExportDeclaration(e) {
      if (this.isContextual(126)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
      } else if (this.isContextual(127)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.flowParseOpaqueType(t, false);
      } else if (this.isContextual(125)) {
        e.exportKind = "type";
        const t = this.startNode();
        return this.next(), this.flowParseInterface(t);
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        e.exportKind = "value";
        const t = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t);
      } else
        return super.parseExportDeclaration(e);
    }
    eatExportStar(e) {
      return super.eatExportStar(...arguments) ? true : this.isContextual(126) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      const {
        startLoc: t
      } = this.state, r = super.maybeParseExportNamespaceSpecifier(e);
      return r && e.exportKind === "type" && this.unexpected(t), r;
    }
    parseClassId(e, t, r) {
      super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e, t, r) {
      const {
        startLoc: i
      } = this.state;
      if (this.isContextual(121)) {
        if (this.parseClassMemberFromModifier(e, t))
          return;
        t.declare = true;
      }
      super.parseClassMember(e, t, r), t.declare && (t.type !== "ClassProperty" && t.type !== "ClassPrivateProperty" && t.type !== "PropertyDefinition" ? this.raise(Ce.DeclareClassElement, {
        at: i
      }) : t.value && this.raise(Ce.DeclareClassFieldInitializer, {
        at: t.value
      }));
    }
    isIterator(e) {
      return e === "iterator" || e === "asyncIterator";
    }
    readIterator() {
      const e = super.readWord1(), t = "@@" + e;
      (!this.isIterator(e) || !this.state.inType) && this.raise(m.InvalidIdentifier, {
        at: this.state.curPosition(),
        identifierName: t
      }), this.finishToken(128, t);
    }
    getTokenFromCode(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      return e === 123 && t === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? t === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : sr(e, t, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
    }
    isAssignable(e, t) {
      return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
    }
    toAssignable(e, t = false) {
      !t && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(...arguments);
    }
    toAssignableList(e, t, r) {
      for (let i = 0; i < e.length; i++) {
        const o = e[i];
        (o == null ? void 0 : o.type) === "TypeCastExpression" && (e[i] = this.typeCastToParameter(o));
      }
      super.toAssignableList(e, t, r);
    }
    toReferencedList(e, t) {
      for (let i = 0; i < e.length; i++) {
        var r;
        const o = e[i];
        o && o.type === "TypeCastExpression" && !((r = o.extra) != null && r.parenthesized) && (e.length > 1 || !t) && this.raise(Ce.TypeCastInPattern, {
          at: o.typeAnnotation
        });
      }
      return e;
    }
    parseArrayLike(e, t, r, i) {
      const o = super.parseArrayLike(e, t, r, i);
      return t && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(e, ...t) {
      return e === "TypeCastExpression" || super.isValidLVal(e, ...t);
    }
    parseClassProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e) {
      return !this.match(14) && super.isNonstaticConstructor(e);
    }
    pushClassMethod(e, t, r, i, o, d) {
      if (t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, i, o, d), t.params && o) {
        const u = t.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ce.ThisParamBannedInConstructor, {
          at: t
        });
      } else if (t.type === "MethodDefinition" && o && t.value.params) {
        const u = t.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ce.ThisParamBannedInConstructor, {
          at: t
        });
      }
    }
    pushClassPrivateMethod(e, t, r, i) {
      t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, i);
    }
    parseClassSuper(e) {
      if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(110)) {
        this.next();
        const t = e.implements = [];
        do {
          const r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, t.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e) {
      super.checkGetterSetterParams(e);
      const t = this.getObjectOrClassMethodParams(e);
      if (t.length > 0) {
        const r = t[0];
        this.isThisParam(r) && e.kind === "get" ? this.raise(Ce.GetterMayNotHaveThisParam, {
          at: r
        }) : this.isThisParam(r) && this.raise(Ce.SetterMayNotHaveThisParam, {
          at: r
        });
      }
    }
    parsePropertyNamePrefixOperator(e) {
      e.variance = this.flowParseVariance();
    }
    parseObjPropValue(e, t, r, i, o, d, u, E) {
      e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
      let w;
      this.match(47) && !u && (w = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(e, t, r, i, o, d, u, E), w && ((e.value || e).typeParameters = w);
    }
    parseAssignableListItemTypes(e) {
      return this.eat(17) && (e.type !== "Identifier" && this.raise(Ce.PatternIsOptional, {
        at: e
      }), this.isThisParam(e) && this.raise(Ce.ThisParamMayNotBeOptional, {
        at: e
      }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(Ce.ThisParamAnnotationRequired, {
        at: e
      }), this.match(29) && this.isThisParam(e) && this.raise(Ce.ThisParamNoDefault, {
        at: e
      }), this.resetEndLocation(e), e;
    }
    parseMaybeDefault(e, t, r) {
      const i = super.parseMaybeDefault(e, t, r);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Ce.TypeBeforeInitializer, {
        at: i.typeAnnotation
      }), i;
    }
    shouldParseDefaultImport(e) {
      return Er(e) ? Jr(this.state.type) : super.shouldParseDefaultImport(e);
    }
    parseImportSpecifierLocal(e, t, r) {
      t.local = Er(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, r));
    }
    maybeParseDefaultImportSpecifier(e) {
      e.importKind = "value";
      let t = null;
      if (this.match(87) ? t = "typeof" : this.isContextual(126) && (t = "type"), t) {
        const r = this.lookahead(), {
          type: i
        } = r;
        t === "type" && i === 55 && this.unexpected(null, r.type), (Jr(i) || i === 5 || i === 55) && (this.next(), e.importKind = t);
      }
      return super.maybeParseDefaultImportSpecifier(e);
    }
    parseImportSpecifier(e, t, r, i) {
      const o = e.imported;
      let d = null;
      o.type === "Identifier" && (o.name === "type" ? d = "type" : o.name === "typeof" && (d = "typeof"));
      let u = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const w = this.parseIdentifier(true);
        d !== null && !z(this.state.type) ? (e.imported = w, e.importKind = d, e.local = at(w)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
      } else {
        if (d !== null && z(this.state.type))
          e.imported = this.parseIdentifier(true), e.importKind = d;
        else {
          if (t)
            throw this.raise(m.ImportBindingIsString, {
              at: e,
              importName: o.value
            });
          e.imported = o, e.importKind = null;
        }
        this.eatContextual(93) ? e.local = this.parseIdentifier() : (u = true, e.local = at(e.imported));
      }
      const E = Er(e);
      return r && E && this.raise(Ce.ImportTypeShorthandOnlyInPureImport, {
        at: e
      }), (r || E) && this.checkReservedType(e.local.name, e.local.loc.start, true), u && !r && !E && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e, t) {
      const r = e.kind;
      r !== "get" && r !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
    }
    parseVarId(e, t) {
      super.parseVarId(e, t), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, t) {
      if (this.match(14)) {
        const r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(e, t);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e, t) {
      var r;
      let i = null, o;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (i = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(e, t), i), !o.error)
          return o.node;
        const {
          context: E
        } = this.state, w = E[E.length - 1];
        (w === j.j_oTag || w === j.j_expr) && E.pop();
      }
      if ((r = o) != null && r.error || this.match(47)) {
        var d, u;
        i = i || this.state.clone();
        let E;
        const w = this.tryParse((ge) => {
          var ye;
          E = this.flowParseTypeParameterDeclaration();
          const Ae = this.forwardNoArrowParamsConversionAt(E, () => {
            const Ve = super.parseMaybeAssign(e, t);
            return this.resetStartLocationFromNode(Ve, E), Ve;
          });
          (ye = Ae.extra) != null && ye.parenthesized && ge();
          const Oe = this.maybeUnwrapTypeCastExpression(Ae);
          return Oe.type !== "ArrowFunctionExpression" && ge(), Oe.typeParameters = E, this.resetStartLocationFromNode(Oe, E), Ae;
        }, i);
        let U = null;
        if (w.node && this.maybeUnwrapTypeCastExpression(w.node).type === "ArrowFunctionExpression") {
          if (!w.error && !w.aborted)
            return w.node.async && this.raise(Ce.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
              at: E
            }), w.node;
          U = w.node;
        }
        if ((d = o) != null && d.node)
          return this.state = o.failState, o.node;
        if (U)
          return this.state = w.failState, U;
        throw (u = o) != null && u.thrown ? o.error : w.thrown ? w.error : this.raise(Ce.UnexpectedTokenAfterTypeParameter, {
          at: E
        });
      }
      return super.parseMaybeAssign(e, t);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const t = this.tryParse(() => {
          const r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const i = this.startNode();
          return [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), i;
        });
        if (t.thrown)
          return null;
        t.error && (this.state = t.failState), e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e);
    }
    shouldParseArrow(e) {
      return this.match(14) || super.shouldParseArrow(e);
    }
    setArrowFunctionParameters(e, t) {
      this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = t : super.setArrowFunctionParameters(e, t);
    }
    checkParams(e, t, r) {
      if (!(r && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
        for (let i = 0; i < e.params.length; i++)
          this.isThisParam(e.params[i]) && i > 0 && this.raise(Ce.ThisParamMustBeFirst, {
            at: e.params[i]
          });
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e) {
      return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e, t, r, i) {
      if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(t) !== -1) {
        this.next();
        const o = this.startNodeAt(t, r);
        o.callee = e, o.arguments = this.parseCallExpressionArguments(11, false), e = this.finishNode(o, "CallExpression");
      } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
        const o = this.state.clone(), d = this.tryParse((E) => this.parseAsyncArrowWithTypeParameters(t, r) || E(), o);
        if (!d.error && !d.aborted)
          return d.node;
        const u = this.tryParse(() => super.parseSubscripts(e, t, r, i), o);
        if (u.node && !u.error)
          return u.node;
        if (d.node)
          return this.state = d.failState, d.node;
        if (u.node)
          return this.state = u.failState, u.node;
        throw d.error || u.error;
      }
      return super.parseSubscripts(e, t, r, i);
    }
    parseSubscript(e, t, r, i, o) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (o.optionalChainMember = true, i)
          return o.stop = true, e;
        this.next();
        const d = this.startNodeAt(t, r);
        return d.callee = e, d.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), d.arguments = this.parseCallExpressionArguments(11, false), d.optional = true, this.finishCallExpression(d, true);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        const d = this.startNodeAt(t, r);
        d.callee = e;
        const u = this.tryParse(() => (d.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), d.arguments = this.parseCallExpressionArguments(11, false), o.optionalChainMember && (d.optional = false), this.finishCallExpression(d, o.optionalChainMember)));
        if (u.node)
          return u.error && (this.state = u.failState), u.node;
      }
      return super.parseSubscript(e, t, r, i, o);
    }
    parseNewCallee(e) {
      super.parseNewCallee(e);
      let t = null;
      this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = t;
    }
    parseAsyncArrowWithTypeParameters(e, t) {
      const r = this.startNodeAt(e, t);
      if (this.parseFunctionParams(r), !!this.parseArrow(r))
        return this.parseArrowExpression(r, void 0, true);
    }
    readToken_mult_modulo(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (e === 42 && t === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(e);
    }
    readToken_pipe_amp(e) {
      const t = this.input.charCodeAt(this.state.pos + 1);
      if (e === 124 && t === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(e);
    }
    parseTopLevel(e, t) {
      const r = super.parseTopLevel(e, t);
      return this.state.hasFlowComment && this.raise(Ce.UnterminatedFlowComment, {
        at: this.state.curPosition()
      }), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ce.NestedFlowComment, {
            at: this.state.startLoc
          });
        this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), this.state.hasFlowComment = true;
        return;
      }
      if (this.state.hasFlowComment) {
        const e = this.input.indexOf("*-/", this.state.pos + 2);
        if (e === -1)
          throw this.raise(m.UnterminatedComment, {
            at: this.state.curPosition()
          });
        this.state.pos = e + 2 + 3;
        return;
      }
      return super.skipBlockComment();
    }
    skipFlowComment() {
      const {
        pos: e
      } = this.state;
      let t = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e + t)); )
        t++;
      const r = this.input.charCodeAt(t + e), i = this.input.charCodeAt(t + e + 1);
      return r === 58 && i === 58 ? t + 2 : this.input.slice(t + e, t + e + 12) === "flow-include" ? t + 12 : r === 58 && i !== 58 ? t : false;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(m.UnterminatedComment, {
          at: this.state.curPosition()
        });
    }
    flowEnumErrorBooleanMemberNotInitialized(e, {
      enumName: t,
      memberName: r
    }) {
      this.raise(Ce.EnumBooleanMemberNotInitialized, {
        at: e,
        memberName: r,
        enumName: t
      });
    }
    flowEnumErrorInvalidMemberInitializer(e, t) {
      return this.raise(t.explicitType ? t.explicitType === "symbol" ? Ce.EnumInvalidMemberInitializerSymbolType : Ce.EnumInvalidMemberInitializerPrimaryType : Ce.EnumInvalidMemberInitializerUnknownType, Object.assign({
        at: e
      }, t));
    }
    flowEnumErrorNumberMemberNotInitialized(e, {
      enumName: t,
      memberName: r
    }) {
      this.raise(Ce.EnumNumberMemberNotInitialized, {
        at: e,
        enumName: t,
        memberName: r
      });
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e, {
      enumName: t
    }) {
      this.raise(Ce.EnumStringMemberInconsistentlyInitailized, {
        at: e,
        enumName: t
      });
    }
    flowEnumMemberInit() {
      const e = this.state.startLoc, t = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 130: {
          const r = this.parseNumericLiteral(this.state.value);
          return t() ? {
            type: "number",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 129: {
          const r = this.parseStringLiteral(this.state.value);
          return t() ? {
            type: "string",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        case 85:
        case 86: {
          const r = this.parseBooleanLiteral(this.match(85));
          return t() ? {
            type: "boolean",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: e
          };
        }
        default:
          return {
            type: "invalid",
            loc: e
          };
      }
    }
    flowEnumMemberRaw() {
      const e = this.state.startLoc, t = this.parseIdentifier(true), r = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: e
      };
      return {
        id: t,
        init: r
      };
    }
    flowEnumCheckExplicitTypeMismatch(e, t, r) {
      const {
        explicitType: i
      } = t;
      i !== null && i !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
    }
    flowEnumMembers({
      enumName: e,
      explicitType: t
    }) {
      const r = /* @__PURE__ */ new Set(), i = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let o = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = true;
          break;
        }
        const d = this.startNode(), {
          id: u,
          init: E
        } = this.flowEnumMemberRaw(), w = u.name;
        if (w === "")
          continue;
        /^[a-z]/.test(w) && this.raise(Ce.EnumInvalidMemberName, {
          at: u,
          memberName: w,
          suggestion: w[0].toUpperCase() + w.slice(1),
          enumName: e
        }), r.has(w) && this.raise(Ce.EnumDuplicateMemberName, {
          at: u,
          memberName: w,
          enumName: e
        }), r.add(w);
        const U = {
          enumName: e,
          explicitType: t,
          memberName: w
        };
        switch (d.id = u, E.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "boolean"), d.init = E.value, i.booleanMembers.push(this.finishNode(d, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "number"), d.init = E.value, i.numberMembers.push(this.finishNode(d, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(E.loc, U, "string"), d.init = E.value, i.stringMembers.push(this.finishNode(d, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(E.loc, U);
          case "none":
            switch (t) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(E.loc, U);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(E.loc, U);
                break;
              default:
                i.defaultedMembers.push(this.finishNode(d, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: i,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(e, t, {
      enumName: r
    }) {
      if (e.length === 0)
        return t;
      if (t.length === 0)
        return e;
      if (t.length > e.length) {
        for (const i of e)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(i, {
            enumName: r
          });
        return t;
      } else {
        for (const i of t)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(i, {
            enumName: r
          });
        return e;
      }
    }
    flowEnumParseExplicitType({
      enumName: e
    }) {
      if (!this.eatContextual(101))
        return null;
      if (!Te(this.state.type))
        throw this.raise(Ce.EnumInvalidExplicitTypeUnknownSupplied, {
          at: this.state.startLoc,
          enumName: e
        });
      const {
        value: t
      } = this.state;
      return this.next(), t !== "boolean" && t !== "number" && t !== "string" && t !== "symbol" && this.raise(Ce.EnumInvalidExplicitType, {
        at: this.state.startLoc,
        enumName: e,
        invalidEnumType: t
      }), t;
    }
    flowEnumBody(e, t) {
      const r = t.name, i = t.loc.start, o = this.flowEnumParseExplicitType({
        enumName: r
      });
      this.expect(5);
      const {
        members: d,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: r,
        explicitType: o
      });
      switch (e.hasUnknownMembers = u, o) {
        case "boolean":
          return e.explicitType = true, e.members = d.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        case "number":
          return e.explicitType = true, e.members = d.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        case "string":
          return e.explicitType = true, e.members = this.flowEnumStringMembers(d.stringMembers, d.defaultedMembers, {
            enumName: r
          }), this.expect(8), this.finishNode(e, "EnumStringBody");
        case "symbol":
          return e.members = d.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
        default: {
          const E = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
          e.explicitType = false;
          const w = d.booleanMembers.length, U = d.numberMembers.length, ge = d.stringMembers.length, ye = d.defaultedMembers.length;
          if (!w && !U && !ge && !ye)
            return E();
          if (!w && !U)
            return e.members = this.flowEnumStringMembers(d.stringMembers, d.defaultedMembers, {
              enumName: r
            }), this.expect(8), this.finishNode(e, "EnumStringBody");
          if (!U && !ge && w >= ye) {
            for (const Ae of d.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(Ae.loc.start, {
                enumName: r,
                memberName: Ae.id.name
              });
            return e.members = d.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
          } else if (!w && !ge && U >= ye) {
            for (const Ae of d.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(Ae.loc.start, {
                enumName: r,
                memberName: Ae.id.name
              });
            return e.members = d.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
          } else
            return this.raise(Ce.EnumInconsistentMemberValues, {
              at: i,
              enumName: r
            }), E();
        }
      }
    }
    flowParseEnumDeclaration(e) {
      const t = this.parseIdentifier();
      return e.id = t, e.body = this.flowEnumBody(this.startNode(), t), this.finishNode(e, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e = this.nextTokenStart();
      if (this.input.charCodeAt(e) === 60) {
        const t = this.input.charCodeAt(e + 1);
        return t !== 60 && t !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e) {
      return e.type === "TypeCastExpression" ? e.expression : e;
    }
  };
  const ui = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }, Et = _`jsx`((a) => ({
    AttributeIsEmpty: a("JSX attributes must only be assigned a non-empty expression."),
    MissingClosingTagElement: a(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`),
    MissingClosingTagFragment: a("Expected corresponding JSX closing tag for <>."),
    UnexpectedSequenceExpression: a("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"),
    UnexpectedToken: a(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`),
    UnsupportedJsxValue: a("JSX value should be either an expression or a quoted JSX text."),
    UnterminatedJsxContent: a("Unterminated JSX contents."),
    UnwrappedAdjacentJSXElements: a("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?")
  }));
  function ht(a) {
    return a ? a.type === "JSXOpeningFragment" || a.type === "JSXClosingFragment" : false;
  }
  function kt(a) {
    if (a.type === "JSXIdentifier")
      return a.name;
    if (a.type === "JSXNamespacedName")
      return a.namespace.name + ":" + a.name.name;
    if (a.type === "JSXMemberExpression")
      return kt(a.object) + "." + kt(a.property);
    throw new Error("Node had unexpected type: " + a.type);
  }
  var ci = (a) => class extends a {
    jsxReadToken() {
      let e = "", t = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Et.UnterminatedJsxContent, {
            at: this.state.startLoc
          });
        const r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(r) : (e += this.input.slice(t, this.state.pos), this.finishToken(137, e));
          case 38:
            e += this.input.slice(t, this.state.pos), e += this.jsxReadEntity(), t = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            St(r) ? (e += this.input.slice(t, this.state.pos), e += this.jsxReadNewLine(true), t = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e) {
      const t = this.input.charCodeAt(this.state.pos);
      let r;
      return ++this.state.pos, t === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = e ? `
` : `\r
`) : r = String.fromCharCode(t), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(e) {
      let t = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(m.UnterminatedString, {
            at: this.state.startLoc
          });
        const i = this.input.charCodeAt(this.state.pos);
        if (i === e)
          break;
        i === 38 ? (t += this.input.slice(r, this.state.pos), t += this.jsxReadEntity(), r = this.state.pos) : St(i) ? (t += this.input.slice(r, this.state.pos), t += this.jsxReadNewLine(false), r = this.state.pos) : ++this.state.pos;
      }
      return t += this.input.slice(r, this.state.pos++), this.finishToken(129, t);
    }
    jsxReadEntity() {
      const e = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let t = 10;
        this.codePointAtPos(this.state.pos) === 120 && (t = 16, ++this.state.pos);
        const r = this.readInt(t, void 0, false, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let t = 0, r = false;
        for (; t++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (r) {
          const i = this.input.slice(e, this.state.pos), o = ui[i];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = e, "&";
    }
    jsxReadWord() {
      let e;
      const t = this.state.pos;
      do
        e = this.input.charCodeAt(++this.state.pos);
      while (Be(e) || e === 45);
      return this.finishToken(136, this.input.slice(t, this.state.pos));
    }
    jsxParseIdentifier() {
      const e = this.startNode();
      return this.match(136) ? e.name = this.state.value : Ee(this.state.type) ? e.name = $e(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e = this.state.start, t = this.state.startLoc, r = this.jsxParseIdentifier();
      if (!this.eat(14))
        return r;
      const i = this.startNodeAt(e, t);
      return i.namespace = r, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e = this.state.start, t = this.state.startLoc;
      let r = this.jsxParseNamespacedName();
      if (r.type === "JSXNamespacedName")
        return r;
      for (; this.eat(16); ) {
        const i = this.startNodeAt(e, t);
        i.object = r, i.property = this.jsxParseIdentifier(), r = this.finishNode(i, "JSXMemberExpression");
      }
      return r;
    }
    jsxParseAttributeValue() {
      let e;
      switch (this.state.type) {
        case 5:
          return e = this.startNode(), this.setContext(j.brace), this.next(), e = this.jsxParseExpressionContainer(e, j.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Et.AttributeIsEmpty, {
            at: e
          }), e;
        case 138:
        case 129:
          return this.parseExprAtom();
        default:
          throw this.raise(Et.UnsupportedJsxValue, {
            at: this.state.startLoc
          });
      }
    }
    jsxParseEmptyExpression() {
      const e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
      return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e) {
      return this.next(), e.expression = this.parseExpression(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e, t) {
      if (this.match(8))
        e.expression = this.jsxParseEmptyExpression();
      else {
        const r = this.parseExpression();
        e.expression = r;
      }
      return this.setContext(t), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e = this.startNode();
      return this.match(5) ? (this.setContext(j.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e, t) {
      const r = this.startNodeAt(e, t);
      return this.eat(139) ? this.finishNode(r, "JSXOpeningFragment") : (r.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r));
    }
    jsxParseOpeningElementAfterName(e) {
      const t = [];
      for (; !this.match(56) && !this.match(139); )
        t.push(this.jsxParseAttribute());
      return e.attributes = t, e.selfClosing = this.eat(56), this.expect(139), this.finishNode(e, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e, t) {
      const r = this.startNodeAt(e, t);
      return this.eat(139) ? this.finishNode(r, "JSXClosingFragment") : (r.name = this.jsxParseElementName(), this.expect(139), this.finishNode(r, "JSXClosingElement"));
    }
    jsxParseElementAt(e, t) {
      const r = this.startNodeAt(e, t), i = [], o = this.jsxParseOpeningElementAt(e, t);
      let d = null;
      if (!o.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 138:
                if (e = this.state.start, t = this.state.startLoc, this.next(), this.eat(56)) {
                  d = this.jsxParseClosingElementAt(e, t);
                  break e;
                }
                i.push(this.jsxParseElementAt(e, t));
                break;
              case 137:
                i.push(this.parseExprAtom());
                break;
              case 5: {
                const u = this.startNode();
                this.setContext(j.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(u)) : i.push(this.jsxParseExpressionContainer(u, j.j_expr));
                break;
              }
              default:
                throw this.unexpected();
            }
        ht(o) && !ht(d) && d !== null ? this.raise(Et.MissingClosingTagFragment, {
          at: d
        }) : !ht(o) && ht(d) ? this.raise(Et.MissingClosingTagElement, {
          at: d,
          openingTagName: kt(o.name)
        }) : !ht(o) && !ht(d) && kt(d.name) !== kt(o.name) && this.raise(Et.MissingClosingTagElement, {
          at: d,
          openingTagName: kt(o.name)
        });
      }
      if (ht(o) ? (r.openingFragment = o, r.closingFragment = d) : (r.openingElement = o, r.closingElement = d), r.children = i, this.match(47))
        throw this.raise(Et.UnwrappedAdjacentJSXElements, {
          at: this.state.startLoc
        });
      return ht(o) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
    }
    jsxParseElement() {
      const e = this.state.start, t = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e, t);
    }
    setContext(e) {
      const {
        context: t
      } = this.state;
      t[t.length - 1] = e;
    }
    parseExprAtom(e) {
      return this.match(137) ? this.parseLiteral(this.state.value, "JSXText") : this.match(138) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(138), this.jsxParseElement()) : super.parseExprAtom(e);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e) {
      const t = this.curContext();
      if (t === j.j_expr)
        return this.jsxReadToken();
      if (t === j.j_oTag || t === j.j_cTag) {
        if (Ne(e))
          return this.jsxReadWord();
        if (e === 62)
          return ++this.state.pos, this.finishToken(139);
        if ((e === 34 || e === 39) && t === j.j_oTag)
          return this.jsxReadString(e);
      }
      return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(e);
    }
    updateContext(e) {
      const {
        context: t,
        type: r
      } = this.state;
      if (r === 56 && e === 138)
        t.splice(-2, 2, j.j_cTag), this.state.canStartJSXElement = false;
      else if (r === 138)
        t.push(j.j_oTag);
      else if (r === 139) {
        const i = t[t.length - 1];
        i === j.j_oTag && e === 56 || i === j.j_cTag ? (t.pop(), this.state.canStartJSXElement = t[t.length - 1] === j.j_expr) : (this.setContext(j.j_expr), this.state.canStartJSXElement = true);
      } else
        this.state.canStartJSXElement = ae(r);
    }
  };
  class pi extends Tr {
    constructor(...e) {
      super(...e), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
    }
  }
  class fi extends xr {
    createScope(e) {
      return new pi(e);
    }
    declareName(e, t, r) {
      const i = this.currentScope();
      if (t & cr) {
        this.maybeExportDefined(i, e), i.exportOnlyBindings.add(e);
        return;
      }
      super.declareName(...arguments), t & wt && (t & it || (this.checkRedeclarationInScope(i, e, t, r), this.maybeExportDefined(i, e)), i.types.add(e)), t & lr && i.enums.add(e), t & ur && i.constEnums.add(e), t & Wt && i.classes.add(e);
    }
    isRedeclaredInScope(e, t, r) {
      if (e.enums.has(t)) {
        if (r & lr) {
          const i = !!(r & ur), o = e.constEnums.has(t);
          return i !== o;
        }
        return true;
      }
      return r & Wt && e.classes.has(t) ? e.lexical.has(t) ? !!(r & it) : false : r & wt && e.types.has(t) ? true : super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(e) {
      const t = this.scopeStack[0], {
        name: r
      } = e;
      !t.types.has(r) && !t.exportOnlyBindings.has(r) && super.checkLocalExport(e);
    }
  }
  const hi = (a, e) => Object.hasOwnProperty.call(a, e) && a[e];
  function di(a) {
    if (a == null)
      throw new Error(`Unexpected ${a} value.`);
    return a;
  }
  function Yr(a) {
    if (!a)
      throw new Error("Assert fail");
  }
  const ve = _`typescript`((a) => ({
    AbstractMethodHasImplementation: a(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`),
    AbstractPropertyHasInitializer: a(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`),
    AccesorCannotDeclareThisParameter: a("'get' and 'set' accessors cannot declare 'this' parameters."),
    AccesorCannotHaveTypeParameters: a("An accessor cannot have type parameters."),
    CannotFindName: a(({
      name: e
    }) => `Cannot find name '${e}'.`),
    ClassMethodHasDeclare: a("Class methods cannot have the 'declare' modifier."),
    ClassMethodHasReadonly: a("Class methods cannot have the 'readonly' modifier."),
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: a("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
    ConstructorHasTypeParameters: a("Type parameters cannot appear on a constructor declaration."),
    DeclareAccessor: a(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`),
    DeclareClassFieldHasInitializer: a("Initializers are not allowed in ambient contexts."),
    DeclareFunctionHasImplementation: a("An implementation cannot be declared in ambient contexts."),
    DuplicateAccessibilityModifier: a(({
      modifier: e
    }) => "Accessibility modifier already seen."),
    DuplicateModifier: a(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`),
    EmptyHeritageClauseType: a(({
      token: e
    }) => `'${e}' list cannot be empty.`),
    EmptyTypeArguments: a("Type argument list cannot be empty."),
    EmptyTypeParameters: a("Type parameter list cannot be empty."),
    ExpectedAmbientAfterExportDeclare: a("'export declare' must be followed by an ambient declaration."),
    ImportAliasHasImportType: a("An import alias can not use 'import type'."),
    IncompatibleModifiers: a(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`),
    IndexSignatureHasAbstract: a("Index signatures cannot have the 'abstract' modifier."),
    IndexSignatureHasAccessibility: a(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`),
    IndexSignatureHasDeclare: a("Index signatures cannot have the 'declare' modifier."),
    IndexSignatureHasOverride: a("'override' modifier cannot appear on an index signature."),
    IndexSignatureHasStatic: a("Index signatures cannot have the 'static' modifier."),
    InitializerNotAllowedInAmbientContext: a("Initializers are not allowed in ambient contexts."),
    InvalidModifierOnTypeMember: a(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`),
    InvalidModifierOnTypeParameter: a(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`),
    InvalidModifierOnTypeParameterPositions: a(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`),
    InvalidModifiersOrder: a(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`),
    InvalidPropertyAccessAfterInstantiationExpression: a("Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments."),
    InvalidTupleMemberLabel: a("Tuple members must be labeled with a simple identifier."),
    MissingInterfaceName: a("'interface' declarations must be followed by an identifier."),
    MixedLabeledAndUnlabeledElements: a("Tuple members must all have names or all not have names."),
    NonAbstractClassHasAbstractMethod: a("Abstract methods can only appear within an abstract class."),
    NonClassMethodPropertyHasAbstractModifer: a("'abstract' modifier can only appear on a class, method, or property declaration."),
    OptionalTypeBeforeRequired: a("A required element cannot follow an optional element."),
    OverrideNotInSubClass: a("This member cannot have an 'override' modifier because its containing class does not extend another class."),
    PatternIsOptional: a("A binding pattern parameter cannot be optional in an implementation signature."),
    PrivateElementHasAbstract: a("Private elements cannot have the 'abstract' modifier."),
    PrivateElementHasAccessibility: a(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`),
    ReadonlyForMethodSignature: a("'readonly' modifier can only appear on a property declaration or index signature."),
    ReservedArrowTypeParam: a("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."),
    ReservedTypeAssertion: a("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
    SetAccesorCannotHaveOptionalParameter: a("A 'set' accessor cannot have an optional parameter."),
    SetAccesorCannotHaveRestParameter: a("A 'set' accessor cannot have rest parameter."),
    SetAccesorCannotHaveReturnType: a("A 'set' accessor cannot have a return type annotation."),
    SingleTypeParameterWithoutTrailingComma: a(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`),
    StaticBlockCannotHaveModifier: a("Static class blocks cannot have any modifier."),
    TypeAnnotationAfterAssign: a("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
    TypeImportCannotSpecifyDefaultAndNamed: a("A type-only import can specify a default import or named bindings, but not both."),
    TypeModifierIsUsedInTypeExports: a("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
    TypeModifierIsUsedInTypeImports: a("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
    UnexpectedParameterModifier: a("A parameter property is only allowed in a constructor implementation."),
    UnexpectedReadonly: a("'readonly' type modifier is only permitted on array and tuple literal types."),
    UnexpectedTypeAnnotation: a("Did not expect a type annotation here."),
    UnexpectedTypeCastInParameter: a("Unexpected type cast in parameter position."),
    UnsupportedImportTypeArgument: a("Argument in a type import must be a string literal."),
    UnsupportedParameterPropertyKind: a("A parameter property may not be declared using a binding pattern."),
    UnsupportedSignatureParameterKind: a(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`)
  }));
  function mi(a) {
    switch (a) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Qr(a) {
    return a === "private" || a === "public" || a === "protected";
  }
  function yi(a) {
    return a === "in" || a === "out";
  }
  var bi = (a) => class extends a {
    getScopeHandler() {
      return fi;
    }
    tsIsIdentifier() {
      return Te(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e, t) {
      if (!Te(this.state.type) && this.state.type !== 58)
        return;
      const r = this.state.value;
      if (e.indexOf(r) !== -1) {
        if (t && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers({
      modified: e,
      allowedModifiers: t,
      disallowedModifiers: r,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: o = ve.InvalidModifierOnTypeMember
    }) {
      const d = (E, w, U, ge) => {
        w === U && e[ge] && this.raise(ve.InvalidModifiersOrder, {
          at: E,
          orderedModifiers: [U, ge]
        });
      }, u = (E, w, U, ge) => {
        (e[U] && w === ge || e[ge] && w === U) && this.raise(ve.IncompatibleModifiers, {
          at: E,
          modifiers: [U, ge]
        });
      };
      for (; ; ) {
        const {
          startLoc: E
        } = this.state, w = this.tsParseModifier(t.concat(r != null ? r : []), i);
        if (!w)
          break;
        Qr(w) ? e.accessibility ? this.raise(ve.DuplicateAccessibilityModifier, {
          at: E,
          modifier: w
        }) : (d(E, w, w, "override"), d(E, w, w, "static"), d(E, w, w, "readonly"), e.accessibility = w) : yi(w) ? (e[w] && this.raise(ve.DuplicateModifier, {
          at: E,
          modifier: w
        }), e[w] = true, d(E, w, "in", "out")) : (Object.hasOwnProperty.call(e, w) ? this.raise(ve.DuplicateModifier, {
          at: E,
          modifier: w
        }) : (d(E, w, "static", "readonly"), d(E, w, "static", "override"), d(E, w, "override", "readonly"), d(E, w, "abstract", "override"), u(E, w, "declare", "override"), u(E, w, "static", "abstract")), e[w] = true), r != null && r.includes(w) && this.raise(o, {
          at: E,
          modifier: w
        });
      }
    }
    tsIsListTerminator(e) {
      switch (e) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
      throw new Error("Unreachable");
    }
    tsParseList(e, t) {
      const r = [];
      for (; !this.tsIsListTerminator(e); )
        r.push(t());
      return r;
    }
    tsParseDelimitedList(e, t, r) {
      return di(this.tsParseDelimitedListWorker(e, t, true, r));
    }
    tsParseDelimitedListWorker(e, t, r, i) {
      const o = [];
      let d = -1;
      for (; !this.tsIsListTerminator(e); ) {
        d = -1;
        const u = t();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          d = this.state.lastTokStart;
          continue;
        }
        if (this.tsIsListTerminator(e))
          break;
        r && this.expect(12);
        return;
      }
      return i && (i.value = d), o;
    }
    tsParseBracketedList(e, t, r, i, o) {
      i || (r ? this.expect(0) : this.expect(47));
      const d = this.tsParseDelimitedList(e, t, o);
      return r ? this.expect(3) : this.expect(48), d;
    }
    tsParseImportType() {
      const e = this.startNode();
      return this.expect(83), this.expect(10), this.match(129) || this.raise(ve.UnsupportedImportTypeArgument, {
        at: this.state.startLoc
      }), e.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
    }
    tsParseEntityName(e = true) {
      let t = this.parseIdentifier(e);
      for (; this.eat(16); ) {
        const r = this.startNodeAtNode(t);
        r.left = t, r.right = this.parseIdentifier(e), t = this.finishNode(r, "TSQualifiedName");
      }
      return t;
    }
    tsParseTypeReference() {
      const e = this.startNode();
      return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
    }
    tsParseThisTypePredicate(e) {
      this.next();
      const t = this.startNodeAtNode(e);
      return t.parameterName = e, t.typeAnnotation = this.tsParseTypeAnnotation(false), t.asserts = false, this.finishNode(t, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "TSThisType");
    }
    tsParseTypeQuery() {
      const e = this.startNode();
      return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
    }
    tsParseInOutModifiers(e) {
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ve.InvalidModifierOnTypeParameter
      });
    }
    tsParseNoneModifiers(e) {
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: [],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ve.InvalidModifierOnTypeParameterPositions
      });
    }
    tsParseTypeParameter(e = this.tsParseNoneModifiers.bind(this)) {
      const t = this.startNode();
      return e(t), t.name = this.tsParseTypeParameterName(), t.constraint = this.tsEatThenParseType(81), t.default = this.tsEatThenParseType(29), this.finishNode(t, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e) {
      if (this.match(47))
        return this.tsParseTypeParameters(e);
    }
    tsParseTypeParameters(e) {
      const t = this.startNode();
      this.match(47) || this.match(138) ? this.next() : this.unexpected();
      const r = {
        value: -1
      };
      return t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, r), t.params.length === 0 && this.raise(ve.EmptyTypeParameters, {
        at: t
      }), r.value !== -1 && this.addExtra(t, "trailingComma", r.value), this.finishNode(t, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type !== 75)
        return null;
      this.next();
      const e = this.tsParseTypeReference();
      return e.typeParameters && this.raise(ve.CannotFindName, {
        at: e.typeName,
        name: "const"
      }), e;
    }
    tsFillSignature(e, t) {
      const r = e === 19, i = "parameters", o = "typeAnnotation";
      t.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), t[i] = this.tsParseBindingListForSignature(), r ? t[o] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (t[o] = this.tsParseTypeOrTypePredicateAnnotation(e));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(11, 41).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(ve.UnsupportedSignatureParameterKind, {
        at: e,
        type: e.type
      }), e));
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(e, t) {
      return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Te(this.state.type) ? (this.next(), this.match(14)) : false;
    }
    tsTryParseIndexSignature(e) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const t = this.parseIdentifier();
      t.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t), this.expect(3), e.parameters = [t];
      const r = this.tsTryParseTypeAnnotation();
      return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e, t) {
      this.eat(17) && (e.optional = true);
      const r = e;
      if (this.match(10) || this.match(47)) {
        t && this.raise(ve.ReadonlyForMethodSignature, {
          at: e
        });
        const i = r;
        i.kind && this.match(47) && this.raise(ve.AccesorCannotHaveTypeParameters, {
          at: this.state.curPosition()
        }), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
        const o = "parameters", d = "typeAnnotation";
        if (i.kind === "get")
          i[o].length > 0 && (this.raise(m.BadGetterArity, {
            at: this.state.curPosition()
          }), this.isThisParam(i[o][0]) && this.raise(ve.AccesorCannotDeclareThisParameter, {
            at: this.state.curPosition()
          }));
        else if (i.kind === "set") {
          if (i[o].length !== 1)
            this.raise(m.BadSetterArity, {
              at: this.state.curPosition()
            });
          else {
            const u = i[o][0];
            this.isThisParam(u) && this.raise(ve.AccesorCannotDeclareThisParameter, {
              at: this.state.curPosition()
            }), u.type === "Identifier" && u.optional && this.raise(ve.SetAccesorCannotHaveOptionalParameter, {
              at: this.state.curPosition()
            }), u.type === "RestElement" && this.raise(ve.SetAccesorCannotHaveRestParameter, {
              at: this.state.curPosition()
            });
          }
          i[d] && this.raise(ve.SetAccesorCannotHaveReturnType, {
            at: i[d]
          });
        } else
          i.kind = "method";
        return this.finishNode(i, "TSMethodSignature");
      } else {
        const i = r;
        t && (i.readonly = true);
        const o = this.tsTryParseTypeAnnotation();
        return o && (i.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
      if (this.match(77)) {
        const r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(e, false));
      }
      this.tsParseModifiers({
        modified: e,
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      });
      const t = this.tsTryParseIndexSignature(e);
      return t || (this.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, this.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
    }
    tsParseTypeLiteral() {
      const e = this.startNode();
      return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(118) : (this.isContextual(118) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      const e = this.startNode();
      return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e = this.startNode();
      return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(118)) : this.eatContextual(118) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
    }
    tsParseTupleType() {
      const e = this.startNode();
      e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t = false, r = null;
      return e.elementTypes.forEach((i) => {
        var o;
        let {
          type: d
        } = i;
        t && d !== "TSRestType" && d !== "TSOptionalType" && !(d === "TSNamedTupleMember" && i.optional) && this.raise(ve.OptionalTypeBeforeRequired, {
          at: i
        }), t = t || d === "TSNamedTupleMember" && i.optional || d === "TSOptionalType", d === "TSRestType" && (i = i.typeAnnotation, d = i.type);
        const u = d === "TSNamedTupleMember";
        r = (o = r) != null ? o : u, r !== u && this.raise(ve.MixedLabeledAndUnlabeledElements, {
          at: i
        });
      }), this.finishNode(e, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        start: e,
        startLoc: t
      } = this.state, r = this.eat(21);
      let i = this.tsParseType();
      const o = this.eat(17);
      if (this.eat(14)) {
        const u = this.startNodeAtNode(i);
        u.optional = o, i.type === "TSTypeReference" && !i.typeParameters && i.typeName.type === "Identifier" ? u.label = i.typeName : (this.raise(ve.InvalidTupleMemberLabel, {
          at: i
        }), u.label = i), u.elementType = this.tsParseType(), i = this.finishNode(u, "TSNamedTupleMember");
      } else if (o) {
        const u = this.startNodeAtNode(i);
        u.typeAnnotation = i, i = this.finishNode(u, "TSOptionalType");
      }
      if (r) {
        const u = this.startNodeAt(e, t);
        u.typeAnnotation = i, i = this.finishNode(u, "TSRestType");
      }
      return i;
    }
    tsParseParenthesizedType() {
      const e = this.startNode();
      return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e, t) {
      const r = this.startNode();
      return e === "TSConstructorType" && (r.abstract = !!t, t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
    }
    tsParseLiteralTypeNode() {
      const e = this.startNode();
      return e.literal = (() => {
        switch (this.state.type) {
          case 130:
          case 131:
          case 129:
          case 85:
          case 86:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e = this.startNode();
      return e.literal = this.parseTemplate(false), this.finishNode(e, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e = this.tsParseThisTypeNode();
      return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 129:
        case 130:
        case 131:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const e = this.startNode(), t = this.lookahead();
            if (t.type !== 130 && t.type !== 131)
              throw this.unexpected();
            return e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: e
          } = this.state;
          if (Te(e) || e === 88 || e === 84) {
            const t = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : mi(this.state.value);
            if (t !== void 0 && this.lookaheadCharCode() !== 46) {
              const r = this.startNode();
              return this.next(), this.finishNode(r, t);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const t = this.startNodeAtNode(e);
          t.elementType = e, this.expect(3), e = this.finishNode(t, "TSArrayType");
        } else {
          const t = this.startNodeAtNode(e);
          t.objectType = e, t.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(t, "TSIndexedAccessType");
        }
      return e;
    }
    tsParseTypeOperator() {
      const e = this.startNode(), t = this.state.value;
      return this.next(), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), t === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e) {
      switch (e.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ve.UnexpectedReadonly, {
            at: e
          });
      }
    }
    tsParseInferType() {
      const e = this.startNode();
      this.expectContextual(112);
      const t = this.startNode();
      return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(t, "TSTypeParameter"), this.finishNode(e, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return e;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return _e(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e, t, r) {
      const i = this.startNode(), o = this.eat(r), d = [];
      do
        d.push(t());
      while (this.eat(r));
      return d.length === 1 && !o ? d[0] : (i.types = d, this.finishNode(i, e));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Te(this.state.type) || this.match(78))
        return this.next(), true;
      if (this.match(5)) {
        const {
          errors: e
        } = this.state, t = e.length;
        try {
          return this.parseObjectLike(8, true), e.length === t;
        } catch {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: e
        } = this.state, t = e.length;
        try {
          return this.parseBindingList(3, 93, true), e.length === t;
        } catch {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(e) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(e);
        const r = this.startNode(), i = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (i && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (r.parameterName = u, r.asserts = true, r.typeAnnotation = null, u = this.finishNode(r, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, r), u.asserts = true), t.typeAnnotation = u, this.finishNode(t, "TSTypeAnnotation");
        }
        const o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return i ? (r.parameterName = this.parseIdentifier(), r.asserts = i, r.typeAnnotation = null, t.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t);
        const d = this.tsParseTypeAnnotation(false);
        return r.parameterName = o, r.typeAnnotation = d, r.asserts = i, t.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const e = this.parseIdentifier();
      if (this.isContextual(113) && !this.hasPrecedingLineBreak())
        return this.next(), e;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 106)
        return false;
      const e = this.state.containsEsc;
      return this.next(), !Te(this.state.type) && !this.match(78) ? false : (e && this.raise(m.InvalidEscapedReservedWord, {
        at: this.state.lastTokStartLoc,
        reservedWord: "asserts"
      }), true);
    }
    tsParseTypeAnnotation(e = true, t = this.startNode()) {
      return this.tsInType(() => {
        e && this.expect(14), t.typeAnnotation = this.tsParseType();
      }), this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      Yr(this.state.inType);
      const e = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return e;
      const t = this.startNodeAtNode(e);
      return t.checkType = e, t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(120) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ve.ReservedTypeAssertion, {
        at: this.state.startLoc
      });
      const e = this.startNode(), t = this.tsTryNextParseConstantContext();
      return e.typeAnnotation = t || this.tsNextThenParseType(), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
    }
    tsParseHeritageClause(e) {
      const t = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const i = this.startNode();
        return i.expression = this.tsParseEntityName(), this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSExpressionWithTypeArguments");
      });
      return r.length || this.raise(ve.EmptyHeritageClauseType, {
        at: t,
        token: e
      }), r;
    }
    tsParseInterfaceDeclaration(e, t = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(125), t.declare && (e.declare = true), Te(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Es)) : (e.id = null, this.raise(ve.MissingInterfaceName, {
        at: this.state.startLoc
      })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
      const r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e) {
      return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, vs), e.typeAnnotation = this.tsInType(() => {
        if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(111) && this.lookahead().type !== 16) {
          const t = this.startNode();
          return this.next(), this.finishNode(t, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e) {
      const t = this.state.context;
      this.state.context = [t[0]];
      try {
        return e();
      } finally {
        this.state.context = t;
      }
    }
    tsInType(e) {
      const t = this.state.inType;
      this.state.inType = true;
      try {
        return e();
      } finally {
        this.state.inType = t;
      }
    }
    tsInDisallowConditionalTypesContext(e) {
      const t = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = t;
      }
    }
    tsInAllowConditionalTypesContext(e) {
      const t = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = t;
      }
    }
    tsEatThenParseType(e) {
      return this.match(e) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e) {
      return this.tsDoThenParseType(() => this.expect(e));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e) {
      return this.tsInType(() => (e(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e = this.startNode();
      return e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
    }
    tsParseEnumDeclaration(e, t = {}) {
      return t.const && (e.const = true), t.declare && (e.declare = true), this.expectContextual(122), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? Cs : Rr), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e = this.startNode();
      return this.scope.enter(At), this.expect(5), this.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e, t = false) {
      if (e.id = this.parseIdentifier(), t || this.checkIdentifier(e.id, ws), this.eat(16)) {
        const r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, true), e.body = r;
      } else
        this.scope.enter(qt), this.prodParam.enter(It), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e) {
      return this.isContextual(109) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(129) ? e.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(qt), this.prodParam.enter(It), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e, t) {
      e.isExport = t || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, nt), this.expect(29);
      const r = this.tsParseModuleReference();
      return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(ve.ImportAliasHasImportType, {
        at: r
      }), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(116) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e = this.startNode();
      if (this.expectContextual(116), this.expect(10), !this.match(129))
        throw this.unexpected();
      return e.expression = this.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
    }
    tsLookAhead(e) {
      const t = this.state.clone(), r = e();
      return this.state = t, r;
    }
    tsTryParseAndCatch(e) {
      const t = this.tryParse((r) => e() || r());
      if (!(t.aborted || !t.node))
        return t.error && (this.state = t.failState), t.node;
    }
    tsTryParse(e) {
      const t = this.state.clone(), r = e();
      if (r !== void 0 && r !== false)
        return r;
      this.state = t;
    }
    tsTryParseDeclare(e) {
      if (this.isLineTerminator())
        return;
      let t = this.state.type, r;
      return this.isContextual(99) && (t = 74, r = "let"), this.tsInAmbientContext(() => {
        if (t === 68)
          return e.declare = true, this.parseFunctionStatement(e, false, true);
        if (t === 80)
          return e.declare = true, this.parseClass(e, true, false);
        if (t === 122)
          return this.tsParseEnumDeclaration(e, {
            declare: true
          });
        if (t === 109)
          return this.tsParseAmbientExternalModuleDeclaration(e);
        if (t === 75 || t === 74)
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, r || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, {
            const: true,
            declare: true
          }));
        if (t === 125) {
          const i = this.tsParseInterfaceDeclaration(e, {
            declare: true
          });
          if (i)
            return i;
        }
        if (Te(t))
          return this.tsParseDeclaration(e, this.state.value, true);
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e, t) {
      switch (t.name) {
        case "declare": {
          const r = this.tsTryParseDeclare(e);
          if (r)
            return r.declare = true, r;
          break;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(qt), this.prodParam.enter(It);
            const r = e;
            return r.global = true, r.id = t, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e, t.name, false);
      }
    }
    tsParseDeclaration(e, t, r) {
      switch (t) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || Te(this.state.type)))
            return this.tsParseAbstractDeclaration(e);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(129))
              return this.tsParseAmbientExternalModuleDeclaration(e);
            if (Te(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(e);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && Te(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(e);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && Te(this.state.type))
            return this.tsParseTypeAliasDeclaration(e);
          break;
      }
    }
    tsCheckLineTerminator(e) {
      return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e, t) {
      if (!this.match(47))
        return;
      const r = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const i = this.tsTryParseAndCatch(() => {
        const o = this.startNodeAt(e, t);
        return o.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(o), o.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), o;
      });
      if (this.state.maybeInArrowParameters = r, !!i)
        return this.parseArrowExpression(i, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const e = this.startNode();
      return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(ve.EmptyTypeArguments, {
        at: e
      }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Re(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      let o, d = false, u = false;
      if (e !== void 0) {
        const U = {};
        this.tsParseModifiers({
          modified: U,
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }), o = U.accessibility, u = U.override, d = U.readonly, e === false && (o || d || u) && this.raise(ve.UnexpectedParameterModifier, {
          at: i
        });
      }
      const E = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(E);
      const w = this.parseMaybeDefault(E.start, E.loc.start, E);
      if (o || d || u) {
        const U = this.startNodeAt(r, i);
        return t.length && (U.decorators = t), o && (U.accessibility = o), d && (U.readonly = d), u && (U.override = u), w.type !== "Identifier" && w.type !== "AssignmentPattern" && this.raise(ve.UnsupportedParameterPropertyKind, {
          at: U
        }), U.parameter = w, this.finishNode(U, "TSParameterProperty");
      }
      return t.length && (E.decorators = t), w;
    }
    isSimpleParameter(e) {
      return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const i = t === "FunctionDeclaration" ? "TSDeclareFunction" : t === "ClassMethod" || t === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      if (i && !this.match(5) && this.isLineTerminator()) {
        this.finishNode(e, i);
        return;
      }
      if (i === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ve.DeclareFunctionHasImplementation, {
        at: e
      }), e.declare)) {
        super.parseFunctionBodyAndFinish(e, i, r);
        return;
      }
      super.parseFunctionBodyAndFinish(e, t, r);
    }
    registerFunctionStatementId(e) {
      !e.body && e.id ? this.checkIdentifier(e.id, Ur) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e) {
      e.forEach((t) => {
        (t == null ? void 0 : t.type) === "TSTypeCastExpression" && this.raise(ve.UnexpectedTypeAnnotation, {
          at: t.typeAnnotation
        });
      });
    }
    toReferencedList(e, t) {
      return this.tsCheckForInvalidTypeCasts(e), e;
    }
    parseArrayLike(...e) {
      const t = super.parseArrayLike(...e);
      return t.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t.elements), t;
    }
    parseSubscript(e, t, r, i, o) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        const u = this.startNodeAt(t, r);
        return u.expression = e, this.finishNode(u, "TSNonNullExpression");
      }
      let d = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return o.stop = true, e;
        o.optionalChainMember = d = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let u;
        const E = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(e)) {
            const ye = this.tsTryParseGenericAsyncArrowFunction(t, r);
            if (ye)
              return ye;
          }
          const w = this.tsParseTypeArgumentsInExpression();
          if (!w)
            return;
          if (d && !this.match(10)) {
            u = this.state.curPosition();
            return;
          }
          if (Ze(this.state.type)) {
            const ye = this.parseTaggedTemplateExpression(e, t, r, o);
            return ye.typeParameters = w, ye;
          }
          if (!i && this.eat(10)) {
            const ye = this.startNodeAt(t, r);
            return ye.callee = e, ye.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(ye.arguments), ye.typeParameters = w, o.optionalChainMember && (ye.optional = d), this.finishCallExpression(ye, o.optionalChainMember);
          }
          const U = this.state.type;
          if (U === 48 || U !== 10 && ce(U) && !this.hasPrecedingLineBreak())
            return;
          const ge = this.startNodeAt(t, r);
          return ge.expression = e, ge.typeParameters = w, this.finishNode(ge, "TSInstantiationExpression");
        });
        if (u && this.unexpected(u, 10), E)
          return E.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ve.InvalidPropertyAccessAfterInstantiationExpression, {
            at: this.state.startLoc
          }), E;
      }
      return super.parseSubscript(e, t, r, i, o);
    }
    parseNewCallee(e) {
      var t;
      super.parseNewCallee(e);
      const {
        callee: r
      } = e;
      r.type === "TSInstantiationExpression" && !((t = r.extra) != null && t.parenthesized) && (e.typeParameters = r.typeParameters, e.callee = r.expression);
    }
    parseExprOp(e, t, r, i) {
      if (Ge(58) > i && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
        const o = this.startNodeAt(t, r);
        o.expression = e;
        const d = this.tsTryNextParseConstantContext();
        return d ? o.typeAnnotation = d : o.typeAnnotation = this.tsNextThenParseType(), this.finishNode(o, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(o, t, r, i);
      }
      return super.parseExprOp(e, t, r, i);
    }
    checkReservedWord(e, t, r, i) {
      this.state.isAmbientContext || super.checkReservedWord(e, t, r, i);
    }
    checkDuplicateExports() {
    }
    parseImport(e) {
      if (e.importKind = "value", Te(this.state.type) || this.match(55) || this.match(5)) {
        let r = this.lookahead();
        if (this.isContextual(126) && r.type !== 12 && r.type !== 97 && r.type !== 29 && (e.importKind = "type", this.next(), r = this.lookahead()), Te(this.state.type) && r.type === 29)
          return this.tsParseImportEqualsDeclaration(e);
      }
      const t = super.parseImport(e);
      return t.importKind === "type" && t.specifiers.length > 1 && t.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ve.TypeImportCannotSpecifyDefaultAndNamed, {
        at: t
      }), t;
    }
    parseExport(e) {
      if (this.match(83))
        return this.next(), this.isContextual(126) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
      if (this.eat(29)) {
        const t = e;
        return t.expression = this.parseExpression(), this.semicolon(), this.finishNode(t, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const t = e;
        return this.expectContextual(124), t.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
      } else
        return this.isContextual(126) && this.lookahead().type === 5 ? (this.next(), e.exportKind = "type") : e.exportKind = "value", super.parseExport(e);
    }
    isAbstractClass() {
      return this.isContextual(120) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e = this.startNode();
        return this.next(), e.abstract = true, this.parseClass(e, true, true), e;
      }
      if (this.match(125)) {
        const e = this.tsParseInterfaceDeclaration(this.startNode());
        if (e)
          return e;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e, t, r = false) {
      const {
        isAmbientContext: i
      } = this.state, o = super.parseVarStatement(e, t, r || i);
      if (!i)
        return o;
      for (const {
        id: d,
        init: u
      } of o.declarations)
        !u || (t !== "const" || !!d.typeAnnotation ? this.raise(ve.InitializerNotAllowedInAmbientContext, {
          at: u
        }) : u.type !== "StringLiteral" && u.type !== "BooleanLiteral" && u.type !== "NumericLiteral" && u.type !== "BigIntLiteral" && (u.type !== "TemplateLiteral" || u.expressions.length > 0) && !gi(u) && this.raise(ve.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
          at: u
        }));
      return o;
    }
    parseStatementContent(e, t) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, {
          const: true
        });
      }
      if (this.isContextual(122))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(125)) {
        const r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r)
          return r;
      }
      return super.parseStatementContent(e, t);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e, t) {
      return t.some((r) => Qr(r) ? e.accessibility === r : !!e[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e, t, r) {
      const i = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        modified: t,
        allowedModifiers: i,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: ve.InvalidModifierOnTypeParameterPositions
      });
      const o = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, i) && this.raise(ve.StaticBlockCannotHaveModifier, {
          at: this.state.curPosition()
        }), this.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
      };
      t.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(e, t, r, i) {
      const o = this.tsTryParseIndexSignature(t);
      if (o) {
        e.body.push(o), t.abstract && this.raise(ve.IndexSignatureHasAbstract, {
          at: t
        }), t.accessibility && this.raise(ve.IndexSignatureHasAccessibility, {
          at: t,
          modifier: t.accessibility
        }), t.declare && this.raise(ve.IndexSignatureHasDeclare, {
          at: t
        }), t.override && this.raise(ve.IndexSignatureHasOverride, {
          at: t
        });
        return;
      }
      !this.state.inAbstractClass && t.abstract && this.raise(ve.NonAbstractClassHasAbstractMethod, {
        at: t
      }), t.override && (r.hadSuperClass || this.raise(ve.OverrideNotInSubClass, {
        at: t
      })), super.parseClassMemberWithIsStatic(e, t, r, i);
    }
    parsePostMemberNameModifiers(e) {
      this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(ve.ClassMethodHasReadonly, {
        at: e
      }), e.declare && this.match(10) && this.raise(ve.ClassMethodHasDeclare, {
        at: e
      });
    }
    parseExpressionStatement(e, t) {
      return (t.type === "Identifier" ? this.tsParseExpressionStatement(e, t) : void 0) || super.parseExpressionStatement(e, t);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
    }
    parseConditional(e, t, r, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(e, t, r, i);
      const o = this.tryParse(() => super.parseConditional(e, t, r));
      return o.node ? (o.error && (this.state = o.failState), o.node) : (o.error && super.setOptionalParametersError(i, o.error), e);
    }
    parseParenItem(e, t, r) {
      if (e = super.parseParenItem(e, t, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        const i = this.startNodeAt(t, r);
        return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
      }
      return e;
    }
    parseExportDeclaration(e) {
      if (!this.state.isAmbientContext && this.isContextual(121))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
      const t = this.state.start, r = this.state.startLoc, i = this.eatContextual(121);
      if (i && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
        throw this.raise(ve.ExpectedAmbientAfterExportDeclare, {
          at: this.state.startLoc
        });
      const d = Te(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
      return d ? ((d.type === "TSInterfaceDeclaration" || d.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(d, t, r), d.declare = true), d) : null;
    }
    parseClassId(e, t, r) {
      if ((!t || r) && this.isContextual(110))
        return;
      super.parseClassId(e, t, r, e.declare ? Ur : Fr);
      const i = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
      i && (e.typeParameters = i);
    }
    parseClassPropertyAnnotation(e) {
      !e.optional && this.eat(35) && (e.definite = true);
      const t = this.tsTryParseTypeAnnotation();
      t && (e.typeAnnotation = t);
    }
    parseClassProperty(e) {
      if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && this.match(29) && this.raise(ve.DeclareClassFieldHasInitializer, {
        at: this.state.startLoc
      }), e.abstract && this.match(29)) {
        const {
          key: t
        } = e;
        this.raise(ve.AbstractPropertyHasInitializer, {
          at: this.state.startLoc,
          propertyName: t.type === "Identifier" && !e.computed ? t.name : `[${this.input.slice(t.start, t.end)}]`
        });
      }
      return super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return e.abstract && this.raise(ve.PrivateElementHasAbstract, {
        at: e
      }), e.accessibility && this.raise(ve.PrivateElementHasAccessibility, {
        at: e,
        modifier: e.accessibility
      }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
    }
    pushClassMethod(e, t, r, i, o, d) {
      const u = this.tsTryParseTypeParameters();
      u && o && this.raise(ve.ConstructorHasTypeParameters, {
        at: u
      });
      const {
        declare: E = false,
        kind: w
      } = t;
      E && (w === "get" || w === "set") && this.raise(ve.DeclareAccessor, {
        at: t,
        kind: w
      }), u && (t.typeParameters = u), super.pushClassMethod(e, t, r, i, o, d);
    }
    pushClassPrivateMethod(e, t, r, i) {
      const o = this.tsTryParseTypeParameters();
      o && (t.typeParameters = o), super.pushClassPrivateMethod(e, t, r, i);
    }
    declareClassPrivateMethodInScope(e, t) {
      e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, t));
    }
    parseClassSuper(e) {
      super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(110) && (e.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e, ...t) {
      const r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseObjPropValue(e, ...t);
    }
    parseFunctionParams(e, t) {
      const r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseFunctionParams(e, t);
    }
    parseVarId(e, t) {
      super.parseVarId(e, t), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
      const r = this.tsTryParseTypeAnnotation();
      r && (e.id.typeAnnotation = r, this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, t) {
      return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
    }
    parseMaybeAssign(...e) {
      var t, r, i, o, d, u, E;
      let w, U, ge;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (w = this.state.clone(), U = this.tryParse(() => super.parseMaybeAssign(...e), w), !U.error)
          return U.node;
        const {
          context: Oe
        } = this.state, Ve = Oe[Oe.length - 1];
        (Ve === j.j_oTag || Ve === j.j_expr) && Oe.pop();
      }
      if (!((t = U) != null && t.error) && !this.match(47))
        return super.parseMaybeAssign(...e);
      (!w || w === this.state) && (w = this.state.clone());
      let ye;
      const Ae = this.tryParse((Oe) => {
        var Ve, Ke;
        ye = this.tsParseTypeParameters();
        const He = super.parseMaybeAssign(...e);
        return (He.type !== "ArrowFunctionExpression" || (Ve = He.extra) != null && Ve.parenthesized) && Oe(), ((Ke = ye) == null ? void 0 : Ke.params.length) !== 0 && this.resetStartLocationFromNode(He, ye), He.typeParameters = ye, He;
      }, w);
      if (!Ae.error && !Ae.aborted)
        return ye && this.reportReservedArrowTypeParam(ye), Ae.node;
      if (!U && (Yr(!this.hasPlugin("jsx")), ge = this.tryParse(() => super.parseMaybeAssign(...e), w), !ge.error))
        return ge.node;
      if ((r = U) != null && r.node)
        return this.state = U.failState, U.node;
      if (Ae.node)
        return this.state = Ae.failState, ye && this.reportReservedArrowTypeParam(ye), Ae.node;
      if ((i = ge) != null && i.node)
        return this.state = ge.failState, ge.node;
      throw (o = U) != null && o.thrown ? U.error : Ae.thrown ? Ae.error : (d = ge) != null && d.thrown ? ge.error : ((u = U) == null ? void 0 : u.error) || Ae.error || ((E = ge) == null ? void 0 : E.error);
    }
    reportReservedArrowTypeParam(e) {
      var t;
      e.params.length === 1 && !((t = e.extra) != null && t.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ve.ReservedArrowTypeParam, {
        at: e
      });
    }
    parseMaybeUnary(e) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e);
    }
    parseArrow(e) {
      if (this.match(14)) {
        const t = this.tryParse((r) => {
          const i = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), i;
        });
        if (t.aborted)
          return;
        t.thrown || (t.error && (this.state = t.failState), e.returnType = t.node);
      }
      return super.parseArrow(e);
    }
    parseAssignableListItemTypes(e) {
      this.eat(17) && (e.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(ve.PatternIsOptional, {
        at: e
      }), e.optional = true);
      const t = this.tsTryParseTypeAnnotation();
      return t && (e.typeAnnotation = t), this.resetEndLocation(e), e;
    }
    isAssignable(e, t) {
      switch (e.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e.expression, t);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e, t);
      }
    }
    toAssignable(e, t = false) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e, t);
          break;
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          t ? this.expressionScope.recordArrowParemeterBindingError(ve.UnexpectedTypeCastInParameter, {
            at: e
          }) : this.raise(ve.UnexpectedTypeCastInParameter, {
            at: e
          }), this.toAssignable(e.expression, t);
          break;
        case "AssignmentExpression":
          !t && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
        default:
          super.toAssignable(e, t);
      }
    }
    toAssignableParenthesizedExpression(e, t) {
      switch (e.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, t);
          break;
        default:
          super.toAssignable(e, t);
      }
    }
    checkToRestConversion(e, t) {
      switch (e.type) {
        case "TSAsExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e.expression, false);
          break;
        default:
          super.checkToRestConversion(e, t);
      }
    }
    isValidLVal(e, t, r) {
      return hi({
        TSTypeCastExpression: true,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (r !== Pt || !t) && ["expression", true],
        TSTypeAssertion: (r !== Pt || !t) && ["expression", true]
      }, e) || super.isValidLVal(e, t, r);
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e) {
      if (this.match(47) || this.match(51)) {
        const t = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const r = super.parseMaybeDecoratorArguments(e);
          return r.typeParameters = t, r;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e);
    }
    checkCommaAfterRest(e) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(...e) {
      const t = super.parseMaybeDefault(...e);
      return t.type === "AssignmentPattern" && t.typeAnnotation && t.right.start < t.typeAnnotation.start && this.raise(ve.TypeAnnotationAfterAssign, {
        at: t.typeAnnotation
      }), t;
    }
    getTokenFromCode(e) {
      if (this.state.inType) {
        if (e === 62)
          return this.finishOp(48, 1);
        if (e === 60)
          return this.finishOp(47, 1);
      }
      return super.getTokenFromCode(e);
    }
    reScan_lt_gt() {
      const {
        type: e
      } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: e
      } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    toAssignableList(e) {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        (r == null ? void 0 : r.type) === "TSTypeCastExpression" && (e[t] = this.typeCastToParameter(r));
      }
      super.toAssignableList(...arguments);
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    shouldParseArrow(e) {
      return this.match(14) ? e.every((t) => this.isAssignable(t, true)) : super.shouldParseArrow(e);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e) {
      if (this.match(47) || this.match(51)) {
        const t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        t && (e.typeParameters = t);
      }
      return super.jsxParseOpeningElementAfterName(e);
    }
    getGetterSetterExpectedParamCount(e) {
      const t = super.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e)[0];
      return i && this.isThisParam(i) ? t + 1 : t;
    }
    parseCatchClauseParam() {
      const e = super.parseCatchClauseParam(), t = this.tsTryParseTypeAnnotation();
      return t && (e.typeAnnotation = t, this.resetEndLocation(e)), e;
    }
    tsInAmbientContext(e) {
      const t = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e();
      } finally {
        this.state.isAmbientContext = t;
      }
    }
    parseClass(e, ...t) {
      const r = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e.abstract;
      try {
        return super.parseClass(e, ...t);
      } finally {
        this.state.inAbstractClass = r;
      }
    }
    tsParseAbstractDeclaration(e) {
      if (this.match(80))
        return e.abstract = true, this.parseClass(e, true, false);
      if (this.isContextual(125)) {
        if (!this.hasFollowingLineBreak())
          return e.abstract = true, this.raise(ve.NonClassMethodPropertyHasAbstractModifer, {
            at: e
          }), this.tsParseInterfaceDeclaration(e);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(...e) {
      const t = super.parseMethod(...e);
      if (t.abstract && (this.hasPlugin("estree") ? !!t.value.body : !!t.body)) {
        const {
          key: i
        } = t;
        this.raise(ve.AbstractMethodHasImplementation, {
          at: t,
          methodName: i.type === "Identifier" && !t.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
        });
      }
      return t;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e, t, r, i) {
      return !t && i ? (this.parseTypeOnlyImportExportSpecifier(e, false, r), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, t, r, i));
    }
    parseImportSpecifier(e, t, r, i) {
      return !t && i ? (this.parseTypeOnlyImportExportSpecifier(e, true, r), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, t, r, i));
    }
    parseTypeOnlyImportExportSpecifier(e, t, r) {
      const i = t ? "imported" : "local", o = t ? "local" : "exported";
      let d = e[i], u, E = false, w = true;
      const U = d.loc.start;
      if (this.isContextual(93)) {
        const ye = this.parseIdentifier();
        if (this.isContextual(93)) {
          const Ae = this.parseIdentifier();
          z(this.state.type) ? (E = true, d = ye, u = t ? this.parseIdentifier() : this.parseModuleExportName(), w = false) : (u = Ae, w = false);
        } else
          z(this.state.type) ? (w = false, u = t ? this.parseIdentifier() : this.parseModuleExportName()) : (E = true, d = ye);
      } else
        z(this.state.type) && (E = true, t ? (d = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(d.name, d.loc.start, true, true)) : d = this.parseModuleExportName());
      E && r && this.raise(t ? ve.TypeModifierIsUsedInTypeImports : ve.TypeModifierIsUsedInTypeExports, {
        at: U
      }), e[i] = d, e[o] = u;
      const ge = t ? "importKind" : "exportKind";
      e[ge] = E ? "type" : "value", w && this.eatContextual(93) && (e[o] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[o] || (e[o] = at(e[i])), t && this.checkIdentifier(e[o], nt);
    }
  };
  function gi(a) {
    if (a.type !== "MemberExpression")
      return false;
    const {
      computed: e,
      property: t
    } = a;
    return e && t.type !== "StringLiteral" && (t.type !== "TemplateLiteral" || t.expressions.length > 0) ? false : Zr(a.object);
  }
  function Zr(a) {
    return a.type === "Identifier" ? true : a.type !== "MemberExpression" || a.computed ? false : Zr(a.object);
  }
  const es = _`placeholders`((a) => ({
    ClassNameIsRequired: a("A class name is required."),
    UnexpectedSpace: a("Unexpected space in placeholder.")
  }));
  var Ti = (a) => class extends a {
    parsePlaceholder(e) {
      if (this.match(140)) {
        const t = this.startNode();
        return this.next(), this.assertNoSpace(), t.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(140), this.finishPlaceholder(t, e);
      }
    }
    finishPlaceholder(e, t) {
      const r = !!(e.expectedNode && e.type === "Placeholder");
      return e.expectedNode = t, r ? e : this.finishNode(e, "Placeholder");
    }
    getTokenFromCode(e) {
      return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(140, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e) {
      e !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    isValidLVal(e, ...t) {
      return e === "Placeholder" || super.isValidLVal(e, ...t);
    }
    toAssignable(e) {
      e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(...arguments);
    }
    isLet(e) {
      return super.isLet(e) ? true : !this.isContextual(99) || e ? false : this.lookahead().type === 140;
    }
    verifyBreakContinue(e) {
      e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e, t) {
      if (t.type !== "Placeholder" || t.extra && t.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(14)) {
        const r = e;
        return r.label = this.finishPlaceholder(t, "Identifier"), this.next(), r.body = this.parseStatement("label"), this.finishNode(r, "LabeledStatement");
      }
      return this.semicolon(), e.name = t.name, this.finishPlaceholder(e, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e, t, r) {
      const i = t ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e);
      const o = this.state.strict, d = this.parsePlaceholder("Identifier");
      if (d)
        if (this.match(81) || this.match(140) || this.match(5))
          e.id = d;
        else {
          if (r || !t)
            return e.id = null, e.body = this.finishPlaceholder(d, "ClassBody"), this.finishNode(e, i);
          throw this.raise(es.ClassNameIsRequired, {
            at: this.state.startLoc
          });
        }
      else
        this.parseClassId(e, t, r);
      return this.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e.superClass, o), this.finishNode(e, i);
    }
    parseExport(e) {
      const t = this.parsePlaceholder("Identifier");
      if (!t)
        return super.parseExport(...arguments);
      if (!this.isContextual(97) && !this.match(12))
        return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(t, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const r = this.startNode();
      return r.exported = t, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], super.parseExport(e);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const e = this.nextTokenStart();
        if (this.isUnparsedContextual(e, "from") && this.input.startsWith($e(140), this.nextTokenStartSince(e + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e) {
      return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e) {
      const {
        specifiers: t
      } = e;
      t != null && t.length && (e.specifiers = t.filter((r) => r.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = t;
    }
    parseImport(e) {
      const t = this.parsePlaceholder("Identifier");
      if (!t)
        return super.parseImport(...arguments);
      if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
        return e.source = this.finishPlaceholder(t, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
      const r = this.startNodeAtNode(t);
      return r.local = t, this.finishNode(r, "ImportDefaultSpecifier"), e.specifiers.push(r), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(es.UnexpectedSpace, {
        at: this.state.lastTokEndLoc
      });
    }
  }, xi = (a) => class extends a {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const e = this.state.startLoc, t = this.startNode();
        if (this.next(), Te(this.state.type)) {
          const r = this.parseIdentifierName(this.state.start), i = this.createIdentifier(t, r);
          if (i.type = "V8IntrinsicIdentifier", this.match(10))
            return i;
        }
        this.unexpected(e);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  };
  function ze(a, e) {
    const [t, r] = typeof e == "string" ? [e, {}] : e, i = Object.keys(r), o = i.length === 0;
    return a.some((d) => {
      if (typeof d == "string")
        return o && d === t;
      {
        const [u, E] = d;
        if (u !== t)
          return false;
        for (const w of i)
          if (E[w] !== r[w])
            return false;
        return true;
      }
    });
  }
  function Ft(a, e, t) {
    const r = a.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return r && Array.isArray(r) ? r[1][t] : null;
  }
  const ts = ["minimal", "fsharp", "hack", "smart"], rs = ["^^", "@@", "^", "%", "#"], ss = ["hash", "bar"];
  function Pi(a) {
    if (ze(a, "decorators")) {
      if (ze(a, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const e = Ft(a, "decorators", "decoratorsBeforeExport");
      if (e == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (ze(a, "flow") && ze(a, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (ze(a, "placeholders") && ze(a, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (ze(a, "pipelineOperator")) {
      const e = Ft(a, "pipelineOperator", "proposal");
      if (!ts.includes(e)) {
        const r = ts.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`);
      }
      const t = ze(a, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (e === "hack") {
        if (ze(a, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (ze(a, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const r = Ft(a, "pipelineOperator", "topicToken");
        if (!rs.includes(r)) {
          const i = rs.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
        }
        if (r === "#" && t)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (e === "smart" && t)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (ze(a, "moduleAttributes")) {
      if (ze(a, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Ft(a, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (ze(a, "recordAndTuple") && !ss.includes(Ft(a, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + ss.map((e) => `'${e}'`).join(", "));
    if (ze(a, "asyncDoExpressions") && !ze(a, "doExpressions")) {
      const e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
  }
  const is = {
    estree: B,
    jsx: ci,
    flow: li,
    typescript: bi,
    v8intrinsic: xi,
    placeholders: Ti
  }, Si = Object.keys(is), ns = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true
  };
  function Ei(a) {
    const e = {};
    for (const t of Object.keys(ns))
      e[t] = a && a[t] != null ? a[t] : ns[t];
    return e;
  }
  const vi = (a, e) => Object.hasOwnProperty.call(a, e) && a[e], as = (a) => a.type === "ParenthesizedExpression" ? as(a.expression) : a;
  class Ai extends ri {
    toAssignable(e, t = false) {
      var r, i;
      let o;
      switch ((e.type === "ParenthesizedExpression" || (r = e.extra) != null && r.parenthesized) && (o = as(e), t ? o.type === "Identifier" ? this.expressionScope.recordArrowParemeterBindingError(m.InvalidParenthesizedAssignment, {
        at: e
      }) : o.type !== "MemberExpression" && this.raise(m.InvalidParenthesizedAssignment, {
        at: e
      }) : this.raise(m.InvalidParenthesizedAssignment, {
        at: e
      })), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let u = 0, E = e.properties.length, w = E - 1; u < E; u++) {
            var d;
            const U = e.properties[u], ge = u === w;
            this.toAssignableObjectExpressionProp(U, ge, t), ge && U.type === "RestElement" && (d = e.extra) != null && d.trailingCommaLoc && this.raise(m.RestTrailingComma, {
              at: e.extra.trailingCommaLoc
            });
          }
          break;
        case "ObjectProperty": {
          const {
            key: u,
            value: E
          } = e;
          this.isPrivateName(u) && this.classScope.usePrivateName(this.getPrivateNameSV(u), u.loc.start), this.toAssignable(E, t);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, t);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(m.MissingEqInAssignment, {
            at: e.left.loc.end
          }), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(o, t);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, t, r) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? m.PatternHasAccessor : m.PatternHasMethod, {
          at: e.key
        });
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        const i = e.argument;
        this.checkToRestConversion(i, false), this.toAssignable(i, r), t || this.raise(m.RestTrailingComma, {
          at: e
        });
      } else
        this.toAssignable(e, r);
    }
    toAssignableList(e, t, r) {
      const i = e.length - 1;
      for (let o = 0; o <= i; o++) {
        const d = e[o];
        if (!!d) {
          if (d.type === "SpreadElement") {
            d.type = "RestElement";
            const u = d.argument;
            this.checkToRestConversion(u, true), this.toAssignable(u, r);
          } else
            this.toAssignable(d, r);
          d.type === "RestElement" && (o < i ? this.raise(m.RestTrailingComma, {
            at: d
          }) : t && this.raise(m.RestTrailingComma, {
            at: t
          }));
        }
      }
    }
    isAssignable(e, t) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const r = e.properties.length - 1;
          return e.properties.every((i, o) => i.type !== "ObjectMethod" && (o === r || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((r) => r === null || this.isAssignable(r));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t;
        default:
          return false;
      }
    }
    toReferencedList(e, t) {
      return e;
    }
    toReferencedListDeep(e, t) {
      this.toReferencedList(e, t);
      for (const r of e)
        (r == null ? void 0 : r.type) === "ArrayExpression" && this.toReferencedListDeep(r.elements);
    }
    parseSpread(e, t) {
      const r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0, t), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      const e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, true), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, t, r, i) {
      const o = [];
      let d = true;
      for (; !this.eat(e); )
        if (d ? d = false : this.expect(12), r && this.match(12))
          o.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (o.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(t)) {
              this.expect(e);
              break;
            }
          } else {
            const u = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(m.UnsupportedParameterDecorator, {
              at: this.state.startLoc
            }); this.match(26); )
              u.push(this.parseDecorator());
            o.push(this.parseAssignableListItem(i, u));
          }
        }
      return o;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      const e = this.startNode(), {
        type: t,
        start: r,
        startLoc: i
      } = this.state;
      return t === 21 ? this.parseBindingRestProperty(e) : (t === 134 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(this.state.value, i), e.key = this.parsePrivateName()) : this.parsePropertyName(e), e.method = false, this.parseObjPropValue(e, r, i, false, false, true, false), e);
    }
    parseAssignableListItem(e, t) {
      const r = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(r);
      const i = this.parseMaybeDefault(r.start, r.loc.start, r);
      return t.length && (r.decorators = t), i;
    }
    parseAssignableListItemTypes(e) {
      return e;
    }
    parseMaybeDefault(e, t, r) {
      var i, o, d;
      if (t = (i = t) != null ? i : this.state.startLoc, e = (o = e) != null ? o : this.state.start, r = (d = r) != null ? d : this.parseBindingAtom(), !this.eat(29))
        return r;
      const u = this.startNodeAt(e, t);
      return u.left = r, u.right = this.parseMaybeAssignAllowIn(), this.finishNode(u, "AssignmentPattern");
    }
    isValidLVal(e, t, r) {
      return vi({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    checkLVal(e, {
      in: t,
      binding: r = Pt,
      checkClashes: i = false,
      strictModeChanged: o = false,
      allowingSloppyLetBinding: d = !(r & pt),
      hasParenthesizedAncestor: u = false
    }) {
      var E;
      const w = e.type;
      if (this.isObjectMethod(e))
        return;
      if (w === "MemberExpression") {
        r !== Pt && this.raise(m.InvalidPropertyBindingPattern, {
          at: e
        });
        return;
      }
      if (e.type === "Identifier") {
        this.checkIdentifier(e, r, o, d);
        const {
          name: Oe
        } = e;
        i && (i.has(Oe) ? this.raise(m.ParamDupe, {
          at: e
        }) : i.add(Oe));
        return;
      }
      const U = this.isValidLVal(e.type, !(u || (E = e.extra) != null && E.parenthesized) && t.type === "AssignmentExpression", r);
      if (U === true)
        return;
      if (U === false) {
        const Oe = r === Pt ? m.InvalidLhs : m.InvalidLhsBinding;
        this.raise(Oe, {
          at: e,
          ancestor: t.type === "UpdateExpression" ? {
            type: "UpdateExpression",
            prefix: t.prefix
          } : {
            type: t.type
          }
        });
        return;
      }
      const [ge, ye] = Array.isArray(U) ? U : [U, w === "ParenthesizedExpression"], Ae = e.type === "ArrayPattern" || e.type === "ObjectPattern" || e.type === "ParenthesizedExpression" ? e : t;
      for (const Oe of [].concat(e[ge]))
        Oe && this.checkLVal(Oe, {
          in: Ae,
          binding: r,
          checkClashes: i,
          allowingSloppyLetBinding: d,
          strictModeChanged: o,
          hasParenthesizedAncestor: ye
        });
    }
    checkIdentifier(e, t, r = false, i = !(t & pt)) {
      this.state.strict && (r ? De(e.name, this.inModule) : qe(e.name)) && (t === Pt ? this.raise(m.StrictEvalArguments, {
        at: e,
        referenceName: e.name
      }) : this.raise(m.StrictEvalArgumentsBinding, {
        at: e,
        bindingName: e.name
      })), !i && e.name === "let" && this.raise(m.LetInLexicalBinding, {
        at: e
      }), t & Pt || this.declareNameFromIdentifier(e, t);
    }
    declareNameFromIdentifier(e, t) {
      this.scope.declareName(e.name, t, e.loc.start);
    }
    checkToRestConversion(e, t) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, t);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (t)
            break;
        default:
          this.raise(m.InvalidRestAssignmentPattern, {
            at: e
          });
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? m.RestTrailingComma : m.ElementAfterRest, {
        at: this.state.startLoc
      }), true) : false;
    }
  }
  class Ci extends Ai {
    checkProto(e, t, r, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      const o = e.key;
      if ((o.type === "Identifier" ? o.name : o.value) === "__proto__") {
        if (t) {
          this.raise(m.RecordNoProto, {
            at: o
          });
          return;
        }
        r.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = o.loc.start) : this.raise(m.DuplicateProto, {
          at: o
        })), r.used = true;
      }
    }
    shouldExitDescending(e, t) {
      return e.type === "ArrowFunctionExpression" && e.start === t;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e = this.parseExpression();
      return this.match(135) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.state.comments, e.errors = this.state.errors, this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, t) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
    }
    parseExpressionBase(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        const o = this.startNodeAt(t, r);
        for (o.expressions = [i]; this.eat(12); )
          o.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(o.expressions), this.finishNode(o, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, t) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
    }
    parseMaybeAssignAllowIn(e, t) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, t));
    }
    setOptionalParametersError(e, t) {
      var r;
      e.optionalParametersLoc = (r = t == null ? void 0 : t.loc) != null ? r : this.state.startLoc;
    }
    parseMaybeAssign(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      if (this.isContextual(105) && this.prodParam.hasYield) {
        let E = this.parseYield();
        return t && (E = t.call(this, E, r, i)), E;
      }
      let o;
      e ? o = false : (e = new Zt(), o = true);
      const {
        type: d
      } = this.state;
      (d === 10 || Te(d)) && (this.state.potentialArrowAt = this.state.start);
      let u = this.parseMaybeConditional(e);
      if (t && (u = t.call(this, u, r, i)), xe(this.state.type)) {
        const E = this.startNodeAt(r, i), w = this.state.value;
        return E.operator = w, this.match(29) ? (this.toAssignable(u, true), E.left = u, e.doubleProtoLoc != null && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), e.privateKeyLoc = null)) : E.left = u, this.next(), E.right = this.parseMaybeAssign(), this.checkLVal(u, {
          in: this.finishNode(E, "AssignmentExpression")
        }), E;
      } else
        o && this.checkExpressionErrors(e, true);
      return u;
    }
    parseMaybeConditional(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseExprOps(e);
      return this.shouldExitDescending(o, i) ? o : this.parseConditional(o, t, r, e);
    }
    parseConditional(e, t, r, i) {
      if (this.eat(17)) {
        const o = this.startNodeAt(t, r);
        return o.test = e, o.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), o.alternate = this.parseMaybeAssign(), this.finishNode(o, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(o, i) ? o : this.parseExprOp(o, t, r, -1);
    }
    parseExprOp(e, t, r, i) {
      if (this.isPrivateName(e)) {
        const d = this.getPrivateNameSV(e);
        (i >= Ge(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(m.PrivateInExpectedIn, {
          at: e,
          identifierName: d
        }), this.classScope.usePrivateName(d, e.loc.start);
      }
      const o = this.state.type;
      if (J(o) && (this.prodParam.hasIn || !this.match(58))) {
        let d = Ge(o);
        if (d > i) {
          if (o === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          const u = this.startNodeAt(t, r);
          u.left = e, u.operator = this.state.value;
          const E = o === 41 || o === 42, w = o === 40;
          if (w && (d = Ge(42)), this.next(), o === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(m.UnexpectedAwaitAfterPipelineBody, {
              at: this.state.startLoc
            });
          u.right = this.parseExprOpRightExpr(o, d), this.finishNode(u, E || w ? "LogicalExpression" : "BinaryExpression");
          const U = this.state.type;
          if (w && (U === 41 || U === 42) || E && U === 40)
            throw this.raise(m.MixingCoalesceWithLogical, {
              at: this.state.startLoc
            });
          return this.parseExprOp(u, t, r, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(105))
                  throw this.raise(m.PipeBodyIsTighter, {
                    at: this.state.startLoc
                  });
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r, i);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, t);
      }
    }
    parseExprOpBaseRightExpr(e, t) {
      const r = this.state.start, i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, i, lt(e) ? t - 1 : t);
    }
    parseHackPipeBody() {
      var e;
      const {
        startLoc: t
      } = this.state, r = this.parseMaybeAssign();
      return T.has(r.type) && !((e = r.extra) != null && e.parenthesized) && this.raise(m.PipeUnparenthesizedBody, {
        at: t,
        type: r.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(m.PipeTopicUnused, {
        at: t
      }), r;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(m.UnexpectedTokenUnaryExponentiation, {
        at: e.argument
      });
    }
    parseMaybeUnary(e, t) {
      const r = this.state.start, i = this.state.startLoc, o = this.isContextual(96);
      if (o && this.isAwaitAllowed()) {
        this.next();
        const w = this.parseAwait(r, i);
        return t || this.checkExponentialAfterUnary(w), w;
      }
      const d = this.match(34), u = this.startNode();
      if (ke(this.state.type)) {
        u.operator = this.state.value, u.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        const w = this.match(89);
        if (this.next(), u.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e, true), this.state.strict && w) {
          const U = u.argument;
          U.type === "Identifier" ? this.raise(m.StrictDelete, {
            at: u
          }) : this.hasPropertyAsPrivateName(U) && this.raise(m.DeletePrivateField, {
            at: u
          });
        }
        if (!d)
          return t || this.checkExponentialAfterUnary(u), this.finishNode(u, "UnaryExpression");
      }
      const E = this.parseUpdate(u, d, e);
      if (o) {
        const {
          type: w
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? ce(w) : ce(w) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(m.AwaitNotInAsyncContext, {
            at: i
          }), this.parseAwait(r, i);
      }
      return E;
    }
    parseUpdate(e, t, r) {
      if (t)
        return this.checkLVal(e.argument, {
          in: this.finishNode(e, "UpdateExpression")
        }), e;
      const i = this.state.start, o = this.state.startLoc;
      let d = this.parseExprSubscripts(r);
      if (this.checkExpressionErrors(r, false))
        return d;
      for (; me(this.state.type) && !this.canInsertSemicolon(); ) {
        const u = this.startNodeAt(i, o);
        u.operator = this.state.value, u.prefix = false, u.argument = d, this.next(), this.checkLVal(d, {
          in: d = this.finishNode(u, "UpdateExpression")
        });
      }
      return d;
    }
    parseExprSubscripts(e) {
      const t = this.state.start, r = this.state.startLoc, i = this.state.potentialArrowAt, o = this.parseExprAtom(e);
      return this.shouldExitDescending(o, i) ? o : this.parseSubscripts(o, t, r);
    }
    parseSubscripts(e, t, r, i) {
      const o = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: false
      };
      do
        e = this.parseSubscript(e, t, r, i, o), o.maybeAsyncArrow = false;
      while (!o.stop);
      return e;
    }
    parseSubscript(e, t, r, i, o) {
      const {
        type: d
      } = this.state;
      if (!i && d === 15)
        return this.parseBind(e, t, r, i, o);
      if (Ze(d))
        return this.parseTaggedTemplateExpression(e, t, r, o);
      let u = false;
      if (d === 18) {
        if (i && this.lookaheadCharCode() === 40)
          return o.stop = true, e;
        o.optionalChainMember = u = true, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, t, r, o, u);
      {
        const E = this.eat(0);
        return E || u || this.eat(16) ? this.parseMember(e, t, r, o, E, u) : (o.stop = true, e);
      }
    }
    parseMember(e, t, r, i, o, d) {
      const u = this.startNodeAt(t, r);
      return u.object = e, u.computed = o, o ? (u.property = this.parseExpression(), this.expect(3)) : this.match(134) ? (e.type === "Super" && this.raise(m.SuperPrivateField, {
        at: r
      }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), u.property = this.parsePrivateName()) : u.property = this.parseIdentifier(true), i.optionalChainMember ? (u.optional = d, this.finishNode(u, "OptionalMemberExpression")) : this.finishNode(u, "MemberExpression");
    }
    parseBind(e, t, r, i, o) {
      const d = this.startNodeAt(t, r);
      return d.object = e, this.next(), d.callee = this.parseNoCallExpr(), o.stop = true, this.parseSubscripts(this.finishNode(d, "BindExpression"), t, r, i);
    }
    parseCoverCallAndAsyncArrowHead(e, t, r, i, o) {
      const d = this.state.maybeInArrowParameters;
      let u = null;
      this.state.maybeInArrowParameters = true, this.next();
      let E = this.startNodeAt(t, r);
      E.callee = e;
      const {
        maybeAsyncArrow: w,
        optionalChainMember: U
      } = i;
      return w && (this.expressionScope.enter(Ys()), u = new Zt()), U && (E.optional = o), o ? E.arguments = this.parseCallExpressionArguments(11) : E.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", E, u), this.finishCallExpression(E, U), w && this.shouldParseAsyncArrow() && !o ? (i.stop = true, this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), E = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t, r), E)) : (w && (this.checkExpressionErrors(u, true), this.expressionScope.exit()), this.toReferencedArguments(E)), this.state.maybeInArrowParameters = d, E;
    }
    toReferencedArguments(e, t) {
      this.toReferencedListDeep(e.arguments, t);
    }
    parseTaggedTemplateExpression(e, t, r, i) {
      const o = this.startNodeAt(t, r);
      return o.tag = e, o.quasi = this.parseTemplate(true), i.optionalChainMember && this.raise(m.OptionalChainingNoTemplate, {
        at: r
      }), this.finishNode(o, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    finishCallExpression(e, t) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(m.ImportCallArity, {
            at: e,
            maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        else
          for (const r of e.arguments)
            r.type === "SpreadElement" && this.raise(m.ImportCallSpreadArgument, {
              at: r
            });
      return this.finishNode(e, t ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, t, r, i, o) {
      const d = [];
      let u = true;
      const E = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e); ) {
        if (u)
          u = false;
        else if (this.expect(12), this.match(e)) {
          t && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(m.ImportCallArgumentTrailingComma, {
            at: this.state.lastTokStartLoc
          }), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        d.push(this.parseExprListItem(false, o, r));
      }
      return this.state.inFSharpPipelineDirectBody = E, d;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, t) {
      var r;
      return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, true, (r = t.extra) == null ? void 0 : r.trailingCommaLoc), t.innerComments && Bt(e, t.innerComments), t.callee.trailingComments && Bt(e, t.callee.trailingComments), e;
    }
    parseNoCallExpr() {
      const e = this.state.start, t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, t, true);
    }
    parseExprAtom(e) {
      let t;
      const {
        type: r
      } = this.state;
      switch (r) {
        case 79:
          return this.parseSuper();
        case 83:
          return t = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : (this.match(10) || this.raise(m.UnsupportedImport, {
            at: this.state.lastTokStartLoc
          }), this.finishNode(t, "Import"));
        case 78:
          return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 130:
          return this.parseNumericLiteral(this.state.value);
        case 131:
          return this.parseBigIntLiteral(this.state.value);
        case 132:
          return this.parseDecimalLiteral(this.state.value);
        case 129:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const i = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(i);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          this.parseDecorators();
        case 80:
          return t = this.startNode(), this.takeDecorators(t), this.parseClass(t, false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          t = this.startNode(), this.next(), t.object = null;
          const i = t.callee = this.parseNoCallExpr();
          if (i.type === "MemberExpression")
            return this.finishNode(t, "BindExpression");
          throw this.raise(m.UnsupportedBind, {
            at: i
          });
        }
        case 134:
          return this.raise(m.PrivateInExpectedIn, {
            at: this.state.startLoc,
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const i = this.getPluginOption("pipelineOperator", "proposal");
          if (i)
            return this.parseTopicReference(i);
          throw this.unexpected();
        }
        case 47: {
          const i = this.input.codePointAt(this.nextTokenStart());
          if (Ne(i) || i === 62) {
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
            break;
          } else
            throw this.unexpected();
        }
        default:
          if (Te(r)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression();
            const i = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, d = this.parseIdentifier();
            if (!o && d.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(d), this.next(), this.parseFunction(this.startNodeAtNode(d), void 0, true);
              if (Te(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(d)) : d;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(d), this.parseDo(this.startNodeAtNode(d), true);
            }
            return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(d), [d], false)) : d;
          } else
            throw this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, t) {
      const r = this.getPluginOption("pipelineOperator", "proposal");
      if (r)
        return this.state.type = e, this.state.value = t, this.state.pos--, this.state.end--, this.state.endLoc = f2(this.state.endLoc, -1), this.parseTopicReference(r);
      throw this.unexpected();
    }
    parseTopicReference(e) {
      const t = this.startNode(), r = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(t, r, e, i);
    }
    finishTopicReference(e, t, r, i) {
      if (this.testTopicReferenceConfiguration(r, t, i)) {
        const o = r === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(r === "smart" ? m.PrimaryTopicNotAllowed : m.PipeTopicUnbound, {
          at: t
        }), this.registerTopicReference(), this.finishNode(e, o);
      } else
        throw this.raise(m.PipeTopicUnconfiguredToken, {
          at: t,
          token: $e(i)
        });
    }
    testTopicReferenceConfiguration(e, t, r) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: $e(r)
          }]);
        case "smart":
          return r === 27;
        default:
          throw this.raise(m.PipeTopicRequiresHackPipes, {
            at: t
          });
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Qt(true, this.prodParam.hasYield));
      const t = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(m.LineTerminatorBeforeArrow, {
        at: this.state.curPosition()
      }), this.expect(19), this.parseArrowExpression(e, t, true), e;
    }
    parseDo(e, t) {
      this.expectPlugin("doExpressions"), t && this.expectPlugin("asyncDoExpressions"), e.async = t, this.next();
      const r = this.state.labels;
      return this.state.labels = [], t ? (this.prodParam.enter(Yt), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(), this.state.labels = r, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      const e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(m.SuperNotAllowed, {
        at: e
      }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(m.UnexpectedSuper, {
        at: e
      }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(m.UnsupportedSuper, {
        at: e
      }), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      const e = this.startNode(), t = this.startNodeAt(this.state.start + 1, new n(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), r = this.state.value;
      return this.next(), e.id = this.createIdentifier(t, r), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const t = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e, t, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, t, r) {
      e.meta = t;
      const i = this.state.containsEsc;
      return e.property = this.parseIdentifier(true), (e.property.name !== r || i) && this.raise(m.UnsupportedMetaProperty, {
        at: e.property,
        target: t.name,
        onlyValidPropertyName: r
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      const t = this.createIdentifier(this.startNodeAtNode(e), "import");
      return this.next(), this.isContextual(100) && (this.inModule || this.raise(m.ImportMetaOutsideModule, {
        at: t
      }), this.sawUnambiguousESM = true), this.parseMetaProperty(e, t, "meta");
    }
    parseLiteralAtNode(e, t, r) {
      return this.addExtra(r, "rawValue", e), this.addExtra(r, "raw", this.input.slice(r.start, this.state.end)), r.value = e, this.next(), this.finishNode(r, t);
    }
    parseLiteral(e, t) {
      const r = this.startNode();
      return this.parseLiteralAtNode(e, t, r);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      const t = this.parseLiteral(e.value, "RegExpLiteral");
      return t.pattern = e.pattern, t.flags = e.flags, t;
    }
    parseBooleanLiteral(e) {
      const t = this.startNode();
      return t.value = e, this.next(), this.finishNode(t, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      const t = this.state.start, r = this.state.startLoc;
      let i;
      this.next(), this.expressionScope.enter(Js());
      const o = this.state.maybeInArrowParameters, d = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const u = this.state.start, E = this.state.startLoc, w = [], U = new Zt();
      let ge = true, ye, Ae;
      for (; !this.match(11); ) {
        if (ge)
          ge = false;
        else if (this.expect(12, U.optionalParametersLoc === null ? null : U.optionalParametersLoc), this.match(11)) {
          Ae = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const Ke = this.state.start, He = this.state.startLoc;
          if (ye = this.state.startLoc, w.push(this.parseParenItem(this.parseRestBinding(), Ke, He)), !this.checkCommaAfterRest(41))
            break;
        } else
          w.push(this.parseMaybeAssignAllowIn(U, this.parseParenItem));
      }
      const Oe = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = o, this.state.inFSharpPipelineDirectBody = d;
      let Ve = this.startNodeAt(t, r);
      return e && this.shouldParseArrow(w) && (Ve = this.parseArrow(Ve)) ? (this.checkDestructuringPrivate(U), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(Ve, w, false), Ve) : (this.expressionScope.exit(), w.length || this.unexpected(this.state.lastTokStartLoc), Ae && this.unexpected(Ae), ye && this.unexpected(ye), this.checkExpressionErrors(U, true), this.toReferencedListDeep(w, true), w.length > 1 ? (i = this.startNodeAt(u, E), i.expressions = w, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, Oe)) : i = w[0], this.wrapParenthesis(t, r, i));
    }
    wrapParenthesis(e, t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", true), this.addExtra(r, "parenStart", e), this.takeSurroundingComments(r, e, this.state.lastTokEndLoc.index), r;
      const i = this.startNodeAt(e, t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression"), i;
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, t, r) {
      return e;
    }
    parseNewOrNewTarget() {
      const e = this.startNode();
      if (this.next(), this.match(16)) {
        const t = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        const r = this.parseMetaProperty(e, t, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(m.UnexpectedNewTarget, {
          at: r
        }), r;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        const t = this.parseExprList(11);
        this.toReferencedList(t), e.arguments = t;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      e.callee = this.parseNoCallExpr(), e.callee.type === "Import" ? this.raise(m.ImportCallNotNewExpression, {
        at: e.callee
      }) : this.isOptionalChain(e.callee) ? this.raise(m.OptionalChainingNoNew, {
        at: this.state.lastTokEndLoc
      }) : this.eat(18) && this.raise(m.OptionalChainingNoNew, {
        at: this.state.startLoc
      });
    }
    parseTemplateElement(e) {
      const {
        start: t,
        startLoc: r,
        end: i,
        value: o
      } = this.state, d = t + 1, u = this.startNodeAt(d, f2(r, 1));
      o === null && (e || this.raise(m.InvalidEscapeSequenceTemplate, {
        at: f2(r, 2)
      }));
      const E = this.match(24), w = E ? -1 : -2, U = i + w;
      return u.value = {
        raw: this.input.slice(d, U).replace(/\r\n?/g, `
`),
        cooked: o === null ? null : o.slice(1, w)
      }, u.tail = E, this.next(), this.finishNode(u, "TemplateElement"), this.resetEndLocation(u, f2(this.state.lastTokEndLoc, w)), u;
    }
    parseTemplate(e) {
      const t = this.startNode();
      t.expressions = [];
      let r = this.parseTemplateElement(e);
      for (t.quasis = [r]; !r.tail; )
        t.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t.quasis.push(r = this.parseTemplateElement(e));
      return this.finishNode(t, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const d = /* @__PURE__ */ Object.create(null);
      let u = true;
      const E = this.startNode();
      for (E.properties = [], this.next(); !this.match(e); ) {
        if (u)
          u = false;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(E);
          break;
        }
        let U;
        t ? U = this.parseBindingProperty() : (U = this.parsePropertyDefinition(i), this.checkProto(U, r, d, i)), r && !this.isObjectProperty(U) && U.type !== "SpreadElement" && this.raise(m.InvalidRecordProperty, {
          at: U
        }), U.shorthand && this.addExtra(U, "shorthand", true), E.properties.push(U);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = o;
      let w = "ObjectExpression";
      return t ? w = "ObjectPattern" : r && (w = "RecordExpression"), this.finishNode(E, w);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStart), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let t = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(m.UnsupportedPropertyDecorator, {
          at: this.state.startLoc
        }); this.match(26); )
          t.push(this.parseDecorator());
      const r = this.startNode();
      let i = false, o = false, d, u;
      if (this.match(21))
        return t.length && this.unexpected(), this.parseSpread();
      t.length && (r.decorators = t, t = []), r.method = false, e && (d = this.state.start, u = this.state.startLoc);
      let E = this.eat(55);
      this.parsePropertyNamePrefixOperator(r);
      const w = this.state.containsEsc, U = this.parsePropertyName(r, e);
      if (!E && !w && this.maybeAsyncOrAccessorProp(r)) {
        const ge = U.name;
        ge === "async" && !this.hasPrecedingLineBreak() && (i = true, this.resetPreviousNodeTrailingComments(U), E = this.eat(55), this.parsePropertyName(r)), (ge === "get" || ge === "set") && (o = true, this.resetPreviousNodeTrailingComments(U), r.kind = ge, this.match(55) && (E = true, this.raise(m.AccessorIsGenerator, {
          at: this.state.curPosition(),
          kind: ge
        }), this.next()), this.parsePropertyName(r));
      }
      return this.parseObjPropValue(r, d, u, E, i, false, o, e), r;
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var t;
      const r = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== r && this.raise(e.kind === "get" ? m.BadGetterArity : m.BadSetterArity, {
        at: e
      }), e.kind === "set" && ((t = i[i.length - 1]) == null ? void 0 : t.type) === "RestElement" && this.raise(m.BadSetterRestParameter, {
        at: e
      });
    }
    parseObjectMethod(e, t, r, i, o) {
      if (o)
        return this.parseMethod(e, t, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e), e;
      if (r || t || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = true, this.parseMethod(e, t, r, false, false, "ObjectMethod");
    }
    parseObjectProperty(e, t, r, i, o) {
      if (e.shorthand = false, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(o), this.finishNode(e, "ObjectProperty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, true, false), i)
          e.value = this.parseMaybeDefault(t, r, at(e.key));
        else if (this.match(29)) {
          const d = this.state.startLoc;
          o != null ? o.shorthandAssignLoc === null && (o.shorthandAssignLoc = d) : this.raise(m.InvalidCoverInitializedName, {
            at: d
          }), e.value = this.parseMaybeDefault(t, r, at(e.key));
        } else
          e.value = at(e.key);
        return e.shorthand = true, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, t, r, i, o, d, u, E) {
      const w = this.parseObjectMethod(e, i, o, d, u) || this.parseObjectProperty(e, t, r, d, E);
      return w || this.unexpected(), w;
    }
    parsePropertyName(e, t) {
      if (this.eat(0))
        e.computed = true, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: r,
          value: i
        } = this.state;
        let o;
        if (z(r))
          o = this.parseIdentifier(true);
        else
          switch (r) {
            case 130:
              o = this.parseNumericLiteral(i);
              break;
            case 129:
              o = this.parseStringLiteral(i);
              break;
            case 131:
              o = this.parseBigIntLiteral(i);
              break;
            case 132:
              o = this.parseDecimalLiteral(i);
              break;
            case 134: {
              const d = this.state.startLoc;
              t != null ? t.privateKeyLoc === null && (t.privateKeyLoc = d) : this.raise(m.UnexpectedPrivateField, {
                at: d
              }), o = this.parsePrivateName();
              break;
            }
            default:
              throw this.unexpected();
          }
        e.key = o, r !== 134 && (e.computed = false);
      }
      return e.key;
    }
    initFunction(e, t) {
      e.id = null, e.generator = false, e.async = !!t;
    }
    parseMethod(e, t, r, i, o, d, u = false) {
      this.initFunction(e, r), e.generator = !!t;
      const E = i;
      return this.scope.enter(Ye | $t | (u ? xt : 0) | (o ? Mr : 0)), this.prodParam.enter(Qt(r, e.generator)), this.parseFunctionParams(e, E), this.parseFunctionBodyAndFinish(e, d, true), this.prodParam.exit(), this.scope.exit(), e;
    }
    parseArrayLike(e, t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      const o = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const d = this.startNode();
      return this.next(), d.elements = this.parseExprList(e, !r, i, d), this.state.inFSharpPipelineDirectBody = o, this.finishNode(d, r ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, t, r, i) {
      this.scope.enter(Ye | bt);
      let o = Qt(r, false);
      !this.match(5) && this.prodParam.hasIn && (o |= Nt), this.prodParam.enter(o), this.initFunction(e, r);
      const d = this.state.maybeInArrowParameters;
      return t && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e, t, i)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = d, this.finishNode(e, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e, t, r) {
      this.toAssignableList(t, r, false), e.params = t;
    }
    parseFunctionBodyAndFinish(e, t, r = false) {
      this.parseFunctionBody(e, false, r), this.finishNode(e, t);
    }
    parseFunctionBody(e, t, r = false) {
      const i = t && !this.match(5);
      if (this.expressionScope.enter(zr()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, false, t, false);
      else {
        const o = this.state.strict, d = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Xr), e.body = this.parseBlock(true, false, (u) => {
          const E = !this.isSimpleParamList(e.params);
          u && E && this.raise(m.IllegalLanguageModeDirective, {
            at: (e.kind === "method" || e.kind === "constructor") && !!e.key ? e.key.loc.end : e
          });
          const w = !o && this.state.strict;
          this.checkParams(e, !this.state.strict && !t && !r && !E, t, w), this.state.strict && e.id && this.checkIdentifier(e.id, As, w);
        }), this.prodParam.exit(), this.state.labels = d;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let t = 0, r = e.length; t < r; t++)
        if (!this.isSimpleParameter(e[t]))
          return false;
      return true;
    }
    checkParams(e, t, r, i = true) {
      const o = !t && /* @__PURE__ */ new Set(), d = {
        type: "FormalParameters"
      };
      for (const u of e.params)
        this.checkLVal(u, {
          in: d,
          binding: Ht,
          checkClashes: o,
          strictModeChanged: i
        });
    }
    parseExprList(e, t, r, i) {
      const o = [];
      let d = true;
      for (; !this.eat(e); ) {
        if (d)
          d = false;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(t, r));
      }
      return o;
    }
    parseExprListItem(e, t, r) {
      let i;
      if (this.match(12))
        e || this.raise(m.UnexpectedToken, {
          at: this.state.curPosition(),
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        const o = this.state.start, d = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(t), o, d);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), r || this.raise(m.UnexpectedArgumentPlaceholder, {
          at: this.state.startLoc
        });
        const o = this.startNode();
        this.next(), i = this.finishNode(o, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      const t = this.startNode(), r = this.parseIdentifierName(t.start, e);
      return this.createIdentifier(t, r);
    }
    createIdentifier(e, t) {
      return e.name = t, e.loc.identifierName = t, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e, t) {
      let r;
      const {
        startLoc: i,
        type: o
      } = this.state;
      if (z(o))
        r = this.state.value;
      else
        throw this.unexpected();
      const d = pe(o);
      return t ? d && this.replaceToken(128) : this.checkReservedWord(r, i, d, false), this.next(), r;
    }
    checkReservedWord(e, t, r, i) {
      if (e.length > 10 || !Nr(e))
        return;
      if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(m.YieldBindingIdentifier, {
            at: t
          });
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(m.AwaitBindingIdentifier, {
            at: t
          });
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(m.AwaitBindingIdentifierInStaticBlock, {
            at: t
          });
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError({
          at: t
        });
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(m.ArgumentsInClass, {
          at: t
        });
        return;
      }
      if (r && Tt(e)) {
        this.raise(m.UnexpectedKeyword, {
          at: t,
          keyword: e
        });
        return;
      }
      (this.state.strict ? i ? De : ut : gt)(e, this.inModule) && this.raise(m.UnexpectedReservedWord, {
        at: t,
        reservedWord: e
      });
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e, t) {
      const r = this.startNodeAt(e, t);
      return this.expressionScope.recordParameterInitializerError(m.AwaitExpressionFormalParameter, {
        at: r
      }), this.eat(55) && this.raise(m.ObsoleteAwaitStar, {
        at: r
      }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, true)), this.finishNode(r, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      const {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Ze(e) || e === 133 || e === 56 || this.hasPlugin("v8intrinsic") && e === 54;
    }
    parseYield() {
      const e = this.startNode();
      this.expressionScope.recordParameterInitializerError(m.YieldInParameter, {
        at: e
      }), this.next();
      let t = false, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (t = this.eat(55), this.state.type) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!t)
              break;
          default:
            r = this.parseMaybeAssign();
        }
      return e.delegate = t, e.argument = r, this.finishNode(e, "YieldExpression");
    }
    checkPipelineAtInfixOperator(e, t) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(m.PipelineHeadSequenceExpression, {
        at: t
      });
    }
    parseSmartPipelineBodyInStyle(e, t, r) {
      const i = this.startNodeAt(t, r);
      return this.isSimpleReference(e) ? (i.callee = e, this.finishNode(i, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = e, this.finishNode(i, "PipelineTopicExpression"));
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(m.PipelineBodyNoArrow, {
          at: this.state.startLoc
        });
      this.topicReferenceWasUsedInCurrentContext() || this.raise(m.PipelineTopicUnused, {
        at: e
      });
    }
    withTopicBindingContext(e) {
      const t = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = t;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const t = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = t;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      const t = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e();
      } finally {
        this.state.soloAwait = t;
      }
    }
    allowInAnd(e) {
      const t = this.prodParam.currentFlags();
      if (Nt & ~t) {
        this.prodParam.enter(t | Nt);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      const t = this.prodParam.currentFlags();
      if (Nt & t) {
        this.prodParam.enter(t & ~Nt);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      const t = this.state.start, r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const o = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, r, e);
      return this.state.inFSharpPipelineDirectBody = i, o;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e = this.startNode();
      this.next(), this.eat(5);
      const t = this.initializeScopes(true);
      this.enterInitialScopes();
      const r = this.startNode();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        t();
      }
      return this.eat(8), this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }
  const vr = {
    kind: "loop"
  }, wi = {
    kind: "switch"
  }, Ii = 0, Ar = 1, os = 2, ls = 4, Ni = /[\uD800-\uDFFF]/u, Cr = /in(?:stanceof)?/y;
  function ki(a, e) {
    for (let t = 0; t < a.length; t++) {
      const r = a[t], {
        type: i
      } = r;
      if (typeof i == "number") {
        {
          if (i === 134) {
            const {
              loc: o,
              start: d,
              value: u,
              end: E
            } = r, w = d + 1, U = f2(o.start, 1);
            a.splice(t, 1, new ft({
              type: Xe(27),
              value: "#",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            }), new ft({
              type: Xe(128),
              value: u,
              start: w,
              end: E,
              startLoc: U,
              endLoc: o.end
            })), t++;
            continue;
          }
          if (Ze(i)) {
            const {
              loc: o,
              start: d,
              value: u,
              end: E
            } = r, w = d + 1, U = f2(o.start, 1);
            let ge;
            e.charCodeAt(d) === 96 ? ge = new ft({
              type: Xe(22),
              value: "`",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            }) : ge = new ft({
              type: Xe(8),
              value: "}",
              start: d,
              end: w,
              startLoc: o.start,
              endLoc: U
            });
            let ye, Ae, Oe, Ve;
            i === 24 ? (Ae = E - 1, Oe = f2(o.end, -1), ye = u === null ? null : u.slice(1, -1), Ve = new ft({
              type: Xe(22),
              value: "`",
              start: Ae,
              end: E,
              startLoc: Oe,
              endLoc: o.end
            })) : (Ae = E - 2, Oe = f2(o.end, -2), ye = u === null ? null : u.slice(1, -2), Ve = new ft({
              type: Xe(23),
              value: "${",
              start: Ae,
              end: E,
              startLoc: Oe,
              endLoc: o.end
            })), a.splice(t, 1, ge, new ft({
              type: Xe(20),
              value: ye,
              start: w,
              end: Ae,
              startLoc: U,
              endLoc: Oe
            }), Ve), t += 2;
            continue;
          }
        }
        r.type = Xe(i);
      }
    }
    return a;
  }
  class Oi extends Ci {
    parseTopLevel(e, t) {
      return e.program = this.parseProgram(t), e.comments = this.state.comments, this.options.tokens && (e.tokens = ki(this.tokens, this.input)), this.finishNode(e, "File");
    }
    parseProgram(e, t = 135, r = this.options.sourceType) {
      if (e.sourceType = r, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, true, true, t), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (const [i, o] of Array.from(this.scope.undefinedExports))
          this.raise(m.ModuleExportUndefined, {
            at: o,
            localName: i
          });
      return this.finishNode(e, "Program");
    }
    stmtToDirective(e) {
      const t = e;
      t.type = "Directive", t.value = t.expression, delete t.expression;
      const r = t.value, i = r.value, o = this.input.slice(r.start, r.end), d = r.value = o.slice(1, -1);
      return this.addExtra(r, "raw", o), this.addExtra(r, "rawValue", d), this.addExtra(r, "expressionValue", i), r.type = "DirectiveLiteral", t;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet(e) {
      return this.isContextual(99) ? this.isLetKeyword(e) : false;
    }
    isLetKeyword(e) {
      const t = this.nextTokenStart(), r = this.codePointAtPos(t);
      if (r === 92 || r === 91)
        return true;
      if (e)
        return false;
      if (r === 123)
        return true;
      if (Ne(r)) {
        if (Cr.lastIndex = t, Cr.test(this.input)) {
          const i = this.codePointAtPos(Cr.lastIndex);
          if (!Be(i) && i !== 92)
            return false;
        }
        return true;
      }
      return false;
    }
    parseStatement(e, t) {
      return this.match(26) && this.parseDecorators(true), this.parseStatementContent(e, t);
    }
    parseStatementContent(e, t) {
      let r = this.state.type;
      const i = this.startNode();
      let o;
      switch (this.isLet(e) && (r = 74, o = "let"), r) {
        case 60:
          return this.parseBreakContinueStatement(i, true);
        case 63:
          return this.parseBreakContinueStatement(i, false);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return e && (this.state.strict ? this.raise(m.StrictFunction, {
            at: this.state.startLoc
          }) : e !== "if" && e !== "label" && this.raise(m.SloppyFunction, {
            at: this.state.startLoc
          })), this.parseFunctionStatement(i, false, !e);
        case 80:
          return e && this.unexpected(), this.parseClass(i, true);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 75:
        case 74:
          return o = o || this.state.value, e && o !== "var" && this.raise(m.UnexpectedLexicalDeclaration, {
            at: this.state.startLoc
          }), this.parseVarStatement(i, o);
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          const E = this.lookaheadCharCode();
          if (E === 40 || E === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !t && this.raise(m.UnexpectedImportExport, {
            at: this.state.startLoc
          }), this.next();
          let E;
          return r === 83 ? (E = this.parseImport(i), E.type === "ImportDeclaration" && (!E.importKind || E.importKind === "value") && (this.sawUnambiguousESM = true)) : (E = this.parseExport(i), (E.type === "ExportNamedDeclaration" && (!E.exportKind || E.exportKind === "value") || E.type === "ExportAllDeclaration" && (!E.exportKind || E.exportKind === "value") || E.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(i), E;
        }
        default:
          if (this.isAsyncFunction())
            return e && this.raise(m.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc
            }), this.next(), this.parseFunctionStatement(i, true, !e);
      }
      const d = this.state.value, u = this.parseExpression();
      return Te(r) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, d, u, e) : this.parseExpressionStatement(i, u);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(m.ImportOutsideModule, {
        at: e
      });
    }
    takeDecorators(e) {
      const t = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      t.length && (e.decorators = t, this.resetStartLocationFromNode(e, t[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      const t = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (; this.match(26); ) {
        const r = this.parseDecorator();
        t.push(r);
      }
      if (this.match(82))
        e || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(m.DecoratorExportClass, {
          at: this.state.startLoc
        });
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(m.UnexpectedLeadingDecorator, {
          at: this.state.startLoc
        });
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const t = this.state.start, r = this.state.startLoc;
        let i;
        if (this.match(10)) {
          const o = this.state.start, d = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(o, d, i);
        } else
          for (i = this.parseIdentifier(false); this.eat(16); ) {
            const o = this.startNodeAt(t, r);
            o.object = i, o.property = this.parseIdentifier(true), o.computed = false, i = this.finishNode(o, "MemberExpression");
          }
        e.expression = this.parseMaybeDecoratorArguments(i), this.state.decoratorStack.pop();
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        const t = this.startNodeAtNode(e);
        return t.callee = e, t.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(t.arguments), this.finishNode(t, "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, t) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, t) {
      let r;
      for (r = 0; r < this.state.labels.length; ++r) {
        const i = this.state.labels[r];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (t || i.kind === "loop") || e.label && t))
          break;
      }
      if (r === this.state.labels.length) {
        const i = t ? "BreakStatement" : "ContinueStatement";
        this.raise(m.IllegalBreakContinue, {
          at: e,
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoStatement(e) {
      return this.next(), this.state.labels.push(vr), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(vr);
      let t = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (t = this.state.lastTokStartLoc), this.scope.enter(At), this.expect(10), this.match(13))
        return t !== null && this.unexpected(t), this.parseFor(e, null);
      const r = this.isContextual(99), i = r && this.isLetKeyword();
      if (this.match(74) || this.match(75) || i) {
        const w = this.startNode(), U = i ? "let" : this.state.value;
        return this.next(), this.parseVar(w, true, U), this.finishNode(w, "VariableDeclaration"), (this.match(58) || this.isContextual(101)) && w.declarations.length === 1 ? this.parseForIn(e, w, t) : (t !== null && this.unexpected(t), this.parseFor(e, w));
      }
      const o = this.isContextual(95), d = new Zt(), u = this.parseExpression(true, d), E = this.isContextual(101);
      if (E && (r && this.raise(m.ForOfLet, {
        at: u
      }), t === null && o && u.type === "Identifier" && this.raise(m.ForOfAsync, {
        at: u
      })), E || this.match(58)) {
        this.checkDestructuringPrivate(d), this.toAssignable(u, true);
        const w = E ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(u, {
          in: {
            type: w
          }
        }), this.parseForIn(e, u, t);
      } else
        this.checkExpressionErrors(d, true);
      return t !== null && this.unexpected(t), this.parseFor(e, u);
    }
    parseFunctionStatement(e, t, r) {
      return this.next(), this.parseFunction(e, Ar | (r ? 0 : os), t);
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(m.IllegalReturn, {
        at: this.state.startLoc
      }), this.next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      const t = e.cases = [];
      this.expect(5), this.state.labels.push(wi), this.scope.enter(At);
      let r;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const o = this.match(61);
          r && this.finishNode(r, "SwitchCase"), t.push(r = this.startNode()), r.consequent = [], this.next(), o ? r.test = this.parseExpression() : (i && this.raise(m.MultipleDefaultsInSwitch, {
            at: this.state.lastTokStartLoc
          }), i = true, r.test = null), this.expect(14);
        } else
          r ? r.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), r && this.finishNode(r, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchStatement");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(m.NewlineAfterThrow, {
        at: this.state.lastTokEndLoc
      }), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e = this.parseBindingAtom(), t = e.type === "Identifier";
      return this.scope.enter(t ? ct : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: nt,
        allowingSloppyLetBinding: true
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        const t = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), t.param = this.parseCatchClauseParam(), this.expect(11)) : (t.param = null, this.scope.enter(At)), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e.handler = this.finishNode(t, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(m.NoCatchOrFinally, {
        at: e
      }), this.finishNode(e, "TryStatement");
    }
    parseVarStatement(e, t, r = false) {
      return this.next(), this.parseVar(e, false, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(vr), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(m.StrictWith, {
        at: this.state.startLoc
      }), this.next(), e.object = this.parseHeaderExpression(), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, t, r, i) {
      for (const d of this.state.labels)
        d.name === t && this.raise(m.LabelRedeclaration, {
          at: r,
          labelName: t
        });
      const o = Le(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
      for (let d = this.state.labels.length - 1; d >= 0; d--) {
        const u = this.state.labels[d];
        if (u.statementStart === e.start)
          u.statementStart = this.state.start, u.kind = o;
        else
          break;
      }
      return this.state.labels.push({
        name: t,
        kind: o,
        statementStart: this.state.start
      }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i + "label" : i : "label"), this.state.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, t) {
      return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = false, t = true, r) {
      const i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(At), this.parseBlockBody(i, e, false, 8, r), t && this.scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, t, r, i, o) {
      const d = e.body = [], u = e.directives = [];
      this.parseBlockOrModuleBlockBody(d, t ? u : void 0, r, i, o);
    }
    parseBlockOrModuleBlockBody(e, t, r, i, o) {
      const d = this.state.strict;
      let u = false, E = false;
      for (; !this.match(i); ) {
        const w = this.parseStatement(null, r);
        if (t && !E) {
          if (this.isValidDirective(w)) {
            const U = this.stmtToDirective(w);
            t.push(U), !u && U.value.value === "use strict" && (u = true, this.setStrict(true));
            continue;
          }
          E = true, this.state.strictErrors.clear();
        }
        e.push(w);
      }
      o && o.call(this, u), d || this.setStrict(false), this.next();
    }
    parseFor(e, t) {
      return e.init = t, this.semicolon(false), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, t, r) {
      const i = this.match(58);
      return this.next(), i ? r !== null && this.unexpected(r) : e.await = r !== null, t.type === "VariableDeclaration" && t.declarations[0].init != null && (!i || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(m.ForInOfLoopInitializer, {
        at: t,
        type: i ? "ForInStatement" : "ForOfStatement"
      }), t.type === "AssignmentPattern" && this.raise(m.InvalidLhs, {
        at: t,
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = t, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, t, r, i = false) {
      const o = e.declarations = [];
      for (e.kind = r; ; ) {
        const d = this.startNode();
        if (this.parseVarId(d, r), d.init = this.eat(29) ? t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, d.init === null && !i && (d.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(101))) ? this.raise(m.DeclarationMissingInitializer, {
          at: this.state.lastTokEndLoc,
          kind: "destructuring"
        }) : r === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(m.DeclarationMissingInitializer, {
          at: this.state.lastTokEndLoc,
          kind: "const"
        })), o.push(this.finishNode(d, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return e;
    }
    parseVarId(e, t) {
      e.id = this.parseBindingAtom(), this.checkLVal(e.id, {
        in: {
          type: "VariableDeclarator"
        },
        binding: t === "var" ? Ht : nt
      });
    }
    parseFunction(e, t = Ii, r = false) {
      const i = t & Ar, o = t & os, d = !!i && !(t & ls);
      this.initFunction(e, r), this.match(55) && o && this.raise(m.GeneratorInSingleStatementContext, {
        at: this.state.startLoc
      }), e.generator = this.eat(55), i && (e.id = this.parseFunctionId(d));
      const u = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(Ye), this.prodParam.enter(Qt(r, e.generator)), i || (e.id = this.parseFunctionId()), this.parseFunctionParams(e, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !o && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = u, e;
    }
    parseFunctionId(e) {
      return e || Te(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, t) {
      this.expect(10), this.expressionScope.enter(Xs()), e.params = this.parseBindingList(11, 41, false, t), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      !e.id || this.scope.declareName(e.id.name, this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ? Ht : nt : jr, e.id.loc.start);
    }
    parseClass(e, t, r) {
      this.next(), this.takeDecorators(e);
      const i = this.state.strict;
      return this.state.strict = true, this.parseClassId(e, t, r), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === "constructor" || e.key.value === "constructor");
    }
    parseClassBody(e, t) {
      this.classScope.enter();
      const r = {
        hadConstructor: false,
        hadSuperClass: e
      };
      let i = [];
      const o = this.startNode();
      if (o.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(m.DecoratorSemicolon, {
                at: this.state.lastTokEndLoc
              });
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          const d = this.startNode();
          i.length && (d.decorators = i, this.resetStartLocationFromNode(d, i[0]), i = []), this.parseClassMember(o, d, r), d.kind === "constructor" && d.decorators && d.decorators.length > 0 && this.raise(m.DecoratorConstructor, {
            at: d
          });
        }
      }), this.state.strict = t, this.next(), i.length)
        throw this.raise(m.TrailingDecorator, {
          at: this.state.startLoc
        });
      return this.classScope.exit(), this.finishNode(o, "ClassBody");
    }
    parseClassMemberFromModifier(e, t) {
      const r = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const i = t;
        return i.kind = "method", i.computed = false, i.key = r, i.static = false, this.pushClassMethod(e, i, false, false, false, false), true;
      } else if (this.isClassProperty()) {
        const i = t;
        return i.computed = false, i.key = r, i.static = false, e.body.push(this.parseClassProperty(i)), true;
      }
      return this.resetPreviousNodeTrailingComments(r), false;
    }
    parseClassMember(e, t, r) {
      const i = this.isContextual(104);
      if (i) {
        if (this.parseClassMemberFromModifier(e, t))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, t);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, t, r, i);
    }
    parseClassMemberWithIsStatic(e, t, r, i) {
      const o = t, d = t, u = t, E = t, w = t, U = o, ge = o;
      if (t.static = i, this.parsePropertyNamePrefixOperator(t), this.eat(55)) {
        U.kind = "method";
        const Ke = this.match(134);
        if (this.parseClassElementName(U), Ke) {
          this.pushClassPrivateMethod(e, d, true, false);
          return;
        }
        this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsGenerator, {
          at: o.key
        }), this.pushClassMethod(e, o, true, false, false, false);
        return;
      }
      const ye = Te(this.state.type) && !this.state.containsEsc, Ae = this.match(134), Oe = this.parseClassElementName(t), Ve = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(ge), this.isClassMethod()) {
        if (U.kind = "method", Ae) {
          this.pushClassPrivateMethod(e, d, false, false);
          return;
        }
        const Ke = this.isNonstaticConstructor(o);
        let He = false;
        Ke && (o.kind = "constructor", r.hadConstructor && !this.hasPlugin("typescript") && this.raise(m.DuplicateConstructor, {
          at: Oe
        }), Ke && this.hasPlugin("typescript") && t.override && this.raise(m.OverrideOnConstructor, {
          at: Oe
        }), r.hadConstructor = true, He = r.hadSuperClass), this.pushClassMethod(e, o, false, false, Ke, He);
      } else if (this.isClassProperty())
        Ae ? this.pushClassPrivateProperty(e, E) : this.pushClassProperty(e, u);
      else if (ye && Oe.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(Oe);
        const Ke = this.eat(55);
        ge.optional && this.unexpected(Ve), U.kind = "method";
        const He = this.match(134);
        this.parseClassElementName(U), this.parsePostMemberNameModifiers(ge), He ? this.pushClassPrivateMethod(e, d, Ke, true) : (this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsAsync, {
          at: o.key
        }), this.pushClassMethod(e, o, Ke, true, false, false));
      } else if (ye && (Oe.name === "get" || Oe.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(Oe), U.kind = Oe.name;
        const Ke = this.match(134);
        this.parseClassElementName(o), Ke ? this.pushClassPrivateMethod(e, d, false, false) : (this.isNonstaticConstructor(o) && this.raise(m.ConstructorIsAccessor, {
          at: o.key
        }), this.pushClassMethod(e, o, false, false, false, false)), this.checkGetterSetterParams(o);
      } else if (ye && Oe.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(Oe);
        const Ke = this.match(134);
        this.parseClassElementName(u), this.pushClassAccessorProperty(e, w, Ke);
      } else
        this.isLineTerminator() ? Ae ? this.pushClassPrivateProperty(e, E) : this.pushClassProperty(e, u) : this.unexpected();
    }
    parseClassElementName(e) {
      const {
        type: t,
        value: r
      } = this.state;
      if ((t === 128 || t === 129) && e.static && r === "prototype" && this.raise(m.StaticPrototype, {
        at: this.state.startLoc
      }), t === 134) {
        r === "constructor" && this.raise(m.ConstructorClassPrivateField, {
          at: this.state.startLoc
        });
        const i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e);
    }
    parseClassStaticBlock(e, t) {
      var r;
      this.scope.enter(xt | or | $t);
      const i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(It);
      const o = t.body = [];
      this.parseBlockOrModuleBlockBody(o, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.finishNode(t, "StaticBlock")), (r = t.decorators) != null && r.length && this.raise(m.DecoratorStaticBlock, {
        at: t
      });
    }
    pushClassProperty(e, t) {
      !t.computed && (t.key.name === "constructor" || t.key.value === "constructor") && this.raise(m.ConstructorClassField, {
        at: t.key
      }), e.body.push(this.parseClassProperty(t));
    }
    pushClassPrivateProperty(e, t) {
      const r = this.parseClassPrivateProperty(t);
      e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), mr, r.key.loc.start);
    }
    pushClassAccessorProperty(e, t, r) {
      if (!r && !t.computed) {
        const o = t.key;
        (o.name === "constructor" || o.value === "constructor") && this.raise(m.ConstructorClassField, {
          at: o
        });
      }
      const i = this.parseClassAccessorProperty(t);
      e.body.push(i), r && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), mr, i.key.loc.start);
    }
    pushClassMethod(e, t, r, i, o, d) {
      e.body.push(this.parseMethod(t, r, i, o, d, "ClassMethod", true));
    }
    pushClassPrivateMethod(e, t, r, i) {
      const o = this.parseMethod(t, r, i, false, false, "ClassPrivateMethod", true);
      e.body.push(o);
      const d = o.kind === "get" ? o.static ? Ns : Os : o.kind === "set" ? o.static ? ks : Ds : mr;
      this.declareClassPrivateMethodInScope(o, d);
    }
    declareClassPrivateMethodInScope(e, t) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(xt | $t), this.expressionScope.enter(zr()), this.prodParam.enter(It), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, t, r, i = Fr) {
      if (Te(this.state.type))
        e.id = this.parseIdentifier(), t && this.declareNameFromIdentifier(e.id, i);
      else if (r || !t)
        e.id = null;
      else
        throw this.raise(m.MissingClassName, {
          at: this.state.startLoc
        });
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e) {
      const t = this.maybeParseExportDefaultSpecifier(e), r = !t || this.eat(12), i = r && this.eatExportStar(e), o = i && this.maybeParseExportNamespaceSpecifier(e), d = r && (!o || this.eat(12)), u = t || i;
      if (i && !o)
        return t && this.unexpected(), this.parseExportFrom(e, true), this.finishNode(e, "ExportAllDeclaration");
      const E = this.maybeParseExportNamedSpecifiers(e);
      if (t && r && !i && !E || o && d && !E)
        throw this.unexpected(null, 5);
      let w;
      if (u || E ? (w = false, this.parseExportFrom(e, u)) : w = this.maybeParseExportDeclaration(e), u || E || w)
        return this.checkExport(e, true, false, !!e.source), this.finishNode(e, "ExportNamedDeclaration");
      if (this.eat(65))
        return e.declaration = this.parseExportDefaultExpression(), this.checkExport(e, true, true), this.finishNode(e, "ExportDefaultDeclaration");
      throw this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const t = this.startNode();
        return t.exported = this.parseIdentifier(true), e.specifiers = [this.finishNode(t, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = []);
        const t = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), t.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = []);
        const t = e.exportKind === "type";
        return e.specifiers.push(...this.parseExportSpecifiers(t)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") && (e.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions = []), e.declaration = this.parseExportDeclaration(e), true) : false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      const e = this.nextTokenStart();
      return !yr.test(this.input.slice(this.state.pos, e)) && this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      const e = this.startNode(), t = this.isAsyncFunction();
      if (this.match(68) || t)
        return this.next(), t && this.next(), this.parseFunction(e, Ar | ls, t);
      if (this.match(80))
        return this.parseClass(e, true, true);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(m.DecoratorBeforeExport, {
          at: this.state.startLoc
        }), this.parseDecorators(false), this.parseClass(e, true, true);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(m.UnsupportedDefaultExport, {
          at: this.state.startLoc
        });
      const r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      const {
        type: e
      } = this.state;
      if (Te(e)) {
        if (e === 95 && !this.state.containsEsc || e === 99)
          return false;
        if ((e === 126 || e === 125) && !this.state.containsEsc) {
          const {
            type: i
          } = this.lookahead();
          if (Te(i) && i !== 97 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65))
        return false;
      const t = this.nextTokenStart(), r = this.isUnparsedContextual(t, "from");
      if (this.input.charCodeAt(t) === 44 || Te(this.state.type) && r)
        return true;
      if (this.match(65) && r) {
        const i = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
        return i === 34 || i === 39;
      }
      return false;
    }
    parseExportFrom(e, t) {
      if (this.eatContextual(97)) {
        e.source = this.parseImportSource(), this.checkExport(e);
        const r = this.maybeParseImportAssertions();
        r && (e.assertions = r, this.checkJSONModuleImport(e));
      } else
        t && this.unexpected();
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: e
      } = this.state;
      if (e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
          throw this.raise(m.DecoratorBeforeExport, {
            at: this.state.startLoc
          });
        return true;
      }
      return e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, t, r, i) {
      if (t) {
        if (r) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            const u = e.declaration;
            u.type === "Identifier" && u.name === "from" && u.end - u.start === 4 && !((o = u.extra) != null && o.parenthesized) && this.raise(m.ExportDefaultFromAsIdentifier, {
              at: u
            });
          }
        } else if (e.specifiers && e.specifiers.length)
          for (const u of e.specifiers) {
            const {
              exported: E
            } = u, w = E.type === "Identifier" ? E.name : E.value;
            if (this.checkDuplicateExports(u, w), !i && u.local) {
              const {
                local: U
              } = u;
              U.type !== "Identifier" ? this.raise(m.ExportBindingIsString, {
                at: u,
                localName: U.value,
                exportName: w
              }) : (this.checkReservedWord(U.name, U.loc.start, true, false), this.scope.checkLocalExport(U));
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === "FunctionDeclaration" || e.declaration.type === "ClassDeclaration") {
            const u = e.declaration.id;
            if (!u)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (e.declaration.type === "VariableDeclaration")
            for (const u of e.declaration.declarations)
              this.checkDeclaration(u.id);
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(m.UnsupportedDecoratorExport, {
          at: e
        });
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (const t of e.properties)
          this.checkDeclaration(t);
      else if (e.type === "ArrayPattern")
        for (const t of e.elements)
          t && this.checkDeclaration(t);
      else
        e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type === "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, t) {
      this.exportedIdentifiers.has(t) && (t === "default" ? this.raise(m.DuplicateDefaultExport, {
        at: e
      }) : this.raise(m.DuplicateExport, {
        at: e,
        exportName: t
      })), this.exportedIdentifiers.add(t);
    }
    parseExportSpecifiers(e) {
      const t = [];
      let r = true;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = false;
        else if (this.expect(12), this.eat(8))
          break;
        const i = this.isContextual(126), o = this.match(129), d = this.startNode();
        d.local = this.parseModuleExportName(), t.push(this.parseExportSpecifier(d, o, e, i));
      }
      return t;
    }
    parseExportSpecifier(e, t, r, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : t ? e.exported = ti(e.local) : e.exported || (e.exported = at(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(129)) {
        const e = this.parseStringLiteral(this.state.value), t = e.value.match(Ni);
        return t && this.raise(m.ModuleExportNameHasLoneSurrogate, {
          at: e,
          surrogateCharCode: t[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: t,
        value: r
      }) => r.value === "json" && (t.type === "Identifier" ? t.name === "type" : t.value === "type")) : false;
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        const {
          specifiers: t
        } = e;
        if (e.specifiers != null) {
          const r = t.find((i) => {
            let o;
            if (i.type === "ExportSpecifier" ? o = i.local : i.type === "ImportSpecifier" && (o = i.imported), o !== void 0)
              return o.type === "Identifier" ? o.name !== "default" : o.value !== "default";
          });
          r !== void 0 && this.raise(m.ImportJSONBindingNotDefault, {
            at: r.loc.start
          });
        }
      }
    }
    parseImport(e) {
      if (e.specifiers = [], !this.match(129)) {
        const i = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12), o = i && this.maybeParseStarImportSpecifier(e);
        i && !o && this.parseNamedImportSpecifiers(e), this.expectContextual(97);
      }
      e.source = this.parseImportSource();
      const t = this.maybeParseImportAssertions();
      if (t)
        e.assertions = t;
      else {
        const r = this.maybeParseModuleAttributes();
        r && (e.attributes = r);
      }
      return this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(129) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(e) {
      return Te(this.state.type);
    }
    parseImportSpecifierLocal(e, t, r) {
      t.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(t, r));
    }
    finishImportSpecifier(e, t) {
      return this.checkLVal(e.local, {
        in: e,
        binding: nt
      }), this.finishNode(e, t);
    }
    parseAssertEntries() {
      const e = [], t = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const r = this.startNode(), i = this.state.value;
        if (t.has(i) && this.raise(m.ModuleAttributesWithDuplicateKeys, {
          at: this.state.startLoc,
          key: i
        }), t.add(i), this.match(129) ? r.key = this.parseStringLiteral(i) : r.key = this.parseIdentifier(true), this.expect(14), !this.match(129))
          throw this.raise(m.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        r.value = this.parseStringLiteral(this.state.value), this.finishNode(r, "ImportAttribute"), e.push(r);
      } while (this.eat(12));
      return e;
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak())
        this.expectPlugin("moduleAttributes"), this.next();
      else
        return this.hasPlugin("moduleAttributes") ? [] : null;
      const e = [], t = /* @__PURE__ */ new Set();
      do {
        const r = this.startNode();
        if (r.key = this.parseIdentifier(true), r.key.name !== "type" && this.raise(m.ModuleAttributeDifferentFromType, {
          at: r.key
        }), t.has(r.key.name) && this.raise(m.ModuleAttributesWithDuplicateKeys, {
          at: r.key,
          key: r.key.name
        }), t.add(r.key.name), this.expect(14), !this.match(129))
          throw this.raise(m.ModuleAttributeInvalidValue, {
            at: this.state.startLoc
          });
        r.value = this.parseStringLiteral(this.state.value), this.finishNode(r, "ImportAttribute"), e.push(r);
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.expectPlugin("importAssertions"), this.next();
      else
        return this.hasPlugin("importAssertions") ? [] : null;
      this.eat(5);
      const e = this.parseAssertEntries();
      return this.eat(8), e;
    }
    maybeParseDefaultImportSpecifier(e) {
      return this.shouldParseDefaultImport(e) ? (this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), true) : false;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        const t = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e) {
      let t = true;
      for (this.expect(5); !this.eat(8); ) {
        if (t)
          t = false;
        else {
          if (this.eat(14))
            throw this.raise(m.DestructureNamedImport, {
              at: this.state.startLoc
            });
          if (this.expect(12), this.eat(8))
            break;
        }
        const r = this.startNode(), i = this.match(129), o = this.isContextual(126);
        r.imported = this.parseModuleExportName();
        const d = this.parseImportSpecifier(r, i, e.importKind === "type" || e.importKind === "typeof", o);
        e.specifiers.push(d);
      }
    }
    parseImportSpecifier(e, t, r, i) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        const {
          imported: o
        } = e;
        if (t)
          throw this.raise(m.ImportBindingIsString, {
            at: e,
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, true, true), e.local || (e.local = at(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier");
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }
  class us extends Oi {
    constructor(e, t) {
      e = Ei(e), super(e, t), this.options = e, this.initializeScopes(), this.plugins = Di(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return xr;
    }
    parse() {
      this.enterInitialScopes();
      const e = this.startNode(), t = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, t), e.errors = this.state.errors, e;
    }
  }
  function Di(a) {
    const e = /* @__PURE__ */ new Map();
    for (const t of a) {
      const [r, i] = Array.isArray(t) ? t : [t, {}];
      e.has(r) || e.set(r, i || {});
    }
    return e;
  }
  function Li(a, e) {
    var t;
    if (((t = e) == null ? void 0 : t.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        const r = jt(e, a), i = r.parse();
        if (r.sawUnambiguousESM)
          return i;
        if (r.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", jt(e, a).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (r) {
        try {
          return e.sourceType = "script", jt(e, a).parse();
        } catch {
        }
        throw r;
      }
    } else
      return jt(e, a).parse();
  }
  function Mi(a, e) {
    const t = jt(e, a);
    return t.options.strictMode && (t.state.strict = true), t.getExpression();
  }
  function Bi(a) {
    const e = {};
    for (const t of Object.keys(a))
      e[t] = Xe(a[t]);
    return e;
  }
  const _i = Bi(Ie);
  function jt(a, e) {
    let t = us;
    return a != null && a.plugins && (Pi(a.plugins), t = Fi(a.plugins)), new t(a, e);
  }
  const cs = {};
  function Fi(a) {
    const e = Si.filter((i) => ze(a, i)), t = e.join("/");
    let r = cs[t];
    if (!r) {
      r = us;
      for (const i of e)
        r = is[i](r);
      cs[t] = r;
    }
    return r;
  }
  return Mn.parse = Li, Mn.parseExpression = Mi, Mn.tokTypes = _i, Mn;
}
var lc = {};
var uc;
var pm;
function Wi() {
  if (pm)
    return uc;
  pm = 1;
  const s = Symbol.for("gensync:v1:start"), n = Symbol.for("gensync:v1:suspend"), h = "GENSYNC_EXPECTED_START", f2 = "GENSYNC_EXPECTED_SUSPEND", p = "GENSYNC_OPTIONS_ERROR", g = "GENSYNC_RACE_NONEMPTY", P = "GENSYNC_ERRBACK_NO_CALLBACK";
  uc = Object.assign(function(R) {
    let O = R;
    return typeof R != "function" ? O = S(R) : O = v(R), Object.assign(O, x(O));
  }, {
    all: T({
      name: "all",
      arity: 1,
      sync: function(L) {
        return Array.from(L[0]).map((O) => C(O));
      },
      async: function(L, R, O) {
        const B = Array.from(L[0]);
        if (B.length === 0) {
          Promise.resolve().then(() => R([]));
          return;
        }
        let M = 0;
        const j = B.map(() => {
        });
        B.forEach(($, k) => {
          I($, (ne) => {
            j[k] = ne, M += 1, M === j.length && R(j);
          }, O);
        });
      }
    }),
    race: T({
      name: "race",
      arity: 1,
      sync: function(L) {
        const R = Array.from(L[0]);
        if (R.length === 0)
          throw A("Must race at least 1 item", g);
        return C(R[0]);
      },
      async: function(L, R, O) {
        const B = Array.from(L[0]);
        if (B.length === 0)
          throw A("Must race at least 1 item", g);
        for (const M of B)
          I(M, R, O);
      }
    })
  });
  function x(L) {
    return {
      sync: function(...O) {
        return C(L.apply(this, O));
      },
      async: function(...O) {
        return new Promise((B, M) => {
          I(L.apply(this, O), B, M);
        });
      },
      errback: function(...O) {
        const B = O.pop();
        if (typeof B != "function")
          throw A("Asynchronous function called without callback", P);
        let M;
        try {
          M = L.apply(this, O);
        } catch (j) {
          B(j);
          return;
        }
        I(M, (j) => B(void 0, j), (j) => B(j));
      }
    };
  }
  function y(L, R, O, B) {
    if (typeof O === L || B && typeof O > "u")
      return;
    let M;
    throw B ? M = `Expected opts.${R} to be either a ${L}, or undefined.` : M = `Expected opts.${R} to be a ${L}.`, A(M, p);
  }
  function A(L, R) {
    return Object.assign(new Error(L), { code: R });
  }
  function S({ name: L, arity: R, sync: O, async: B, errback: M }) {
    if (y("string", "name", L, true), y("number", "arity", R, true), y("function", "sync", O), y("function", "async", B, true), y("function", "errback", M, true), B && M)
      throw A("Expected one of either opts.async or opts.errback, but got _both_.", p);
    if (typeof L != "string") {
      let j;
      M && M.name && M.name !== "errback" && (j = M.name), B && B.name && B.name !== "async" && (j = B.name.replace(/Async$/, "")), O && O.name && O.name !== "sync" && (j = O.name.replace(/Sync$/, "")), typeof j == "string" && (L = j);
    }
    return typeof R != "number" && (R = O.length), T({
      name: L,
      arity: R,
      sync: function(j) {
        return O.apply(this, j);
      },
      async: function(j, $, k) {
        B ? B.apply(this, j).then($, k) : M ? M.call(this, ...j, (ne, Q) => {
          ne == null ? $(Q) : k(ne);
        }) : $(O.apply(this, j));
      }
    });
  }
  function v(L) {
    return m(L.name, L.length, function(...R) {
      return L.apply(this, R);
    });
  }
  function T({ name: L, arity: R, sync: O, async: B }) {
    return m(L, R, function* (...M) {
      const j = yield s;
      if (!j)
        return O.call(this, M);
      let $;
      try {
        B.call(this, M, (k) => {
          $ || ($ = { value: k }, j());
        }, (k) => {
          $ || ($ = { err: k }, j());
        });
      } catch (k) {
        $ = { err: k }, j();
      }
      if (yield n, $.hasOwnProperty("err"))
        throw $.err;
      return $.value;
    });
  }
  function C(L) {
    let R;
    for (; !({ value: R } = L.next()).done; )
      N(R, L);
    return R;
  }
  function I(L, R, O) {
    (function B() {
      try {
        let M;
        for (; !({ value: M } = L.next()).done; ) {
          N(M, L);
          let j = true, $ = false;
          const k = L.next(() => {
            j ? $ = true : B();
          });
          if (j = false, D(k, L), !$)
            return;
        }
        return R(M);
      } catch (M) {
        return O(M);
      }
    })();
  }
  function N(L, R) {
    L !== s && _(R, A(`Got unexpected yielded value in gensync generator: ${JSON.stringify(L)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, h));
  }
  function D({ value: L, done: R }, O) {
    !R && L === n || _(O, A(R ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(L)}. If you get this, it is probably a gensync bug.`, f2));
  }
  function _(L, R) {
    throw L.throw && L.throw(R), R;
  }
  function m(L, R, O) {
    if (typeof L == "string") {
      const B = Object.getOwnPropertyDescriptor(O, "name");
      (!B || B.configurable) && Object.defineProperty(O, "name", Object.assign(B || {}, {
        configurable: true,
        value: L
      }));
    }
    if (typeof R == "number") {
      const B = Object.getOwnPropertyDescriptor(O, "length");
      (!B || B.configurable) && Object.defineProperty(O, "length", Object.assign(B || {}, {
        configurable: true,
        value: R
      }));
    }
    return O;
  }
  return uc;
}
var Aa = {};
var Ss = {};
Object.defineProperty(Ss, "__esModule", {
  value: true
});
Ss.forwardAsync = xx;
Ss.isAsync = void 0;
Ss.isThenable = b0;
Ss.maybeAsync = gx;
Ss.waitFor = Ss.onFirstPause = void 0;
function fn() {
  const s = Wi();
  return fn = function() {
    return s;
  }, s;
}
function fm(s, n, h, f2, p, g, P) {
  try {
    var x = s[g](P), y = x.value;
  } catch (A) {
    h(A);
    return;
  }
  x.done ? n(y) : Promise.resolve(y).then(f2, p);
}
function y0(s) {
  return function() {
    var n = this, h = arguments;
    return new Promise(function(f2, p) {
      var g = s.apply(n, h);
      function P(y) {
        fm(g, f2, p, P, x, "next", y);
      }
      function x(y) {
        fm(g, f2, p, P, x, "throw", y);
      }
      P(void 0);
    });
  };
}
var hm = fn()(function* (s) {
  return yield* s;
});
var bx = fn()({
  sync: () => false,
  errback: (s) => s(null, true)
});
Ss.isAsync = bx;
function gx(s, n) {
  return fn()({
    sync(...h) {
      const f2 = s.apply(this, h);
      if (b0(f2))
        throw new Error(n);
      return f2;
    },
    async(...h) {
      return Promise.resolve(s.apply(this, h));
    }
  });
}
var Tx = fn()({
  sync: (s) => s("sync"),
  async: function() {
    var s = y0(function* (n) {
      return n("async");
    });
    return function(h) {
      return s.apply(this, arguments);
    };
  }()
});
function xx(s, n) {
  const h = fn()(s);
  return Tx((f2) => {
    const p = h[f2];
    return n(p);
  });
}
var Px = fn()({
  name: "onFirstPause",
  arity: 2,
  sync: function(s) {
    return hm.sync(s);
  },
  errback: function(s, n, h) {
    let f2 = false;
    hm.errback(s, (p, g) => {
      f2 = true, h(p, g);
    }), f2 || n();
  }
});
Ss.onFirstPause = Px;
var Sx = fn()({
  sync: (s) => s,
  async: function() {
    var s = y0(function* (n) {
      return n;
    });
    return function(h) {
      return s.apply(this, arguments);
    };
  }()
});
Ss.waitFor = Sx;
function b0(s) {
  return !!s && (typeof s == "object" || typeof s == "function") && !!s.then && typeof s.then == "function";
}
var zn = {};
Object.defineProperty(zn, "__esModule", {
  value: true
});
zn.isIterableIterator = Ax;
zn.mergeOptions = Ex;
function Ex(s, n) {
  for (const h of Object.keys(n))
    if ((h === "parserOpts" || h === "generatorOpts" || h === "assumptions") && n[h]) {
      const f2 = n[h], p = s[h] || (s[h] = {});
      vx(p, f2);
    } else {
      const f2 = n[h];
      f2 !== void 0 && (s[h] = f2);
    }
}
function vx(s, n) {
  for (const h of Object.keys(n)) {
    const f2 = n[h];
    f2 !== void 0 && (s[h] = f2);
  }
}
function Ax(s) {
  return !!s && typeof s.next == "function" && typeof s[Symbol.iterator] == "function";
}
var Gn = {};
var Xn = {};
Object.defineProperty(Xn, "__esModule", {
  value: true
});
Xn.finalize = Cx;
Xn.flattenToSet = wx;
function Cx(s) {
  return Object.freeze(s);
}
function wx(s) {
  const n = /* @__PURE__ */ new Set(), h = [s];
  for (; h.length > 0; )
    for (const f2 of h.pop())
      Array.isArray(f2) ? h.push(f2) : n.add(f2);
  return n;
}
Object.defineProperty(Gn, "__esModule", {
  value: true
});
Gn.default = void 0;
var Ix = Xn;
var Nx = class {
  constructor(n, h, f2, p = (0, Ix.finalize)([])) {
    this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = n.name || f2, this.manipulateOptions = n.manipulateOptions, this.post = n.post, this.pre = n.pre, this.visitor = n.visitor || {}, this.parserOverride = n.parserOverride, this.generatorOverride = n.generatorOverride, this.options = h, this.externalDependencies = p;
  }
};
Gn.default = Nx;
var Bn = {};
var _n = {};
var Hi = {};
Object.defineProperty(Hi, "__esModule", {
  value: true
});
Hi.assertSimpleType = Sl;
Hi.makeStrongCache = P0;
Hi.makeStrongCacheSync = Lx;
Hi.makeWeakCache = x0;
Hi.makeWeakCacheSync = Dx;
function g0() {
  const s = Wi();
  return g0 = function() {
    return s;
  }, s;
}
var $n = Ss;
var kx = zn;
var T0 = (s) => g0()(s).sync;
function* Ox() {
  return true;
}
function x0(s) {
  return S0(WeakMap, s);
}
function Dx(s) {
  return T0(x0(s));
}
function P0(s) {
  return S0(Map, s);
}
function Lx(s) {
  return T0(P0(s));
}
function S0(s, n) {
  const h = new s(), f2 = new s(), p = new s();
  return function* (P, x) {
    const y = yield* (0, $n.isAsync)(), A = y ? f2 : h, S = yield* Mx(y, A, p, P, x);
    if (S.valid)
      return S.value;
    const v = new _x(x), T = n(P, v);
    let C, I;
    return (0, kx.isIterableIterator)(T) ? I = yield* (0, $n.onFirstPause)(T, () => {
      C = Bx(v, p, P);
    }) : I = T, E0(A, v, P, I), C && (p.delete(P), C.release(I)), I;
  };
}
function* dm(s, n, h) {
  const f2 = s.get(n);
  if (f2) {
    for (const {
      value: p,
      valid: g
    } of f2)
      if (yield* g(h))
        return {
          valid: true,
          value: p
        };
  }
  return {
    valid: false,
    value: null
  };
}
function* Mx(s, n, h, f2, p) {
  const g = yield* dm(n, f2, p);
  if (g.valid)
    return g;
  if (s) {
    const P = yield* dm(h, f2, p);
    if (P.valid) {
      const x = yield* (0, $n.waitFor)(P.value.promise);
      return {
        valid: true,
        value: x
      };
    }
  }
  return {
    valid: false,
    value: null
  };
}
function Bx(s, n, h) {
  const f2 = new jx();
  return E0(n, s, h, f2), f2;
}
function E0(s, n, h, f2) {
  n.configured() || n.forever();
  let p = s.get(h);
  switch (n.deactivate(), n.mode()) {
    case "forever":
      p = [{
        value: f2,
        valid: Ox
      }], s.set(h, p);
      break;
    case "invalidate":
      p = [{
        value: f2,
        valid: n.validator()
      }], s.set(h, p);
      break;
    case "valid":
      p ? p.push({
        value: f2,
        valid: n.validator()
      }) : (p = [{
        value: f2,
        valid: n.validator()
      }], s.set(h, p));
  }
}
var _x = class {
  constructor(n) {
    this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = n;
  }
  simple() {
    return Fx(this);
  }
  mode() {
    return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
  }
  forever() {
    if (!this._active)
      throw new Error("Cannot change caching after evaluation has completed.");
    if (this._never)
      throw new Error("Caching has already been configured with .never()");
    this._forever = true, this._configured = true;
  }
  never() {
    if (!this._active)
      throw new Error("Cannot change caching after evaluation has completed.");
    if (this._forever)
      throw new Error("Caching has already been configured with .forever()");
    this._never = true, this._configured = true;
  }
  using(n) {
    if (!this._active)
      throw new Error("Cannot change caching after evaluation has completed.");
    if (this._never || this._forever)
      throw new Error("Caching has already been configured with .never or .forever()");
    this._configured = true;
    const h = n(this._data), f2 = (0, $n.maybeAsync)(n, "You appear to be using an async cache handler, but Babel has been called synchronously");
    return (0, $n.isThenable)(h) ? h.then((p) => (this._pairs.push([p, f2]), p)) : (this._pairs.push([h, f2]), h);
  }
  invalidate(n) {
    return this._invalidate = true, this.using(n);
  }
  validator() {
    const n = this._pairs;
    return function* (h) {
      for (const [f2, p] of n)
        if (f2 !== (yield* p(h)))
          return false;
      return true;
    };
  }
  deactivate() {
    this._active = false;
  }
  configured() {
    return this._configured;
  }
};
function Fx(s) {
  function n(h) {
    if (typeof h == "boolean") {
      h ? s.forever() : s.never();
      return;
    }
    return s.using(() => Sl(h()));
  }
  return n.forever = () => s.forever(), n.never = () => s.never(), n.using = (h) => s.using(() => Sl(h())), n.invalidate = (h) => s.invalidate(() => Sl(h())), n;
}
function Sl(s) {
  if ((0, $n.isThenable)(s))
    throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
  if (s != null && typeof s != "string" && typeof s != "boolean" && typeof s != "number")
    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
  return s;
}
var jx = class {
  constructor() {
    this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((n) => {
      this._resolve = n;
    });
  }
  release(n) {
    this.released = true, this._resolve(n);
  }
};
var Ua = {};
var cc = {};
var Rx = [
  {
    name: "nodejs",
    version: "0.2.0",
    date: "2011-08-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.3.0",
    date: "2011-08-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.4.0",
    date: "2011-08-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.5.0",
    date: "2011-08-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.6.0",
    date: "2011-11-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.7.0",
    date: "2012-01-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.8.0",
    date: "2012-06-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.9.0",
    date: "2012-07-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.10.0",
    date: "2013-03-11",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.11.0",
    date: "2013-03-28",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "0.12.0",
    date: "2015-02-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "4.0.0",
    date: "2015-09-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "4.1.0",
    date: "2015-09-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "4.2.0",
    date: "2015-10-12",
    lts: "Argon",
    security: false
  },
  {
    name: "nodejs",
    version: "4.3.0",
    date: "2016-02-09",
    lts: "Argon",
    security: false
  },
  {
    name: "nodejs",
    version: "4.4.0",
    date: "2016-03-08",
    lts: "Argon",
    security: false
  },
  {
    name: "nodejs",
    version: "4.5.0",
    date: "2016-08-16",
    lts: "Argon",
    security: false
  },
  {
    name: "nodejs",
    version: "4.6.0",
    date: "2016-09-27",
    lts: "Argon",
    security: true
  },
  {
    name: "nodejs",
    version: "4.7.0",
    date: "2016-12-06",
    lts: "Argon",
    security: false
  },
  {
    name: "nodejs",
    version: "4.8.0",
    date: "2017-02-21",
    lts: "Argon",
    security: false
  },
  {
    name: "nodejs",
    version: "4.9.0",
    date: "2018-03-28",
    lts: "Argon",
    security: true
  },
  {
    name: "nodejs",
    version: "5.0.0",
    date: "2015-10-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.1.0",
    date: "2015-11-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.2.0",
    date: "2015-12-09",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.3.0",
    date: "2015-12-15",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.4.0",
    date: "2016-01-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.5.0",
    date: "2016-01-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.6.0",
    date: "2016-02-09",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.7.0",
    date: "2016-02-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.8.0",
    date: "2016-03-09",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.9.0",
    date: "2016-03-16",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.10.0",
    date: "2016-04-01",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.11.0",
    date: "2016-04-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "5.12.0",
    date: "2016-06-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.0.0",
    date: "2016-04-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.1.0",
    date: "2016-05-05",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.2.0",
    date: "2016-05-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.3.0",
    date: "2016-07-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.4.0",
    date: "2016-08-12",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.5.0",
    date: "2016-08-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.6.0",
    date: "2016-09-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.7.0",
    date: "2016-09-27",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "6.8.0",
    date: "2016-10-12",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "6.9.0",
    date: "2016-10-18",
    lts: "Boron",
    security: false
  },
  {
    name: "nodejs",
    version: "6.10.0",
    date: "2017-02-21",
    lts: "Boron",
    security: false
  },
  {
    name: "nodejs",
    version: "6.11.0",
    date: "2017-06-06",
    lts: "Boron",
    security: false
  },
  {
    name: "nodejs",
    version: "6.12.0",
    date: "2017-11-06",
    lts: "Boron",
    security: false
  },
  {
    name: "nodejs",
    version: "6.13.0",
    date: "2018-02-10",
    lts: "Boron",
    security: false
  },
  {
    name: "nodejs",
    version: "6.14.0",
    date: "2018-03-28",
    lts: "Boron",
    security: true
  },
  {
    name: "nodejs",
    version: "6.15.0",
    date: "2018-11-27",
    lts: "Boron",
    security: true
  },
  {
    name: "nodejs",
    version: "6.16.0",
    date: "2018-12-26",
    lts: "Boron",
    security: false
  },
  {
    name: "nodejs",
    version: "6.17.0",
    date: "2019-02-28",
    lts: "Boron",
    security: true
  },
  {
    name: "nodejs",
    version: "7.0.0",
    date: "2016-10-25",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.1.0",
    date: "2016-11-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.2.0",
    date: "2016-11-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.3.0",
    date: "2016-12-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.4.0",
    date: "2017-01-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.5.0",
    date: "2017-01-31",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.6.0",
    date: "2017-02-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.7.0",
    date: "2017-02-28",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.8.0",
    date: "2017-03-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.9.0",
    date: "2017-04-11",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "7.10.0",
    date: "2017-05-02",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.0.0",
    date: "2017-05-30",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.1.0",
    date: "2017-06-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.2.0",
    date: "2017-07-19",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.3.0",
    date: "2017-08-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.4.0",
    date: "2017-08-15",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.5.0",
    date: "2017-09-12",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.6.0",
    date: "2017-09-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.7.0",
    date: "2017-10-11",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.8.0",
    date: "2017-10-24",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "8.9.0",
    date: "2017-10-31",
    lts: "Carbon",
    security: false
  },
  {
    name: "nodejs",
    version: "8.10.0",
    date: "2018-03-06",
    lts: "Carbon",
    security: false
  },
  {
    name: "nodejs",
    version: "8.11.0",
    date: "2018-03-28",
    lts: "Carbon",
    security: true
  },
  {
    name: "nodejs",
    version: "8.12.0",
    date: "2018-09-10",
    lts: "Carbon",
    security: false
  },
  {
    name: "nodejs",
    version: "8.13.0",
    date: "2018-11-20",
    lts: "Carbon",
    security: false
  },
  {
    name: "nodejs",
    version: "8.14.0",
    date: "2018-11-27",
    lts: "Carbon",
    security: true
  },
  {
    name: "nodejs",
    version: "8.15.0",
    date: "2018-12-26",
    lts: "Carbon",
    security: false
  },
  {
    name: "nodejs",
    version: "8.16.0",
    date: "2019-04-16",
    lts: "Carbon",
    security: false
  },
  {
    name: "nodejs",
    version: "8.17.0",
    date: "2019-12-17",
    lts: "Carbon",
    security: true
  },
  {
    name: "nodejs",
    version: "9.0.0",
    date: "2017-10-31",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.1.0",
    date: "2017-11-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.2.0",
    date: "2017-11-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.3.0",
    date: "2017-12-12",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.4.0",
    date: "2018-01-10",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.5.0",
    date: "2018-01-31",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.6.0",
    date: "2018-02-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.7.0",
    date: "2018-03-01",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.8.0",
    date: "2018-03-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.9.0",
    date: "2018-03-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "9.10.0",
    date: "2018-03-28",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "9.11.0",
    date: "2018-04-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.0.0",
    date: "2018-04-24",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.1.0",
    date: "2018-05-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.2.0",
    date: "2018-05-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.3.0",
    date: "2018-05-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.4.0",
    date: "2018-06-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.5.0",
    date: "2018-06-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.6.0",
    date: "2018-07-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.7.0",
    date: "2018-07-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.8.0",
    date: "2018-08-01",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.9.0",
    date: "2018-08-15",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.10.0",
    date: "2018-09-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.11.0",
    date: "2018-09-19",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.12.0",
    date: "2018-10-10",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "10.13.0",
    date: "2018-10-30",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.14.0",
    date: "2018-11-27",
    lts: "Dubnium",
    security: true
  },
  {
    name: "nodejs",
    version: "10.15.0",
    date: "2018-12-26",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.16.0",
    date: "2019-05-28",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.17.0",
    date: "2019-10-22",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.18.0",
    date: "2019-12-17",
    lts: "Dubnium",
    security: true
  },
  {
    name: "nodejs",
    version: "10.19.0",
    date: "2020-02-05",
    lts: "Dubnium",
    security: true
  },
  {
    name: "nodejs",
    version: "10.20.0",
    date: "2020-03-26",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.21.0",
    date: "2020-06-02",
    lts: "Dubnium",
    security: true
  },
  {
    name: "nodejs",
    version: "10.22.0",
    date: "2020-07-21",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.23.0",
    date: "2020-10-27",
    lts: "Dubnium",
    security: false
  },
  {
    name: "nodejs",
    version: "10.24.0",
    date: "2021-02-23",
    lts: "Dubnium",
    security: true
  },
  {
    name: "nodejs",
    version: "11.0.0",
    date: "2018-10-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.1.0",
    date: "2018-10-30",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.2.0",
    date: "2018-11-15",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.3.0",
    date: "2018-11-27",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "11.4.0",
    date: "2018-12-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.5.0",
    date: "2018-12-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.6.0",
    date: "2018-12-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.7.0",
    date: "2019-01-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.8.0",
    date: "2019-01-24",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.9.0",
    date: "2019-01-30",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.10.0",
    date: "2019-02-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.11.0",
    date: "2019-03-05",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.12.0",
    date: "2019-03-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.13.0",
    date: "2019-03-28",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.14.0",
    date: "2019-04-10",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "11.15.0",
    date: "2019-04-30",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.0.0",
    date: "2019-04-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.1.0",
    date: "2019-04-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.2.0",
    date: "2019-05-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.3.0",
    date: "2019-05-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.4.0",
    date: "2019-06-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.5.0",
    date: "2019-06-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.6.0",
    date: "2019-07-03",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.7.0",
    date: "2019-07-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.8.0",
    date: "2019-08-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.9.0",
    date: "2019-08-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.10.0",
    date: "2019-09-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.11.0",
    date: "2019-09-25",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.12.0",
    date: "2019-10-11",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "12.13.0",
    date: "2019-10-21",
    lts: "Erbium",
    security: false
  },
  {
    name: "nodejs",
    version: "12.14.0",
    date: "2019-12-17",
    lts: "Erbium",
    security: true
  },
  {
    name: "nodejs",
    version: "12.15.0",
    date: "2020-02-05",
    lts: "Erbium",
    security: true
  },
  {
    name: "nodejs",
    version: "12.16.0",
    date: "2020-02-11",
    lts: "Erbium",
    security: false
  },
  {
    name: "nodejs",
    version: "12.17.0",
    date: "2020-05-26",
    lts: "Erbium",
    security: false
  },
  {
    name: "nodejs",
    version: "12.18.0",
    date: "2020-06-02",
    lts: "Erbium",
    security: true
  },
  {
    name: "nodejs",
    version: "12.19.0",
    date: "2020-10-06",
    lts: "Erbium",
    security: false
  },
  {
    name: "nodejs",
    version: "12.20.0",
    date: "2020-11-24",
    lts: "Erbium",
    security: false
  },
  {
    name: "nodejs",
    version: "12.21.0",
    date: "2021-02-23",
    lts: "Erbium",
    security: true
  },
  {
    name: "nodejs",
    version: "12.22.0",
    date: "2021-03-30",
    lts: "Erbium",
    security: false
  },
  {
    name: "nodejs",
    version: "13.0.0",
    date: "2019-10-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.1.0",
    date: "2019-11-05",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.2.0",
    date: "2019-11-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.3.0",
    date: "2019-12-03",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.4.0",
    date: "2019-12-17",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "13.5.0",
    date: "2019-12-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.6.0",
    date: "2020-01-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.7.0",
    date: "2020-01-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.8.0",
    date: "2020-02-05",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "13.9.0",
    date: "2020-02-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.10.0",
    date: "2020-03-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.11.0",
    date: "2020-03-12",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.12.0",
    date: "2020-03-26",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.13.0",
    date: "2020-04-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "13.14.0",
    date: "2020-04-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.0.0",
    date: "2020-04-21",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.1.0",
    date: "2020-04-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.2.0",
    date: "2020-05-05",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.3.0",
    date: "2020-05-19",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.4.0",
    date: "2020-06-02",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "14.5.0",
    date: "2020-06-30",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.6.0",
    date: "2020-07-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.7.0",
    date: "2020-07-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.8.0",
    date: "2020-08-11",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.9.0",
    date: "2020-08-27",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.10.0",
    date: "2020-09-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.11.0",
    date: "2020-09-15",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "14.12.0",
    date: "2020-09-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.13.0",
    date: "2020-09-29",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.14.0",
    date: "2020-10-15",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "14.15.0",
    date: "2020-10-27",
    lts: "Fermium",
    security: false
  },
  {
    name: "nodejs",
    version: "14.16.0",
    date: "2021-02-23",
    lts: "Fermium",
    security: true
  },
  {
    name: "nodejs",
    version: "14.17.0",
    date: "2021-05-11",
    lts: "Fermium",
    security: false
  },
  {
    name: "nodejs",
    version: "14.18.0",
    date: "2021-09-28",
    lts: "Fermium",
    security: false
  },
  {
    name: "nodejs",
    version: "14.19.0",
    date: "2022-02-01",
    lts: "Fermium",
    security: false
  },
  {
    name: "nodejs",
    version: "14.20.0",
    date: "2022-07-07",
    lts: "Fermium",
    security: true
  },
  {
    name: "nodejs",
    version: "15.0.0",
    date: "2020-10-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.1.0",
    date: "2020-11-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.2.0",
    date: "2020-11-10",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.3.0",
    date: "2020-11-24",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.4.0",
    date: "2020-12-09",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.5.0",
    date: "2020-12-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.6.0",
    date: "2021-01-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.7.0",
    date: "2021-01-25",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.8.0",
    date: "2021-02-02",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.9.0",
    date: "2021-02-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.10.0",
    date: "2021-02-23",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "15.11.0",
    date: "2021-03-03",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.12.0",
    date: "2021-03-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.13.0",
    date: "2021-03-31",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "15.14.0",
    date: "2021-04-06",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.0.0",
    date: "2021-04-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.1.0",
    date: "2021-05-04",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.2.0",
    date: "2021-05-19",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.3.0",
    date: "2021-06-03",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.4.0",
    date: "2021-06-23",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.5.0",
    date: "2021-07-14",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.6.0",
    date: "2021-07-29",
    lts: false,
    security: true
  },
  {
    name: "nodejs",
    version: "16.7.0",
    date: "2021-08-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.8.0",
    date: "2021-08-25",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.9.0",
    date: "2021-09-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.10.0",
    date: "2021-09-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.11.0",
    date: "2021-10-08",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.12.0",
    date: "2021-10-20",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "16.13.0",
    date: "2021-10-26",
    lts: "Gallium",
    security: false
  },
  {
    name: "nodejs",
    version: "16.14.0",
    date: "2022-02-08",
    lts: "Gallium",
    security: false
  },
  {
    name: "nodejs",
    version: "16.15.0",
    date: "2022-04-26",
    lts: "Gallium",
    security: false
  },
  {
    name: "nodejs",
    version: "16.16.0",
    date: "2022-07-07",
    lts: "Gallium",
    security: true
  },
  {
    name: "nodejs",
    version: "17.0.0",
    date: "2021-10-19",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.1.0",
    date: "2021-11-09",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.2.0",
    date: "2021-11-30",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.3.0",
    date: "2021-12-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.4.0",
    date: "2022-01-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.5.0",
    date: "2022-02-10",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.6.0",
    date: "2022-02-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.7.0",
    date: "2022-03-09",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.8.0",
    date: "2022-03-22",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "17.9.0",
    date: "2022-04-07",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "18.0.0",
    date: "2022-04-18",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "18.1.0",
    date: "2022-05-03",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "18.2.0",
    date: "2022-05-17",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "18.3.0",
    date: "2022-06-02",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "18.4.0",
    date: "2022-06-16",
    lts: false,
    security: false
  },
  {
    name: "nodejs",
    version: "18.5.0",
    date: "2022-07-06",
    lts: false,
    security: true
  }
];
var pc = {};
var fc = {};
var hc;
var mm;
function Ux() {
  return mm || (mm = 1, hc = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" }), hc;
}
var ym;
function $x() {
  return ym || (ym = 1, fc.browsers = Ux()), fc;
}
var dc = {};
var mc;
var bm;
function qx() {
  return bm || (bm = 1, mc = { 0: "31", 1: "32", 2: "33", 3: "34", 4: "35", 5: "36", 6: "37", 7: "38", 8: "39", 9: "40", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "103", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "79", Q: "80", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "101", Y: "64", Z: "88", a: "89", b: "90", c: "91", d: "92", e: "93", f: "94", g: "95", h: "96", i: "97", j: "98", k: "99", l: "100", m: "102", n: "5", o: "19", p: "20", q: "21", r: "22", s: "23", t: "24", u: "25", v: "26", w: "27", x: "28", y: "29", z: "30", AB: "41", BB: "42", CB: "43", DB: "44", EB: "45", FB: "46", GB: "47", HB: "48", IB: "49", JB: "50", KB: "51", LB: "52", MB: "53", NB: "54", OB: "55", PB: "56", QB: "57", RB: "58", SB: "60", TB: "62", UB: "63", VB: "65", WB: "66", XB: "67", YB: "68", ZB: "69", aB: "70", bB: "71", cB: "72", dB: "73", eB: "74", fB: "75", gB: "76", hB: "77", iB: "78", jB: "11.1", kB: "12.1", lB: "16.0", mB: "3", nB: "59", oB: "61", pB: "82", qB: "104", rB: "3.2", sB: "10.1", tB: "15.2-15.3", uB: "15.4", vB: "15.5", wB: "11.5", xB: "4.2-4.3", yB: "5.5", zB: "2", "0B": "3.5", "1B": "3.6", "2B": "105", "3B": "106", "4B": "3.1", "5B": "5.1", "6B": "6.1", "7B": "7.1", "8B": "9.1", "9B": "13.1", AC: "14.1", BC: "15.1", CC: "15.6", DC: "TP", EC: "9.5-9.6", FC: "10.0-10.1", GC: "10.5", HC: "10.6", IC: "11.6", JC: "4.0-4.1", KC: "5.0-5.1", LC: "6.0-6.1", MC: "7.0-7.1", NC: "8.1-8.4", OC: "9.0-9.2", PC: "9.3", QC: "10.0-10.2", RC: "10.3", SC: "11.0-11.2", TC: "11.3-11.4", UC: "12.0-12.1", VC: "12.2-12.5", WC: "13.0-13.1", XC: "13.2", YC: "13.3", ZC: "13.4-13.7", aC: "14.0-14.4", bC: "14.5-14.8", cC: "15.0-15.1", dC: "all", eC: "2.1", fC: "2.2", gC: "2.3", hC: "4.1", iC: "4.4", jC: "4.4.3-4.4.4", kC: "12.12", lC: "5.0-5.4", mC: "6.2-6.4", nC: "7.2-7.4", oC: "8.2", pC: "9.2", qC: "11.1-11.2", rC: "12.0", sC: "13.0", tC: "14.0", uC: "15.0", vC: "17.0", wC: "10.4", xC: "7.12", yC: "2.5" }), mc;
}
var gm;
function Vx() {
  return gm || (gm = 1, dc.browserVersions = qx()), dc;
}
var yc;
var Tm;
function Kx() {
  return Tm || (Tm = 1, yc = { A: { A: { J: 0.0131217, D: 621152e-8, E: 0.0145876, F: 0.0364691, A: 556471e-8, B: 0.488685, yB: 9298e-6 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "yB", "J", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { yB: 962323200, J: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { C: 3801e-6, K: 4267e-6, L: 4268e-6, G: 3801e-6, M: 3801e-6, N: 7602e-6, O: 0.022806, P: 0, Q: 4298e-6, R: 944e-5, S: 4043e-6, T: 3801e-6, U: 7602e-6, V: 3801e-6, W: 3801e-6, Z: 4318e-6, a: 7602e-6, b: 4118e-6, c: 3939e-6, d: 7602e-6, e: 4118e-6, f: 3939e-6, g: 3801e-6, h: 7602e-6, i: 7602e-6, j: 0.011403, k: 0.019005, l: 0.034209, X: 0.444717, m: 2.86595, H: 0.589155 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "G", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "X", "m", "H", "", "", ""], E: "Edge", F: { C: 1438128e3, K: 1447286400, L: 1470096e3, G: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, P: 1579046400, Q: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, Z: 161136e4, a: 1614816e3, b: 1618358400, c: 1622073600, d: 1626912e3, e: 1630627200, f: 1632441600, g: 1634774400, h: 1637539200, i: 1641427200, j: 1643932800, k: 1646265600, l: 1649635200, X: 1651190400, m: 1653955200, H: 1655942400 }, D: { C: "ms", K: "ms", L: "ms", G: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { 0: 8928e-6, 1: 4471e-6, 2: 9284e-6, 3: 4707e-6, 4: 9076e-6, 5: 7602e-6, 6: 4783e-6, 7: 4271e-6, 8: 4783e-6, 9: 487e-5, zB: 4118e-6, mB: 4271e-6, I: 0.019005, n: 4879e-6, J: 0.020136, D: 5725e-6, E: 4525e-6, F: 533e-5, A: 4283e-6, B: 0.011403, C: 4471e-6, K: 4486e-6, L: 453e-5, G: 8322e-6, M: 4417e-6, N: 4425e-6, O: 4161e-6, o: 4443e-6, p: 4283e-6, q: 8322e-6, r: 0.013698, s: 4161e-6, t: 8786e-6, u: 4118e-6, v: 4317e-6, w: 4393e-6, x: 4418e-6, y: 8834e-6, z: 8322e-6, AB: 5029e-6, BB: 47e-4, CB: 0.019005, DB: 7602e-6, EB: 3867e-6, FB: 4525e-6, GB: 4293e-6, HB: 3801e-6, IB: 4538e-6, JB: 8282e-6, KB: 0.011601, LB: 0.060816, MB: 0.011601, NB: 7602e-6, OB: 3801e-6, PB: 7602e-6, QB: 0.011601, RB: 3939e-6, nB: 3801e-6, SB: 3801e-6, oB: 4356e-6, TB: 4425e-6, UB: 8322e-6, Y: 415e-5, VB: 4267e-6, WB: 3801e-6, XB: 4267e-6, YB: 7602e-6, ZB: 415e-5, aB: 4293e-6, bB: 4425e-6, cB: 3801e-6, dB: 415e-5, eB: 415e-5, fB: 4318e-6, gB: 4356e-6, hB: 3801e-6, iB: 0.041811, P: 3801e-6, Q: 3801e-6, R: 0.011403, pB: 3801e-6, S: 3801e-6, T: 7602e-6, U: 4268e-6, V: 3801e-6, W: 0.011403, Z: 0.011403, a: 7602e-6, b: 7602e-6, c: 0.095025, d: 3801e-6, e: 7602e-6, f: 0.022806, g: 7602e-6, h: 7602e-6, i: 0.011403, j: 0.015204, k: 0.045612, l: 0.288876, X: 2.00313, m: 0.083622, H: 0, qB: 0, "0B": 8786e-6, "1B": 487e-5 }, B: "moz", C: ["zB", "mB", "0B", "1B", "I", "n", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "nB", "SB", "oB", "TB", "UB", "Y", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "P", "Q", "R", "pB", "S", "T", "U", "V", "W", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "X", "m", "H", "qB", ""], E: "Firefox", F: { 0: 1405987200, 1: 1409616e3, 2: 1413244800, 3: 1417392e3, 4: 1421107200, 5: 1424736e3, 6: 1428278400, 7: 1431475200, 8: 1435881600, 9: 1439251200, zB: 1161648e3, mB: 1213660800, "0B": 124632e4, "1B": 1264032e3, I: 1300752e3, n: 1308614400, J: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, K: 1335225600, L: 1338854400, G: 1342483200, M: 1346112e3, N: 1349740800, O: 1353628800, o: 1357603200, p: 1361232e3, q: 1364860800, r: 1368489600, s: 1372118400, t: 1375747200, u: 1379376e3, v: 1386633600, w: 1391472e3, x: 1395100800, y: 1398729600, z: 1402358400, AB: 144288e4, BB: 1446508800, CB: 1450137600, DB: 1453852800, EB: 1457395200, FB: 1461628800, GB: 1465257600, HB: 1470096e3, IB: 1474329600, JB: 1479168e3, KB: 1485216e3, LB: 1488844800, MB: 149256e4, NB: 1497312e3, OB: 1502150400, PB: 1506556800, QB: 1510617600, RB: 1516665600, nB: 1520985600, SB: 1525824e3, oB: 1529971200, TB: 1536105600, UB: 1540252800, Y: 1544486400, VB: 154872e4, WB: 1552953600, XB: 1558396800, YB: 1562630400, ZB: 1567468800, aB: 1571788800, bB: 1575331200, cB: 1578355200, dB: 1581379200, eB: 1583798400, fB: 1586304e3, gB: 1588636800, hB: 1591056e3, iB: 1593475200, P: 1595894400, Q: 1598313600, R: 1600732800, pB: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, Z: 1618790400, a: 1622505600, b: 1626134400, c: 1628553600, d: 1630972800, e: 1633392e3, f: 1635811200, g: 1638835200, h: 1641859200, i: 1644364800, j: 1646697600, k: 1649116800, l: 1651536e3, X: 1653955200, m: 1656374400, H: null, qB: null } }, D: { A: { 0: 8596e-6, 1: 4566e-6, 2: 4118e-6, 3: 7602e-6, 4: 3801e-6, 5: 4335e-6, 6: 4464e-6, 7: 0.019005, 8: 3867e-6, 9: 0.011403, I: 4706e-6, n: 4879e-6, J: 4879e-6, D: 5591e-6, E: 5591e-6, F: 5591e-6, A: 4534e-6, B: 4464e-6, C: 0.010424, K: 83e-4, L: 4706e-6, G: 0.015087, M: 4393e-6, N: 4393e-6, O: 8652e-6, o: 8322e-6, p: 4393e-6, q: 4317e-6, r: 7602e-6, s: 8786e-6, t: 3939e-6, u: 4461e-6, v: 4141e-6, w: 4326e-6, x: 47e-4, y: 4538e-6, z: 8322e-6, AB: 7734e-6, BB: 7734e-6, CB: 7602e-6, DB: 3867e-6, EB: 3867e-6, FB: 3867e-6, GB: 0.011403, HB: 0.019005, IB: 0.053214, JB: 3867e-6, KB: 3801e-6, LB: 3801e-6, MB: 0.011403, NB: 3867e-6, OB: 3801e-6, PB: 0.026607, QB: 3801e-6, RB: 7602e-6, nB: 3801e-6, SB: 0.011403, oB: 0.011403, TB: 7602e-6, UB: 0.011403, Y: 7602e-6, VB: 0.011403, WB: 0.026607, XB: 0.011403, YB: 7602e-6, ZB: 0.049413, aB: 0.022806, bB: 0.011403, cB: 0.026607, dB: 7602e-6, eB: 0.022806, fB: 0.060816, gB: 0.060816, hB: 0.011403, iB: 0.034209, P: 0.193851, Q: 0.03801, R: 0.034209, S: 0.110229, T: 0.049413, U: 0.07602, V: 0.072219, W: 0.448518, Z: 0.019005, a: 0.060816, b: 0.026607, c: 0.072219, d: 0.053214, e: 0.045612, f: 0.049413, g: 0.034209, h: 0.106428, i: 0.098826, j: 0.129234, k: 0.163443, l: 0.387702, X: 1.47099, m: 17.8077, H: 1.61923, qB: 0.015204, "2B": 0.011403, "3B": 0 }, B: "webkit", C: ["", "", "", "", "I", "n", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "nB", "SB", "oB", "TB", "UB", "Y", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "P", "Q", "R", "S", "T", "U", "V", "W", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "X", "m", "H", "qB", "2B", "3B"], E: "Chrome", F: { 0: 1384214400, 1: 1389657600, 2: 1392940800, 3: 1397001600, 4: 1400544e3, 5: 1405468800, 6: 1409011200, 7: 141264e4, 8: 1416268800, 9: 1421798400, I: 1264377600, n: 1274745600, J: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, G: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, o: 1332892800, p: 133704e4, q: 1340668800, r: 1343692800, s: 1348531200, t: 1352246400, u: 1357862400, v: 1361404800, w: 1364428800, x: 1369094400, y: 1374105600, z: 1376956800, AB: 1425513600, BB: 1429401600, CB: 143208e4, DB: 1437523200, EB: 1441152e3, FB: 1444780800, GB: 1449014400, HB: 1453248e3, IB: 1456963200, JB: 1460592e3, KB: 1464134400, LB: 1469059200, MB: 1472601600, NB: 1476230400, OB: 1480550400, PB: 1485302400, QB: 1489017600, RB: 149256e4, nB: 1496707200, SB: 1500940800, oB: 1504569600, TB: 1508198400, UB: 1512518400, Y: 1516752e3, VB: 1520294400, WB: 1523923200, XB: 1527552e3, YB: 1532390400, ZB: 1536019200, aB: 1539648e3, bB: 1543968e3, cB: 154872e4, dB: 1552348800, eB: 1555977600, fB: 1559606400, gB: 1564444800, hB: 1568073600, iB: 1571702400, P: 1575936e3, Q: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, Z: 1611014400, a: 1614556800, b: 1618272e3, c: 1621987200, d: 1626739200, e: 1630368e3, f: 1632268800, g: 1634601600, h: 1637020800, i: 1641340800, j: 1643673600, k: 1646092800, l: 1648512e3, X: 1650931200, m: 1653350400, H: 1655769600, qB: null, "2B": null, "3B": null } }, E: { A: { I: 0, n: 8322e-6, J: 4656e-6, D: 4465e-6, E: 4356e-6, F: 4891e-6, A: 4425e-6, B: 4318e-6, C: 3801e-6, K: 0.034209, L: 0.140637, G: 0.045612, "4B": 0, rB: 8692e-6, "5B": 7602e-6, "6B": 456e-5, "7B": 4283e-6, "8B": 0.015204, sB: 7602e-6, jB: 0.022806, kB: 0.045612, "9B": 0.254667, AC: 0.41811, BC: 0.083622, tB: 0.079821, uB: 0.528339, vB: 1.47859, CC: 0, lB: 3801e-6, DC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "4B", "rB", "I", "n", "5B", "J", "6B", "D", "7B", "E", "F", "8B", "A", "sB", "B", "jB", "C", "kB", "K", "9B", "L", "AC", "G", "BC", "tB", "uB", "vB", "CC", "lB", "DC"], E: "Safari", F: { "4B": 1205798400, rB: 1226534400, I: 1244419200, n: 1275868800, "5B": 131112e4, J: 1343174400, "6B": 13824e5, D: 13824e5, "7B": 1410998400, E: 1413417600, F: 1443657600, "8B": 1458518400, A: 1474329600, sB: 1490572800, B: 1505779200, jB: 1522281600, C: 1537142400, kB: 1553472e3, K: 1568851200, "9B": 1585008e3, L: 1600214400, AC: 1619395200, G: 1632096e3, BC: 1635292800, tB: 1639353600, uB: 1647216e3, vB: 1652745600, CC: null, lB: null, DC: null } }, F: { A: { 0: 3801e-6, 1: 5152e-6, 2: 5014e-6, 3: 9758e-6, 4: 4879e-6, 5: 3801e-6, 6: 4283e-6, 7: 4367e-6, 8: 4534e-6, 9: 7602e-6, F: 82e-4, B: 0.016581, C: 4317e-6, G: 685e-5, M: 685e-5, N: 685e-5, O: 5014e-6, o: 6015e-6, p: 4879e-6, q: 6597e-6, r: 6597e-6, s: 0.013434, t: 6702e-6, u: 6015e-6, v: 5595e-6, w: 4393e-6, x: 7602e-6, y: 4879e-6, z: 4879e-6, AB: 4227e-6, BB: 4418e-6, CB: 4161e-6, DB: 4227e-6, EB: 4725e-6, FB: 0.011403, GB: 8942e-6, HB: 4707e-6, IB: 4827e-6, JB: 4707e-6, KB: 4707e-6, LB: 4326e-6, MB: 8922e-6, NB: 0.014349, OB: 4425e-6, PB: 472e-5, QB: 4425e-6, RB: 4425e-6, SB: 472e-5, TB: 4532e-6, UB: 4566e-6, Y: 0.02283, VB: 867e-5, WB: 4656e-6, XB: 4642e-6, YB: 3867e-6, ZB: 944e-5, aB: 4293e-6, bB: 3867e-6, cB: 4298e-6, dB: 0.096692, eB: 4201e-6, fB: 4141e-6, gB: 4257e-6, hB: 3939e-6, iB: 8236e-6, P: 3939e-6, Q: 3939e-6, R: 8514e-6, pB: 3939e-6, S: 3939e-6, T: 3801e-6, U: 0.034209, V: 0.300279, W: 0.592956, EC: 685e-5, FC: 0, GC: 8392e-6, HC: 4706e-6, jB: 6229e-6, wB: 4879e-6, IC: 8786e-6, kB: 472e-5 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "EC", "FC", "GC", "HC", "B", "jB", "wB", "IC", "C", "kB", "G", "M", "N", "O", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "Y", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "P", "Q", "R", "pB", "S", "T", "U", "V", "W", "", ""], E: "Opera", F: { 0: 1438646400, 1: 1442448e3, 2: 1445904e3, 3: 1449100800, 4: 1454371200, 5: 1457308800, 6: 146232e4, 7: 1465344e3, 8: 1470096e3, 9: 1474329600, F: 1150761600, EC: 1223424e3, FC: 1251763200, GC: 1267488e3, HC: 1277942400, B: 1292457600, jB: 1302566400, wB: 1309219200, IC: 1323129600, C: 1323129600, kB: 1352073600, G: 1372723200, M: 1377561600, N: 1381104e3, O: 1386288e3, o: 1390867200, p: 1393891200, q: 1399334400, r: 1401753600, s: 1405987200, t: 1409616e3, u: 1413331200, v: 1417132800, w: 1422316800, x: 1425945600, y: 1430179200, z: 1433808e3, AB: 1477267200, BB: 1481587200, CB: 1486425600, DB: 1490054400, EB: 1494374400, FB: 1498003200, GB: 1502236800, HB: 1506470400, IB: 1510099200, JB: 1515024e3, KB: 1517961600, LB: 1521676800, MB: 1525910400, NB: 1530144e3, OB: 1534982400, PB: 1537833600, QB: 1543363200, RB: 1548201600, SB: 1554768e3, TB: 1561593600, UB: 1566259200, Y: 1570406400, VB: 1573689600, WB: 1578441600, XB: 1583971200, YB: 1587513600, ZB: 1592956800, aB: 1595894400, bB: 1600128e3, cB: 1603238400, dB: 161352e4, eB: 1612224e3, fB: 1616544e3, gB: 1619568e3, hB: 1623715200, iB: 1627948800, P: 1631577600, Q: 1633392e3, R: 1635984e3, pB: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: null }, D: { F: "o", B: "o", C: "o", EC: "o", FC: "o", GC: "o", HC: "o", jB: "o", wB: "o", IC: "o", kB: "o" } }, G: { A: { E: 0, rB: 149648e-8, JC: 0, xB: 149648e-8, KC: 448945e-8, LC: 448945e-8, MC: 0.0164613, NC: 748241e-8, OC: 0.0164613, PC: 0.0748241, QC: 897889e-8, RC: 0.0823065, SC: 0.040405, TC: 0.0299296, UC: 0.0299296, VC: 0.559684, WC: 0.0254402, XC: 0.0119719, YC: 0.0553698, ZC: 0.173592, aC: 0.528258, bC: 1.278, cC: 0.399561, tB: 0.749737, uB: 2.16691, vB: 8.63769, lB: 0.0284332 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rB", "JC", "xB", "KC", "LC", "MC", "E", "NC", "OC", "PC", "QC", "RC", "SC", "TC", "UC", "VC", "WC", "XC", "YC", "ZC", "aC", "bC", "cC", "tB", "uB", "vB", "lB", "", ""], E: "Safari on iOS", F: { rB: 1270252800, JC: 1283904e3, xB: 1299628800, KC: 1331078400, LC: 1359331200, MC: 1394409600, E: 1410912e3, NC: 1413763200, OC: 1442361600, PC: 1458518400, QC: 1473724800, RC: 1490572800, SC: 1505779200, TC: 1522281600, UC: 1537142400, VC: 1553472e3, WC: 1568851200, XC: 1572220800, YC: 1580169600, ZC: 1585008e3, aC: 1600214400, bC: 1619395200, cC: 1632096e3, tB: 1639353600, uB: 1647216e3, vB: 1652659200, lB: null } }, H: { A: { dC: 0.950748 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "dC", "", "", ""], E: "Opera Mini", F: { dC: 1426464e3 } }, I: { A: { mB: 0, I: 0.0154975, H: 0, eC: 0, fC: 0, gC: 0, hC: 0.0206633, xB: 0.06199, iC: 0, jC: 0.304784 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "eC", "fC", "gC", "mB", "I", "hC", "xB", "iC", "jC", "H", "", "", ""], E: "Android Browser", F: { eC: 1256515200, fC: 1274313600, gC: 1291593600, mB: 1298332800, I: 1318896e3, hC: 1341792e3, xB: 1374624e3, iC: 1386547200, jC: 1401667200, H: 1655856e3 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, Y: 0.0111391, jB: 0, wB: 0, kB: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "jB", "wB", "C", "kB", "Y", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, jB: 1314835200, wB: 1318291200, C: 1330300800, kB: 1349740800, Y: 1613433600 }, D: { Y: "webkit" } }, L: { A: { H: 42.3898 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""], E: "Chrome for Android", F: { H: 1655769600 } }, M: { A: { X: 0.30995 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "X", "", "", ""], E: "Firefox for Android", F: { X: 1653955200 } }, N: { A: { A: 0.0115934, B: 0.022664 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { kC: 0.712885 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "kC", "", "", ""], E: "UC Browser for Android", F: { kC: 1471392e3 }, D: { kC: "webkit" } }, P: { A: { I: 0.207064, lC: 0.0103543, mC: 0.010304, nC: 0.0828255, oC: 0.0103584, pC: 0.0103532, sB: 0.0105043, qC: 0.0414128, rC: 0.0207064, sC: 0.0828255, tC: 0.0931787, uC: 0.0931787, lB: 0.238123, vC: 2.11205 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "lC", "mC", "nC", "oC", "pC", "sB", "qC", "rC", "sC", "tC", "uC", "lB", "vC", "", "", ""], E: "Samsung Internet", F: { I: 1461024e3, lC: 1481846400, mC: 1509408e3, nC: 1528329600, oC: 1546128e3, pC: 1554163200, sB: 1567900800, qC: 1582588800, rC: 1593475200, sC: 1605657600, tC: 1618531200, uC: 1629072e3, lB: 1640736e3, vC: 1651708800 } }, Q: { A: { wC: 0.142577 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "wC", "", "", ""], E: "QQ Browser", F: { wC: 1589846400 } }, R: { A: { xC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "xC", "", "", ""], E: "Baidu Browser", F: { xC: 1491004800 } }, S: { A: { yC: 0.049592 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "yC", "", "", ""], E: "KaiOS Browser", F: { yC: 1527811200 } } }), yc;
}
var xm;
function Wx() {
  if (xm)
    return pc;
  xm = 1;
  const s = $x().browsers, n = Vx().browserVersions, h = Kx();
  function f2(p) {
    return Object.keys(p).reduce((g, P) => (g[n[P]] = p[P], g), {});
  }
  return pc.agents = Object.keys(h).reduce((p, g) => {
    let P = h[g];
    return p[s[g]] = Object.keys(P).reduce((x, y) => (y === "A" ? x.usage_global = f2(P[y]) : y === "C" ? x.versions = P[y].reduce((A, S) => (S === "" ? A.push(null) : A.push(n[S]), A), []) : y === "D" ? x.prefix_exceptions = f2(P[y]) : y === "E" ? x.browser = P[y] : y === "F" ? x.release_date = Object.keys(P[y]).reduce((A, S) => (A[n[S]] = P[y][S], A), {}) : x.prefix = P[y], x), {}), p;
  }, {}), pc;
}
var Hx = {
  start: "2015-09-08",
  lts: "2015-10-12",
  maintenance: "2017-04-01",
  end: "2018-04-30",
  codename: "Argon"
};
var zx = {
  start: "2015-10-29",
  maintenance: "2016-04-30",
  end: "2016-06-30"
};
var Gx = {
  start: "2016-04-26",
  lts: "2016-10-18",
  maintenance: "2018-04-30",
  end: "2019-04-30",
  codename: "Boron"
};
var Xx = {
  start: "2016-10-25",
  maintenance: "2017-04-30",
  end: "2017-06-30"
};
var Jx = {
  start: "2017-05-30",
  lts: "2017-10-31",
  maintenance: "2019-01-01",
  end: "2019-12-31",
  codename: "Carbon"
};
var Yx = {
  start: "2017-10-01",
  maintenance: "2018-04-01",
  end: "2018-06-30"
};
var Qx = {
  start: "2018-04-24",
  lts: "2018-10-30",
  maintenance: "2020-05-19",
  end: "2021-04-30",
  codename: "Dubnium"
};
var Zx = {
  start: "2018-10-23",
  maintenance: "2019-04-22",
  end: "2019-06-01"
};
var eP = {
  start: "2019-04-23",
  lts: "2019-10-21",
  maintenance: "2020-11-30",
  end: "2022-04-30",
  codename: "Erbium"
};
var tP = {
  start: "2019-10-22",
  maintenance: "2020-04-01",
  end: "2020-06-01"
};
var rP = {
  start: "2020-04-21",
  lts: "2020-10-27",
  maintenance: "2021-10-19",
  end: "2023-04-30",
  codename: "Fermium"
};
var sP = {
  start: "2020-10-20",
  maintenance: "2021-04-01",
  end: "2021-06-01"
};
var iP = {
  start: "2021-04-20",
  lts: "2021-10-26",
  maintenance: "2022-10-18",
  end: "2023-09-11",
  codename: "Gallium"
};
var nP = {
  start: "2021-10-19",
  maintenance: "2022-04-01",
  end: "2022-06-01"
};
var aP = {
  start: "2022-04-19",
  lts: "2022-10-25",
  maintenance: "2023-10-18",
  end: "2025-04-30",
  codename: ""
};
var oP = {
  start: "2022-10-18",
  maintenance: "2023-04-01",
  end: "2023-06-01"
};
var lP = {
  start: "2023-04-18",
  lts: "2023-10-24",
  maintenance: "2024-10-22",
  end: "2026-04-30",
  codename: ""
};
var uP = {
  "v0.8": {
    start: "2012-06-25",
    end: "2014-07-31"
  },
  "v0.10": {
    start: "2013-03-11",
    end: "2016-10-31"
  },
  "v0.12": {
    start: "2015-02-06",
    end: "2016-12-31"
  },
  v4: Hx,
  v5: zx,
  v6: Gx,
  v7: Xx,
  v8: Jx,
  v9: Yx,
  v10: Qx,
  v11: Zx,
  v12: eP,
  v13: tP,
  v14: rP,
  v15: sP,
  v16: iP,
  v17: nP,
  v18: aP,
  v19: oP,
  v20: lP
};
var bc;
var Pm;
function cP() {
  return Pm || (Pm = 1, bc = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "20.0": "104"
  }), bc;
}
var gc;
var Sm;
function v0() {
  if (Sm)
    return gc;
  Sm = 1;
  function s(n) {
    this.name = "BrowserslistError", this.message = n, this.browserslist = true, Error.captureStackTrace && Error.captureStackTrace(this, s);
  }
  return s.prototype = Error.prototype, gc = s, gc;
}
var Tc;
var Em;
function pP() {
  if (Em)
    return Tc;
  Em = 1;
  var s = /^\s+and\s+(.*)/i, n = /^(?:,\s*|\s+or\s+)(.*)/i;
  function h(P) {
    return Array.isArray(P) ? P.reduce(function(x, y) {
      return x.concat(h(y));
    }, []) : [P];
  }
  function f2(P, x) {
    for (var y = 1, A = P.length; y <= A; y++) {
      var S = P.substr(-y, y);
      if (x(S, y, A))
        return P.slice(0, -y);
    }
    return "";
  }
  function p(P, x) {
    var y = { query: x };
    x.indexOf("not ") === 0 && (y.not = true, x = x.slice(4));
    for (var A in P) {
      var S = P[A], v = x.match(S.regexp);
      if (v) {
        y.type = A;
        for (var T = 0; T < S.matches.length; T++)
          y[S.matches[T]] = v[T + 1];
        return y;
      }
    }
    return y.type = "unknown", y;
  }
  function g(P, x, y) {
    var A;
    return f2(x, function(S, v, T) {
      return s.test(S) ? (A = p(P, S.match(s)[1]), A.compose = "and", y.unshift(A), true) : n.test(S) ? (A = p(P, S.match(n)[1]), A.compose = "or", y.unshift(A), true) : v === T ? (A = p(P, S.trim()), A.compose = "or", y.unshift(A), true) : false;
    });
  }
  return Tc = function(x, y) {
    return Array.isArray(y) || (y = [y]), h(y.map(function(A) {
      var S = [];
      do
        A = g(x, A, S);
      while (A);
      return S;
    }));
  }, Tc;
}
var xc;
var vm;
function fP() {
  if (vm)
    return xc;
  vm = 1;
  var s = v0();
  function n() {
  }
  return xc = {
    loadQueries: function() {
      throw new s("Sharable configs are not supported in client-side build of Browserslist");
    },
    getStat: function(f2) {
      return f2.stats;
    },
    loadConfig: function(f2) {
      if (f2.config)
        throw new s("Browserslist config are not supported in client-side build");
    },
    loadCountry: function() {
      throw new s("Country statistics are not supported in client-side build of Browserslist");
    },
    loadFeature: function() {
      throw new s("Supports queries are not available in client-side build of Browserslist");
    },
    currentNode: function(f2, p) {
      return f2(["maintained node versions"], p)[0];
    },
    parseConfig: n,
    readConfig: n,
    findConfig: n,
    clearCaches: n,
    oldDataWarning: n
  }, xc;
}
var Pc;
var Am;
function hP() {
  if (Am)
    return Pc;
  Am = 1;
  var s = Rx, n = Wx().agents, h = uP, f2 = an(), p = cP(), g = v0(), P = pP(), x = fP(), y = 365.259641 * 24 * 60 * 60 * 1e3, A = 37;
  function S(z, W) {
    return (z + ".").indexOf(W + ".") === 0;
  }
  function v(z) {
    var W = z.slice(1);
    return H.nodeVersions.some(function(ae) {
      return S(ae, W);
    });
  }
  function T(z) {
    return z.filter(function(W) {
      return typeof W == "string";
    });
  }
  function C(z) {
    var W = z;
    return z.split(".").length === 3 && (W = z.split(".").slice(0, -1).join(".")), W;
  }
  function I(z) {
    return function(ae) {
      return z + " " + ae;
    };
  }
  function N(z) {
    return parseInt(z.split(".")[0]);
  }
  function D(z, W) {
    if (z.length === 0)
      return [];
    var ae = _(z.map(N)), ce = ae[ae.length - W];
    if (!ce)
      return z;
    for (var xe = [], Se = z.length - 1; Se >= 0 && !(ce > N(z[Se])); Se--)
      xe.unshift(z[Se]);
    return xe;
  }
  function _(z) {
    for (var W = [], ae = 0; ae < z.length; ae++)
      W.indexOf(z[ae]) === -1 && W.push(z[ae]);
    return W;
  }
  function m(z, W, ae) {
    for (var ce in ae)
      z[W + " " + ce] = ae[ce];
  }
  function L(z, W) {
    return W = parseFloat(W), z === ">" ? function(ae) {
      return parseFloat(ae) > W;
    } : z === ">=" ? function(ae) {
      return parseFloat(ae) >= W;
    } : z === "<" ? function(ae) {
      return parseFloat(ae) < W;
    } : function(ae) {
      return parseFloat(ae) <= W;
    };
  }
  function R(z, W) {
    return W = W.split(".").map(O), W[1] = W[1] || 0, W[2] = W[2] || 0, z === ">" ? function(ae) {
      return ae = ae.split(".").map(O), M(ae, W) > 0;
    } : z === ">=" ? function(ae) {
      return ae = ae.split(".").map(O), M(ae, W) >= 0;
    } : z === "<" ? function(ae) {
      return ae = ae.split(".").map(O), M(W, ae) > 0;
    } : function(ae) {
      return ae = ae.split(".").map(O), M(W, ae) >= 0;
    };
  }
  function O(z) {
    return parseInt(z);
  }
  function B(z, W) {
    return z < W ? -1 : z > W ? 1 : 0;
  }
  function M(z, W) {
    return B(parseInt(z[0]), parseInt(W[0])) || B(parseInt(z[1] || "0"), parseInt(W[1] || "0")) || B(parseInt(z[2] || "0"), parseInt(W[2] || "0"));
  }
  function j(z, W) {
    switch (W = W.split(".").map(O), typeof W[1] > "u" && (W[1] = "x"), z) {
      case "<=":
        return function(ae) {
          return ae = ae.split(".").map(O), $(ae, W) <= 0;
        };
      case ">=":
      default:
        return function(ae) {
          return ae = ae.split(".").map(O), $(ae, W) >= 0;
        };
    }
  }
  function $(z, W) {
    return z[0] !== W[0] ? z[0] < W[0] ? -1 : 1 : W[1] === "x" ? 0 : z[1] !== W[1] ? z[1] < W[1] ? -1 : 1 : 0;
  }
  function k(z, W) {
    return z.versions.indexOf(W) !== -1 ? W : H.versionAliases[z.name][W] ? H.versionAliases[z.name][W] : false;
  }
  function ne(z, W) {
    var ae = k(z, W);
    return ae || (z.versions.length === 1 ? z.versions[0] : false);
  }
  function Q(z, W) {
    return z = z / 1e3, Object.keys(n).reduce(function(ae, ce) {
      var xe = K(ce, W);
      if (!xe)
        return ae;
      var Se = Object.keys(xe.releaseDate).filter(function(Le) {
        var Ee = xe.releaseDate[Le];
        return Ee !== null && Ee >= z;
      });
      return ae.concat(Se.map(I(xe.name)));
    }, []);
  }
  function q(z) {
    return {
      name: z.name,
      versions: z.versions,
      released: z.released,
      releaseDate: z.releaseDate
    };
  }
  function ee(z, W) {
    z.versions = z.versions.map(function(xe) {
      return W[xe] || xe;
    }), z.released = z.released.map(function(xe) {
      return W[xe] || xe;
    });
    var ae = {};
    for (var ce in z.releaseDate)
      ae[W[ce] || ce] = z.releaseDate[ce];
    return z.releaseDate = ae, z;
  }
  function K(z, W) {
    if (z = z.toLowerCase(), z = H.aliases[z] || z, W.mobileToDesktop && H.desktopNames[z]) {
      var ae = H.data[H.desktopNames[z]];
      if (z === "android")
        return V(q(H.data[z]), ae);
      var ce = q(ae);
      return ce.name = z, z === "op_mob" && (ce = ee(ce, { "10.0-10.1": "10" })), ce;
    }
    return H.data[z];
  }
  function G(z, W) {
    var ae = A, ce = W[W.length - 1];
    return z.filter(function(xe) {
      return /^(?:[2-4]\.|[34]$)/.test(xe);
    }).concat(W.slice(ae - ce - 1));
  }
  function V(z, W) {
    return z.released = G(z.released, W.released), z.versions = G(z.versions, W.versions), z;
  }
  function F(z, W) {
    var ae = K(z, W);
    if (!ae)
      throw new g("Unknown browser " + z);
    return ae;
  }
  function le(z) {
    return new g("Unknown browser query `" + z + "`. Maybe you are using old Browserslist or made typo in query.");
  }
  function oe(z, W, ae) {
    if (ae.mobileToDesktop)
      return z;
    var ce = H.data.android.released, xe = ce[ce.length - 1], Se = xe - A - W;
    return Se > 0 ? z.slice(-1) : z.slice(Se - 1);
  }
  function fe(z, W) {
    return P(pe, z).reduce(function(ae, ce, xe) {
      if (ce.not && xe === 0)
        throw new g("Write any browsers query (for instance, `defaults`) before `" + ce.query + "`");
      var Se = pe[ce.type], Le = Se.select.call(H, W, ce).map(function(J) {
        var me = J.split(" ");
        return me[1] === "0" ? me[0] + " " + K(me[0], W).versions[0] : J;
      });
      if (ce.compose === "and")
        return ce.not ? ae.filter(function(J) {
          return Le.indexOf(J) === -1;
        }) : ae.filter(function(J) {
          return Le.indexOf(J) !== -1;
        });
      if (ce.not) {
        var Ee = {};
        return Le.forEach(function(J) {
          Ee[J] = true;
        }), ae.filter(function(J) {
          return !Ee[J];
        });
      }
      return ae.concat(Le);
    }, []);
  }
  function he(z) {
    return typeof z > "u" && (z = {}), typeof z.path > "u" && (z.path = f2.resolve ? f2.resolve(".") : "."), z;
  }
  function de(z, W) {
    if (typeof z > "u" || z === null) {
      var ae = H.loadConfig(W);
      ae ? z = ae : z = H.defaults;
    }
    return z;
  }
  function Pe(z) {
    if (!(typeof z == "string" || Array.isArray(z)))
      throw new g("Browser queries must be an array or string. Got " + typeof z + ".");
  }
  var we = {};
  function H(z, W) {
    W = he(W), z = de(z, W), Pe(z);
    var ae = {
      ignoreUnknownVersions: W.ignoreUnknownVersions,
      dangerousExtend: W.dangerousExtend,
      mobileToDesktop: W.mobileToDesktop,
      path: W.path,
      env: W.env
    };
    x.oldDataWarning(H.data);
    var ce = x.getStat(W, H.data);
    if (ce) {
      ae.customUsage = {};
      for (var xe in ce)
        m(ae.customUsage, xe, ce[xe]);
    }
    var Se = JSON.stringify([z, ae]);
    if (we[Se])
      return we[Se];
    var Le = _(fe(z, ae)).sort(function(Ee, J) {
      if (Ee = Ee.split(" "), J = J.split(" "), Ee[0] === J[0]) {
        var me = Ee[1].split("-")[0], ke = J[1].split("-")[0];
        return M(ke.split("."), me.split("."));
      } else
        return B(Ee[0], J[0]);
    });
    return process.env.BROWSERSLIST_DISABLE_CACHE || (we[Se] = Le), Le;
  }
  H.parse = function(z, W) {
    return W = he(W), z = de(z, W), Pe(z), P(pe, z);
  }, H.cache = {}, H.data = {}, H.usage = {
    global: {},
    custom: null
  }, H.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"], H.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  }, H.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    op_mob: "opera",
    android: "chrome"
  }, H.versionAliases = {}, H.clearCaches = x.clearCaches, H.parseConfig = x.parseConfig, H.readConfig = x.readConfig, H.findConfig = x.findConfig, H.loadConfig = x.loadConfig, H.coverage = function(z, W) {
    var ae;
    if (typeof W > "u")
      ae = H.usage.global;
    else if (W === "my stats") {
      var ce = {};
      ce.path = f2.resolve ? f2.resolve(".") : ".";
      var xe = x.getStat(ce);
      if (!xe)
        throw new g("Custom usage statistics was not provided");
      ae = {};
      for (var Se in xe)
        m(ae, Se, xe[Se]);
    } else if (typeof W == "string")
      W.length > 2 ? W = W.toLowerCase() : W = W.toUpperCase(), x.loadCountry(H.usage, W, H.data), ae = H.usage[W];
    else {
      "dataByBrowser" in W && (W = W.dataByBrowser), ae = {};
      for (var Le in W)
        for (var Ee in W[Le])
          ae[Le + " " + Ee] = W[Le][Ee];
    }
    return z.reduce(function(J, me) {
      var ke = ae[me];
      return ke === void 0 && (ke = ae[me.replace(/ \S+$/, " 0")]), J + (ke || 0);
    }, 0);
  };
  function te(z, W) {
    var ae = H.nodeVersions.filter(function(ce) {
      return S(ce, W.version);
    });
    if (ae.length === 0) {
      if (z.ignoreUnknownVersions)
        return [];
      throw new g("Unknown version " + W.version + " of Node.js");
    }
    return ["node " + ae[ae.length - 1]];
  }
  function Ie(z, W) {
    var ae = parseInt(W.year), ce = parseInt(W.month || "01") - 1, xe = parseInt(W.day || "01");
    return Q(Date.UTC(ae, ce, xe, 0, 0, 0), z);
  }
  function Te(z, W) {
    var ae = parseFloat(W.coverage), ce = H.usage.global;
    if (W.place)
      if (W.place.match(/^my\s+stats$/i)) {
        if (!z.customUsage)
          throw new g("Custom usage statistics was not provided");
        ce = z.customUsage;
      } else {
        var xe;
        W.place.length === 2 ? xe = W.place.toUpperCase() : xe = W.place.toLowerCase(), x.loadCountry(H.usage, xe, H.data), ce = H.usage[xe];
      }
    for (var Se = Object.keys(ce).sort(function(ke, _e) {
      return ce[_e] - ce[ke];
    }), Le = 0, Ee = [], J, me = 0; me < Se.length && (J = Se[me], !(ce[J] === 0 || (Le += ce[J], Ee.push(J), Le >= ae))); me++)
      ;
    return Ee;
  }
  var pe = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: function(z, W) {
        return Object.keys(n).reduce(function(ae, ce) {
          var xe = K(ce, z);
          if (!xe)
            return ae;
          var Se = D(xe.released, W.versions);
          return Se = Se.map(I(xe.name)), xe.name === "android" && (Se = oe(Se, W.versions, z)), ae.concat(Se);
        }, []);
      }
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: function(z, W) {
        return Object.keys(n).reduce(function(ae, ce) {
          var xe = K(ce, z);
          if (!xe)
            return ae;
          var Se = xe.released.slice(-W.versions);
          return Se = Se.map(I(xe.name)), xe.name === "android" && (Se = oe(Se, W.versions, z)), ae.concat(Se);
        }, []);
      }
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: function(z, W) {
        var ae = D(Object.keys(p), W.versions);
        return ae.map(function(ce) {
          return "chrome " + p[ce];
        });
      }
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: function(z, W) {
        return D(H.nodeVersions, W.versions).map(function(ae) {
          return "node " + ae;
        });
      }
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: function(z, W) {
        var ae = F(W.browser, z), ce = D(ae.released, W.versions), xe = ce.map(I(ae.name));
        return ae.name === "android" && (xe = oe(xe, W.versions, z)), xe;
      }
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: function(z, W) {
        return Object.keys(p).slice(-W.versions).map(function(ae) {
          return "chrome " + p[ae];
        });
      }
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: function(z, W) {
        return H.nodeVersions.slice(-W.versions).map(function(ae) {
          return "node " + ae;
        });
      }
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: function(z, W) {
        var ae = F(W.browser, z), ce = ae.released.slice(-W.versions).map(I(ae.name));
        return ae.name === "android" && (ce = oe(ce, W.versions, z)), ce;
      }
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: function(z) {
        return Object.keys(n).reduce(function(W, ae) {
          var ce = K(ae, z);
          if (!ce)
            return W;
          var xe = ce.versions.filter(function(Se) {
            return ce.released.indexOf(Se) === -1;
          });
          return xe = xe.map(I(ce.name)), W.concat(xe);
        }, []);
      }
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: function() {
        return [];
      }
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: function(z, W) {
        var ae = F(W.browser, z);
        return ae.versions.filter(function(ce) {
          return ae.released.indexOf(ce) === -1;
        }).map(I(ae.name));
      }
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
      select: function(z, W) {
        return Q(Date.now() - y * W.years, z);
      }
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: Ie
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: Ie
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: Ie
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: function(z, W) {
        var ae = parseFloat(W.popularity), ce = H.usage.global;
        return Object.keys(ce).reduce(function(xe, Se) {
          return W.sign === ">" ? ce[Se] > ae && xe.push(Se) : W.sign === "<" ? ce[Se] < ae && xe.push(Se) : W.sign === "<=" ? ce[Se] <= ae && xe.push(Se) : ce[Se] >= ae && xe.push(Se), xe;
        }, []);
      }
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: function(z, W) {
        var ae = parseFloat(W.popularity);
        if (!z.customUsage)
          throw new g("Custom usage statistics was not provided");
        var ce = z.customUsage;
        return Object.keys(ce).reduce(function(xe, Se) {
          var Le = ce[Se];
          return Le == null || (W.sign === ">" ? Le > ae && xe.push(Se) : W.sign === "<" ? Le < ae && xe.push(Se) : W.sign === "<=" ? Le <= ae && xe.push(Se) : Le >= ae && xe.push(Se)), xe;
        }, []);
      }
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: function(z, W) {
        var ae = parseFloat(W.popularity), ce = x.loadStat(z, W.config, H.data);
        if (ce) {
          z.customUsage = {};
          for (var xe in ce)
            m(z.customUsage, xe, ce[xe]);
        }
        if (!z.customUsage)
          throw new g("Custom usage statistics was not provided");
        var Se = z.customUsage;
        return Object.keys(Se).reduce(function(Le, Ee) {
          var J = Se[Ee];
          return J == null || (W.sign === ">" ? J > ae && Le.push(Ee) : W.sign === "<" ? J < ae && Le.push(Ee) : W.sign === "<=" ? J <= ae && Le.push(Ee) : J >= ae && Le.push(Ee)), Le;
        }, []);
      }
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: function(z, W) {
        var ae = parseFloat(W.popularity), ce = W.place;
        ce.length === 2 ? ce = ce.toUpperCase() : ce = ce.toLowerCase(), x.loadCountry(H.usage, ce, H.data);
        var xe = H.usage[ce];
        return Object.keys(xe).reduce(function(Se, Le) {
          var Ee = xe[Le];
          return Ee == null || (W.sign === ">" ? Ee > ae && Se.push(Le) : W.sign === "<" ? Ee < ae && Se.push(Le) : W.sign === "<=" ? Ee <= ae && Se.push(Le) : Ee >= ae && Se.push(Le)), Se;
        }, []);
      }
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: Te
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: Te
    },
    supports: {
      matches: ["feature"],
      regexp: /^supports\s+([\w-]+)$/,
      select: function(z, W) {
        x.loadFeature(H.cache, W.feature);
        var ae = H.cache[W.feature];
        return Object.keys(ae).reduce(function(ce, xe) {
          var Se = ae[xe];
          return (Se.indexOf("y") >= 0 || Se.indexOf("a") >= 0) && ce.push(xe), ce;
        }, []);
      }
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function(z, W) {
        var ae = C(W.from), ce = C(W.to), xe = parseFloat(W.from), Se = parseFloat(W.to);
        if (!p[ae])
          throw new g("Unknown version " + xe + " of electron");
        if (!p[ce])
          throw new g("Unknown version " + Se + " of electron");
        return Object.keys(p).filter(function(Le) {
          var Ee = parseFloat(Le);
          return Ee >= xe && Ee <= Se;
        }).map(function(Le) {
          return "chrome " + p[Le];
        });
      }
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function(z, W) {
        return H.nodeVersions.filter(j(">=", W.from)).filter(j("<=", W.to)).map(function(ae) {
          return "node " + ae;
        });
      }
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: function(z, W) {
        var ae = F(W.browser, z), ce = parseFloat(ne(ae, W.from) || W.from), xe = parseFloat(ne(ae, W.to) || W.to);
        function Se(Le) {
          var Ee = parseFloat(Le);
          return Ee >= ce && Ee <= xe;
        }
        return ae.released.filter(Se).map(I(ae.name));
      }
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: function(z, W) {
        var ae = C(W.version);
        return Object.keys(p).filter(L(W.sign, ae)).map(function(ce) {
          return "chrome " + p[ce];
        });
      }
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: function(z, W) {
        return H.nodeVersions.filter(R(W.sign, W.version)).map(function(ae) {
          return "node " + ae;
        });
      }
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: function(z, W) {
        var ae = W.version, ce = F(W.browser, z), xe = H.versionAliases[ce.name][ae];
        return xe && (ae = xe), ce.released.filter(L(W.sign, ae)).map(function(Se) {
          return ce.name + " " + Se;
        });
      }
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: function() {
        return ["firefox 91", "firefox 102"];
      }
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: function() {
        return ["op_mini all"];
      }
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: function(z, W) {
        var ae = C(W.version), ce = p[ae];
        if (!ce)
          throw new g("Unknown version " + W.version + " of electron");
        return ["chrome " + ce];
      }
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: te
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: te
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: te
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: function(z) {
        return [x.currentNode(fe, z)];
      }
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: function(z) {
        var W = Date.now(), ae = Object.keys(h).filter(function(ce) {
          return W < Date.parse(h[ce].end) && W > Date.parse(h[ce].start) && v(ce);
        }).map(function(ce) {
          return "node " + ce.slice(1);
        });
        return fe(ae, z);
      }
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: function() {
        return ["safari 5"];
      }
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: function() {
        return ["safari 6"];
      }
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: function(z, W) {
        var ae = W.version;
        /^tp$/i.test(ae) && (ae = "TP");
        var ce = F(W.browser, z), xe = ne(ce, ae);
        if (xe)
          ae = xe;
        else if (ae.indexOf(".") === -1 ? xe = ae + ".0" : xe = ae.replace(/\.0$/, ""), xe = ne(ce, xe), xe)
          ae = xe;
        else {
          if (z.ignoreUnknownVersions)
            return [];
          throw new g("Unknown version " + ae + " of " + W.browser);
        }
        return [ce.name + " " + ae];
      }
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      select: function(z) {
        return H(void 0, z);
      }
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      select: function(z, W) {
        return fe(x.loadQueries(z, W.config), z);
      }
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: function(z) {
        return fe(H.defaults, z);
      }
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: function(z) {
        var W = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return fe(W, z);
      }
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: function(z, W) {
        throw K(W.query, z) ? new g("Specify versions in Browserslist query for browser " + W.query) : le(W.query);
      }
    }
  };
  return function() {
    for (var z in n) {
      var W = n[z];
      H.data[z] = {
        name: z,
        versions: T(n[z].versions),
        released: T(n[z].versions.slice(0, -3)),
        releaseDate: n[z].release_date
      }, m(H.usage.global, z, W.usage_global), H.versionAliases[z] = {};
      for (var ae = 0; ae < W.versions.length; ae++) {
        var ce = W.versions[ae];
        if (!!ce && ce.indexOf("-") !== -1)
          for (var xe = ce.split("-"), Se = 0; Se < xe.length; Se++)
            H.versionAliases[z][xe[Se]] = ce;
      }
    }
    H.versionAliases.op_mob[59] = "58", H.nodeVersions = s.map(function(Le) {
      return Le.version;
    });
  }(), Pc = H, Pc;
}
var Sc = {};
var Ca = {};
var pl = {};
var Cm;
function A0() {
  if (Cm)
    return pl;
  Cm = 1, Object.defineProperty(pl, "__esModule", {
    value: true
  }), pl.findSuggestion = h;
  const {
    min: s
  } = Math;
  function n(f2, p) {
    let g = [], P = [], x, y;
    const A = f2.length, S = p.length;
    if (!A)
      return S;
    if (!S)
      return A;
    for (y = 0; y <= S; y++)
      g[y] = y;
    for (x = 1; x <= A; x++) {
      for (P = [x], y = 1; y <= S; y++)
        P[y] = f2[x - 1] === p[y - 1] ? g[y - 1] : s(g[y - 1], g[y], P[y - 1]) + 1;
      g = P;
    }
    return P[S];
  }
  function h(f2, p) {
    const g = p.map((P) => n(P, f2));
    return p[g.indexOf(s(...g))];
  }
  return pl;
}
var wm;
function dP() {
  if (wm)
    return Ca;
  wm = 1, Object.defineProperty(Ca, "__esModule", {
    value: true
  }), Ca.OptionValidator = void 0;
  var s = A0();
  class n {
    constructor(f2) {
      this.descriptor = f2;
    }
    validateTopLevelOptions(f2, p) {
      const g = Object.keys(p);
      for (const P of Object.keys(f2))
        if (!g.includes(P))
          throw new Error(this.formatMessage(`'${P}' is not a valid top-level option.
	- Did you mean '${(0, s.findSuggestion)(P, g)}'?`));
    }
    validateBooleanOption(f2, p, g) {
      return p === void 0 ? g : (this.invariant(typeof p == "boolean", `'${f2}' option must be a boolean.`), p);
    }
    validateStringOption(f2, p, g) {
      return p === void 0 ? g : (this.invariant(typeof p == "string", `'${f2}' option must be a string.`), p);
    }
    invariant(f2, p) {
      if (!f2)
        throw new Error(this.formatMessage(p));
    }
    formatMessage(f2) {
      return `${this.descriptor}: ${f2}`;
    }
  }
  return Ca.OptionValidator = n, Ca;
}
var Im;
function C0() {
  return Im || (Im = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "OptionValidator", {
      enumerable: true,
      get: function() {
        return n.OptionValidator;
      }
    }), Object.defineProperty(s, "findSuggestion", {
      enumerable: true,
      get: function() {
        return h.findSuggestion;
      }
    });
    var n = dP(), h = A0();
  }(Sc)), Sc;
}
var Ec = { exports: {} };
var mP = {
  "es6.module": {
    chrome: "61",
    and_chr: "61",
    edge: "16",
    firefox: "60",
    and_ff: "60",
    node: "13.2.0",
    opera: "48",
    op_mob: "48",
    safari: "10.1",
    ios: "10.3",
    samsung: "8.2",
    android: "61",
    electron: "2.0",
    ios_saf: "10.3"
  }
};
var Nm;
function yP() {
  return Nm || (Nm = 1, function(s) {
    s.exports = mP;
  }(Ec)), Ec.exports;
}
var Qi = {};
var mn = {};
var km;
function op() {
  if (km)
    return mn;
  km = 1, Object.defineProperty(mn, "__esModule", {
    value: true
  }), mn.unreleasedLabels = mn.browserNameMap = void 0;
  const s = {
    safari: "tp"
  };
  mn.unreleasedLabels = s;
  const n = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    op_mob: "opera",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
  return mn.browserNameMap = n, mn;
}
var Om;
function lp() {
  if (Om)
    return Qi;
  Om = 1, Object.defineProperty(Qi, "__esModule", {
    value: true
  }), Qi.getHighestUnreleased = A, Qi.getLowestImplementedVersion = S, Qi.getLowestUnreleased = y, Qi.isUnreleasedVersion = x, Qi.semverMin = g, Qi.semverify = P;
  var s = Hn(), n = C0(), h = op();
  const f2 = /^(\d+|\d+.\d+)$/, p = new n.OptionValidator("@babel/helper-compilation-targets");
  function g(v, T) {
    return v && s.lt(v, T) ? v : T;
  }
  function P(v) {
    if (typeof v == "string" && s.valid(v))
      return v;
    p.invariant(typeof v == "number" || typeof v == "string" && f2.test(v), `'${v}' is not a valid version`);
    const T = v.toString().split(".");
    for (; T.length < 3; )
      T.push("0");
    return T.join(".");
  }
  function x(v, T) {
    const C = h.unreleasedLabels[T];
    return !!C && C === v.toString().toLowerCase();
  }
  function y(v, T, C) {
    const I = h.unreleasedLabels[C];
    return v === I ? T : T === I ? v : g(v, T);
  }
  function A(v, T, C) {
    return y(v, T, C) === v ? T : v;
  }
  function S(v, T) {
    const C = v[T];
    return !C && T === "android" ? v.chrome : C;
  }
  return Qi;
}
var wa = {};
var Dm;
function bP() {
  if (Dm)
    return wa;
  Dm = 1, Object.defineProperty(wa, "__esModule", {
    value: true
  }), wa.TargetNames = void 0;
  const s = {
    node: "node",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino"
  };
  return wa.TargetNames = s, wa;
}
var Ia = {};
var Lm;
function w0() {
  if (Lm)
    return Ia;
  Lm = 1, Object.defineProperty(Ia, "__esModule", {
    value: true
  }), Ia.prettifyTargets = f2, Ia.prettifyVersion = h;
  var s = Hn(), n = op();
  function h(p) {
    if (typeof p != "string")
      return p;
    const g = [s.major(p)], P = s.minor(p), x = s.patch(p);
    return (P || x) && g.push(P), x && g.push(x), g.join(".");
  }
  function f2(p) {
    return Object.keys(p).reduce((g, P) => {
      let x = p[P];
      const y = n.unreleasedLabels[P];
      return typeof x == "string" && y !== x && (x = h(x)), g[P] = x, g;
    }, {});
  }
  return Ia;
}
var fl = {};
var Mm;
function gP() {
  if (Mm)
    return fl;
  Mm = 1, Object.defineProperty(fl, "__esModule", {
    value: true
  }), fl.getInclusionReasons = f2;
  var s = Hn(), n = w0(), h = lp();
  function f2(p, g, P) {
    const x = P[p] || {};
    return Object.keys(g).reduce((y, A) => {
      const S = (0, h.getLowestImplementedVersion)(x, A), v = g[A];
      if (!S)
        y[A] = (0, n.prettifyVersion)(v);
      else {
        const T = (0, h.isUnreleasedVersion)(S, A);
        !(0, h.isUnreleasedVersion)(v, A) && (T || s.lt(v.toString(), (0, h.semverify)(S))) && (y[A] = (0, n.prettifyVersion)(v));
      }
      return y;
    }, {});
  }
  return fl;
}
var Fn = {};
var vc = { exports: {} };
var TP = {
  "proposal-class-static-block": {
    chrome: "94",
    opera: "80",
    edge: "94",
    firefox: "93",
    node: "16.11",
    electron: "15.0"
  },
  "proposal-private-property-in-object": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "90",
    safari: "15",
    node: "16.9",
    ios: "15",
    electron: "13.0"
  },
  "proposal-class-properties": {
    chrome: "74",
    opera: "62",
    edge: "79",
    firefox: "90",
    safari: "14.1",
    node: "12",
    ios: "15",
    samsung: "11",
    electron: "6.0"
  },
  "proposal-private-methods": {
    chrome: "84",
    opera: "70",
    edge: "84",
    firefox: "90",
    safari: "15",
    node: "14.6",
    ios: "15",
    samsung: "14",
    electron: "10.0"
  },
  "proposal-numeric-separator": {
    chrome: "75",
    opera: "62",
    edge: "79",
    firefox: "70",
    safari: "13",
    node: "12.5",
    ios: "13",
    samsung: "11",
    rhino: "1.7.14",
    electron: "6.0"
  },
  "proposal-logical-assignment-operators": {
    chrome: "85",
    opera: "71",
    edge: "85",
    firefox: "79",
    safari: "14",
    node: "15",
    ios: "14",
    samsung: "14",
    electron: "10.0"
  },
  "proposal-nullish-coalescing-operator": {
    chrome: "80",
    opera: "67",
    edge: "80",
    firefox: "72",
    safari: "13.1",
    node: "14",
    ios: "13.4",
    samsung: "13",
    electron: "8.0"
  },
  "proposal-optional-chaining": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "74",
    safari: "13.1",
    node: "16.9",
    ios: "13.4",
    electron: "13.0"
  },
  "proposal-json-strings": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "62",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "9",
    rhino: "1.7.14",
    electron: "3.0"
  },
  "proposal-optional-catch-binding": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "58",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "9",
    electron: "3.0"
  },
  "transform-parameters": {
    chrome: "49",
    opera: "36",
    edge: "18",
    firefox: "53",
    node: "6",
    samsung: "5",
    electron: "0.37"
  },
  "proposal-async-generator-functions": {
    chrome: "63",
    opera: "50",
    edge: "79",
    firefox: "57",
    safari: "12",
    node: "10",
    ios: "12",
    samsung: "8",
    electron: "3.0"
  },
  "proposal-object-rest-spread": {
    chrome: "60",
    opera: "47",
    edge: "79",
    firefox: "55",
    safari: "11.1",
    node: "8.3",
    ios: "11.3",
    samsung: "8",
    electron: "2.0"
  },
  "transform-dotall-regex": {
    chrome: "62",
    opera: "49",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "8.10",
    ios: "11.3",
    samsung: "8",
    electron: "3.0"
  },
  "proposal-unicode-property-regex": {
    chrome: "64",
    opera: "51",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "9",
    electron: "3.0"
  },
  "transform-named-capturing-groups-regex": {
    chrome: "64",
    opera: "51",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "10",
    ios: "11.3",
    samsung: "9",
    electron: "3.0"
  },
  "transform-async-to-generator": {
    chrome: "55",
    opera: "42",
    edge: "15",
    firefox: "52",
    safari: "11",
    node: "7.6",
    ios: "11",
    samsung: "6",
    electron: "1.6"
  },
  "transform-exponentiation-operator": {
    chrome: "52",
    opera: "39",
    edge: "14",
    firefox: "52",
    safari: "10.1",
    node: "7",
    ios: "10.3",
    samsung: "6",
    rhino: "1.7.14",
    electron: "1.3"
  },
  "transform-template-literals": {
    chrome: "41",
    opera: "28",
    edge: "13",
    firefox: "34",
    safari: "13",
    node: "4",
    ios: "13",
    samsung: "3.4",
    electron: "0.21"
  },
  "transform-literals": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "53",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    electron: "0.30"
  },
  "transform-function-name": {
    chrome: "51",
    opera: "38",
    edge: "79",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    electron: "1.2"
  },
  "transform-arrow-functions": {
    chrome: "47",
    opera: "34",
    edge: "13",
    firefox: "43",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    rhino: "1.7.13",
    electron: "0.36"
  },
  "transform-block-scoped-functions": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "46",
    safari: "10",
    node: "4",
    ie: "11",
    ios: "10",
    samsung: "3.4",
    electron: "0.21"
  },
  "transform-classes": {
    chrome: "46",
    opera: "33",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    electron: "0.36"
  },
  "transform-object-super": {
    chrome: "46",
    opera: "33",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    electron: "0.36"
  },
  "transform-shorthand-properties": {
    chrome: "43",
    opera: "30",
    edge: "12",
    firefox: "33",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    rhino: "1.7.14",
    electron: "0.27"
  },
  "transform-duplicate-keys": {
    chrome: "42",
    opera: "29",
    edge: "12",
    firefox: "34",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "3.4",
    electron: "0.25"
  },
  "transform-computed-properties": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "34",
    safari: "7.1",
    node: "4",
    ios: "8",
    samsung: "4",
    electron: "0.30"
  },
  "transform-for-of": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    electron: "1.2"
  },
  "transform-sticky-regex": {
    chrome: "49",
    opera: "36",
    edge: "13",
    firefox: "3",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    electron: "0.37"
  },
  "transform-unicode-escapes": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "53",
    safari: "9",
    node: "4",
    ios: "9",
    samsung: "4",
    electron: "0.30"
  },
  "transform-unicode-regex": {
    chrome: "50",
    opera: "37",
    edge: "13",
    firefox: "46",
    safari: "12",
    node: "6",
    ios: "12",
    samsung: "5",
    electron: "1.1"
  },
  "transform-spread": {
    chrome: "46",
    opera: "33",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    electron: "0.36"
  },
  "transform-destructuring": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    ios: "10",
    samsung: "5",
    electron: "1.2"
  },
  "transform-block-scoping": {
    chrome: "49",
    opera: "36",
    edge: "14",
    firefox: "51",
    safari: "11",
    node: "6",
    ios: "11",
    samsung: "5",
    electron: "0.37"
  },
  "transform-typeof-symbol": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "0.12",
    ios: "9",
    samsung: "3",
    rhino: "1.7.13",
    electron: "0.20"
  },
  "transform-new-target": {
    chrome: "46",
    opera: "33",
    edge: "14",
    firefox: "41",
    safari: "10",
    node: "5",
    ios: "10",
    samsung: "5",
    electron: "0.36"
  },
  "transform-regenerator": {
    chrome: "50",
    opera: "37",
    edge: "13",
    firefox: "53",
    safari: "10",
    node: "6",
    ios: "10",
    samsung: "5",
    electron: "1.1"
  },
  "transform-member-expression-literals": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "2",
    safari: "5.1",
    node: "0.4",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    electron: "0.20"
  },
  "transform-property-literals": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "2",
    safari: "5.1",
    node: "0.4",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    electron: "0.20"
  },
  "transform-reserved-words": {
    chrome: "13",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.6",
    ie: "9",
    android: "4.4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    electron: "0.20"
  },
  "proposal-export-namespace-from": {
    chrome: "72",
    and_chr: "72",
    edge: "79",
    firefox: "80",
    and_ff: "80",
    node: "13.2",
    opera: "60",
    op_mob: "51",
    samsung: "11.0",
    android: "72",
    electron: "5.0"
  }
};
var Bm;
function xP() {
  return Bm || (Bm = 1, function(s) {
    s.exports = TP;
  }(vc)), vc.exports;
}
var _m;
function PP() {
  if (_m)
    return Fn;
  _m = 1, Object.defineProperty(Fn, "__esModule", {
    value: true
  }), Fn.default = g, Fn.isRequired = p, Fn.targetsSupported = f2;
  var s = Hn(), n = xP(), h = lp();
  function f2(P, x) {
    const y = Object.keys(P);
    return y.length === 0 ? false : y.filter((S) => {
      const v = (0, h.getLowestImplementedVersion)(x, S);
      if (!v)
        return true;
      const T = P[S];
      if ((0, h.isUnreleasedVersion)(T, S))
        return false;
      if ((0, h.isUnreleasedVersion)(v, S))
        return true;
      if (!s.valid(T.toString()))
        throw new Error(`Invalid version passed for target "${S}": "${T}". Versions must be in semver format (major.minor.patch)`);
      return s.gt((0, h.semverify)(v), T.toString());
    }).length === 0;
  }
  function p(P, x, {
    compatData: y = n,
    includes: A,
    excludes: S
  } = {}) {
    return S != null && S.has(P) ? false : A != null && A.has(P) ? true : !f2(x, y[P]);
  }
  function g(P, x, y, A, S, v, T) {
    const C = /* @__PURE__ */ new Set(), I = {
      compatData: P,
      includes: x,
      excludes: y
    };
    for (const N in P)
      if (p(N, A, I))
        C.add(N);
      else if (T) {
        const D = T.get(N);
        D && C.add(D);
      }
    return S && S.forEach((N) => !y.has(N) && C.add(N)), v && v.forEach((N) => !x.has(N) && C.delete(N)), C;
  }
  return Fn;
}
var Fm;
function I0() {
  return Fm || (Fm = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), Object.defineProperty(s, "TargetNames", {
      enumerable: true,
      get: function() {
        return P.TargetNames;
      }
    }), s.default = B, Object.defineProperty(s, "filterItems", {
      enumerable: true,
      get: function() {
        return A.default;
      }
    }), Object.defineProperty(s, "getInclusionReasons", {
      enumerable: true,
      get: function() {
        return y.getInclusionReasons;
      }
    }), s.isBrowsersQueryValid = C, Object.defineProperty(s, "isRequired", {
      enumerable: true,
      get: function() {
        return A.isRequired;
      }
    }), Object.defineProperty(s, "prettifyTargets", {
      enumerable: true,
      get: function() {
        return x.prettifyTargets;
      }
    }), Object.defineProperty(s, "unreleasedLabels", {
      enumerable: true,
      get: function() {
        return g.unreleasedLabels;
      }
    });
    var n = hP(), h = C0(), f2 = yP(), p = lp(), g = op(), P = bP(), x = w0(), y = gP(), A = PP();
    const S = f2["es6.module"], v = new h.OptionValidator("@babel/helper-compilation-targets");
    function T(M) {
      const j = Object.keys(P.TargetNames);
      for (const $ of Object.keys(M))
        if (!($ in P.TargetNames))
          throw new Error(v.formatMessage(`'${$}' is not a valid target
		- Did you mean '${(0, h.findSuggestion)($, j)}'?`));
      return M;
    }
    function C(M) {
      return typeof M == "string" || Array.isArray(M) && M.every((j) => typeof j == "string");
    }
    function I(M) {
      return v.invariant(M === void 0 || C(M), `'${String(M)}' is not a valid browserslist query`), M;
    }
    function N(M) {
      return M.reduce((j, $) => {
        const [k, ne] = $.split(" "), Q = g.browserNameMap[k];
        if (!Q)
          return j;
        try {
          const q = ne.split("-")[0].toLowerCase(), ee = (0, p.isUnreleasedVersion)(q, Q);
          if (!j[Q])
            return j[Q] = ee ? q : (0, p.semverify)(q), j;
          const K = j[Q], G = (0, p.isUnreleasedVersion)(K, Q);
          if (G && ee)
            j[Q] = (0, p.getLowestUnreleased)(K, q, Q);
          else if (G)
            j[Q] = (0, p.semverify)(q);
          else if (!G && !ee) {
            const V = (0, p.semverify)(q);
            j[Q] = (0, p.semverMin)(K, V);
          }
        } catch {
        }
        return j;
      }, {});
    }
    function D(M) {
      !M.length || (console.warn(`Warning, the following targets are using a decimal version:
`), M.forEach(({
        target: j,
        value: $
      }) => console.warn(`  ${j}: ${$}`)), console.warn(`
		We recommend using a string for minor/patch versions to avoid numbers like 6.10
		getting parsed as 6.1, which can lead to unexpected behavior.
		`));
    }
    function _(M, j) {
      try {
        return (0, p.semverify)(j);
      } catch {
        throw new Error(v.formatMessage(`'${j}' is not a valid value for 'targets.${M}'.`));
      }
    }
    function m(M) {
      const j = M === true || M === "current" ? process.versions.node : _("node", M);
      return ["node", j];
    }
    function L(M, j) {
      const $ = (0, p.isUnreleasedVersion)(j, M) ? j.toLowerCase() : _(M, j);
      return [M, $];
    }
    function R(M) {
      const j = Object.assign({}, M);
      return delete j.esmodules, delete j.browsers, j;
    }
    function O(M, j) {
      const $ = n(M, {
        mobileToDesktop: true,
        env: j
      });
      return N($);
    }
    function B(M = {}, j = {}) {
      var $, k;
      let {
        browsers: ne,
        esmodules: Q
      } = M;
      const {
        configPath: q = "."
      } = j;
      I(ne);
      const ee = R(M);
      let K = T(ee);
      const V = !!ne || Object.keys(K).length > 0, F = !j.ignoreBrowserslistConfig && !V;
      if (!ne && F && (ne = n.loadConfig({
        config: j.configFile,
        path: q,
        env: j.browserslistEnv
      }), ne == null && (ne = [])), Q && (Q !== "intersect" || !(($ = ne) != null && $.length)) && (ne = Object.keys(S).map((fe) => `${fe} >= ${S[fe]}`).join(", "), Q = false), (k = ne) != null && k.length) {
        const fe = O(ne, j.browserslistEnv);
        if (Q === "intersect")
          for (const he of Object.keys(fe)) {
            const de = fe[he], Pe = S[he];
            Pe ? fe[he] = (0, p.getHighestUnreleased)(de, (0, p.semverify)(Pe), he) : delete fe[he];
          }
        K = Object.assign(fe, K);
      }
      const le = {}, oe = [];
      for (const fe of Object.keys(K).sort()) {
        const he = K[fe];
        typeof he == "number" && he % 1 !== 0 && oe.push({
          target: fe,
          value: he
        });
        const [de, Pe] = fe === "node" ? m(he) : L(fe, he);
        Pe && (le[de] = Pe);
      }
      return D(oe), le;
    }
  }(cc)), cc;
}
Object.defineProperty(Ua, "__esModule", {
  value: true
});
Ua.resolveBrowserslistConfigFile = SP;
Ua.resolveTargets = EP;
function N0() {
  const s = I0();
  return N0 = function() {
    return s;
  }, s;
}
function SP(s, n) {
}
function EP(s, n) {
  const h = s.targets;
  let f2;
  return typeof h == "string" || Array.isArray(h) ? f2 = {
    browsers: h
  } : h && ("esmodules" in h ? f2 = Object.assign({}, h, {
    esmodules: "intersect"
  }) : f2 = h), (0, N0().default)(f2, {
    ignoreBrowserslistConfig: true,
    browserslistEnv: s.browserslistEnv
  });
}
var jm;
function k0() {
  if (jm)
    return _n;
  jm = 1, Object.defineProperty(_n, "__esModule", {
    value: true
  }), _n.createCachedDescriptors = y, _n.createDescriptor = L, _n.createUncachedDescriptors = A;
  function s() {
    const O = Wi();
    return s = function() {
      return O;
    }, O;
  }
  var n = Ir, h = Rl(), f2 = Hi, p = Ua;
  function g(O, B) {
    return O.name === B.name && O.value === B.value && O.options === B.options && O.dirname === B.dirname && O.alias === B.alias && O.ownPass === B.ownPass && (O.file && O.file.request) === (B.file && B.file.request) && (O.file && O.file.resolved) === (B.file && B.file.resolved);
  }
  function* P(O) {
    return O;
  }
  function x(O, B) {
    return typeof O.browserslistConfigFile == "string" && (O.browserslistConfigFile = (0, p.resolveBrowserslistConfigFile)(O.browserslistConfigFile, B)), O;
  }
  function y(O, B, M) {
    const {
      plugins: j,
      presets: $,
      passPerPreset: k
    } = B;
    return {
      options: x(B, O),
      plugins: j ? () => C(j, O)(M) : () => P([]),
      presets: $ ? () => v($, O)(M)(!!k) : () => P([])
    };
  }
  function A(O, B, M) {
    let j, $;
    return {
      options: x(B, O),
      *plugins() {
        return j || (j = yield* _(B.plugins || [], O, M)), j;
      },
      *presets() {
        return $ || ($ = yield* D(B.presets || [], O, M, !!B.passPerPreset)), $;
      }
    };
  }
  const S = /* @__PURE__ */ new WeakMap(), v = (0, f2.makeWeakCacheSync)((O, B) => {
    const M = B.using((j) => j);
    return (0, f2.makeStrongCacheSync)((j) => (0, f2.makeStrongCache)(function* ($) {
      return (yield* D(O, M, j, $)).map((ne) => N(S, ne));
    }));
  }), T = /* @__PURE__ */ new WeakMap(), C = (0, f2.makeWeakCacheSync)((O, B) => {
    const M = B.using((j) => j);
    return (0, f2.makeStrongCache)(function* (j) {
      return (yield* _(O, M, j)).map((k) => N(T, k));
    });
  }), I = {};
  function N(O, B) {
    const {
      value: M,
      options: j = I
    } = B;
    if (j === false)
      return B;
    let $ = O.get(M);
    $ || ($ = /* @__PURE__ */ new WeakMap(), O.set(M, $));
    let k = $.get(j);
    if (k || (k = [], $.set(j, k)), k.indexOf(B) === -1) {
      const ne = k.filter((Q) => g(Q, B));
      if (ne.length > 0)
        return ne[0];
      k.push(B);
    }
    return B;
  }
  function* D(O, B, M, j) {
    return yield* m("preset", O, B, M, j);
  }
  function* _(O, B, M) {
    return yield* m("plugin", O, B, M);
  }
  function* m(O, B, M, j, $) {
    const k = yield* s().all(B.map((ne, Q) => L(ne, M, {
      type: O,
      alias: `${j}$${Q}`,
      ownPass: !!$
    })));
    return R(k), k;
  }
  function* L(O, B, {
    type: M,
    alias: j,
    ownPass: $
  }) {
    const k = (0, h.getItemDescriptor)(O);
    if (k)
      return k;
    let ne, Q, q = O;
    Array.isArray(q) && (q.length === 3 ? [q, Q, ne] = q : [q, Q] = q);
    let ee, K = null;
    if (typeof q == "string") {
      if (typeof M != "string")
        throw new Error("To resolve a string-based item, the type of item must be given");
      const G = M === "plugin" ? n.loadPlugin : n.loadPreset, V = q;
      ({
        filepath: K,
        value: q
      } = yield* G(q, B)), ee = {
        request: V,
        resolved: K
      };
    }
    if (!q)
      throw new Error(`Unexpected falsy value: ${String(q)}`);
    if (typeof q == "object" && q.__esModule)
      if (q.default)
        q = q.default;
      else
        throw new Error("Must export a default export when using ES6 modules.");
    if (typeof q != "object" && typeof q != "function")
      throw new Error(`Unsupported format: ${typeof q}. Expected an object or a function.`);
    if (K !== null && typeof q == "object" && q)
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${K}`);
    return {
      name: ne,
      alias: K || j,
      value: q,
      options: Q,
      dirname: B,
      ownPass: $,
      file: ee
    };
  }
  function R(O) {
    const B = /* @__PURE__ */ new Map();
    for (const M of O) {
      if (typeof M.value != "function")
        continue;
      let j = B.get(M.value);
      if (j || (j = /* @__PURE__ */ new Set(), B.set(M.value, j)), j.has(M.name)) {
        const $ = O.filter((k) => k.value === M.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify($, null, 2)}`].join(`
`));
      }
      j.add(M.name);
    }
  }
  return _n;
}
var Rm;
function Rl() {
  if (Rm)
    return Bn;
  Rm = 1, Object.defineProperty(Bn, "__esModule", {
    value: true
  }), Bn.createConfigItem = f2, Bn.createItemFromDescriptor = h, Bn.getItemDescriptor = p;
  function s() {
    const x = an();
    return s = function() {
      return x;
    }, x;
  }
  var n = k0();
  function h(x) {
    return new P(x);
  }
  function* f2(x, {
    dirname: y = ".",
    type: A
  } = {}) {
    const S = yield* (0, n.createDescriptor)(x, s().resolve(y), {
      type: A,
      alias: "programmatic item"
    });
    return h(S);
  }
  function p(x) {
    if (x != null && x[g])
      return x._descriptor;
  }
  const g = Symbol.for("@babel/core@7 - ConfigItem");
  class P {
    constructor(y) {
      this._descriptor = void 0, this[g] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = y, Object.defineProperty(this, "_descriptor", {
        enumerable: false
      }), Object.defineProperty(this, g, {
        enumerable: false
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }
  }
  return Object.freeze(P.prototype), Bn;
}
var Sn = {};
var yn = {};
var Ul = {};
Object.defineProperty(Ul, "__esModule", {
  value: true
});
Ul.default = void 0;
var vP = {
  auxiliaryComment: {
    message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
  },
  blacklist: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  breakConfig: {
    message: "This is not a necessary option in Babel 6"
  },
  experimental: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  externalHelpers: {
    message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
  },
  extra: {
    message: ""
  },
  jsxPragma: {
    message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
  },
  loose: {
    message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
  },
  metadataUsedHelpers: {
    message: "Not required anymore as this is enabled by default"
  },
  modules: {
    message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
  },
  nonStandard: {
    message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
  },
  optional: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  sourceMapName: {
    message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
  },
  stage: {
    message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
  },
  whitelist: {
    message: "Put the specific transforms you want in the `plugins` option"
  },
  resolveModuleSource: {
    version: 6,
    message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
  },
  metadata: {
    version: 6,
    message: "Generated plugin metadata is always included in the output result"
  },
  sourceMapTarget: {
    version: 6,
    message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
  }
};
Ul.default = vP;
var Ut = {};
var Um;
function O0() {
  if (Um)
    return Ut;
  Um = 1, Object.defineProperty(Ut, "__esModule", {
    value: true
  }), Ut.access = f2, Ut.assertArray = I, Ut.assertAssumptions = ne, Ut.assertBabelrcSearch = R, Ut.assertBoolean = T, Ut.assertCallerMetadata = y, Ut.assertCompact = P, Ut.assertConfigApplicableTest = _, Ut.assertConfigFileSearch = L, Ut.assertFunction = v, Ut.assertIgnoreList = N, Ut.assertInputSourceMap = A, Ut.assertObject = C, Ut.assertPluginList = O, Ut.assertRootMode = p, Ut.assertSourceMaps = g, Ut.assertSourceType = x, Ut.assertString = S, Ut.assertTargets = j, Ut.msg = h;
  function s() {
    const Q = I0();
    return s = function() {
      return Q;
    }, Q;
  }
  var n = $l();
  function h(Q) {
    switch (Q.type) {
      case "root":
        return "";
      case "env":
        return `${h(Q.parent)}.env["${Q.name}"]`;
      case "overrides":
        return `${h(Q.parent)}.overrides[${Q.index}]`;
      case "option":
        return `${h(Q.parent)}.${Q.name}`;
      case "access":
        return `${h(Q.parent)}[${JSON.stringify(Q.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${Q.type}`);
    }
  }
  function f2(Q, q) {
    return {
      type: "access",
      name: q,
      parent: Q
    };
  }
  function p(Q, q) {
    if (q !== void 0 && q !== "root" && q !== "upward" && q !== "upward-optional")
      throw new Error(`${h(Q)} must be a "root", "upward", "upward-optional" or undefined`);
    return q;
  }
  function g(Q, q) {
    if (q !== void 0 && typeof q != "boolean" && q !== "inline" && q !== "both")
      throw new Error(`${h(Q)} must be a boolean, "inline", "both", or undefined`);
    return q;
  }
  function P(Q, q) {
    if (q !== void 0 && typeof q != "boolean" && q !== "auto")
      throw new Error(`${h(Q)} must be a boolean, "auto", or undefined`);
    return q;
  }
  function x(Q, q) {
    if (q !== void 0 && q !== "module" && q !== "script" && q !== "unambiguous")
      throw new Error(`${h(Q)} must be "module", "script", "unambiguous", or undefined`);
    return q;
  }
  function y(Q, q) {
    const ee = C(Q, q);
    if (ee) {
      if (typeof ee.name != "string")
        throw new Error(`${h(Q)} set but does not contain "name" property string`);
      for (const K of Object.keys(ee)) {
        const G = f2(Q, K), V = ee[K];
        if (V != null && typeof V != "boolean" && typeof V != "string" && typeof V != "number")
          throw new Error(`${h(G)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return q;
  }
  function A(Q, q) {
    if (q !== void 0 && typeof q != "boolean" && (typeof q != "object" || !q))
      throw new Error(`${h(Q)} must be a boolean, object, or undefined`);
    return q;
  }
  function S(Q, q) {
    if (q !== void 0 && typeof q != "string")
      throw new Error(`${h(Q)} must be a string, or undefined`);
    return q;
  }
  function v(Q, q) {
    if (q !== void 0 && typeof q != "function")
      throw new Error(`${h(Q)} must be a function, or undefined`);
    return q;
  }
  function T(Q, q) {
    if (q !== void 0 && typeof q != "boolean")
      throw new Error(`${h(Q)} must be a boolean, or undefined`);
    return q;
  }
  function C(Q, q) {
    if (q !== void 0 && (typeof q != "object" || Array.isArray(q) || !q))
      throw new Error(`${h(Q)} must be an object, or undefined`);
    return q;
  }
  function I(Q, q) {
    if (q != null && !Array.isArray(q))
      throw new Error(`${h(Q)} must be an array, or undefined`);
    return q;
  }
  function N(Q, q) {
    const ee = I(Q, q);
    return ee && ee.forEach((K, G) => D(f2(Q, G), K)), ee;
  }
  function D(Q, q) {
    if (typeof q != "string" && typeof q != "function" && !(q instanceof RegExp))
      throw new Error(`${h(Q)} must be an array of string/Function/RegExp values, or undefined`);
    return q;
  }
  function _(Q, q) {
    if (q === void 0)
      return q;
    if (Array.isArray(q))
      q.forEach((ee, K) => {
        if (!m(ee))
          throw new Error(`${h(f2(Q, K))} must be a string/Function/RegExp.`);
      });
    else if (!m(q))
      throw new Error(`${h(Q)} must be a string/Function/RegExp, or an array of those`);
    return q;
  }
  function m(Q) {
    return typeof Q == "string" || typeof Q == "function" || Q instanceof RegExp;
  }
  function L(Q, q) {
    if (q !== void 0 && typeof q != "boolean" && typeof q != "string")
      throw new Error(`${h(Q)} must be a undefined, a boolean, a string, got ${JSON.stringify(q)}`);
    return q;
  }
  function R(Q, q) {
    if (q === void 0 || typeof q == "boolean")
      return q;
    if (Array.isArray(q))
      q.forEach((ee, K) => {
        if (!m(ee))
          throw new Error(`${h(f2(Q, K))} must be a string/Function/RegExp.`);
      });
    else if (!m(q))
      throw new Error(`${h(Q)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(q)}`);
    return q;
  }
  function O(Q, q) {
    const ee = I(Q, q);
    return ee && ee.forEach((K, G) => B(f2(Q, G), K)), ee;
  }
  function B(Q, q) {
    if (Array.isArray(q)) {
      if (q.length === 0)
        throw new Error(`${h(Q)} must include an object`);
      if (q.length > 3)
        throw new Error(`${h(Q)} may only be a two-tuple or three-tuple`);
      if (M(f2(Q, 0), q[0]), q.length > 1) {
        const ee = q[1];
        if (ee !== void 0 && ee !== false && (typeof ee != "object" || Array.isArray(ee) || ee === null))
          throw new Error(`${h(f2(Q, 1))} must be an object, false, or undefined`);
      }
      if (q.length === 3) {
        const ee = q[2];
        if (ee !== void 0 && typeof ee != "string")
          throw new Error(`${h(f2(Q, 2))} must be a string, or undefined`);
      }
    } else
      M(Q, q);
    return q;
  }
  function M(Q, q) {
    if ((typeof q != "object" || !q) && typeof q != "string" && typeof q != "function")
      throw new Error(`${h(Q)} must be a string, object, function`);
    return q;
  }
  function j(Q, q) {
    if ((0, s().isBrowsersQueryValid)(q))
      return q;
    if (typeof q != "object" || !q || Array.isArray(q))
      throw new Error(`${h(Q)} must be a string, an array of strings or an object`);
    const ee = f2(Q, "browsers"), K = f2(Q, "esmodules");
    $(ee, q.browsers), T(K, q.esmodules);
    for (const G of Object.keys(q)) {
      const V = q[G], F = f2(Q, G);
      if (G === "esmodules")
        T(F, V);
      else if (G === "browsers")
        $(F, V);
      else if (Object.hasOwnProperty.call(s().TargetNames, G))
        k(F, V);
      else {
        const le = Object.keys(s().TargetNames).join(", ");
        throw new Error(`${h(F)} is not a valid target. Supported targets are ${le}`);
      }
    }
    return q;
  }
  function $(Q, q) {
    if (q !== void 0 && !(0, s().isBrowsersQueryValid)(q))
      throw new Error(`${h(Q)} must be undefined, a string or an array of strings`);
  }
  function k(Q, q) {
    if (!(typeof q == "number" && Math.round(q) === q) && typeof q != "string")
      throw new Error(`${h(Q)} must be a string or an integer number`);
  }
  function ne(Q, q) {
    if (q === void 0)
      return;
    if (typeof q != "object" || q === null)
      throw new Error(`${h(Q)} must be an object or undefined.`);
    let ee = Q;
    do
      ee = ee.parent;
    while (ee.type !== "root");
    const K = ee.source === "preset";
    for (const G of Object.keys(q)) {
      const V = f2(Q, G);
      if (!n.assumptionsNames.has(G))
        throw new Error(`${h(V)} is not a supported assumption.`);
      if (typeof q[G] != "boolean")
        throw new Error(`${h(V)} must be a boolean.`);
      if (K && q[G] === false)
        throw new Error(`${h(V)} cannot be set to 'false' inside presets.`);
    }
    return q;
  }
  return Ut;
}
var $m;
function $l() {
  if ($m)
    return yn;
  $m = 1, Object.defineProperty(yn, "__esModule", {
    value: true
  }), yn.assumptionsNames = void 0, yn.checkNoUnwrappedItemOptionPairs = D, yn.validate = A;
  var s = Ul, n = O0();
  const h = {
    cwd: n.assertString,
    root: n.assertString,
    rootMode: n.assertRootMode,
    configFile: n.assertConfigFileSearch,
    caller: n.assertCallerMetadata,
    filename: n.assertString,
    filenameRelative: n.assertString,
    code: n.assertBoolean,
    ast: n.assertBoolean,
    cloneInputAst: n.assertBoolean,
    envName: n.assertString
  }, f2 = {
    babelrc: n.assertBoolean,
    babelrcRoots: n.assertBabelrcSearch
  }, p = {
    extends: n.assertString,
    ignore: n.assertIgnoreList,
    only: n.assertIgnoreList,
    targets: n.assertTargets,
    browserslistConfigFile: n.assertConfigFileSearch,
    browserslistEnv: n.assertString
  }, g = {
    inputSourceMap: n.assertInputSourceMap,
    presets: n.assertPluginList,
    plugins: n.assertPluginList,
    passPerPreset: n.assertBoolean,
    assumptions: n.assertAssumptions,
    env: I,
    overrides: N,
    test: n.assertConfigApplicableTest,
    include: n.assertConfigApplicableTest,
    exclude: n.assertConfigApplicableTest,
    retainLines: n.assertBoolean,
    comments: n.assertBoolean,
    shouldPrintComment: n.assertFunction,
    compact: n.assertCompact,
    minified: n.assertBoolean,
    auxiliaryCommentBefore: n.assertString,
    auxiliaryCommentAfter: n.assertString,
    sourceType: n.assertSourceType,
    wrapPluginVisitorMethod: n.assertFunction,
    highlightCode: n.assertBoolean,
    sourceMaps: n.assertSourceMaps,
    sourceMap: n.assertSourceMaps,
    sourceFileName: n.assertString,
    sourceRoot: n.assertString,
    parserOpts: n.assertObject,
    generatorOpts: n.assertObject
  };
  Object.assign(g, {
    getModuleId: n.assertFunction,
    moduleRoot: n.assertString,
    moduleIds: n.assertBoolean,
    moduleId: n.assertString
  });
  const P = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], x = new Set(P);
  yn.assumptionsNames = x;
  function y(_) {
    return _.type === "root" ? _.source : y(_.parent);
  }
  function A(_, m) {
    return S({
      type: "root",
      source: _
    }, m);
  }
  function S(_, m) {
    const L = y(_);
    return C(m), Object.keys(m).forEach((R) => {
      const O = {
        type: "option",
        name: R,
        parent: _
      };
      if (L === "preset" && p[R])
        throw new Error(`${(0, n.msg)(O)} is not allowed in preset options`);
      if (L !== "arguments" && h[R])
        throw new Error(`${(0, n.msg)(O)} is only allowed in root programmatic options`);
      if (L !== "arguments" && L !== "configfile" && f2[R])
        throw L === "babelrcfile" || L === "extendsfile" ? new Error(`${(0, n.msg)(O)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, n.msg)(O)} is only allowed in root programmatic options, or babel.config.js/config file options`);
      (g[R] || p[R] || f2[R] || h[R] || v)(O, m[R]);
    }), m;
  }
  function v(_) {
    const m = _.name;
    if (s.default[m]) {
      const {
        message: L,
        version: R = 5
      } = s.default[m];
      throw new Error(`Using removed Babel ${R} option: ${(0, n.msg)(_)} - ${L}`);
    } else {
      const L = new Error(`Unknown option: ${(0, n.msg)(_)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
      throw L.code = "BABEL_UNKNOWN_OPTION", L;
    }
  }
  function T(_, m) {
    return Object.prototype.hasOwnProperty.call(_, m);
  }
  function C(_) {
    if (T(_, "sourceMap") && T(_, "sourceMaps"))
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
  function I(_, m) {
    if (_.parent.type === "env")
      throw new Error(`${(0, n.msg)(_)} is not allowed inside of another .env block`);
    const L = _.parent, R = (0, n.assertObject)(_, m);
    if (R)
      for (const O of Object.keys(R)) {
        const B = (0, n.assertObject)((0, n.access)(_, O), R[O]);
        if (!B)
          continue;
        S({
          type: "env",
          name: O,
          parent: L
        }, B);
      }
    return R;
  }
  function N(_, m) {
    if (_.parent.type === "env")
      throw new Error(`${(0, n.msg)(_)} is not allowed inside an .env block`);
    if (_.parent.type === "overrides")
      throw new Error(`${(0, n.msg)(_)} is not allowed inside an .overrides block`);
    const L = _.parent, R = (0, n.assertArray)(_, m);
    if (R)
      for (const [O, B] of R.entries()) {
        const M = (0, n.access)(_, O), j = (0, n.assertObject)(M, B);
        if (!j)
          throw new Error(`${(0, n.msg)(M)} must be an object`);
        S({
          type: "overrides",
          index: O,
          parent: L
        }, j);
      }
    return R;
  }
  function D(_, m, L, R) {
    if (m === 0)
      return;
    const O = _[m - 1], B = _[m];
    O.file && O.options === void 0 && typeof B.value == "object" && (R.message += `
- Maybe you meant to use
"${L}s": [
  ["${O.file.request}", ${JSON.stringify(B.value, void 0, 2)}]
]
To be a valid ${L}, its name and options should be wrapped in a pair of brackets`);
  }
  return yn;
}
var up = {};
Object.defineProperty(up, "__esModule", {
  value: true
});
up.default = wP;
function Il() {
  const s = an();
  return Il = function() {
    return s;
  }, s;
}
var La = `\\${Il().sep}`;
var Lc = `(?:${La}|$)`;
var cp = `[^${La}]+`;
var pp = `(?:${cp}${La})`;
var D0 = `(?:${cp}${Lc})`;
var AP = `${pp}*?`;
var CP = `${pp}*?${D0}?`;
function qm(s) {
  return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
}
function wP(s, n) {
  const h = Il().resolve(n, s).split(Il().sep);
  return new RegExp(["^", ...h.map((f2, p) => {
    const g = p === h.length - 1;
    return f2 === "**" ? g ? CP : AP : f2 === "*" ? g ? D0 : pp : f2.indexOf("*.") === 0 ? cp + qm(f2.slice(1)) + (g ? Lc : La) : qm(f2) + (g ? Lc : La);
  })].join(""));
}
var qn = {};
Object.defineProperty(qn, "__esModule", {
  value: true
});
qn.ConfigPrinter = qn.ChainFormatter = void 0;
function L0() {
  const s = Wi();
  return L0 = function() {
    return s;
  }, s;
}
var M0 = {
  Programmatic: 0,
  Config: 1
};
qn.ChainFormatter = M0;
var Ac = {
  title(s, n, h) {
    let f2 = "";
    return s === M0.Programmatic ? (f2 = "programmatic options", n && (f2 += " from " + n)) : f2 = "config " + h, f2;
  },
  loc(s, n) {
    let h = "";
    return s != null && (h += `.overrides[${s}]`), n != null && (h += `.env["${n}"]`), h;
  },
  *optionsAndDescriptors(s) {
    const n = Object.assign({}, s.options);
    delete n.overrides, delete n.env;
    const h = [...yield* s.plugins()];
    h.length && (n.plugins = h.map((p) => Vm(p)));
    const f2 = [...yield* s.presets()];
    return f2.length && (n.presets = [...f2].map((p) => Vm(p))), JSON.stringify(n, void 0, 2);
  }
};
function Vm(s) {
  var n;
  let h = (n = s.file) == null ? void 0 : n.request;
  return h == null && (typeof s.value == "object" ? h = s.value : typeof s.value == "function" && (h = `[Function: ${s.value.toString().slice(0, 50)} ... ]`)), h == null && (h = "[Unknown]"), s.options === void 0 ? h : s.name == null ? [h, s.options] : [h, s.options, s.name];
}
var fp = class _fp {
  constructor() {
    this._stack = [];
  }
  configure(n, h, {
    callerName: f2,
    filepath: p
  }) {
    return n ? (g, P, x) => {
      this._stack.push({
        type: h,
        callerName: f2,
        filepath: p,
        content: g,
        index: P,
        envName: x
      });
    } : () => {
    };
  }
  static *format(n) {
    let h = Ac.title(n.type, n.callerName, n.filepath);
    const f2 = Ac.loc(n.index, n.envName);
    f2 && (h += ` ${f2}`);
    const p = yield* Ac.optionsAndDescriptors(n.content);
    return `${h}
${p}`;
  }
  *output() {
    return this._stack.length === 0 ? "" : (yield* L0().all(this._stack.map((h) => _fp.format(h)))).join(`

`);
  }
};
qn.ConfigPrinter = fp;
Object.defineProperty(Sn, "__esModule", {
  value: true
});
Sn.buildPresetChain = IP;
Sn.buildPresetChainWalker = void 0;
Sn.buildRootChain = LP;
function B0() {
  const s = an();
  return B0 = function() {
    return s;
  }, s;
}
function _0() {
  const s = Yc();
  return _0 = function() {
    return s;
  }, s;
}
var hp = $l();
var F0 = up;
var Da = qn;
var ka = Ir;
var ir = Hi;
var Ps = k0();
var Km = _0()("babel:config:config-chain");
function* IP(s, n) {
  const h = yield* j0(s, n);
  return h ? {
    plugins: Nl(h.plugins),
    presets: Nl(h.presets),
    options: h.options.map((f2) => R0(f2)),
    files: /* @__PURE__ */ new Set()
  } : null;
}
var j0 = gp({
  root: (s) => NP(s),
  env: (s, n) => kP(s)(n),
  overrides: (s, n) => OP(s)(n),
  overridesEnv: (s, n, h) => DP(s)(n)(h),
  createLogger: () => () => {
  }
});
Sn.buildPresetChainWalker = j0;
var NP = (0, ir.makeWeakCacheSync)((s) => dp(s, s.alias, Ps.createUncachedDescriptors));
var kP = (0, ir.makeWeakCacheSync)((s) => (0, ir.makeStrongCacheSync)((n) => mp(s, s.alias, Ps.createUncachedDescriptors, n)));
var OP = (0, ir.makeWeakCacheSync)((s) => (0, ir.makeStrongCacheSync)((n) => yp(s, s.alias, Ps.createUncachedDescriptors, n)));
var DP = (0, ir.makeWeakCacheSync)((s) => (0, ir.makeStrongCacheSync)((n) => (0, ir.makeStrongCacheSync)((h) => bp(s, s.alias, Ps.createUncachedDescriptors, n, h))));
function* LP(s, n) {
  let h, f2;
  const p = new Da.ConfigPrinter(), g = yield* jP({
    options: s,
    dirname: n.cwd
  }, n, void 0, p);
  if (!g)
    return null;
  const P = yield* p.output();
  let x;
  typeof s.configFile == "string" ? x = yield* (0, ka.loadConfig)(s.configFile, n.cwd, n.envName, n.caller) : s.configFile !== false && (x = yield* (0, ka.findRootConfig)(n.root, n.envName, n.caller));
  let {
    babelrc: y,
    babelrcRoots: A
  } = s, S = n.cwd;
  const v = El(), T = new Da.ConfigPrinter();
  if (x) {
    const m = BP(x), L = yield* Mc(m, n, void 0, T);
    if (!L)
      return null;
    h = yield* T.output(), y === void 0 && (y = m.options.babelrc), A === void 0 && (S = m.dirname, A = m.options.babelrcRoots), Un(v, L);
  }
  let C, I, N = false;
  const D = El();
  if ((y === true || y === void 0) && typeof n.filename == "string") {
    const m = yield* (0, ka.findPackageData)(n.filename);
    if (m && MP(n, m, A, S)) {
      if ({
        ignore: C,
        config: I
      } = yield* (0, ka.findRelativeConfig)(m, n.envName, n.caller), C && D.files.add(C.filepath), C && U0(n, C.ignore, null, C.dirname) && (N = true), I && !N) {
        const L = _P(I), R = new Da.ConfigPrinter(), O = yield* Mc(L, n, void 0, R);
        O ? (f2 = yield* R.output(), Un(D, O)) : N = true;
      }
      I && N && D.files.add(I.filepath);
    }
  }
  n.showConfig && console.log(`Babel configs on "${n.filename}" (ascending priority):
` + [h, f2, P].filter((m) => !!m).join(`

`) + `
-----End Babel configs-----`);
  const _ = Un(Un(Un(El(), v), D), g);
  return {
    plugins: N ? [] : Nl(_.plugins),
    presets: N ? [] : Nl(_.presets),
    options: N ? [] : _.options.map((m) => R0(m)),
    fileHandling: N ? "ignored" : "transpile",
    ignore: C || void 0,
    babelrc: I || void 0,
    config: x || void 0,
    files: _.files
  };
}
function MP(s, n, h, f2) {
  if (typeof h == "boolean")
    return h;
  const p = s.root;
  if (h === void 0)
    return n.directories.indexOf(p) !== -1;
  let g = h;
  return Array.isArray(g) || (g = [g]), g = g.map((P) => typeof P == "string" ? B0().resolve(f2, P) : P), g.length === 1 && g[0] === p ? n.directories.indexOf(p) !== -1 : g.some((P) => (typeof P == "string" && (P = (0, F0.default)(P, f2)), n.directories.some((x) => $0(P, f2, x, s))));
}
var BP = (0, ir.makeWeakCacheSync)((s) => ({
  filepath: s.filepath,
  dirname: s.dirname,
  options: (0, hp.validate)("configfile", s.options)
}));
var _P = (0, ir.makeWeakCacheSync)((s) => ({
  filepath: s.filepath,
  dirname: s.dirname,
  options: (0, hp.validate)("babelrcfile", s.options)
}));
var FP = (0, ir.makeWeakCacheSync)((s) => ({
  filepath: s.filepath,
  dirname: s.dirname,
  options: (0, hp.validate)("extendsfile", s.options)
}));
var jP = gp({
  root: (s) => dp(s, "base", Ps.createCachedDescriptors),
  env: (s, n) => mp(s, "base", Ps.createCachedDescriptors, n),
  overrides: (s, n) => yp(s, "base", Ps.createCachedDescriptors, n),
  overridesEnv: (s, n, h) => bp(s, "base", Ps.createCachedDescriptors, n, h),
  createLogger: (s, n, h) => WP(s, n, h)
});
var RP = gp({
  root: (s) => UP(s),
  env: (s, n) => $P(s)(n),
  overrides: (s, n) => qP(s)(n),
  overridesEnv: (s, n, h) => VP(s)(n)(h),
  createLogger: (s, n, h) => KP(s.filepath, n, h)
});
function* Mc(s, n, h, f2) {
  const p = yield* RP(s, n, h, f2);
  return p && p.files.add(s.filepath), p;
}
var UP = (0, ir.makeWeakCacheSync)((s) => dp(s, s.filepath, Ps.createUncachedDescriptors));
var $P = (0, ir.makeWeakCacheSync)((s) => (0, ir.makeStrongCacheSync)((n) => mp(s, s.filepath, Ps.createUncachedDescriptors, n)));
var qP = (0, ir.makeWeakCacheSync)((s) => (0, ir.makeStrongCacheSync)((n) => yp(s, s.filepath, Ps.createUncachedDescriptors, n)));
var VP = (0, ir.makeWeakCacheSync)((s) => (0, ir.makeStrongCacheSync)((n) => (0, ir.makeStrongCacheSync)((h) => bp(s, s.filepath, Ps.createUncachedDescriptors, n, h))));
function KP(s, n, h) {
  return h ? h.configure(n.showConfig, Da.ChainFormatter.Config, {
    filepath: s
  }) : () => {
  };
}
function dp({
  dirname: s,
  options: n
}, h, f2) {
  return f2(s, n, h);
}
function WP(s, n, h) {
  var f2;
  return h ? h.configure(n.showConfig, Da.ChainFormatter.Programmatic, {
    callerName: (f2 = n.caller) == null ? void 0 : f2.name
  }) : () => {
  };
}
function mp({
  dirname: s,
  options: n
}, h, f2, p) {
  const g = n.env && n.env[p];
  return g ? f2(s, g, `${h}.env["${p}"]`) : null;
}
function yp({
  dirname: s,
  options: n
}, h, f2, p) {
  const g = n.overrides && n.overrides[p];
  if (!g)
    throw new Error("Assertion failure - missing override");
  return f2(s, g, `${h}.overrides[${p}]`);
}
function bp({
  dirname: s,
  options: n
}, h, f2, p, g) {
  const P = n.overrides && n.overrides[p];
  if (!P)
    throw new Error("Assertion failure - missing override");
  const x = P.env && P.env[g];
  return x ? f2(s, x, `${h}.overrides[${p}].env["${g}"]`) : null;
}
function gp({
  root: s,
  env: n,
  overrides: h,
  overridesEnv: f2,
  createLogger: p
}) {
  return function* (g, P, x = /* @__PURE__ */ new Set(), y) {
    const {
      dirname: A
    } = g, S = [], v = s(g);
    if (hl(v, A, P)) {
      S.push({
        config: v,
        envName: void 0,
        index: void 0
      });
      const I = n(g, P.envName);
      I && hl(I, A, P) && S.push({
        config: I,
        envName: P.envName,
        index: void 0
      }), (v.options.overrides || []).forEach((N, D) => {
        const _ = h(g, D);
        if (hl(_, A, P)) {
          S.push({
            config: _,
            index: D,
            envName: void 0
          });
          const m = f2(g, D, P.envName);
          m && hl(m, A, P) && S.push({
            config: m,
            index: D,
            envName: P.envName
          });
        }
      });
    }
    if (S.some(({
      config: {
        options: {
          ignore: I,
          only: N
        }
      }
    }) => U0(P, I, N, A)))
      return null;
    const T = El(), C = p(g, P, y);
    for (const {
      config: I,
      index: N,
      envName: D
    } of S) {
      if (!(yield* HP(T, I.options, A, P, x, y)))
        return null;
      C(I, N, D), yield* zP(T, I);
    }
    return T;
  };
}
function* HP(s, n, h, f2, p, g) {
  if (n.extends === void 0)
    return true;
  const P = yield* (0, ka.loadConfig)(n.extends, h, f2.envName, f2.caller);
  if (p.has(P))
    throw new Error(`Configuration cycle detected loading ${P.filepath}.
File already loaded following the config chain:
` + Array.from(p, (y) => ` - ${y.filepath}`).join(`
`));
  p.add(P);
  const x = yield* Mc(FP(P), f2, p, g);
  return p.delete(P), x ? (Un(s, x), true) : false;
}
function Un(s, n) {
  s.options.push(...n.options), s.plugins.push(...n.plugins), s.presets.push(...n.presets);
  for (const h of n.files)
    s.files.add(h);
  return s;
}
function* zP(s, {
  options: n,
  plugins: h,
  presets: f2
}) {
  return s.options.push(n), s.plugins.push(...yield* h()), s.presets.push(...yield* f2()), s;
}
function El() {
  return {
    options: [],
    presets: [],
    plugins: [],
    files: /* @__PURE__ */ new Set()
  };
}
function R0(s) {
  const n = Object.assign({}, s);
  return delete n.extends, delete n.env, delete n.overrides, delete n.plugins, delete n.presets, delete n.passPerPreset, delete n.ignore, delete n.only, delete n.test, delete n.include, delete n.exclude, Object.prototype.hasOwnProperty.call(n, "sourceMap") && (n.sourceMaps = n.sourceMap, delete n.sourceMap), n;
}
function Nl(s) {
  const n = /* @__PURE__ */ new Map(), h = [];
  for (const f2 of s)
    if (typeof f2.value == "function") {
      const p = f2.value;
      let g = n.get(p);
      g || (g = /* @__PURE__ */ new Map(), n.set(p, g));
      let P = g.get(f2.name);
      P ? P.value = f2 : (P = {
        value: f2
      }, h.push(P), f2.ownPass || g.set(f2.name, P));
    } else
      h.push({
        value: f2
      });
  return h.reduce((f2, p) => (f2.push(p.value), f2), []);
}
function hl({
  options: s
}, n, h) {
  return (s.test === void 0 || Cc(h, s.test, n)) && (s.include === void 0 || Cc(h, s.include, n)) && (s.exclude === void 0 || !Cc(h, s.exclude, n));
}
function Cc(s, n, h) {
  const f2 = Array.isArray(n) ? n : [n];
  return Bc(s, f2, h);
}
function Wm(s, n) {
  return n instanceof RegExp ? String(n) : n;
}
function U0(s, n, h, f2) {
  if (n && Bc(s, n, f2)) {
    var p;
    const P = `No config is applied to "${(p = s.filename) != null ? p : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(n, Wm)}\` from "${f2}"`;
    return Km(P), s.showConfig && console.log(P), true;
  }
  if (h && !Bc(s, h, f2)) {
    var g;
    const P = `No config is applied to "${(g = s.filename) != null ? g : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(h, Wm)}\` from "${f2}"`;
    return Km(P), s.showConfig && console.log(P), true;
  }
  return false;
}
function Bc(s, n, h) {
  return n.some((f2) => $0(f2, h, s.filename, s));
}
function $0(s, n, h, f2) {
  if (typeof s == "function")
    return !!s(h, {
      dirname: n,
      envName: f2.envName,
      caller: f2.caller
    });
  if (typeof h != "string")
    throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
  return typeof s == "string" && (s = (0, F0.default)(s, n)), s.test(h);
}
var Tp = {};
Object.defineProperty(Tp, "__esModule", {
  value: true
});
Tp.validatePluginObject = YP;
var rn = O0();
var GP = {
  name: rn.assertString,
  manipulateOptions: rn.assertFunction,
  pre: rn.assertFunction,
  post: rn.assertFunction,
  inherits: rn.assertFunction,
  visitor: XP,
  parserOverride: rn.assertFunction,
  generatorOverride: rn.assertFunction
};
function XP(s, n) {
  const h = (0, rn.assertObject)(s, n);
  if (h && (Object.keys(h).forEach((f2) => JP(f2, h[f2])), h.enter || h.exit))
    throw new Error(`${(0, rn.msg)(s)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
  return h;
}
function JP(s, n) {
  if (n && typeof n == "object")
    Object.keys(n).forEach((h) => {
      if (h !== "enter" && h !== "exit")
        throw new Error(`.visitor["${s}"] may only have .enter and/or .exit handlers.`);
    });
  else if (typeof n != "function")
    throw new Error(`.visitor["${s}"] must be a function`);
  return n;
}
function YP(s) {
  const n = {
    type: "root",
    source: "plugin"
  };
  return Object.keys(s).forEach((h) => {
    const f2 = GP[h];
    if (f2)
      f2({
        type: "option",
        name: h,
        parent: n
      }, s[h]);
    else {
      const p = new Error(`.${h} is not a valid Plugin property`);
      throw p.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", p;
    }
  }), s;
}
var jn = {};
var Hm;
function QP() {
  if (Hm)
    return jn;
  Hm = 1, Object.defineProperty(jn, "__esModule", {
    value: true
  }), jn.makeConfigAPI = f2, jn.makePluginAPI = g, jn.makePresetAPI = p;
  function s() {
    const x = Hn();
    return s = function() {
      return x;
    }, x;
  }
  var n = on(), h = Hi;
  function f2(x) {
    const y = (S) => x.using((v) => typeof S > "u" ? v.envName : typeof S == "function" ? (0, h.assertSimpleType)(S(v.envName)) : (Array.isArray(S) ? S : [S]).some((T) => {
      if (typeof T != "string")
        throw new Error("Unexpected non-string value");
      return T === v.envName;
    })), A = (S) => x.using((v) => (0, h.assertSimpleType)(S(v.caller)));
    return {
      version: n.version,
      cache: x.simple(),
      env: y,
      async: () => false,
      caller: A,
      assertVersion: P
    };
  }
  function p(x, y) {
    const A = () => JSON.parse(x.using((v) => JSON.stringify(v.targets))), S = (v) => {
      y.push(v);
    };
    return Object.assign({}, f2(x), {
      targets: A,
      addExternalDependency: S
    });
  }
  function g(x, y) {
    const A = (S) => x.using((v) => v.assumptions[S]);
    return Object.assign({}, p(x, y), {
      assumption: A
    });
  }
  function P(x) {
    if (typeof x == "number") {
      if (!Number.isInteger(x))
        throw new Error("Expected string or integer value.");
      x = `^${x}.0.0-0`;
    }
    if (typeof x != "string")
      throw new Error("Expected string or integer value.");
    if (s().satisfies(n.version, x))
      return;
    const y = Error.stackTraceLimit;
    typeof y == "number" && y < 25 && (Error.stackTraceLimit = 25);
    const A = new Error(`Requires Babel "${x}", but was loaded with "${n.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof y == "number" && (Error.stackTraceLimit = y), Object.assign(A, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: n.version,
      range: x
    });
  }
  return jn;
}
var Jn = {};
Object.defineProperty(Jn, "__esModule", {
  value: true
});
Jn.default = V0;
Jn.loadPartialConfig = void 0;
function vl() {
  const s = an();
  return vl = function() {
    return s;
  }, s;
}
function q0() {
  const s = Wi();
  return q0 = function() {
    return s;
  }, s;
}
var ZP = Gn;
var eS = zn;
var zm = Rl();
var tS = Sn;
var rS = jl;
var sS = $l();
var Al = Ir;
var iS = Ua;
var nS = ["showIgnoredFiles"];
function aS(s, n) {
  if (s == null)
    return {};
  var h = {}, f2 = Object.keys(s), p, g;
  for (g = 0; g < f2.length; g++)
    p = f2[g], !(n.indexOf(p) >= 0) && (h[p] = s[p]);
  return h;
}
function oS(s, n) {
  switch (n) {
    case "root":
      return s;
    case "upward-optional": {
      const h = (0, Al.findConfigUpwards)(s);
      return h === null ? s : h;
    }
    case "upward": {
      const h = (0, Al.findConfigUpwards)(s);
      if (h !== null)
        return h;
      throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${s}".
One of the following config files must be in the directory tree: "${Al.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
        code: "BABEL_ROOT_NOT_FOUND",
        dirname: s
      });
    }
    default:
      throw new Error("Assertion failure - unknown rootMode value.");
  }
}
function* V0(s) {
  if (s != null && (typeof s != "object" || Array.isArray(s)))
    throw new Error("Babel options must be an object, null, or undefined");
  const n = s ? (0, sS.validate)("arguments", s) : {}, {
    envName: h = (0, rS.getEnv)(),
    cwd: f2 = ".",
    root: p = ".",
    rootMode: g = "root",
    caller: P,
    cloneInputAst: x = true
  } = n, y = vl().resolve(f2), A = oS(vl().resolve(y, p), g), S = typeof n.filename == "string" ? vl().resolve(f2, n.filename) : void 0, v = yield* (0, Al.resolveShowConfigPath)(y), T = {
    filename: S,
    cwd: y,
    root: A,
    envName: h,
    caller: P,
    showConfig: v === S
  }, C = yield* (0, tS.buildRootChain)(n, T);
  if (!C)
    return null;
  const I = {
    assumptions: {}
  };
  return C.options.forEach((D) => {
    (0, eS.mergeOptions)(I, D);
  }), {
    options: Object.assign({}, I, {
      targets: (0, iS.resolveTargets)(I, A),
      cloneInputAst: x,
      babelrc: false,
      configFile: false,
      browserslistConfigFile: false,
      passPerPreset: false,
      envName: T.envName,
      cwd: T.cwd,
      root: T.root,
      rootMode: "root",
      filename: typeof T.filename == "string" ? T.filename : void 0,
      plugins: C.plugins.map((D) => (0, zm.createItemFromDescriptor)(D)),
      presets: C.presets.map((D) => (0, zm.createItemFromDescriptor)(D))
    }),
    context: T,
    fileHandling: C.fileHandling,
    ignore: C.ignore,
    babelrc: C.babelrc,
    config: C.config,
    files: C.files
  };
}
var lS = q0()(function* (s) {
  let n = false;
  if (typeof s == "object" && s !== null && !Array.isArray(s)) {
    var h = s;
    ({
      showIgnoredFiles: n
    } = h), s = aS(h, nS);
  }
  const f2 = yield* V0(s);
  if (!f2)
    return null;
  const {
    options: p,
    babelrc: g,
    ignore: P,
    config: x,
    fileHandling: y,
    files: A
  } = f2;
  return y === "ignored" && !n ? null : ((p.plugins || []).forEach((S) => {
    if (S.value instanceof ZP.default)
      throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
  }), new K0(p, g ? g.filepath : void 0, P ? P.filepath : void 0, x ? x.filepath : void 0, y, A));
});
Jn.loadPartialConfig = lS;
var K0 = class {
  constructor(n, h, f2, p, g, P) {
    this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = n, this.babelignore = f2, this.babelrc = h, this.config = p, this.fileHandling = g, this.files = P, Object.freeze(this);
  }
  hasFilesystemConfig() {
    return this.babelrc !== void 0 || this.config !== void 0;
  }
};
Object.freeze(K0.prototype);
var Gm;
function uS() {
  if (Gm)
    return Aa;
  Gm = 1, Object.defineProperty(Aa, "__esModule", {
    value: true
  }), Aa.default = void 0;
  function s() {
    const k = Wi();
    return s = function() {
      return k;
    }, k;
  }
  var n = Ss, h = zn, f2 = on(), p = Gn, g = Rl(), P = Sn, x = Xn;
  function y() {
    const k = qi();
    return y = function() {
      return k;
    }, k;
  }
  var A = Hi, S = $l(), v = Tp, T = QP(), C = Jn, I = s()(function* (ne) {
    var Q;
    const q = yield* (0, C.default)(ne);
    if (!q)
      return null;
    const {
      options: ee,
      context: K,
      fileHandling: G
    } = q;
    if (G === "ignored")
      return null;
    const V = {}, {
      plugins: F,
      presets: le
    } = ee;
    if (!F || !le)
      throw new Error("Assertion failure - plugins and presets exist");
    const oe = Object.assign({}, K, {
      targets: ee.targets
    }), fe = (pe) => {
      const z = (0, g.getItemDescriptor)(pe);
      if (!z)
        throw new Error("Assertion failure - must be config item");
      return z;
    }, he = le.map(fe), de = F.map(fe), Pe = [[]], we = [], H = [];
    if (yield* N(K, function* pe(z, W) {
      const ae = [];
      for (let xe = 0; xe < z.length; xe++) {
        const Se = z[xe];
        if (Se.options !== false) {
          try {
            var ce = yield* M(Se, oe);
          } catch (Le) {
            throw Le.code === "BABEL_UNKNOWN_OPTION" && (0, S.checkNoUnwrappedItemOptionPairs)(z, xe, "preset", Le), Le;
          }
          H.push(ce.externalDependencies), Se.ownPass ? ae.push({
            preset: ce.chain,
            pass: []
          }) : ae.unshift({
            preset: ce.chain,
            pass: W
          });
        }
      }
      if (ae.length > 0) {
        Pe.splice(1, 0, ...ae.map((xe) => xe.pass).filter((xe) => xe !== W));
        for (const {
          preset: xe,
          pass: Se
        } of ae) {
          if (!xe || (Se.push(...xe.plugins), yield* pe(xe.presets, Se)))
            return true;
          xe.options.forEach((Ee) => {
            (0, h.mergeOptions)(V, Ee);
          });
        }
      }
    })(he, Pe[0]))
      return null;
    const Ie = V;
    (0, h.mergeOptions)(Ie, ee);
    const Te = Object.assign({}, oe, {
      assumptions: (Q = Ie.assumptions) != null ? Q : {}
    });
    return yield* N(K, function* () {
      Pe[0].unshift(...de);
      for (const W of Pe) {
        const ae = [];
        we.push(ae);
        for (let ce = 0; ce < W.length; ce++) {
          const xe = W[ce];
          if (xe.options !== false) {
            try {
              var z = yield* L(xe, Te);
            } catch (Se) {
              throw Se.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, S.checkNoUnwrappedItemOptionPairs)(W, ce, "plugin", Se), Se;
            }
            ae.push(z), H.push(z.externalDependencies);
          }
        }
      }
    })(), Ie.plugins = we[0], Ie.presets = we.slice(1).filter((pe) => pe.length > 0).map((pe) => ({
      plugins: pe
    })), Ie.passPerPreset = Ie.presets.length > 0, {
      options: Ie,
      passes: we,
      externalDependencies: (0, x.finalize)(H)
    };
  });
  Aa.default = I;
  function N(k, ne) {
    return function* (Q, q) {
      try {
        return yield* ne(Q, q);
      } catch (ee) {
        throw /^\[BABEL\]/.test(ee.message) || (ee.message = `[BABEL] ${k.filename || "unknown"}: ${ee.message}`), ee;
      }
    };
  }
  const D = (k) => (0, A.makeWeakCache)(function* ({
    value: ne,
    options: Q,
    dirname: q,
    alias: ee
  }, K) {
    if (Q === false)
      throw new Error("Assertion failure");
    Q = Q || {};
    const G = [];
    let V = ne;
    if (typeof ne == "function") {
      const F = (0, n.maybeAsync)(ne, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), le = Object.assign({}, f2, k(K, G));
      try {
        V = yield* F(le, Q, q);
      } catch (oe) {
        throw ee && (oe.message += ` (While processing: ${JSON.stringify(ee)})`), oe;
      }
    }
    if (!V || typeof V != "object")
      throw new Error("Plugin/Preset did not return an object.");
    if ((0, n.isThenable)(V))
      throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(ee)})`);
    if (G.length > 0 && (!K.configured() || K.mode() === "forever")) {
      let F = `A plugin/preset has external untracked dependencies (${G[0]}), but the cache `;
      throw K.configured() ? F += " has been configured to never be invalidated. " : F += "has not been configured to be invalidated when the external dependencies change. ", F += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(ee)})`, new Error(F);
    }
    return {
      value: V,
      options: Q,
      dirname: q,
      alias: ee,
      externalDependencies: (0, x.finalize)(G)
    };
  }), _ = D(T.makePluginAPI), m = D(T.makePresetAPI);
  function* L(k, ne) {
    if (k.value instanceof p.default) {
      if (k.options)
        throw new Error("Passed options to an existing Plugin instance will not work.");
      return k.value;
    }
    return yield* R(yield* _(k, ne), ne);
  }
  const R = (0, A.makeWeakCache)(function* ({
    value: k,
    options: ne,
    dirname: Q,
    alias: q,
    externalDependencies: ee
  }, K) {
    const G = (0, v.validatePluginObject)(k), V = Object.assign({}, G);
    if (V.visitor && (V.visitor = y().default.explode(Object.assign({}, V.visitor))), V.inherits) {
      const F = {
        name: void 0,
        alias: `${q}$inherits`,
        value: V.inherits,
        options: ne,
        dirname: Q
      }, le = yield* (0, n.forwardAsync)(L, (oe) => K.invalidate((fe) => oe(F, fe)));
      V.pre = $(le.pre, V.pre), V.post = $(le.post, V.post), V.manipulateOptions = $(le.manipulateOptions, V.manipulateOptions), V.visitor = y().default.visitors.merge([le.visitor || {}, V.visitor || {}]), le.externalDependencies.length > 0 && (ee.length === 0 ? ee = le.externalDependencies : ee = (0, x.finalize)([ee, le.externalDependencies]));
    }
    return new p.default(V, ne, q, ee);
  }), O = (k, ne) => {
    if (k.test || k.include || k.exclude) {
      const Q = ne.name ? `"${ne.name}"` : "/* your preset */";
      throw new Error([`Preset ${Q} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${Q}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, B = (k, ne, Q) => {
    if (!ne.filename) {
      const {
        options: q
      } = k;
      O(q, Q), q.overrides && q.overrides.forEach((ee) => O(ee, Q));
    }
  };
  function* M(k, ne) {
    const Q = j(yield* m(k, ne));
    return B(Q, ne, k), {
      chain: yield* (0, P.buildPresetChain)(Q, ne),
      externalDependencies: Q.externalDependencies
    };
  }
  const j = (0, A.makeWeakCacheSync)(({
    value: k,
    dirname: ne,
    alias: Q,
    externalDependencies: q
  }) => ({
    options: (0, S.validate)("preset", k),
    alias: Q,
    dirname: ne,
    externalDependencies: q
  }));
  function $(k, ne) {
    const Q = [k, ne].filter(Boolean);
    return Q.length <= 1 ? Q[0] : function(...q) {
      for (const ee of Q)
        ee.apply(this, q);
    };
  }
  return Aa;
}
var Xm;
function ql() {
  return Xm || (Xm = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), s.createConfigItem = D, s.createConfigItemSync = s.createConfigItemAsync = void 0, Object.defineProperty(s, "default", {
      enumerable: true,
      get: function() {
        return h.default;
      }
    }), s.loadPartialConfigSync = s.loadPartialConfigAsync = s.loadPartialConfig = s.loadOptionsSync = s.loadOptionsAsync = s.loadOptions = void 0;
    function n() {
      const _ = Wi();
      return n = function() {
        return _;
      }, _;
    }
    var h = uS(), f2 = Jn, p = Rl();
    const g = n()(function* (_) {
      var m;
      const L = yield* (0, h.default)(_);
      return (m = L == null ? void 0 : L.options) != null ? m : null;
    }), P = n()(p.createConfigItem), x = (_) => (m, L) => {
      let R, O;
      return L === void 0 && typeof m == "function" ? (O = m, R = void 0) : (O = L, R = m), O ? _.errback(R, O) : _.sync(R);
    }, y = x(f2.loadPartialConfig);
    s.loadPartialConfig = y;
    const A = f2.loadPartialConfig.sync;
    s.loadPartialConfigSync = A;
    const S = f2.loadPartialConfig.async;
    s.loadPartialConfigAsync = S;
    const v = x(g);
    s.loadOptions = v;
    const T = g.sync;
    s.loadOptionsSync = T;
    const C = g.async;
    s.loadOptionsAsync = C;
    const I = P.sync;
    s.createConfigItemSync = I;
    const N = P.async;
    s.createConfigItemAsync = N;
    function D(_, m, L) {
      return L !== void 0 ? P.errback(_, m, L) : typeof m == "function" ? P.errback(_, void 0, L) : P.sync(_, m);
    }
  }(lc)), lc;
}
var Zi = {};
var Vl = {};
var Kl = {};
Object.defineProperty(Kl, "__esModule", {
  value: true
});
Kl.default = void 0;
var W0 = class {
  constructor(n, h, f2) {
    this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = h, this.file = n, this.opts = f2 || {}, this.cwd = n.opts.cwd, this.filename = n.opts.filename;
  }
  set(n, h) {
    this._map.set(n, h);
  }
  get(n) {
    return this._map.get(n);
  }
  availableHelper(n, h) {
    return this.file.availableHelper(n, h);
  }
  addHelper(n) {
    return this.file.addHelper(n);
  }
  addImport() {
    return this.file.addImport();
  }
  buildCodeFrameError(n, h, f2) {
    return this.file.buildCodeFrameError(n, h, f2);
  }
};
Kl.default = W0;
W0.prototype.getModuleName = function() {
  return this.file.getModuleName();
};
var xp = {};
Object.defineProperty(xp, "__esModule", {
  value: true
});
xp.default = pS;
function H0() {
  const s = qi();
  return H0 = function() {
    return s;
  }, s;
}
var cS = Gn;
var wc;
function pS() {
  return wc || (wc = new cS.default(Object.assign({}, Jm, {
    visitor: H0().default.explode(Jm.visitor)
  }), {})), wc;
}
function z0(s) {
  const n = s == null ? void 0 : s._blockHoist;
  return n == null ? 1 : n === true ? 2 : n;
}
function fS(s) {
  const n = /* @__PURE__ */ Object.create(null);
  for (let p = 0; p < s.length; p++) {
    const g = s[p], P = z0(g);
    (n[P] || (n[P] = [])).push(g);
  }
  const h = Object.keys(n).map((p) => +p).sort((p, g) => g - p);
  let f2 = 0;
  for (const p of h) {
    const g = n[p];
    for (const P of g)
      s[f2++] = P;
  }
  return s;
}
var Jm = {
  name: "internal.blockHoist",
  visitor: {
    Block: {
      exit({
        node: s
      }) {
        const {
          body: n
        } = s;
        let h = Math.pow(2, 30) - 1, f2 = false;
        for (let p = 0; p < n.length; p++) {
          const g = n[p], P = z0(g);
          if (P > h) {
            f2 = true;
            break;
          }
          h = P;
        }
        !f2 || (s.body = fS(n.slice()));
      }
    }
  }
};
var Wl = {};
Object.defineProperty(Wl, "__esModule", {
  value: true
});
Wl.default = hS;
function Cl() {
  const s = an();
  return Cl = function() {
    return s;
  }, s;
}
function hS(s) {
  const {
    filename: n,
    cwd: h,
    filenameRelative: f2 = typeof n == "string" ? Cl().relative(h, n) : "unknown",
    sourceType: p = "module",
    inputSourceMap: g,
    sourceMaps: P = !!g,
    sourceRoot: x = s.options.moduleRoot,
    sourceFileName: y = Cl().basename(f2),
    comments: A = true,
    compact: S = "auto"
  } = s.options, v = s.options, T = Object.assign({}, v, {
    parserOpts: Object.assign({
      sourceType: Cl().extname(f2) === ".mjs" ? "module" : p,
      sourceFileName: n,
      plugins: []
    }, v.parserOpts),
    generatorOpts: Object.assign({
      filename: n,
      auxiliaryCommentBefore: v.auxiliaryCommentBefore,
      auxiliaryCommentAfter: v.auxiliaryCommentAfter,
      retainLines: v.retainLines,
      comments: A,
      shouldPrintComment: v.shouldPrintComment,
      compact: S,
      minified: v.minified,
      sourceMaps: P,
      sourceRoot: x,
      sourceFileName: y
    }, v.generatorOpts)
  });
  for (const C of s.passes)
    for (const I of C)
      I.manipulateOptions && I.manipulateOptions(T, T.parserOpts);
  return T;
}
var Pp = {};
var dS = {};
var mS = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: dS
}, Symbol.toStringTag, { value: "Module" }));
var Sp = l(mS);
var Ic = {};
var dl = { exports: {} };
var Ym;
function yS() {
  return Ym || (Ym = 1, function(s, n) {
    var h = Sp, f2 = h.Buffer;
    function p(P, x) {
      for (var y in P)
        x[y] = P[y];
    }
    f2.from && f2.alloc && f2.allocUnsafe && f2.allocUnsafeSlow ? s.exports = h : (p(h, n), n.Buffer = g);
    function g(P, x, y) {
      return f2(P, x, y);
    }
    p(f2, g), g.from = function(P, x, y) {
      if (typeof P == "number")
        throw new TypeError("Argument must not be a number");
      return f2(P, x, y);
    }, g.alloc = function(P, x, y) {
      if (typeof P != "number")
        throw new TypeError("Argument must be a number");
      var A = f2(P);
      return x !== void 0 ? typeof y == "string" ? A.fill(x, y) : A.fill(x) : A.fill(0), A;
    }, g.allocUnsafe = function(P) {
      if (typeof P != "number")
        throw new TypeError("Argument must be a number");
      return f2(P);
    }, g.allocUnsafeSlow = function(P) {
      if (typeof P != "number")
        throw new TypeError("Argument must be a number");
      return h.SlowBuffer(P);
    };
  }(dl, dl.exports)), dl.exports;
}
var Qm;
function G0() {
  return Qm || (Qm = 1, function(s) {
    var n = Sp, h = an(), f2 = yS();
    Object.defineProperty(s, "commentRegex", {
      get: function() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    }), Object.defineProperty(s, "mapFileCommentRegex", {
      get: function() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });
    function p(y) {
      return (f2.Buffer.from(y, "base64") || "").toString();
    }
    function g(y) {
      return y.split(",").pop();
    }
    function P(y, A) {
      var S = s.mapFileCommentRegex.exec(y), v = S[1] || S[2], T = h.resolve(A, v);
      try {
        return n.readFileSync(T, "utf8");
      } catch (C) {
        throw new Error("An error occurred while trying to read the map file at " + T + `
` + C);
      }
    }
    function x(y, A) {
      A = A || {}, A.isFileComment && (y = P(y, A.commentFileDir)), A.hasComment && (y = g(y)), A.isEncoded && (y = p(y)), (A.isJSON || A.isEncoded) && (y = JSON.parse(y)), this.sourcemap = y;
    }
    x.prototype.toJSON = function(y) {
      return JSON.stringify(this.sourcemap, null, y);
    }, x.prototype.toBase64 = function() {
      var y = this.toJSON();
      return (f2.Buffer.from(y, "utf8") || "").toString("base64");
    }, x.prototype.toComment = function(y) {
      var A = this.toBase64(), S = "sourceMappingURL=data:application/json;charset=utf-8;base64," + A;
      return y && y.multiline ? "/*# " + S + " */" : "//# " + S;
    }, x.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    }, x.prototype.addProperty = function(y, A) {
      if (this.sourcemap.hasOwnProperty(y))
        throw new Error('property "' + y + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(y, A);
    }, x.prototype.setProperty = function(y, A) {
      return this.sourcemap[y] = A, this;
    }, x.prototype.getProperty = function(y) {
      return this.sourcemap[y];
    }, s.fromObject = function(y) {
      return new x(y);
    }, s.fromJSON = function(y) {
      return new x(y, { isJSON: true });
    }, s.fromBase64 = function(y) {
      return new x(y, { isEncoded: true });
    }, s.fromComment = function(y) {
      return y = y.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), new x(y, { isEncoded: true, hasComment: true });
    }, s.fromMapFileComment = function(y, A) {
      return new x(y, { commentFileDir: A, isFileComment: true, isJSON: true });
    }, s.fromSource = function(y) {
      var A = y.match(s.commentRegex);
      return A ? s.fromComment(A.pop()) : null;
    }, s.fromMapFileSource = function(y, A) {
      var S = y.match(s.mapFileCommentRegex);
      return S ? s.fromMapFileComment(S.pop(), A) : null;
    }, s.removeComments = function(y) {
      return y.replace(s.commentRegex, "");
    }, s.removeMapFileComments = function(y) {
      return y.replace(s.mapFileCommentRegex, "");
    }, s.generateMapFileComment = function(y, A) {
      var S = "sourceMappingURL=" + y;
      return A && A.multiline ? "/*# " + S + " */" : "//# " + S;
    };
  }(Ic)), Ic;
}
var Hl = {};
var Ep = {};
Object.defineProperty(Ep, "__esModule", {
  value: true
});
Ep.default = bS;
var _c = {
  asyncDoExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-async-do-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
    }
  },
  classProperties: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
    },
    transform: {
      name: "@babel/plugin-proposal-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-class-properties"
    }
  },
  classPrivateProperties: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
    },
    transform: {
      name: "@babel/plugin-proposal-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-class-properties"
    }
  },
  classPrivateMethods: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
    },
    transform: {
      name: "@babel/plugin-proposal-private-methods",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-private-methods"
    }
  },
  classStaticBlock: {
    syntax: {
      name: "@babel/plugin-syntax-class-static-block",
      url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
    },
    transform: {
      name: "@babel/plugin-proposal-class-static-block",
      url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-proposal-class-static-block"
    }
  },
  decimal: {
    syntax: {
      name: "@babel/plugin-syntax-decimal",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
    }
  },
  decorators: {
    syntax: {
      name: "@babel/plugin-syntax-decorators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
    },
    transform: {
      name: "@babel/plugin-proposal-decorators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
    }
  },
  doExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-do-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
    },
    transform: {
      name: "@babel/plugin-proposal-do-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
    }
  },
  dynamicImport: {
    syntax: {
      name: "@babel/plugin-syntax-dynamic-import",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
    }
  },
  exportDefaultFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-default-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
    },
    transform: {
      name: "@babel/plugin-proposal-export-default-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
    }
  },
  exportNamespaceFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-namespace-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
    },
    transform: {
      name: "@babel/plugin-proposal-export-namespace-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-namespace-from"
    }
  },
  flow: {
    syntax: {
      name: "@babel/plugin-syntax-flow",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
    },
    transform: {
      name: "@babel/preset-flow",
      url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
    }
  },
  functionBind: {
    syntax: {
      name: "@babel/plugin-syntax-function-bind",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
    },
    transform: {
      name: "@babel/plugin-proposal-function-bind",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
    }
  },
  functionSent: {
    syntax: {
      name: "@babel/plugin-syntax-function-sent",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
    },
    transform: {
      name: "@babel/plugin-proposal-function-sent",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
    }
  },
  importMeta: {
    syntax: {
      name: "@babel/plugin-syntax-import-meta",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
    }
  },
  jsx: {
    syntax: {
      name: "@babel/plugin-syntax-jsx",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
    },
    transform: {
      name: "@babel/preset-react",
      url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
    }
  },
  importAssertions: {
    syntax: {
      name: "@babel/plugin-syntax-import-assertions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
    }
  },
  moduleStringNames: {
    syntax: {
      name: "@babel/plugin-syntax-module-string-names",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
    }
  },
  numericSeparator: {
    syntax: {
      name: "@babel/plugin-syntax-numeric-separator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
    },
    transform: {
      name: "@babel/plugin-proposal-numeric-separator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-numeric-separator"
    }
  },
  optionalChaining: {
    syntax: {
      name: "@babel/plugin-syntax-optional-chaining",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
    },
    transform: {
      name: "@babel/plugin-proposal-optional-chaining",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-optional-chaining"
    }
  },
  pipelineOperator: {
    syntax: {
      name: "@babel/plugin-syntax-pipeline-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
    },
    transform: {
      name: "@babel/plugin-proposal-pipeline-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
    }
  },
  privateIn: {
    syntax: {
      name: "@babel/plugin-syntax-private-property-in-object",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
    },
    transform: {
      name: "@babel/plugin-proposal-private-property-in-object",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-private-property-in-object"
    }
  },
  recordAndTuple: {
    syntax: {
      name: "@babel/plugin-syntax-record-and-tuple",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
    }
  },
  regexpUnicodeSets: {
    syntax: {
      name: "@babel/plugin-syntax-unicode-sets-regex",
      url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
    },
    transform: {
      name: "@babel/plugin-proposal-unicode-sets-regex",
      url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
    }
  },
  throwExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-throw-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
    },
    transform: {
      name: "@babel/plugin-proposal-throw-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
    }
  },
  typescript: {
    syntax: {
      name: "@babel/plugin-syntax-typescript",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
    },
    transform: {
      name: "@babel/preset-typescript",
      url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
    }
  },
  asyncGenerators: {
    syntax: {
      name: "@babel/plugin-syntax-async-generators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
    },
    transform: {
      name: "@babel/plugin-proposal-async-generator-functions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-async-generator-functions"
    }
  },
  logicalAssignment: {
    syntax: {
      name: "@babel/plugin-syntax-logical-assignment-operators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
    },
    transform: {
      name: "@babel/plugin-proposal-logical-assignment-operators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-logical-assignment-operators"
    }
  },
  nullishCoalescingOperator: {
    syntax: {
      name: "@babel/plugin-syntax-nullish-coalescing-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
    },
    transform: {
      name: "@babel/plugin-proposal-nullish-coalescing-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
    }
  },
  objectRestSpread: {
    syntax: {
      name: "@babel/plugin-syntax-object-rest-spread",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
    },
    transform: {
      name: "@babel/plugin-proposal-object-rest-spread",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-object-rest-spread"
    }
  },
  optionalCatchBinding: {
    syntax: {
      name: "@babel/plugin-syntax-optional-catch-binding",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
    },
    transform: {
      name: "@babel/plugin-proposal-optional-catch-binding",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-optional-catch-binding"
    }
  }
};
_c.privateIn.syntax = _c.privateIn.transform;
var Zm = ({
  name: s,
  url: n
}) => `${s} (${n})`;
function bS(s, n, h) {
  let f2 = `Support for the experimental syntax '${s}' isn't currently enabled (${n.line}:${n.column + 1}):

` + h;
  const p = _c[s];
  if (p) {
    const {
      syntax: g,
      transform: P
    } = p;
    if (g) {
      const x = Zm(g);
      if (P) {
        const y = Zm(P), A = P.name.startsWith("@babel/plugin") ? "plugins" : "presets";
        f2 += `

Add ${y} to the '${A}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${x} to the 'plugins' section to enable parsing.`;
      } else
        f2 += `

Add ${x} to the 'plugins' section of your Babel config to enable parsing.`;
    }
  }
  return f2;
}
Object.defineProperty(Hl, "__esModule", {
  value: true
});
Hl.default = TS;
function Fc() {
  const s = m0();
  return Fc = function() {
    return s;
  }, s;
}
function X0() {
  const s = Bl();
  return X0 = function() {
    return s;
  }, s;
}
var gS = Ep;
function* TS(s, {
  parserOpts: n,
  highlightCode: h = true,
  filename: f2 = "unknown"
}, p) {
  try {
    const g = [];
    for (const P of s)
      for (const x of P) {
        const {
          parserOverride: y
        } = x;
        if (y) {
          const A = y(p, n, Fc().parse);
          A !== void 0 && g.push(A);
        }
      }
    if (g.length === 0)
      return (0, Fc().parse)(p, n);
    if (g.length === 1) {
      if (yield* [], typeof g[0].then == "function")
        throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      return g[0];
    }
    throw new Error("More than one plugin attempted to override parsing.");
  } catch (g) {
    g.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (g.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
    const {
      loc: P,
      missingPlugin: x
    } = g;
    if (P) {
      const y = (0, X0().codeFrameColumns)(p, {
        start: {
          line: P.line,
          column: P.column + 1
        }
      }, {
        highlightCode: h
      });
      x ? g.message = `${f2}: ` + (0, gS.default)(x[0], P, y) : g.message = `${f2}: ${g.message}

` + y, g.code = "BABEL_PARSE_ERROR";
    }
    throw g;
  }
}
var vp = {};
Object.defineProperty(vp, "__esModule", {
  value: true
});
vp.default = xS;
function jc(s, n) {
  if (s !== null) {
    if (n.has(s))
      return n.get(s);
    let h;
    if (Array.isArray(s)) {
      h = new Array(s.length);
      for (let f2 = 0; f2 < s.length; f2++)
        h[f2] = typeof s[f2] != "object" ? s[f2] : jc(s[f2], n);
    } else {
      h = {};
      const f2 = Object.keys(s);
      for (let p = 0; p < f2.length; p++) {
        const g = f2[p];
        h[g] = typeof s[g] != "object" ? s[g] : jc(s[g], n);
      }
    }
    return n.set(s, h), h;
  }
  return s;
}
function xS(s) {
  return typeof s != "object" ? s : jc(s, /* @__PURE__ */ new Map());
}
Object.defineProperty(Pp, "__esModule", {
  value: true
});
Pp.default = wS;
function J0() {
  const s = Sp;
  return J0 = function() {
    return s;
  }, s;
}
function Rc() {
  const s = an();
  return Rc = function() {
    return s;
  }, s;
}
function Y0() {
  const s = Yc();
  return Y0 = function() {
    return s;
  }, s;
}
function Q0() {
  const s = Je();
  return Q0 = function() {
    return s;
  }, s;
}
function wl() {
  const s = G0();
  return wl = function() {
    return s;
  }, s;
}
var PS = Kn;
var SS = Hl;
var ES = vp;
var {
  file: vS,
  traverseFast: AS
} = Q0();
var ml = Y0()("babel:transform:file");
var CS = 3e6;
function* wS(s, n, h, f2) {
  if (h = `${h || ""}`, f2) {
    if (f2.type === "Program")
      f2 = vS(f2, [], []);
    else if (f2.type !== "File")
      throw new Error("AST root must be a Program or File node");
    n.cloneInputAst && (f2 = (0, ES.default)(f2));
  } else
    f2 = yield* (0, SS.default)(s, n, h);
  let p = null;
  if (n.inputSourceMap !== false) {
    if (typeof n.inputSourceMap == "object" && (p = wl().fromObject(n.inputSourceMap)), !p) {
      const g = ty(IS, f2);
      if (g)
        try {
          p = wl().fromComment(g);
        } catch (P) {
          ml("discarding unknown inline input sourcemap", P);
        }
    }
    if (!p) {
      const g = ty(ey, f2);
      if (typeof n.filename == "string" && g)
        try {
          const P = ey.exec(g), x = J0().readFileSync(Rc().resolve(Rc().dirname(n.filename), P[1]));
          x.length > CS ? ml("skip merging input map > 1 MB") : p = wl().fromJSON(x);
        } catch (P) {
          ml("discarding unknown file input sourcemap", P);
        }
      else
        g && ml("discarding un-loadable file input sourcemap");
    }
  }
  return new PS.default(n, {
    code: h,
    ast: f2,
    inputMap: p
  });
}
var IS = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
var ey = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
function Nc(s, n, h) {
  return n && (n = n.filter(({
    value: f2
  }) => s.test(f2) ? (h = f2, false) : true)), [n, h];
}
function ty(s, n) {
  let h = null;
  return AS(n, (f2) => {
    [f2.leadingComments, h] = Nc(s, f2.leadingComments, h), [f2.innerComments, h] = Nc(s, f2.innerComments, h), [f2.trailingComments, h] = Nc(s, f2.trailingComments, h);
  }), h;
}
var Ap = {};
var Cp = {};
var zl = zy();
var gn = { exports: {} };
(function(s, n) {
  (function(h, f2) {
    f2(n, Hy(), Qc());
  })(f, function(h, f2, p) {
    h.addSegment = void 0, h.addMapping = void 0, h.setSourceContent = void 0, h.decodedMap = void 0, h.encodedMap = void 0, h.allMappings = void 0;
    class g {
      constructor({ file: T, sourceRoot: C } = {}) {
        this._names = new f2.SetArray(), this._sources = new f2.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = T, this.sourceRoot = C;
      }
    }
    h.addSegment = (v, T, C, I, N, D, _) => {
      const { _mappings: m, _sources: L, _sourcesContent: R, _names: O } = v, B = P(m, T);
      if (I == null) {
        const k = [C], ne = x(B, C, k);
        return S(B, ne, k);
      }
      const M = f2.put(L, I), j = _ ? [C, M, N, D, f2.put(O, _)] : [C, M, N, D], $ = x(B, C, j);
      M === R.length && (R[M] = null), S(B, $, j);
    }, h.addMapping = (v, T) => {
      const { generated: C, source: I, original: N, name: D } = T;
      return h.addSegment(v, C.line - 1, C.column, I, N == null ? void 0 : N.line - 1, N == null ? void 0 : N.column, D);
    }, h.setSourceContent = (v, T, C) => {
      const { _sources: I, _sourcesContent: N } = v;
      N[f2.put(I, T)] = C;
    }, h.decodedMap = (v) => {
      const { file: T, sourceRoot: C, _mappings: I, _sources: N, _sourcesContent: D, _names: _ } = v;
      return {
        version: 3,
        file: T,
        names: _.array,
        sourceRoot: C || void 0,
        sources: N.array,
        sourcesContent: D,
        mappings: I
      };
    }, h.encodedMap = (v) => {
      const T = h.decodedMap(v);
      return Object.assign(Object.assign({}, T), { mappings: p.encode(T.mappings) });
    }, h.allMappings = (v) => {
      const T = [], { _mappings: C, _sources: I, _names: N } = v;
      for (let D = 0; D < C.length; D++) {
        const _ = C[D];
        for (let m = 0; m < _.length; m++) {
          const L = _[m], R = { line: D + 1, column: L[0] };
          let O, B, M;
          L.length !== 1 && (O = I.array[L[1]], B = { line: L[2] + 1, column: L[3] }, L.length === 5 && (M = N.array[L[4]])), T.push({ generated: R, source: O, original: B, name: M });
        }
      }
      return T;
    };
    function P(v, T) {
      for (let C = v.length; C <= T; C++)
        v[C] = [];
      return v[T];
    }
    function x(v, T, C) {
      let I = v.length;
      for (let N = I - 1; N >= 0; N--, I--) {
        const D = v[N], _ = D[0];
        if (_ > T)
          continue;
        if (_ < T)
          break;
        const m = y(D, C);
        if (m === 0)
          return I;
        if (m < 0)
          break;
      }
      return I;
    }
    function y(v, T) {
      let C = A(v.length, T.length);
      return C !== 0 ? C : v.length === 1 ? 0 : (C = A(v[1], T[1]), C !== 0 || (C = A(v[2], T[2]), C !== 0) || (C = A(v[3], T[3]), C !== 0) ? C : v.length === 4 ? 0 : A(v[4], T[4]));
    }
    function A(v, T) {
      return v - T;
    }
    function S(v, T, C) {
      if (T !== -1) {
        for (let I = v.length; I > T; I--)
          v[I] = v[I - 1];
        v[T] = C;
      }
    }
    h.GenMapping = g, Object.defineProperty(h, "__esModule", { value: true });
  });
})(gn, gn.exports);
var Z0 = {
  source: null,
  column: null,
  line: null,
  name: null,
  content: null
};
var NS = [];
function eb(s, n, h, f2) {
  return {
    map: s,
    sources: n,
    source: h,
    content: f2
  };
}
function tb(s, n) {
  return eb(s, n, "", null);
}
function kS(s, n) {
  return eb(null, NS, s, n);
}
function OS(s) {
  const n = new gn.exports.GenMapping({ file: s.map.file }), { sources: h, map: f2 } = s, p = f2.names, g = zl.decodedMappings(f2);
  for (let P = 0; P < g.length; P++) {
    const x = g[P];
    let y = null, A = null, S = null;
    for (let v = 0; v < x.length; v++) {
      const T = x[v], C = T[0];
      let I = Z0;
      if (T.length !== 1) {
        const R = h[T[1]];
        if (I = rb(R, T[2], T[3], T.length === 5 ? p[T[4]] : ""), I == null)
          continue;
      }
      const { column: N, line: D, name: _, content: m, source: L } = I;
      D === A && N === S && L === y || (A = D, S = N, y = L, gn.exports.addSegment(n, P, C, L, D, N, _), m != null && gn.exports.setSourceContent(n, L, m));
    }
  }
  return n;
}
function rb(s, n, h, f2) {
  if (!s.map)
    return { column: h, line: n, name: f2, source: s.source, content: s.content };
  const p = zl.traceSegment(s.map, n, h);
  return p == null ? null : p.length === 1 ? Z0 : rb(s.sources[p[1]], p[2], p[3], p.length === 5 ? s.map.names[p[4]] : f2);
}
function DS(s) {
  return Array.isArray(s) ? s : [s];
}
function LS(s, n) {
  const h = DS(s).map((g) => new zl.TraceMap(g, "")), f2 = h.pop();
  for (let g = 0; g < h.length; g++)
    if (h[g].sources.length > 1)
      throw new Error(`Transformation map ${g} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
  let p = sb(f2, n, "", 0);
  for (let g = h.length - 1; g >= 0; g--)
    p = tb(h[g], [p]);
  return p;
}
function sb(s, n, h, f2) {
  const { resolvedSources: p, sourcesContent: g } = s, P = f2 + 1, x = p.map((y, A) => {
    const S = {
      importer: h,
      depth: P,
      source: y || "",
      content: void 0
    }, v = n(S.source, S), { source: T, content: C } = S;
    if (v)
      return sb(new zl.TraceMap(v, T), n, T, P);
    const I = C !== void 0 ? C : g ? g[A] : null;
    return kS(T, I);
  });
  return tb(s, x);
}
var MS = class {
  constructor(n, h) {
    const f2 = h.decodedMappings ? gn.exports.decodedMap(n) : gn.exports.encodedMap(n);
    this.version = f2.version, this.file = f2.file, this.mappings = f2.mappings, this.names = f2.names, this.sourceRoot = f2.sourceRoot, this.sources = f2.sources, h.excludeContent || (this.sourcesContent = f2.sourcesContent);
  }
  toString() {
    return JSON.stringify(this);
  }
};
function BS(s, n, h) {
  const f2 = typeof h == "object" ? h : { excludeContent: !!h, decodedMappings: false }, p = LS(s, n);
  return new MS(OS(p), f2);
}
var _S = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: BS
}, Symbol.toStringTag, { value: "Module" }));
var FS = l(_S);
Object.defineProperty(Cp, "__esModule", {
  value: true
});
Cp.default = jS;
function ib() {
  const s = FS;
  return ib = function() {
    return s;
  }, s;
}
function jS(s, n, h) {
  const f2 = h.replace(/\\/g, "/");
  let p = false;
  const g = ib()(ry(n), (P, x) => P === f2 && !p ? (p = true, x.source = "", ry(s)) : null);
  return typeof s.sourceRoot == "string" && (g.sourceRoot = s.sourceRoot), Object.assign({}, g);
}
function ry(s) {
  return Object.assign({}, s, {
    sourceRoot: null
  });
}
Object.defineProperty(Ap, "__esModule", {
  value: true
});
Ap.default = US;
function nb() {
  const s = G0();
  return nb = function() {
    return s;
  }, s;
}
function Uc() {
  const s = Zc();
  return Uc = function() {
    return s;
  }, s;
}
var RS = Cp;
function US(s, n) {
  const {
    opts: h,
    ast: f2,
    code: p,
    inputMap: g
  } = n, {
    generatorOpts: P
  } = h, x = [];
  for (const v of s)
    for (const T of v) {
      const {
        generatorOverride: C
      } = T;
      if (C) {
        const I = C(f2, P, p, Uc().default);
        I !== void 0 && x.push(I);
      }
    }
  let y;
  if (x.length === 0)
    y = (0, Uc().default)(f2, P, p);
  else if (x.length === 1) {
    if (y = x[0], typeof y.then == "function")
      throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
  } else
    throw new Error("More than one plugin attempted to override codegen.");
  let {
    code: A,
    decodedMap: S = y.map
  } = y;
  return S && (g ? S = (0, RS.default)(g.toObject(), S, P.sourceFileName) : S = y.map), (h.sourceMaps === "inline" || h.sourceMaps === "both") && (A += `
` + nb().fromObject(S).toComment()), h.sourceMaps === "inline" && (S = null), {
    outputCode: A,
    outputMap: S
  };
}
Object.defineProperty(Vl, "__esModule", {
  value: true
});
Vl.run = zS;
function $c() {
  const s = qi();
  return $c = function() {
    return s;
  }, s;
}
var $S = Kl;
var qS = xp;
var VS = Wl;
var KS = Pp;
var WS = Ap;
var HS = Xn;
function* zS(s, n, h) {
  const f2 = yield* (0, KS.default)(s.passes, (0, VS.default)(s), n, h), p = f2.opts;
  try {
    yield* GS(f2, s.passes);
  } catch (A) {
    var g;
    throw A.message = `${(g = p.filename) != null ? g : "unknown"}: ${A.message}`, A.code || (A.code = "BABEL_TRANSFORM_ERROR"), A;
  }
  let P, x;
  try {
    p.code !== false && ({
      outputCode: P,
      outputMap: x
    } = (0, WS.default)(s.passes, f2));
  } catch (A) {
    var y;
    throw A.message = `${(y = p.filename) != null ? y : "unknown"}: ${A.message}`, A.code || (A.code = "BABEL_GENERATE_ERROR"), A;
  }
  return {
    metadata: f2.metadata,
    options: p,
    ast: p.ast === true ? f2.ast : null,
    code: P === void 0 ? null : P,
    map: x === void 0 ? null : x,
    sourceType: f2.ast.program.sourceType,
    externalDependencies: (0, HS.flattenToSet)(s.externalDependencies)
  };
}
function* GS(s, n) {
  for (const h of n) {
    const f2 = [], p = [], g = [];
    for (const x of h.concat([(0, qS.default)()])) {
      const y = new $S.default(s, x.key, x.options);
      f2.push([x, y]), p.push(y), g.push(x.visitor);
    }
    for (const [x, y] of f2) {
      const A = x.pre;
      if (A) {
        const S = A.call(y, s);
        if (yield* [], sy(S))
          throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      }
    }
    const P = $c().default.visitors.merge(g, p, s.opts.wrapPluginVisitorMethod);
    (0, $c().default)(s.ast, P, s.scope);
    for (const [x, y] of f2) {
      const A = x.post;
      if (A) {
        const S = A.call(y, s);
        if (yield* [], sy(S))
          throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      }
    }
  }
}
function sy(s) {
  return !!s && (typeof s == "object" || typeof s == "function") && !!s.then && typeof s.then == "function";
}
var iy;
function XS() {
  if (iy)
    return Zi;
  iy = 1, Object.defineProperty(Zi, "__esModule", {
    value: true
  }), Zi.transformSync = Zi.transformAsync = Zi.transform = void 0;
  function s() {
    const x = Wi();
    return s = function() {
      return x;
    }, x;
  }
  var n = ql(), h = Vl;
  const f2 = s()(function* (y, A) {
    const S = yield* (0, n.default)(A);
    return S === null ? null : yield* (0, h.run)(S, y);
  }), p = function(y, A, S) {
    let v, T;
    if (typeof A == "function" ? (T = A, v = void 0) : (v = A, T = S), T === void 0)
      return f2.sync(y, v);
    f2.errback(y, v, T);
  };
  Zi.transform = p;
  const g = f2.sync;
  Zi.transformSync = g;
  const P = f2.async;
  return Zi.transformAsync = P, Zi;
}
var Yn = {};
Object.defineProperty(Yn, "__esModule", {
  value: true
});
Yn.transformFile = void 0;
Yn.transformFileAsync = QS;
Yn.transformFileSync = YS;
var JS = function(n, h, f2) {
  typeof h == "function" && (f2 = h), f2(new Error("Transforming files is not supported in browsers"), null);
};
Yn.transformFile = JS;
function YS() {
  throw new Error("Transforming files is not supported in browsers");
}
function QS() {
  return Promise.reject(new Error("Transforming files is not supported in browsers"));
}
var en = {};
var ny;
function ZS() {
  if (ny)
    return en;
  ny = 1, Object.defineProperty(en, "__esModule", {
    value: true
  }), en.transformFromAstSync = en.transformFromAstAsync = en.transformFromAst = void 0;
  function s() {
    const x = Wi();
    return s = function() {
      return x;
    }, x;
  }
  var n = ql(), h = Vl;
  const f2 = s()(function* (x, y, A) {
    const S = yield* (0, n.default)(A);
    if (S === null)
      return null;
    if (!x)
      throw new Error("No AST given");
    return yield* (0, h.run)(S, y, x);
  }), p = function(y, A, S, v) {
    let T, C;
    if (typeof S == "function" ? (C = S, T = void 0) : (T = S, C = v), C === void 0)
      return f2.sync(y, A, T);
    f2.errback(y, A, T, C);
  };
  en.transformFromAst = p;
  const g = f2.sync;
  en.transformFromAstSync = g;
  const P = f2.async;
  return en.transformFromAstAsync = P, en;
}
var tn = {};
var ay;
function eE() {
  if (ay)
    return tn;
  ay = 1, Object.defineProperty(tn, "__esModule", {
    value: true
  }), tn.parseSync = tn.parseAsync = tn.parse = void 0;
  function s() {
    const y = Wi();
    return s = function() {
      return y;
    }, y;
  }
  var n = ql(), h = Hl, f2 = Wl;
  const p = s()(function* (A, S) {
    const v = yield* (0, n.default)(S);
    return v === null ? null : yield* (0, h.default)(v.passes, (0, f2.default)(v), A);
  }), g = function(A, S, v) {
    if (typeof S == "function" && (v = S, S = void 0), v === void 0)
      return p.sync(A, S);
    p.errback(A, S, v);
  };
  tn.parse = g;
  const P = p.sync;
  tn.parseSync = P;
  const x = p.async;
  return tn.parseAsync = x, tn;
}
var oy;
function on() {
  return oy || (oy = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: true
    }), s.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(s, "File", {
      enumerable: true,
      get: function() {
        return n.default;
      }
    }), s.OptionManager = void 0, s.Plugin = _, Object.defineProperty(s, "buildExternalHelpers", {
      enumerable: true,
      get: function() {
        return h.default;
      }
    }), Object.defineProperty(s, "createConfigItem", {
      enumerable: true,
      get: function() {
        return A.createConfigItem;
      }
    }), Object.defineProperty(s, "createConfigItemAsync", {
      enumerable: true,
      get: function() {
        return A.createConfigItemAsync;
      }
    }), Object.defineProperty(s, "createConfigItemSync", {
      enumerable: true,
      get: function() {
        return A.createConfigItemSync;
      }
    }), Object.defineProperty(s, "getEnv", {
      enumerable: true,
      get: function() {
        return p.getEnv;
      }
    }), Object.defineProperty(s, "loadOptions", {
      enumerable: true,
      get: function() {
        return A.loadOptions;
      }
    }), Object.defineProperty(s, "loadOptionsAsync", {
      enumerable: true,
      get: function() {
        return A.loadOptionsAsync;
      }
    }), Object.defineProperty(s, "loadOptionsSync", {
      enumerable: true,
      get: function() {
        return A.loadOptionsSync;
      }
    }), Object.defineProperty(s, "loadPartialConfig", {
      enumerable: true,
      get: function() {
        return A.loadPartialConfig;
      }
    }), Object.defineProperty(s, "loadPartialConfigAsync", {
      enumerable: true,
      get: function() {
        return A.loadPartialConfigAsync;
      }
    }), Object.defineProperty(s, "loadPartialConfigSync", {
      enumerable: true,
      get: function() {
        return A.loadPartialConfigSync;
      }
    }), Object.defineProperty(s, "parse", {
      enumerable: true,
      get: function() {
        return C.parse;
      }
    }), Object.defineProperty(s, "parseAsync", {
      enumerable: true,
      get: function() {
        return C.parseAsync;
      }
    }), Object.defineProperty(s, "parseSync", {
      enumerable: true,
      get: function() {
        return C.parseSync;
      }
    }), Object.defineProperty(s, "resolvePlugin", {
      enumerable: true,
      get: function() {
        return f2.resolvePlugin;
      }
    }), Object.defineProperty(s, "resolvePreset", {
      enumerable: true,
      get: function() {
        return f2.resolvePreset;
      }
    }), Object.defineProperty(s, "template", {
      enumerable: true,
      get: function() {
        return y().default;
      }
    }), Object.defineProperty(s, "tokTypes", {
      enumerable: true,
      get: function() {
        return P().tokTypes;
      }
    }), Object.defineProperty(s, "transform", {
      enumerable: true,
      get: function() {
        return S.transform;
      }
    }), Object.defineProperty(s, "transformAsync", {
      enumerable: true,
      get: function() {
        return S.transformAsync;
      }
    }), Object.defineProperty(s, "transformFile", {
      enumerable: true,
      get: function() {
        return v.transformFile;
      }
    }), Object.defineProperty(s, "transformFileAsync", {
      enumerable: true,
      get: function() {
        return v.transformFileAsync;
      }
    }), Object.defineProperty(s, "transformFileSync", {
      enumerable: true,
      get: function() {
        return v.transformFileSync;
      }
    }), Object.defineProperty(s, "transformFromAst", {
      enumerable: true,
      get: function() {
        return T.transformFromAst;
      }
    }), Object.defineProperty(s, "transformFromAstAsync", {
      enumerable: true,
      get: function() {
        return T.transformFromAstAsync;
      }
    }), Object.defineProperty(s, "transformFromAstSync", {
      enumerable: true,
      get: function() {
        return T.transformFromAstSync;
      }
    }), Object.defineProperty(s, "transformSync", {
      enumerable: true,
      get: function() {
        return S.transformSync;
      }
    }), Object.defineProperty(s, "traverse", {
      enumerable: true,
      get: function() {
        return x().default;
      }
    }), s.version = s.types = void 0;
    var n = Kn, h = rp, f2 = Ir, p = jl;
    function g() {
      const m = Je();
      return g = function() {
        return m;
      }, m;
    }
    Object.defineProperty(s, "types", {
      enumerable: true,
      get: function() {
        return g();
      }
    });
    function P() {
      const m = m0();
      return P = function() {
        return m;
      }, m;
    }
    function x() {
      const m = qi();
      return x = function() {
        return m;
      }, m;
    }
    function y() {
      const m = Pn();
      return y = function() {
        return m;
      }, m;
    }
    var A = ql(), S = XS(), v = Yn, T = ZS(), C = eE();
    const I = "7.18.9";
    s.version = I;
    const N = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
    s.DEFAULT_EXTENSIONS = N;
    class D {
      init(L) {
        return (0, A.loadOptionsSync)(L);
      }
    }
    s.OptionManager = D;
    function _(m) {
      throw new Error(`The (${m}) Babel 5 plugin is being run with an unsupported Babel version.`);
    }
  }(Lu)), Lu;
}
var ab = {};
var Qn = {};
var wp = {};
var Ip = {};
(function(s) {
  Object.defineProperty(s, "__esModule", { value: true });
  var n = Je();
  function h(ee) {
    if (ee && ee.__esModule)
      return ee;
    var K = /* @__PURE__ */ Object.create(null);
    return ee && Object.keys(ee).forEach(function(G) {
      if (G !== "default") {
        var V = Object.getOwnPropertyDescriptor(ee, G);
        Object.defineProperty(K, G, V.get ? V : {
          enumerable: true,
          get: function() {
            return ee[G];
          }
        });
      }
    }), K.default = ee, Object.freeze(K);
  }
  var f2 = h(n);
  function p(ee) {
    const K = ee, {
      node: G,
      parentPath: V
    } = K;
    if (V.isLogicalExpression()) {
      const {
        operator: F,
        right: le
      } = V.node;
      if (F === "&&" || F === "||" || F === "??" && G === le)
        return p(V);
    }
    if (V.isSequenceExpression()) {
      const {
        expressions: F
      } = V.node;
      return F[F.length - 1] === G ? p(V) : true;
    }
    return V.isConditional({
      test: G
    }) || V.isUnaryExpression({
      operator: "!"
    }) || V.isLoop({
      test: G
    });
  }
  const {
    LOGICAL_OPERATORS: g,
    arrowFunctionExpression: P,
    assignmentExpression: x,
    binaryExpression: y,
    booleanLiteral: A,
    callExpression: S,
    cloneNode: v,
    conditionalExpression: T,
    identifier: C,
    isMemberExpression: I,
    isOptionalCallExpression: N,
    isOptionalMemberExpression: D,
    isUpdateExpression: _,
    logicalExpression: m,
    memberExpression: L,
    nullLiteral: R,
    optionalCallExpression: O,
    optionalMemberExpression: B,
    sequenceExpression: M,
    updateExpression: j
  } = f2;
  class $ {
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(K) {
      return this._map.has(K);
    }
    get(K) {
      if (!this.has(K))
        return;
      const G = this._map.get(K), {
        value: V
      } = G;
      return G.count--, G.count === 0 ? x("=", V, K) : V;
    }
    set(K, G, V) {
      return this._map.set(K, {
        count: V,
        value: G
      });
    }
  }
  function k(ee, K) {
    const {
      node: G
    } = ee;
    if (D(G))
      return L(K, G.property, G.computed);
    if (ee.isOptionalCallExpression()) {
      const V = ee.get("callee");
      if (ee.node.optional && V.isOptionalMemberExpression()) {
        const F = V.node.object, le = ee.scope.maybeGenerateMemoised(F);
        return V.get("object").replaceWith(x("=", le, F)), S(L(K, C("call")), [le, ...ee.node.arguments]);
      }
      return S(K, ee.node.arguments);
    }
    return ee.node;
  }
  function ne(ee) {
    for (; ee && !ee.isProgram(); ) {
      const {
        parentPath: K,
        container: G,
        listKey: V
      } = ee, F = K.node;
      if (V) {
        if (G !== F[V])
          return true;
      } else if (G !== F)
        return true;
      ee = K;
    }
    return false;
  }
  const Q = {
    memoise() {
    },
    handle(ee, K) {
      const {
        node: G,
        parent: V,
        parentPath: F,
        scope: le
      } = ee;
      if (ee.isOptionalMemberExpression()) {
        if (ne(ee))
          return;
        const oe = ee.find(({
          node: Se,
          parent: Le
        }) => D(Le) ? Le.optional || Le.object !== Se : N(Le) ? Se !== ee.node && Le.optional || Le.callee !== Se : true);
        if (le.path.isPattern()) {
          oe.replaceWith(S(P([], oe.node), []));
          return;
        }
        const fe = p(oe), he = oe.parentPath;
        if (he.isUpdateExpression({
          argument: G
        }) || he.isAssignmentExpression({
          left: G
        }))
          throw ee.buildCodeFrameError("can't handle assignment");
        const de = he.isUnaryExpression({
          operator: "delete"
        });
        if (de && oe.isOptionalMemberExpression() && oe.get("property").isPrivateName())
          throw ee.buildCodeFrameError("can't delete a private class element");
        let Pe = ee;
        for (; ; ) {
          if (Pe.isOptionalMemberExpression()) {
            if (Pe.node.optional)
              break;
            Pe = Pe.get("object");
            continue;
          } else if (Pe.isOptionalCallExpression()) {
            if (Pe.node.optional)
              break;
            Pe = Pe.get("callee");
            continue;
          }
          throw new Error(`Internal error: unexpected ${Pe.node.type}`);
        }
        const we = Pe.isOptionalMemberExpression() ? Pe.node.object : Pe.node.callee, H = le.maybeGenerateMemoised(we), te = H != null ? H : we, Ie = F.isOptionalCallExpression({
          callee: G
        }), Te = (Se) => Ie, pe = F.isCallExpression({
          callee: G
        });
        Pe.replaceWith(k(Pe, te)), Te() ? V.optional ? F.replaceWith(this.optionalCall(ee, V.arguments)) : F.replaceWith(this.call(ee, V.arguments)) : pe ? ee.replaceWith(this.boundGet(ee)) : ee.replaceWith(this.get(ee));
        let z = ee.node;
        for (let Se = ee; Se !== oe; ) {
          const Le = Se.parentPath;
          if (Le === oe && Te() && V.optional) {
            z = Le.node;
            break;
          }
          z = k(Le, z), Se = Le;
        }
        let W;
        const ae = oe.parentPath;
        if (I(z) && ae.isOptionalCallExpression({
          callee: oe.node,
          optional: true
        })) {
          const {
            object: Se
          } = z;
          W = ee.scope.maybeGenerateMemoised(Se), W && (z.object = x("=", W, Se));
        }
        let ce = oe;
        de && (ce = ae, z = ae.node);
        const xe = H ? x("=", v(te), v(we)) : v(te);
        if (fe) {
          let Se;
          K ? Se = y("!=", xe, R()) : Se = m("&&", y("!==", xe, R()), y("!==", v(te), le.buildUndefinedNode())), ce.replaceWith(m("&&", Se, z));
        } else {
          let Se;
          K ? Se = y("==", xe, R()) : Se = m("||", y("===", xe, R()), y("===", v(te), le.buildUndefinedNode())), ce.replaceWith(T(Se, de ? A(true) : le.buildUndefinedNode(), z));
        }
        if (W) {
          const Se = ae.node;
          ae.replaceWith(O(B(Se.callee, C("call"), false, true), [v(W), ...Se.arguments], false));
        }
        return;
      }
      if (_(V, {
        argument: G
      })) {
        if (this.simpleSet) {
          ee.replaceWith(this.simpleSet(ee));
          return;
        }
        const {
          operator: oe,
          prefix: fe
        } = V;
        this.memoise(ee, 2);
        const he = le.generateUidIdentifierBasedOnNode(G);
        le.push({
          id: he
        });
        const de = [x("=", v(he), this.get(ee))];
        if (fe) {
          de.push(j(oe, v(he), fe));
          const Pe = M(de);
          F.replaceWith(this.set(ee, Pe));
          return;
        } else {
          const Pe = le.generateUidIdentifierBasedOnNode(G);
          le.push({
            id: Pe
          }), de.push(x("=", v(Pe), j(oe, v(he), fe)), v(he));
          const we = M(de);
          F.replaceWith(M([this.set(ee, we), v(Pe)]));
          return;
        }
      }
      if (F.isAssignmentExpression({
        left: G
      })) {
        if (this.simpleSet) {
          ee.replaceWith(this.simpleSet(ee));
          return;
        }
        const {
          operator: oe,
          right: fe
        } = F.node;
        if (oe === "=")
          F.replaceWith(this.set(ee, fe));
        else {
          const he = oe.slice(0, -1);
          g.includes(he) ? (this.memoise(ee, 1), F.replaceWith(m(he, this.get(ee), this.set(ee, fe)))) : (this.memoise(ee, 2), F.replaceWith(this.set(ee, y(he, this.get(ee), fe))));
        }
        return;
      }
      if (F.isCallExpression({
        callee: G
      })) {
        F.replaceWith(this.call(ee, F.node.arguments));
        return;
      }
      if (F.isOptionalCallExpression({
        callee: G
      })) {
        if (le.path.isPattern()) {
          F.replaceWith(S(P([], F.node), []));
          return;
        }
        F.replaceWith(this.optionalCall(ee, F.node.arguments));
        return;
      }
      if (F.isForXStatement({
        left: G
      }) || F.isObjectProperty({
        value: G
      }) && F.parentPath.isObjectPattern() || F.isAssignmentPattern({
        left: G
      }) && F.parentPath.isObjectProperty({
        value: V
      }) && F.parentPath.parentPath.isObjectPattern() || F.isArrayPattern() || F.isAssignmentPattern({
        left: G
      }) && F.parentPath.isArrayPattern() || F.isRestElement()) {
        ee.replaceWith(this.destructureSet(ee));
        return;
      }
      F.isTaggedTemplateExpression() ? ee.replaceWith(this.boundGet(ee)) : ee.replaceWith(this.get(ee));
    }
  };
  function q(ee, K, G) {
    ee.traverse(K, Object.assign({}, Q, G, {
      memoiser: new $()
    }));
  }
  s.default = q;
})(Ip);
var Gl = {};
Object.defineProperty(Gl, "__esModule", {
  value: true
});
Gl.default = iE;
var tE = Je();
var {
  callExpression: ly,
  identifier: yl,
  isIdentifier: rE,
  isSpreadElement: sE,
  memberExpression: uy,
  optionalCallExpression: cy,
  optionalMemberExpression: py
} = tE;
function iE(s, n, h, f2) {
  return h.length === 1 && sE(h[0]) && rE(h[0].argument, {
    name: "arguments"
  }) ? f2 ? cy(py(s, yl("apply"), false, true), [n, h[0].argument], false) : ly(uy(s, yl("apply")), [n, h[0].argument]) : f2 ? cy(py(s, yl("call"), false, true), [n, ...h], false) : ly(uy(s, yl("call")), [n, ...h]);
}
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: true
  }), s.default = void 0, Object.defineProperty(s, "environmentVisitor", {
    enumerable: true,
    get: function() {
      return p.default;
    }
  }), Object.defineProperty(s, "skipAllButComputedKey", {
    enumerable: true,
    get: function() {
      return p.skipAllButComputedKey;
    }
  });
  var n = qi(), h = Ip, f2 = Gl, p = $i, g = Je();
  const {
    assignmentExpression: P,
    booleanLiteral: x,
    callExpression: y,
    cloneNode: A,
    identifier: S,
    memberExpression: v,
    sequenceExpression: T,
    stringLiteral: C,
    thisExpression: I
  } = g;
  function N(O, B, M, j) {
    O = A(O);
    const $ = B || j ? O : v(O, S("prototype"));
    return y(M.addHelper("getPrototypeOf"), [$]);
  }
  const D = n.default.visitors.merge([p.default, {
    Super(O, B) {
      const {
        node: M,
        parentPath: j
      } = O;
      !j.isMemberExpression({
        object: M
      }) || B.handle(j);
    }
  }]), _ = n.default.visitors.merge([p.default, {
    Scopable(O, {
      refName: B
    }) {
      const M = O.scope.getOwnBinding(B);
      M && M.identifier.name === B && O.scope.rename(B);
    }
  }]), m = {
    memoise(O, B) {
      const {
        scope: M,
        node: j
      } = O, {
        computed: $,
        property: k
      } = j;
      if (!$)
        return;
      const ne = M.maybeGenerateMemoised(k);
      !ne || this.memoiser.set(k, ne, B);
    },
    prop(O) {
      const {
        computed: B,
        property: M
      } = O.node;
      return this.memoiser.has(M) ? A(this.memoiser.get(M)) : B ? A(M) : C(M.name);
    },
    get(O) {
      return this._get(O, this._getThisRefs());
    },
    _get(O, B) {
      const M = N(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return y(this.file.addHelper("get"), [B.memo ? T([B.memo, M]) : M, this.prop(O), B.this]);
    },
    _getThisRefs() {
      if (!this.isDerivedConstructor)
        return {
          this: I()
        };
      const O = this.scope.generateDeclaredUidIdentifier("thisSuper");
      return {
        memo: P("=", O, I()),
        this: A(O)
      };
    },
    set(O, B) {
      const M = this._getThisRefs(), j = N(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return y(this.file.addHelper("set"), [M.memo ? T([M.memo, j]) : j, this.prop(O), B, M.this, x(O.isInStrictMode())]);
    },
    destructureSet(O) {
      throw O.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(O, B) {
      const M = this._getThisRefs();
      return (0, f2.default)(this._get(O, M), A(M.this), B, false);
    },
    optionalCall(O, B) {
      const M = this._getThisRefs();
      return (0, f2.default)(this._get(O, M), A(M.this), B, true);
    }
  }, L = Object.assign({}, m, {
    prop(O) {
      const {
        property: B
      } = O.node;
      return this.memoiser.has(B) ? A(this.memoiser.get(B)) : A(B);
    },
    get(O) {
      const {
        isStatic: B,
        getSuperRef: M
      } = this, {
        computed: j
      } = O.node, $ = this.prop(O);
      let k;
      if (B) {
        var ne;
        k = (ne = M()) != null ? ne : v(S("Function"), S("prototype"));
      } else {
        var Q;
        k = v((Q = M()) != null ? Q : S("Object"), S("prototype"));
      }
      return v(k, $, j);
    },
    set(O, B) {
      const {
        computed: M
      } = O.node, j = this.prop(O);
      return P("=", v(I(), j, M), B);
    },
    destructureSet(O) {
      const {
        computed: B
      } = O.node, M = this.prop(O);
      return v(I(), M, B);
    },
    call(O, B) {
      return (0, f2.default)(this.get(O), I(), B, false);
    },
    optionalCall(O, B) {
      return (0, f2.default)(this.get(O), I(), B, true);
    }
  });
  class R {
    constructor(B) {
      var M;
      const j = B.methodPath;
      this.methodPath = j, this.isDerivedConstructor = j.isClassMethod({
        kind: "constructor"
      }) && !!B.superRef, this.isStatic = j.isObjectMethod() || j.node.static || (j.isStaticBlock == null ? void 0 : j.isStaticBlock()), this.isPrivateMethod = j.isPrivate() && j.isMethod(), this.file = B.file, this.constantSuper = (M = B.constantSuper) != null ? M : B.isLoose, this.opts = B;
    }
    getObjectRef() {
      return A(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      if (this.opts.superRef)
        return A(this.opts.superRef);
      if (this.opts.getSuperRef)
        return A(this.opts.getSuperRef());
    }
    replace() {
      this.opts.refToPreserve && this.methodPath.traverse(_, {
        refName: this.opts.refToPreserve.name
      });
      const B = this.constantSuper ? L : m;
      (0, h.default)(this.methodPath, D, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: B.get
      }, B));
    }
  }
  s.default = R;
})(wp);
var Np = {};
Object.defineProperty(Np, "__esModule", {
  value: true
});
Np.default = uE;
var nE = Je();
var {
  addComment: aE
} = nE;
var oE = "#__PURE__";
var lE = ({
  leadingComments: s
}) => !!s && s.some((n) => /[@#]__PURE__/.test(n.value));
function uE(s) {
  const n = s.node || s;
  lE(n) || aE(n, "leading", oE);
}
var Xl = {};
Object.defineProperty(Xl, "__esModule", {
  value: true
});
Xl.assertFieldTransformed = cE;
function cE(s) {
  if (s.node.declare)
    throw s.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-proposal-class-properties
 - @babel/plugin-proposal-private-methods
 - @babel/plugin-proposal-decorators`);
}
Object.defineProperty(Qn, "__esModule", {
  value: true
});
Qn.buildFieldsInitNodes = DE;
Qn.buildPrivateNamesMap = mE;
Qn.buildPrivateNamesNodes = yE;
Qn.transformPrivateNamesUsage = PE;
var Fe = on();
var pE = wp;
var ob = $i;
var fE = Ip;
var fy = Gl;
var hE = Np;
var dE = Xl;
function mE(s) {
  const n = /* @__PURE__ */ new Map();
  for (const h of s)
    if (h.isPrivate()) {
      const {
        name: f2
      } = h.node.key.id, p = n.has(f2) ? n.get(f2) : {
        id: h.scope.generateUidIdentifier(f2),
        static: h.node.static,
        method: !h.isProperty()
      };
      h.isClassPrivateMethod() && (h.node.kind === "get" ? p.getId = h.scope.generateUidIdentifier(`get_${f2}`) : h.node.kind === "set" ? p.setId = h.scope.generateUidIdentifier(`set_${f2}`) : h.node.kind === "method" && (p.methodId = h.scope.generateUidIdentifier(f2))), n.set(f2, p);
    }
  return n;
}
function yE(s, n, h) {
  const f2 = [];
  for (const [p, g] of s) {
    const {
      static: P,
      method: x,
      getId: y,
      setId: A
    } = g, S = y || A, v = Fe.types.cloneNode(g.id);
    let T;
    n ? T = Fe.types.callExpression(h.addHelper("classPrivateFieldLooseKey"), [Fe.types.stringLiteral(p)]) : P || (T = Fe.types.newExpression(Fe.types.identifier(!x || S ? "WeakMap" : "WeakSet"), [])), T && ((0, hE.default)(T), f2.push(Fe.template.statement.ast`var ${v} = ${T}`));
  }
  return f2;
}
function lb(s) {
  const n = Object.assign({}, s, {
    Class(f2) {
      const {
        privateNamesMap: p
      } = this, g = f2.get("body.body"), P = new Map(p), x = [];
      for (const y of g) {
        if (!y.isPrivate())
          continue;
        const {
          name: A
        } = y.node.key.id;
        P.delete(A), x.push(A);
      }
      !x.length || (f2.get("body").traverse(h, Object.assign({}, this, {
        redeclared: x
      })), f2.traverse(n, Object.assign({}, this, {
        privateNamesMap: P
      })), f2.skipKey("body"));
    }
  }), h = Fe.traverse.visitors.merge([Object.assign({}, s), ob.default]);
  return n;
}
var bE = lb({
  PrivateName(s, {
    noDocumentAll: n
  }) {
    const {
      privateNamesMap: h,
      redeclared: f2
    } = this, {
      node: p,
      parentPath: g
    } = s;
    if (!g.isMemberExpression({
      property: p
    }) && !g.isOptionalMemberExpression({
      property: p
    }))
      return;
    const {
      name: P
    } = p.id;
    !h.has(P) || f2 && f2.includes(P) || this.handle(g, n);
  }
});
function ub(s, n, h) {
  for (; (f2 = n) != null && f2.hasBinding(s) && !n.bindingIdentifierEquals(s, h); ) {
    var f2;
    n.rename(s), n = n.parent;
  }
}
var gE = lb({
  BinaryExpression(s) {
    const {
      operator: n,
      left: h,
      right: f2
    } = s.node;
    if (n !== "in" || !Fe.types.isPrivateName(h))
      return;
    const {
      privateFieldsAsProperties: p,
      privateNamesMap: g,
      redeclared: P
    } = this, {
      name: x
    } = h.id;
    if (!g.has(x) || P && P.includes(x))
      return;
    if (ub(this.classRef.name, s.scope, this.innerBinding), p) {
      const {
        id: S
      } = g.get(x);
      s.replaceWith(Fe.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${f2}, ${Fe.types.cloneNode(S)})
      `);
      return;
    }
    const {
      id: y,
      static: A
    } = g.get(x);
    if (A) {
      s.replaceWith(Fe.template.expression.ast`${f2} === ${this.classRef}`);
      return;
    }
    s.replaceWith(Fe.template.expression.ast`${Fe.types.cloneNode(y)}.has(${f2})`);
  }
});
var TE = {
  memoise(s, n) {
    const {
      scope: h
    } = s, {
      object: f2
    } = s.node, p = h.maybeGenerateMemoised(f2);
    !p || this.memoiser.set(f2, p, n);
  },
  receiver(s) {
    const {
      object: n
    } = s.node;
    return this.memoiser.has(n) ? Fe.types.cloneNode(this.memoiser.get(n)) : Fe.types.cloneNode(n);
  },
  get(s) {
    const {
      classRef: n,
      privateNamesMap: h,
      file: f2,
      innerBinding: p
    } = this, {
      name: g
    } = s.node.property.id, {
      id: P,
      static: x,
      method: y,
      methodId: A,
      getId: S,
      setId: v
    } = h.get(g), T = S || v;
    if (x) {
      const C = y && !T ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
      return ub(n.name, s.scope, p), Fe.types.callExpression(f2.addHelper(C), [this.receiver(s), Fe.types.cloneNode(n), Fe.types.cloneNode(P)]);
    }
    if (y) {
      if (T) {
        if (!S && v) {
          if (f2.availableHelper("writeOnlyError"))
            return Fe.types.sequenceExpression([this.receiver(s), Fe.types.callExpression(f2.addHelper("writeOnlyError"), [Fe.types.stringLiteral(`#${g}`)])]);
          console.warn("@babel/helpers is outdated, update it to silence this warning.");
        }
        return Fe.types.callExpression(f2.addHelper("classPrivateFieldGet"), [this.receiver(s), Fe.types.cloneNode(P)]);
      }
      return Fe.types.callExpression(f2.addHelper("classPrivateMethodGet"), [this.receiver(s), Fe.types.cloneNode(P), Fe.types.cloneNode(A)]);
    }
    return Fe.types.callExpression(f2.addHelper("classPrivateFieldGet"), [this.receiver(s), Fe.types.cloneNode(P)]);
  },
  boundGet(s) {
    return this.memoise(s, 1), Fe.types.callExpression(Fe.types.memberExpression(this.get(s), Fe.types.identifier("bind")), [this.receiver(s)]);
  },
  set(s, n) {
    const {
      classRef: h,
      privateNamesMap: f2,
      file: p
    } = this, {
      name: g
    } = s.node.property.id, {
      id: P,
      static: x,
      method: y,
      setId: A,
      getId: S
    } = f2.get(g), v = S || A;
    if (x) {
      const T = y && !v ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
      return Fe.types.callExpression(p.addHelper(T), [this.receiver(s), Fe.types.cloneNode(h), Fe.types.cloneNode(P), n]);
    }
    return y ? A ? Fe.types.callExpression(p.addHelper("classPrivateFieldSet"), [this.receiver(s), Fe.types.cloneNode(P), n]) : Fe.types.sequenceExpression([this.receiver(s), n, Fe.types.callExpression(p.addHelper("readOnlyError"), [Fe.types.stringLiteral(`#${g}`)])]) : Fe.types.callExpression(p.addHelper("classPrivateFieldSet"), [this.receiver(s), Fe.types.cloneNode(P), n]);
  },
  destructureSet(s) {
    const {
      classRef: n,
      privateNamesMap: h,
      file: f2
    } = this, {
      name: p
    } = s.node.property.id, {
      id: g,
      static: P
    } = h.get(p);
    if (P) {
      try {
        var x = f2.addHelper("classStaticPrivateFieldDestructureSet");
      } catch {
        throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
      }
      return Fe.types.memberExpression(Fe.types.callExpression(x, [this.receiver(s), Fe.types.cloneNode(n), Fe.types.cloneNode(g)]), Fe.types.identifier("value"));
    }
    return Fe.types.memberExpression(Fe.types.callExpression(f2.addHelper("classPrivateFieldDestructureSet"), [this.receiver(s), Fe.types.cloneNode(g)]), Fe.types.identifier("value"));
  },
  call(s, n) {
    return this.memoise(s, 1), (0, fy.default)(this.get(s), this.receiver(s), n, false);
  },
  optionalCall(s, n) {
    return this.memoise(s, 1), (0, fy.default)(this.get(s), this.receiver(s), n, true);
  }
};
var xE = {
  get(s) {
    const {
      privateNamesMap: n,
      file: h
    } = this, {
      object: f2
    } = s.node, {
      name: p
    } = s.node.property.id;
    return Fe.template.expression`BASE(REF, PROP)[PROP]`({
      BASE: h.addHelper("classPrivateFieldLooseBase"),
      REF: Fe.types.cloneNode(f2),
      PROP: Fe.types.cloneNode(n.get(p).id)
    });
  },
  set() {
    throw new Error("private name handler with loose = true don't need set()");
  },
  boundGet(s) {
    return Fe.types.callExpression(Fe.types.memberExpression(this.get(s), Fe.types.identifier("bind")), [Fe.types.cloneNode(s.node.object)]);
  },
  simpleSet(s) {
    return this.get(s);
  },
  destructureSet(s) {
    return this.get(s);
  },
  call(s, n) {
    return Fe.types.callExpression(this.get(s), n);
  },
  optionalCall(s, n) {
    return Fe.types.optionalCallExpression(this.get(s), n, true);
  }
};
function PE(s, n, h, {
  privateFieldsAsProperties: f2,
  noDocumentAll: p,
  innerBinding: g
}, P) {
  if (!h.size)
    return;
  const x = n.get("body"), y = f2 ? xE : TE;
  (0, fE.default)(x, bE, Object.assign({
    privateNamesMap: h,
    classRef: s,
    file: P
  }, y, {
    noDocumentAll: p,
    innerBinding: g
  })), x.traverse(gE, {
    privateNamesMap: h,
    classRef: s,
    file: P,
    privateFieldsAsProperties: f2,
    innerBinding: g
  });
}
function hy(s, n, h) {
  const {
    id: f2
  } = h.get(n.node.key.id.name), p = n.node.value || n.scope.buildUndefinedNode();
  return Fe.template.statement.ast`
    Object.defineProperty(${s}, ${Fe.types.cloneNode(f2)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${p}
    });
  `;
}
function SE(s, n, h, f2) {
  const {
    id: p
  } = h.get(n.node.key.id.name), g = n.node.value || n.scope.buildUndefinedNode();
  if (!f2.availableHelper("classPrivateFieldInitSpec"))
    return Fe.template.statement.ast`${Fe.types.cloneNode(p)}.set(${s}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${g},
      })`;
  const P = f2.addHelper("classPrivateFieldInitSpec");
  return Fe.template.statement.ast`${P}(
    ${Fe.types.thisExpression()},
    ${Fe.types.cloneNode(p)},
    {
      writable: true,
      value: ${g}
    },
  )`;
}
function dy(s, n) {
  const h = n.get(s.node.key.id.name), {
    id: f2,
    getId: p,
    setId: g,
    initAdded: P
  } = h, x = p || g;
  if (!s.isProperty() && (P || !x))
    return;
  if (x)
    return n.set(s.node.key.id.name, Object.assign({}, h, {
      initAdded: true
    })), Fe.template.statement.ast`
      var ${Fe.types.cloneNode(f2)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${p ? p.name : s.scope.buildUndefinedNode()},
        set: ${g ? g.name : s.scope.buildUndefinedNode()}
      }
    `;
  const y = s.node.value || s.scope.buildUndefinedNode();
  return Fe.template.statement.ast`
    var ${Fe.types.cloneNode(f2)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${y}
    };
  `;
}
function EE(s, n, h) {
  const f2 = h.get(n.node.key.id.name), {
    methodId: p,
    id: g,
    getId: P,
    setId: x,
    initAdded: y
  } = f2;
  if (y)
    return;
  if (p)
    return Fe.template.statement.ast`
        Object.defineProperty(${s}, ${g}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${p.name}
        });
      `;
  if (P || x)
    return h.set(n.node.key.id.name, Object.assign({}, f2, {
      initAdded: true
    })), Fe.template.statement.ast`
      Object.defineProperty(${s}, ${g}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${P ? P.name : n.scope.buildUndefinedNode()},
        set: ${x ? x.name : n.scope.buildUndefinedNode()}
      });
    `;
}
function vE(s, n, h, f2) {
  const p = h.get(n.node.key.id.name), {
    getId: g,
    setId: P,
    initAdded: x
  } = p;
  return x ? void 0 : g || P ? AE(s, n, h, f2) : CE(s, n, h, f2);
}
function AE(s, n, h, f2) {
  const p = h.get(n.node.key.id.name), {
    id: g,
    getId: P,
    setId: x
  } = p;
  if (h.set(n.node.key.id.name, Object.assign({}, p, {
    initAdded: true
  })), !f2.availableHelper("classPrivateFieldInitSpec"))
    return Fe.template.statement.ast`
      ${g}.set(${s}, {
        get: ${P ? P.name : n.scope.buildUndefinedNode()},
        set: ${x ? x.name : n.scope.buildUndefinedNode()}
      });
    `;
  const y = f2.addHelper("classPrivateFieldInitSpec");
  return Fe.template.statement.ast`${y}(
    ${Fe.types.thisExpression()},
    ${Fe.types.cloneNode(g)},
    {
      get: ${P ? P.name : n.scope.buildUndefinedNode()},
      set: ${x ? x.name : n.scope.buildUndefinedNode()}
    },
  )`;
}
function CE(s, n, h, f2) {
  const p = h.get(n.node.key.id.name), {
    id: g
  } = p;
  if (!f2.availableHelper("classPrivateMethodInitSpec"))
    return Fe.template.statement.ast`${g}.add(${s})`;
  const P = f2.addHelper("classPrivateMethodInitSpec");
  return Fe.template.statement.ast`${P}(
    ${Fe.types.thisExpression()},
    ${Fe.types.cloneNode(g)}
  )`;
}
function my(s, n) {
  const {
    key: h,
    computed: f2
  } = n.node, p = n.node.value || n.scope.buildUndefinedNode();
  return Fe.types.expressionStatement(Fe.types.assignmentExpression("=", Fe.types.memberExpression(s, h, f2 || Fe.types.isLiteral(h)), p));
}
function yy(s, n, h) {
  const {
    key: f2,
    computed: p
  } = n.node, g = n.node.value || n.scope.buildUndefinedNode();
  return Fe.types.expressionStatement(Fe.types.callExpression(h.addHelper("defineProperty"), [s, p || Fe.types.isLiteral(f2) ? f2 : Fe.types.stringLiteral(f2.name), g]));
}
function wE(s, n, h, f2) {
  const p = f2.get(n.node.key.id.name), {
    id: g,
    methodId: P,
    getId: x,
    setId: y,
    initAdded: A
  } = p;
  return A ? void 0 : x || y ? (f2.set(n.node.key.id.name, Object.assign({}, p, {
    initAdded: true
  })), Fe.template.statement.ast`
      Object.defineProperty(${s}, ${g}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${x ? x.name : n.scope.buildUndefinedNode()},
        set: ${y ? y.name : n.scope.buildUndefinedNode()}
      })
    `) : Fe.template.statement.ast`
    Object.defineProperty(${s}, ${g}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${P.name}
    });
  `;
}
function bl(s, n, h = false) {
  const f2 = n.get(s.node.key.id.name), {
    id: p,
    methodId: g,
    getId: P,
    setId: x,
    getterDeclared: y,
    setterDeclared: A,
    static: S
  } = f2, {
    params: v,
    body: T,
    generator: C,
    async: I
  } = s.node, N = P && !y && v.length === 0, D = x && !A && v.length > 0;
  let _ = g;
  return N ? (n.set(s.node.key.id.name, Object.assign({}, f2, {
    getterDeclared: true
  })), _ = P) : D ? (n.set(s.node.key.id.name, Object.assign({}, f2, {
    setterDeclared: true
  })), _ = x) : S && !h && (_ = p), Fe.types.functionDeclaration(Fe.types.cloneNode(_), v, T, C, I);
}
var IE = Fe.traverse.visitors.merge([{
  ThisExpression(s, n) {
    n.needsClassRef = true, s.replaceWith(Fe.types.cloneNode(n.classRef));
  },
  MetaProperty(s) {
    const n = s.get("meta"), h = s.get("property"), {
      scope: f2
    } = s;
    n.isIdentifier({
      name: "new"
    }) && h.isIdentifier({
      name: "target"
    }) && s.replaceWith(f2.buildUndefinedNode());
  }
}, ob.default]);
var NE = {
  ReferencedIdentifier(s, n) {
    s.scope.bindingIdentifierEquals(s.node.name, n.innerBinding) && (n.needsClassRef = true, s.node.name = n.classRef.name);
  }
};
function kE(s, n, h, f2, p, g, P) {
  var x;
  const y = {
    classRef: n,
    needsClassRef: false,
    innerBinding: P
  };
  return new pE.default({
    methodPath: s,
    constantSuper: g,
    file: f2,
    refToPreserve: n,
    getSuperRef: h,
    getObjectRef() {
      return y.needsClassRef = true, Fe.types.isStaticBlock != null && Fe.types.isStaticBlock(s.node) || s.node.static ? n : Fe.types.memberExpression(n, Fe.types.identifier("prototype"));
    }
  }).replace(), (p || s.isProperty()) && s.traverse(IE, y), P != null && (x = y.classRef) != null && x.name && y.classRef.name !== (P == null ? void 0 : P.name) && s.traverse(NE, y), y.needsClassRef;
}
function OE({
  key: s,
  computed: n
}) {
  return s.type === "Identifier" ? !n && (s.name === "name" || s.name === "length") : s.type === "StringLiteral" ? s.value === "name" || s.value === "length" : false;
}
function DE(s, n, h, f2, p, g, P, x, y) {
  let A = false, S;
  const v = [], T = [], C = [], I = Fe.types.isIdentifier(n) ? () => n : () => {
    var N;
    return (N = S) != null || (S = h[0].scope.generateUidIdentifierBasedOnNode(n)), S;
  };
  for (const N of h) {
    N.isClassProperty() && dE.assertFieldTransformed(N);
    const D = !(Fe.types.isStaticBlock != null && Fe.types.isStaticBlock(N.node)) && N.node.static, _ = !D, m = N.isPrivate(), L = !m, R = N.isProperty(), O = !R, B = N.isStaticBlock == null ? void 0 : N.isStaticBlock();
    if (D || O && m || B) {
      const M = kE(N, s, I, p, B, x, y);
      A = A || M;
    }
    switch (true) {
      case B: {
        const M = N.node.body;
        M.length === 1 && Fe.types.isExpressionStatement(M[0]) ? v.push(M[0]) : v.push(Fe.template.statement.ast`(() => { ${M} })()`);
        break;
      }
      case (D && m && R && P):
        A = true, v.push(hy(Fe.types.cloneNode(s), N, f2));
        break;
      case (D && m && R && !P):
        A = true, v.push(dy(N, f2));
        break;
      case (D && L && R && g):
        if (!OE(N.node)) {
          A = true, v.push(my(Fe.types.cloneNode(s), N));
          break;
        }
      case (D && L && R && !g):
        A = true, v.push(yy(Fe.types.cloneNode(s), N, p));
        break;
      case (_ && m && R && P):
        T.push(hy(Fe.types.thisExpression(), N, f2));
        break;
      case (_ && m && R && !P):
        T.push(SE(Fe.types.thisExpression(), N, f2, p));
        break;
      case (_ && m && O && P):
        T.unshift(EE(Fe.types.thisExpression(), N, f2)), C.push(bl(N, f2, P));
        break;
      case (_ && m && O && !P):
        T.unshift(vE(Fe.types.thisExpression(), N, f2, p)), C.push(bl(N, f2, P));
        break;
      case (D && m && O && !P):
        A = true, v.unshift(dy(N, f2)), C.push(bl(N, f2, P));
        break;
      case (D && m && O && P):
        A = true, v.unshift(wE(Fe.types.cloneNode(s), N, p, f2)), C.push(bl(N, f2, P));
        break;
      case (_ && L && R && g):
        T.push(my(Fe.types.thisExpression(), N));
        break;
      case (_ && L && R && !g):
        T.push(yy(Fe.types.thisExpression(), N, p));
        break;
      default:
        throw new Error("Unreachable.");
    }
  }
  return {
    staticNodes: v.filter(Boolean),
    instanceNodes: T.filter(Boolean),
    pureStaticNodes: C.filter(Boolean),
    wrapClass(N) {
      for (const D of h)
        D.remove();
      return S && (N.scope.push({
        id: Fe.types.cloneNode(S)
      }), N.set("superClass", Fe.types.assignmentExpression("=", S, N.node.superClass))), A && (N.isClassExpression() ? (N.scope.push({
        id: s
      }), N.replaceWith(Fe.types.assignmentExpression("=", Fe.types.cloneNode(s), N.node))) : N.node.id || (N.node.id = s)), N;
    }
  };
}
var Zn = {};
Object.defineProperty(Zn, "__esModule", {
  value: true
});
Zn.buildDecoratedClass = UE;
Zn.hasDecorators = BE;
Zn.hasOwnDecorators = qc;
var Ct = on();
var LE = wp;
var ME = ja;
function qc(s) {
  return !!(s.decorators && s.decorators.length);
}
function BE(s) {
  return qc(s) || s.body.body.some(qc);
}
function Rn(s, n) {
  return n ? Ct.types.objectProperty(Ct.types.identifier(s), n) : null;
}
function _E(s, n) {
  return Ct.types.objectMethod("method", Ct.types.identifier(s), [], Ct.types.blockStatement(n));
}
function cb(s) {
  let n;
  return s.decorators && s.decorators.length > 0 && (n = Ct.types.arrayExpression(s.decorators.map((h) => h.expression))), s.decorators = void 0, n;
}
function FE(s) {
  return s.computed ? s.key : Ct.types.isIdentifier(s.key) ? Ct.types.stringLiteral(s.key.name) : Ct.types.stringLiteral(String(s.key.value));
}
function jE(s, n, h, f2) {
  const p = f2.isClassMethod();
  if (f2.isPrivate())
    throw f2.buildCodeFrameError(`Private ${p ? "methods" : "fields"} in decorated classes are not supported yet.`);
  if (f2.node.type === "ClassAccessorProperty")
    throw f2.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
  if (f2.node.type === "StaticBlock")
    throw f2.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
  const {
    node: g,
    scope: P
  } = f2;
  f2.isTSDeclareMethod() || new LE.default({
    methodPath: f2,
    objectRef: n,
    superRef: h,
    file: s,
    refToPreserve: n
  }).replace();
  const x = [Rn("kind", Ct.types.stringLiteral(Ct.types.isClassMethod(g) ? g.kind : "field")), Rn("decorators", cb(g)), Rn("static", g.static && Ct.types.booleanLiteral(true)), Rn("key", FE(g))].filter(Boolean);
  if (Ct.types.isClassMethod(g)) {
    const y = g.computed ? null : g.key, A = Ct.types.toExpression(g);
    x.push(Rn("value", (0, ME.default)({
      node: A,
      id: y,
      scope: P
    }) || A));
  } else
    Ct.types.isClassProperty(g) && g.value ? x.push(_E("value", Ct.template.statements.ast`return ${g.value}`)) : x.push(Rn("value", P.buildUndefinedNode()));
  return f2.remove(), Ct.types.objectExpression(x);
}
function RE(s) {
  try {
    return s.addHelper("decorate");
  } catch (n) {
    throw n.code === "BABEL_HELPER_UNKNOWN" && (n.message += `
  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version.`), n;
  }
}
function UE(s, n, h, f2) {
  const {
    node: p,
    scope: g
  } = n, P = g.generateUidIdentifier("initialize"), x = p.id && n.isDeclaration(), y = n.isInStrictMode(), {
    superClass: A
  } = p;
  p.type = "ClassDeclaration", p.id || (p.id = Ct.types.cloneNode(s));
  let S;
  A && (S = g.generateUidIdentifierBasedOnNode(p.superClass, "super"), p.superClass = S);
  const v = cb(p), T = Ct.types.arrayExpression(h.filter((D) => !D.node.abstract && D.node.type !== "TSIndexSignature").map((D) => jE(f2, p.id, S, D))), C = Ct.template.expression.ast`
    ${RE(f2)}(
      ${v || Ct.types.nullLiteral()},
      function (${P}, ${A ? Ct.types.cloneNode(S) : null}) {
        ${p}
        return { F: ${Ct.types.cloneNode(p.id)}, d: ${T} };
      },
      ${A}
    )
  `;
  y || C.arguments[1].body.directives.push(Ct.types.directive(Ct.types.directiveLiteral("use strict")));
  let I = C, N = "arguments.1.body.body.0";
  return x && (I = Ct.template.statement.ast`let ${s} = ${C}`, N = "declarations.0.init." + N), {
    instanceNodes: [Ct.template.statement.ast`${Ct.types.cloneNode(P)}(this)`],
    wrapClass(D) {
      return D.replaceWith(I), D.get(N);
    }
  };
}
var Jl = {};
Object.defineProperty(Jl, "__esModule", {
  value: true
});
Jl.extractComputedKeys = HE;
Jl.injectInitialization = WE;
var Lr = on();
var $E = $i;
var qE = Lr.traverse.visitors.merge([{
  Super(s) {
    const {
      node: n,
      parentPath: h
    } = s;
    h.isCallExpression({
      callee: n
    }) && this.push(h);
  }
}, $E.default]);
var VE = {
  "TSTypeAnnotation|TypeAnnotation"(s) {
    s.skip();
  },
  ReferencedIdentifier(s, {
    scope: n
  }) {
    n.hasOwnBinding(s.node.name) && (n.rename(s.node.name), s.skip());
  }
};
function pb(s, n) {
  if (n.classBinding && n.classBinding === s.scope.getBinding(s.node.name)) {
    const h = n.file.addHelper("classNameTDZError"), f2 = Lr.types.callExpression(h, [Lr.types.stringLiteral(s.node.name)]);
    s.replaceWith(Lr.types.sequenceExpression([f2, s.node])), s.skip();
  }
}
var KE = {
  ReferencedIdentifier: pb
};
function WE(s, n, h, f2) {
  if (!h.length)
    return;
  const p = !!s.node.superClass;
  if (!n) {
    const g = Lr.types.classMethod("constructor", Lr.types.identifier("constructor"), [], Lr.types.blockStatement([]));
    p && (g.params = [Lr.types.restElement(Lr.types.identifier("args"))], g.body.body.push(Lr.template.statement.ast`super(...args)`)), [n] = s.get("body").unshiftContainer("body", g);
  }
  if (f2 && f2(VE, {
    scope: n.scope
  }), p) {
    const g = [];
    n.traverse(qE, g);
    let P = true;
    for (const x of g)
      P ? (x.insertAfter(h), P = false) : x.insertAfter(h.map((y) => Lr.types.cloneNode(y)));
  } else
    n.get("body").unshiftContainer("body", h);
}
function HE(s, n, h) {
  const f2 = [], p = {
    classBinding: s.node.id && s.scope.getBinding(s.node.id.name),
    file: h
  };
  for (const g of n) {
    const P = g.get("key");
    P.isReferencedIdentifier() ? pb(P, p) : P.traverse(KE, p);
    const x = g.node;
    if (!P.isConstantExpression()) {
      const y = s.scope.generateUidIdentifierBasedOnNode(x.key);
      s.scope.push({
        id: y,
        kind: "let"
      }), f2.push(Lr.types.expressionStatement(Lr.types.assignmentExpression("=", Lr.types.cloneNode(y), x.key))), x.key = Lr.types.cloneNode(y);
    }
  }
  return f2;
}
var En = {};
Object.defineProperty(En, "__esModule", {
  value: true
});
En.FEATURES = void 0;
En.enableFeature = zE;
En.isLoose = Kc;
En.shouldTransform = GE;
var by = Zn;
var Ki = Object.freeze({
  fields: 1 << 1,
  privateMethods: 1 << 2,
  decorators: 1 << 3,
  privateIn: 1 << 4,
  staticBlocks: 1 << 5
});
En.FEATURES = Ki;
var gy = /* @__PURE__ */ new Map([[Ki.fields, "@babel/plugin-proposal-class-properties"], [Ki.privateMethods, "@babel/plugin-proposal-private-methods"], [Ki.privateIn, "@babel/plugin-proposal-private-property-in-object"]]);
var Vc = "@babel/plugin-class-features/featuresKey";
var Oa = "@babel/plugin-class-features/looseKey";
var bn = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
function zE(s, n, h) {
  (!sn(s, n) || Ty(s, n)) && (s.set(Vc, s.get(Vc) | n), h === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (gl(s, n, true), s.set(bn, s.get(bn) | n)) : h === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (gl(s, n, false), s.set(bn, s.get(bn) | n)) : gl(s, n, h));
  let f2, p;
  for (const [g, P] of gy) {
    if (!sn(s, g))
      continue;
    const x = Kc(s, g);
    if (!Ty(s, g)) {
      if (f2 === !x)
        throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");
      f2 = x, p = P;
    }
  }
  if (f2 !== void 0)
    for (const [g, P] of gy)
      sn(s, g) && Kc(s, g) !== f2 && (gl(s, g, f2), console.warn(`Though the "loose" option was set to "${!f2}" in your @babel/preset-env config, it will not be used for ${P} since the "loose" mode option was set to "${f2}" for ${p}.
The "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${P}", { "loose": ${f2} }]
to the "plugins" section of your Babel config.`));
}
function sn(s, n) {
  return !!(s.get(Vc) & n);
}
function Kc(s, n) {
  return !!(s.get(Oa) & n);
}
function gl(s, n, h) {
  h ? s.set(Oa, s.get(Oa) | n) : s.set(Oa, s.get(Oa) & ~n), s.set(bn, s.get(bn) & ~n);
}
function Ty(s, n) {
  return !!(s.get(bn) & n);
}
function GE(s, n) {
  let h = null, f2 = null, p = null, g = null, P = null;
  (0, by.hasOwnDecorators)(s.node) && (h = s.get("decorators.0"));
  for (const x of s.get("body.body"))
    !h && (0, by.hasOwnDecorators)(x.node) && (h = x.get("decorators.0")), !f2 && x.isClassProperty() && (f2 = x), !p && x.isClassPrivateProperty() && (p = x), !g && x.isClassPrivateMethod != null && x.isClassPrivateMethod() && (g = x), !P && x.isStaticBlock != null && x.isStaticBlock() && (P = x);
  if (h && p)
    throw p.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
  if (h && g)
    throw g.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
  if (h && !sn(n, Ki.decorators))
    throw s.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-proposal-class-properties", { "loose": true }]`);
  if (g && !sn(n, Ki.privateMethods))
    throw g.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-proposal-private-methods` to your configuration.");
  if ((f2 || p) && !sn(n, Ki.fields) && !sn(n, Ki.privateMethods))
    throw s.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-proposal-class-properties` to your configuration.");
  if (P && !sn(n, Ki.staticBlocks))
    throw s.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.");
  return !!(h || g || P || (f2 || p) && sn(n, Ki.fields));
}
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: true
  }), Object.defineProperty(s, "FEATURES", {
    enumerable: true,
    get: function() {
      return x.FEATURES;
    }
  }), s.createClassFeaturePlugin = v, Object.defineProperty(s, "enableFeature", {
    enumerable: true,
    get: function() {
      return x.enableFeature;
    }
  }), Object.defineProperty(s, "injectInitialization", {
    enumerable: true,
    get: function() {
      return P.injectInitialization;
    }
  });
  var n = on(), h = ja, f2 = Fa, p = Qn, g = Zn, P = Jl, x = En, y = Xl;
  const A = "7.18.9".split(".").reduce((T, C) => T * 1e5 + +C, 0), S = "@babel/plugin-class-features/version";
  function v({
    name: T,
    feature: C,
    loose: I,
    manipulateOptions: N,
    api: D = {
      assumption: () => {
      }
    },
    inherits: _
  }) {
    const m = D.assumption("setPublicClassFields"), L = D.assumption("privateFieldsAsProperties"), R = D.assumption("constantSuper"), O = D.assumption("noDocumentAll");
    if (I === true) {
      const B = [];
      m !== void 0 && B.push('"setPublicClassFields"'), L !== void 0 && B.push('"privateFieldsAsProperties"'), B.length !== 0 && console.warn(`[${T}]: You are using the "loose: true" option and you are explicitly setting a value for the ${B.join(" and ")} assumption${B.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsProperties": true
	}`);
    }
    return {
      name: T,
      manipulateOptions: N,
      inherits: _,
      pre(B) {
        (0, x.enableFeature)(B, C, I), (!B.get(S) || B.get(S) < A) && B.set(S, A);
      },
      visitor: {
        Class(B, {
          file: M
        }) {
          if (M.get(S) !== A || !(0, x.shouldTransform)(B, M))
            return;
          B.isClassDeclaration() && (0, y.assertFieldTransformed)(B);
          const j = (0, x.isLoose)(M, C);
          let $;
          const k = (0, g.hasDecorators)(B.node), ne = [], Q = [], q = [], ee = /* @__PURE__ */ new Set(), K = B.get("body");
          for (const H of K.get("body")) {
            if ((H.isClassProperty() || H.isClassMethod()) && H.node.computed && q.push(H), H.isPrivate()) {
              const {
                name: te
              } = H.node.key.id, Ie = `get ${te}`, Te = `set ${te}`;
              if (H.isClassPrivateMethod()) {
                if (H.node.kind === "get") {
                  if (ee.has(Ie) || ee.has(te) && !ee.has(Te))
                    throw H.buildCodeFrameError("Duplicate private field");
                  ee.add(Ie).add(te);
                } else if (H.node.kind === "set") {
                  if (ee.has(Te) || ee.has(te) && !ee.has(Ie))
                    throw H.buildCodeFrameError("Duplicate private field");
                  ee.add(Te).add(te);
                }
              } else {
                if (ee.has(te) && !ee.has(Ie) && !ee.has(Te) || ee.has(te) && (ee.has(Ie) || ee.has(Te)))
                  throw H.buildCodeFrameError("Duplicate private field");
                ee.add(te);
              }
            }
            H.isClassMethod({
              kind: "constructor"
            }) ? $ = H : (Q.push(H), (H.isProperty() || H.isPrivate() || H.isStaticBlock != null && H.isStaticBlock()) && ne.push(H));
          }
          if (!ne.length && !k)
            return;
          const G = B.node.id;
          let V;
          !G || B.isClassExpression() ? ((0, h.default)(B), V = B.scope.generateUidIdentifier("class")) : V = n.types.cloneNode(B.node.id);
          const F = (0, p.buildPrivateNamesMap)(ne), le = (0, p.buildPrivateNamesNodes)(F, L != null ? L : j, M);
          (0, p.transformPrivateNamesUsage)(V, B, F, {
            privateFieldsAsProperties: L != null ? L : j,
            noDocumentAll: O,
            innerBinding: G
          }, M);
          let oe, fe, he, de, Pe;
          k ? (fe = de = oe = [], {
            instanceNodes: he,
            wrapClass: Pe
          } = (0, g.buildDecoratedClass)(V, B, Q, M)) : (oe = (0, P.extractComputedKeys)(B, q, M), {
            staticNodes: fe,
            pureStaticNodes: de,
            instanceNodes: he,
            wrapClass: Pe
          } = (0, p.buildFieldsInitNodes)(V, B.node.superClass, ne, F, M, m != null ? m : j, L != null ? L : j, R != null ? R : j, G)), he.length > 0 && (0, P.injectInitialization)(B, $, he, (H, te) => {
            if (!k)
              for (const Ie of ne)
                n.types.isStaticBlock != null && n.types.isStaticBlock(Ie.node) || Ie.node.static || Ie.traverse(H, te);
          });
          const we = Pe(B);
          we.insertBefore([...le, ...oe]), fe.length > 0 && we.insertAfter(fe), de.length > 0 && we.find((H) => H.isStatement() || H.isDeclaration()).insertAfter(de);
        },
        ExportDefaultDeclaration(B, {
          file: M
        }) {
          {
            if (M.get(S) !== A)
              return;
            const j = B.get("declaration");
            j.isClassDeclaration() && (0, g.hasDecorators)(j.node) && (j.node.id ? (0, f2.default)(B) : j.node.type = "ClassExpression");
          }
        }
      }
    };
  }
})(ab);
var kp = {};
var $a = {};
Object.defineProperty($a, "__esModule", {
  value: true
});
$a.default = JE;
$a.translateEnumValues = hb;
var Op = on();
var XE = Ra;
function JE(s, n) {
  const {
    node: h
  } = s;
  if (h.declare) {
    s.remove();
    return;
  }
  const f2 = h.id.name, p = rv(s, n, h.id);
  switch (s.parent.type) {
    case "BlockStatement":
    case "ExportNamedDeclaration":
    case "Program": {
      if (s.insertAfter(p), g(s.parentPath))
        s.remove();
      else {
        const P = n.isProgram(s.parent);
        s.scope.registerDeclaration(s.replaceWith(YE(h.id, n, P ? "var" : "let"))[0]);
      }
      break;
    }
    default:
      throw new Error(`Unexpected enum parent '${s.parent.type}`);
  }
  function g(P) {
    return P.isExportDeclaration() ? g(P.parentPath) : P.getData(f2) ? true : (P.setData(f2, true), false);
  }
}
function YE(s, n, h) {
  return n.variableDeclaration(h, [n.variableDeclarator(s)]);
}
var QE = (0, Op.template)(`
  (function (ID) {
    ASSIGNMENTS;
  })(ID || (ID = {}));
`);
var ZE = (0, Op.template)(`
  ENUM["NAME"] = VALUE;
`);
var ev = (0, Op.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`);
var tv = (s, n) => (s ? ZE : ev)(n);
function rv(s, n, h) {
  const p = hb(s, n).map(([g, P]) => tv(n.isStringLiteral(P), {
    ENUM: n.cloneNode(h),
    NAME: g,
    VALUE: P
  }));
  return QE({
    ID: n.cloneNode(h),
    ASSIGNMENTS: p
  });
}
function fb(s, n) {
  const {
    seen: h,
    path: f2,
    t: p
  } = n, g = s.node.name;
  h.has(g) && !s.scope.hasOwnBinding(g) && (s.replaceWith(p.memberExpression(p.cloneNode(f2.node.id), p.cloneNode(s.node))), s.skip());
}
var sv = {
  ReferencedIdentifier: fb
};
function hb(s, n) {
  const h = /* @__PURE__ */ new Map();
  let f2 = -1, p;
  return s.get("members").map((g) => {
    const P = g.node, x = n.isIdentifier(P.id) ? P.id.name : P.id.value, y = P.initializer;
    let A;
    if (y)
      if (f2 = iv(y, h), f2 !== void 0)
        h.set(x, f2), typeof f2 == "number" ? A = n.numericLiteral(f2) : (XE(typeof f2 == "string"), A = n.stringLiteral(f2));
      else {
        const S = g.get("initializer");
        S.isReferencedIdentifier() ? fb(S, {
          t: n,
          seen: h,
          path: s
        }) : S.traverse(sv, {
          t: n,
          seen: h,
          path: s
        }), A = S.node, h.set(x, void 0);
      }
    else if (typeof f2 == "number")
      f2 += 1, A = n.numericLiteral(f2), h.set(x, f2);
    else {
      if (typeof f2 == "string")
        throw s.buildCodeFrameError("Enum member must have initializer.");
      {
        const S = n.memberExpression(n.cloneNode(s.node.id), n.stringLiteral(p), true);
        A = n.binaryExpression("+", n.numericLiteral(1), S), h.set(x, void 0);
      }
    }
    return p = x, [x, A];
  });
}
function iv(s, n) {
  return h(s);
  function h(g) {
    switch (g.type) {
      case "StringLiteral":
        return g.value;
      case "UnaryExpression":
        return f2(g);
      case "BinaryExpression":
        return p(g);
      case "NumericLiteral":
        return g.value;
      case "ParenthesizedExpression":
        return h(g.expression);
      case "Identifier":
        return n.get(g.name);
      case "TemplateLiteral":
        if (g.quasis.length === 1)
          return g.quasis[0].value.cooked;
      default:
        return;
    }
  }
  function f2({
    argument: g,
    operator: P
  }) {
    const x = h(g);
    if (x !== void 0)
      switch (P) {
        case "+":
          return x;
        case "-":
          return -x;
        case "~":
          return ~x;
        default:
          return;
      }
  }
  function p(g) {
    const P = h(g.left);
    if (P === void 0)
      return;
    const x = h(g.right);
    if (x !== void 0)
      switch (g.operator) {
        case "|":
          return P | x;
        case "&":
          return P & x;
        case ">>":
          return P >> x;
        case ">>>":
          return P >>> x;
        case "<<":
          return P << x;
        case "^":
          return P ^ x;
        case "*":
          return P * x;
        case "/":
          return P / x;
        case "+":
          return P + x;
        case "-":
          return P - x;
        case "%":
          return P % x;
        default:
          return;
      }
  }
}
Object.defineProperty(kp, "__esModule", {
  value: true
});
kp.default = av;
var nv = $a;
function av(s, n) {
  const {
    name: h
  } = s.node.id, f2 = s.parentPath.isExportNamedDeclaration();
  let p = f2;
  !p && n.isProgram(s.parent) && (p = s.parent.body.some((x) => n.isExportNamedDeclaration(x) && x.exportKind !== "type" && !x.source && x.specifiers.some((y) => n.isExportSpecifier(y) && y.exportKind !== "type" && y.local.name === h)));
  const g = (0, nv.translateEnumValues)(s, n);
  if (p) {
    const x = n.objectExpression(g.map(([y, A]) => n.objectProperty(n.isValidIdentifier(y) ? n.identifier(y) : n.stringLiteral(y), A)));
    s.scope.hasOwnBinding(h) ? (f2 ? s.parentPath : s).replaceWith(n.expressionStatement(n.callExpression(n.memberExpression(n.identifier("Object"), n.identifier("assign")), [s.node.id, x]))) : (s.replaceWith(n.variableDeclaration("var", [n.variableDeclarator(s.node.id, x)])), s.scope.registerDeclaration(s));
    return;
  }
  const P = new Map(g);
  s.scope.path.traverse({
    Scope(x) {
      x.scope.hasOwnBinding(h) && x.skip();
    },
    MemberExpression(x) {
      if (!n.isIdentifier(x.node.object, {
        name: h
      }))
        return;
      let y;
      if (x.node.computed)
        if (n.isStringLiteral(x.node.property))
          y = x.node.property.value;
        else
          return;
      else if (n.isIdentifier(x.node.property))
        y = x.node.property.name;
      else
        return;
      !P.has(y) || x.replaceWith(n.cloneNode(P.get(y)));
    }
  }), s.remove();
}
var Dp = {};
Object.defineProperty(Dp, "__esModule", {
  value: true
});
Dp.default = ov;
var mt = on();
function ov(s, n) {
  if (s.node.declare || s.node.id.type === "StringLiteral") {
    s.remove();
    return;
  }
  if (!n)
    throw s.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
  const h = s.node.id.name, f2 = Hc(s, mt.types.cloneNode(s.node, true)), p = s.scope.hasOwnBinding(h);
  s.parent.type === "ExportNamedDeclaration" ? p ? s.parentPath.replaceWith(f2) : (s.parentPath.insertAfter(f2), s.replaceWith(kl(h)), s.scope.registerDeclaration(s.parentPath)) : p ? s.replaceWith(f2) : s.scope.registerDeclaration(s.replaceWithMultiple([kl(h), f2])[0]);
}
function kl(s) {
  return mt.types.variableDeclaration("let", [mt.types.variableDeclarator(mt.types.identifier(s))]);
}
function Wc(s, n) {
  return mt.types.memberExpression(mt.types.identifier(s), mt.types.identifier(n));
}
function lv(s, n, h) {
  if (s.kind !== "const")
    throw h.file.buildCodeFrameError(s, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
  const {
    declarations: f2
  } = s;
  if (f2.every((P) => mt.types.isIdentifier(P.id))) {
    for (const P of f2)
      P.init = mt.types.assignmentExpression("=", Wc(n, P.id.name), P.init);
    return [s];
  }
  const p = mt.types.getBindingIdentifiers(s), g = [];
  for (const P in p)
    g.push(mt.types.assignmentExpression("=", Wc(n, P), mt.types.cloneNode(p[P])));
  return [s, mt.types.expressionStatement(mt.types.sequenceExpression(g))];
}
function xy(s, n) {
  throw s.hub.buildError(n, "Ambient modules cannot be nested in other modules or namespaces.", Error);
}
function Hc(s, n, h) {
  const f2 = /* @__PURE__ */ new Set(), p = n.id;
  mt.types.assertIdentifier(p);
  const g = s.scope.generateUid(p.name), P = mt.types.isTSModuleBlock(n.body) ? n.body.body : [mt.types.exportNamedDeclaration(n.body)];
  for (let y = 0; y < P.length; y++) {
    const A = P[y];
    switch (A.type) {
      case "TSModuleDeclaration": {
        if (!mt.types.isIdentifier(A.id))
          throw xy(s, A);
        const S = Hc(s, A), v = A.id.name;
        f2.has(v) ? P[y] = S : (f2.add(v), P.splice(y++, 1, kl(v), S));
        continue;
      }
      case "TSEnumDeclaration":
      case "FunctionDeclaration":
      case "ClassDeclaration":
        f2.add(A.id.name);
        continue;
      case "VariableDeclaration": {
        for (const S in mt.types.getBindingIdentifiers(A))
          f2.add(S);
        continue;
      }
      default:
        continue;
      case "ExportNamedDeclaration":
    }
    switch (A.declaration.type) {
      case "TSEnumDeclaration":
      case "FunctionDeclaration":
      case "ClassDeclaration": {
        const S = A.declaration.id.name;
        f2.add(S), P.splice(y++, 1, A.declaration, mt.types.expressionStatement(mt.types.assignmentExpression("=", Wc(g, S), mt.types.identifier(S))));
        break;
      }
      case "VariableDeclaration": {
        const S = lv(A.declaration, g, s.hub);
        P.splice(y, S.length, ...S), y += S.length - 1;
        break;
      }
      case "TSModuleDeclaration": {
        if (!mt.types.isIdentifier(A.declaration.id))
          throw xy(s, A.declaration);
        const S = Hc(s, A.declaration, mt.types.identifier(g)), v = A.declaration.id.name;
        f2.has(v) ? P[y] = S : (f2.add(v), P.splice(y++, 1, kl(v), S));
      }
    }
  }
  let x = mt.types.objectExpression([]);
  if (h) {
    const y = mt.types.memberExpression(h, p);
    x = mt.template.expression.ast`
      ${mt.types.cloneNode(y)} ||
        (${mt.types.cloneNode(y)} = ${x})
    `;
  }
  return mt.template.statement.ast`
    (function (${mt.types.identifier(g)}) {
      ${P}
    })(${p} || (${mt.types.cloneNode(p)} = ${x}));
  `;
}
Object.defineProperty(Dl, "__esModule", {
  value: true
});
var db = Dl.default = void 0;
var uv = Vn;
var cv = Ll;
var tr = on();
var pv = ab;
var fv = kp;
var hv = $a;
var dv = Dp;
function mv(s) {
  switch (s.parent.type) {
    case "TSTypeReference":
    case "TSQualifiedName":
    case "TSExpressionWithTypeArguments":
    case "TSTypeQuery":
      return true;
    case "ExportSpecifier":
      return s.parentPath.parent.exportKind === "type";
    default:
      return false;
  }
}
var Ol = /* @__PURE__ */ new WeakMap();
var xs = /* @__PURE__ */ new WeakMap();
var Py = /* @__PURE__ */ new WeakSet();
function kc(s, n) {
  const h = s.find((f2) => f2.isProgram()).node;
  return s.scope.hasOwnBinding(n) ? false : Ol.get(h).has(n) ? true : (console.warn(`The exported identifier "${n}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${n}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), false);
}
function Tl(s, n) {
  Ol.get(s).add(n);
}
var yv = (0, uv.declare)((s, n) => {
  s.assertVersion(7);
  const h = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, {
    allowNamespaces: f2 = true,
    jsxPragma: p = "React.createElement",
    jsxPragmaFrag: g = "React.Fragment",
    onlyRemoveTypeImports: P = false,
    optimizeConstEnums: x = false
  } = n;
  var {
    allowDeclareFields: y = false
  } = n;
  const A = {
    field(C) {
      const {
        node: I
      } = C;
      if (!y && I.declare)
        throw C.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
      if (I.declare) {
        if (I.value)
          throw C.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
        I.decorators || C.remove();
      } else if (I.definite) {
        if (I.value)
          throw C.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
        !y && !I.decorators && C.remove();
      } else
        !y && !I.value && !I.decorators && !tr.types.isClassPrivateProperty(I) && C.remove();
      I.accessibility && (I.accessibility = null), I.abstract && (I.abstract = null), I.readonly && (I.readonly = null), I.optional && (I.optional = null), I.typeAnnotation && (I.typeAnnotation = null), I.definite && (I.definite = null), I.declare && (I.declare = null), I.override && (I.override = null);
    },
    method({
      node: C
    }) {
      C.accessibility && (C.accessibility = null), C.abstract && (C.abstract = null), C.optional && (C.optional = null), C.override && (C.override = null);
    },
    constructor(C, I) {
      C.node.accessibility && (C.node.accessibility = null);
      const N = [], {
        scope: D
      } = C;
      for (const _ of C.get("params")) {
        const m = _.node;
        if (m.type === "TSParameterProperty") {
          const L = m.parameter;
          if (Py.has(L))
            continue;
          Py.add(L);
          let R;
          if (tr.types.isIdentifier(L))
            R = L;
          else if (tr.types.isAssignmentPattern(L) && tr.types.isIdentifier(L.left))
            R = L.left;
          else
            throw _.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
          N.push(tr.template.statement.ast`
          this.${tr.types.cloneNode(R)} = ${tr.types.cloneNode(R)}`), _.replaceWith(_.get("parameter")), D.registerBinding("param", _);
        }
      }
      (0, pv.injectInitialization)(I, C, N);
    }
  };
  return {
    name: "transform-typescript",
    inherits: cv.default,
    visitor: {
      Pattern: v,
      Identifier: v,
      RestElement: v,
      Program: {
        enter(C, I) {
          const {
            file: N
          } = I;
          let D = null, _ = null;
          const m = C.node;
          if (Ol.has(m) || Ol.set(m, /* @__PURE__ */ new Set()), N.ast.comments)
            for (const O of N.ast.comments) {
              const B = h.exec(O.value);
              B && (B[1] ? _ = B[2] : D = B[2]);
            }
          let L = D || p;
          L && ([L] = L.split("."));
          let R = _ || g;
          R && ([R] = R.split("."));
          for (let O of C.get("body")) {
            if (O.isImportDeclaration()) {
              if (xs.has(I.file.ast.program) || xs.set(I.file.ast.program, true), O.node.importKind === "type") {
                for (const $ of O.node.specifiers)
                  Tl(m, $.local.name);
                O.remove();
                continue;
              }
              const B = /* @__PURE__ */ new Set(), M = O.node.specifiers.length, j = () => M > 0 && M === B.size;
              for (const $ of O.node.specifiers)
                if ($.type === "ImportSpecifier" && $.importKind === "type") {
                  Tl(m, $.local.name);
                  const k = O.scope.getBinding($.local.name);
                  k && B.add(k.path);
                }
              if (P)
                xs.set(C.node, false);
              else {
                if (O.node.specifiers.length === 0) {
                  xs.set(C.node, false);
                  continue;
                }
                for (const $ of O.node.specifiers) {
                  const k = O.scope.getBinding($.local.name);
                  k && !B.has(k.path) && (T({
                    binding: k,
                    programPath: C,
                    pragmaImportName: L,
                    pragmaFragImportName: R
                  }) ? B.add(k.path) : xs.set(C.node, false));
                }
              }
              if (j())
                O.remove();
              else
                for (const $ of B)
                  $.remove();
              continue;
            }
            if (O.isExportDeclaration() && (O = O.get("declaration")), O.isVariableDeclaration({
              declare: true
            }))
              for (const B of Object.keys(O.getBindingIdentifiers()))
                Tl(m, B);
            else
              (O.isTSTypeAliasDeclaration() || O.isTSDeclareFunction() && O.get("id").isIdentifier() || O.isTSInterfaceDeclaration() || O.isClassDeclaration({
                declare: true
              }) || O.isTSEnumDeclaration({
                declare: true
              }) || O.isTSModuleDeclaration({
                declare: true
              }) && O.get("id").isIdentifier()) && Tl(m, O.node.id.name);
          }
        },
        exit(C) {
          C.node.sourceType === "module" && xs.get(C.node) && C.pushContainer("body", tr.types.exportNamedDeclaration());
        }
      },
      ExportNamedDeclaration(C, I) {
        if (xs.has(I.file.ast.program) || xs.set(I.file.ast.program, true), C.node.exportKind === "type") {
          C.remove();
          return;
        }
        if (C.node.source && C.node.specifiers.length > 0 && C.node.specifiers.every((N) => N.type === "ExportSpecifier" && N.exportKind === "type")) {
          C.remove();
          return;
        }
        if (!C.node.source && C.node.specifiers.length > 0 && C.node.specifiers.every((N) => tr.types.isExportSpecifier(N) && kc(C, N.local.name))) {
          C.remove();
          return;
        }
        xs.set(I.file.ast.program, false);
      },
      ExportSpecifier(C) {
        (!C.parent.source && kc(C, C.node.local.name) || C.node.exportKind === "type") && C.remove();
      },
      ExportDefaultDeclaration(C, I) {
        if (xs.has(I.file.ast.program) || xs.set(I.file.ast.program, true), tr.types.isIdentifier(C.node.declaration) && kc(C, C.node.declaration.name)) {
          C.remove();
          return;
        }
        xs.set(I.file.ast.program, false);
      },
      TSDeclareFunction(C) {
        C.remove();
      },
      TSDeclareMethod(C) {
        C.remove();
      },
      VariableDeclaration(C) {
        C.node.declare && C.remove();
      },
      VariableDeclarator({
        node: C
      }) {
        C.definite && (C.definite = null);
      },
      TSIndexSignature(C) {
        C.remove();
      },
      ClassDeclaration(C) {
        const {
          node: I
        } = C;
        if (I.declare) {
          C.remove();
          return;
        }
      },
      Class(C) {
        const {
          node: I
        } = C;
        I.typeParameters && (I.typeParameters = null), I.superTypeParameters && (I.superTypeParameters = null), I.implements && (I.implements = null), I.abstract && (I.abstract = null), C.get("body.body").forEach((N) => {
          N.isClassMethod() || N.isClassPrivateMethod() ? N.node.kind === "constructor" ? A.constructor(N, C) : A.method(N) : (N.isClassProperty() || N.isClassPrivateProperty()) && A.field(N);
        });
      },
      Function(C) {
        const {
          node: I
        } = C;
        I.typeParameters && (I.typeParameters = null), I.returnType && (I.returnType = null);
        const N = I.params;
        N.length > 0 && tr.types.isIdentifier(N[0], {
          name: "this"
        }) && N.shift();
      },
      TSModuleDeclaration(C) {
        (0, dv.default)(C, f2);
      },
      TSInterfaceDeclaration(C) {
        C.remove();
      },
      TSTypeAliasDeclaration(C) {
        C.remove();
      },
      TSEnumDeclaration(C) {
        x && C.node.const ? (0, fv.default)(C, tr.types) : (0, hv.default)(C, tr.types);
      },
      TSImportEqualsDeclaration(C) {
        if (tr.types.isTSExternalModuleReference(C.node.moduleReference))
          throw C.buildCodeFrameError(`\`import ${C.node.id.name} = require('${C.node.moduleReference.expression.value}')\` is not supported by @babel/plugin-transform-typescript
Please consider using \`import ${C.node.id.name} from '${C.node.moduleReference.expression.value}';\` alongside Typescript's --allowSyntheticDefaultImports option.`);
        C.replaceWith(tr.types.variableDeclaration("var", [tr.types.variableDeclarator(C.node.id, S(C.node.moduleReference))]));
      },
      TSExportAssignment(C) {
        throw C.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `export <value>;`.");
      },
      TSTypeAssertion(C) {
        C.replaceWith(C.node.expression);
      },
      TSAsExpression(C) {
        let {
          node: I
        } = C;
        do
          I = I.expression;
        while (tr.types.isTSAsExpression(I));
        C.replaceWith(I);
      },
      [s.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](C) {
        C.replaceWith(C.node.expression);
      },
      CallExpression(C) {
        C.node.typeParameters = null;
      },
      OptionalCallExpression(C) {
        C.node.typeParameters = null;
      },
      NewExpression(C) {
        C.node.typeParameters = null;
      },
      JSXOpeningElement(C) {
        C.node.typeParameters = null;
      },
      TaggedTemplateExpression(C) {
        C.node.typeParameters = null;
      }
    }
  };
  function S(C) {
    return tr.types.isTSQualifiedName(C) ? tr.types.memberExpression(S(C.left), C.right) : C;
  }
  function v({
    node: C
  }) {
    C.typeAnnotation && (C.typeAnnotation = null), tr.types.isIdentifier(C) && C.optional && (C.optional = null);
  }
  function T({
    binding: C,
    programPath: I,
    pragmaImportName: N,
    pragmaFragImportName: D
  }) {
    for (const m of C.referencePaths)
      if (!mv(m))
        return false;
    if (C.identifier.name !== N && C.identifier.name !== D)
      return true;
    let _ = false;
    return I.traverse({
      "JSXElement|JSXFragment"(m) {
        _ = true, m.stop();
      }
    }), !_;
  }
});
db = Dl.default = yv;
var gv = mb({
  __proto__: null,
  get default() {
    return db;
  }
}, [Dl]);
export {
  gv as i
};
//# sourceMappingURL=index.76c75465-M4R7BFDA.js.map
